// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@mappedin/mvf
//   ../three
//   ../@tweenjs/tween.js
//   ../geojson
//   ../minisearch
//   ../n8ao
//   ../postprocessing

declare module '@mappedin/mappedin-js' {
    import { MapView } from '@mappedin/mappedin-js/renderer/public/MapView';
    import { getVenue, getVenueMVF, getVenueBundle, getVenueMaker, Mappedin, downloadBundle, getVenueBundleURL, downloadVenueBundleMVF, MappedinDestinationSet, MappedinMap, TGetVenueBundleOptions, TGetVenueOptions, hydrateVenue } from '@mappedin/mappedin-js/get-venue';
    import { PositionUpdater } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.core';
    import type { TMapViewOptions } from '@mappedin/mappedin-js/renderer/MapView.types';
    export { E_SDK_LOG_LEVEL, setLoggerLevel } from '@mappedin/mappedin-js/--/common/Mappedin.Logger';
    export type { Marker } from '@mappedin/mappedin-js/renderer/private/controllers/MarkersController';
    export type { Path } from '@mappedin/mappedin-js/renderer/private/controllers/PathsController';
    export type { FloatingLabel } from '@mappedin/mappedin-js/renderer/private/controllers/FloatingLabelsController';
    export { BEARING_TYPE, ACTION_TYPE } from '@mappedin/mappedin-js/navigator';
    export type { IDirectionsResult, TSimplifyDirectionsOptions, E_MESSAGES as E_GET_DIRECTIONS_MESSAGES, } from '@mappedin/mappedin-js/navigator';
    /**
        * APIs for TypeDoc
        */
    export type { IFlatLabels, FlatLabels } from '@mappedin/mappedin-js/renderer/public/api/FlatLabels';
    export type { IFloatingLabels, FloatingLabels } from '@mappedin/mappedin-js/renderer/public/api/FloatingLabels';
    export type { Camera } from '@mappedin/mappedin-js/renderer/public/api/Camera';
    export type { BlueDot } from '@mappedin/mappedin-js/renderer/public/api/BlueDot';
    export type { Markers } from '@mappedin/mappedin-js/renderer/public/api/Markers';
    export type { Paths } from '@mappedin/mappedin-js/renderer/public/api/Paths';
    export type { StackedMaps } from '@mappedin/mappedin-js/renderer/public/api/StackedMaps';
    export type { OutdoorView } from '@mappedin/mappedin-js/renderer/public/api/OutdoorView';
    export type { DynamicFocus } from '@mappedin/mappedin-js/renderer/public/api/DynamicFocus';
    export type { Layers } from '@mappedin/mappedin-js/renderer/public/api/Layers';
    export type { TOOLTIP_ANCHOR } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartTooltip';
    export type TMappedinInitializeOutput = {
            mapView: MapView;
            venue: Mappedin;
    };
    type _TGetVenueOptions = TGetVenueOptions & {
            useVenueBundle?: false | undefined;
    };
    type _TGetVenueBundleOptions = TGetVenueBundleOptions & {
            useVenueBundle: true;
    };
    type TMappedinInitializeOptions = {
            mapView?: TMapViewOptions;
            venue: _TGetVenueOptions | _TGetVenueBundleOptions;
            firstMapSelector?: (venue: Mappedin) => MappedinMap | MappedinMap['id'];
    };
    /**
        *
        * @param el HTML Element where the mapView should be placed
        * @param venue Venue Object returned by {@link getVenue}
        * @param options MapView Options
        * @returns
        */
    function showVenue<T extends Mappedin>(el: HTMLElement, venue: T, options?: TMapViewOptions): Promise<MapView>;
    export { COLLISION_RANKING_TIERS, STATE, E_SDK_EVENT, E_BLUEDOT_STATE_REASON, E_BLUEDOT_MARKER_STATE, E_BLUEDOT_EVENT, E_BLUEDOT_STATE, E_CAMERA_EVENT, E_CAMERA_DIRECTION, SAFE_AREA_INSET_TYPE, ANIMATION_TWEENS, CAMERA_EASING_MODE, STACKED_MAPS_STATE, MARKER_ANCHOR, GEOLOCATION_STATUS, E_MAP_CHANGED_REASON, } from '@mappedin/mappedin-js/renderer/MapView.enums';
    export { getVenue, getVenueMVF, getVenueBundle, getVenueMaker, showVenue, downloadBundle, getVenueBundleURL, downloadVenueBundleMVF, hydrateVenue, PositionUpdater, MappedinDestinationSet, };
    import DefaultAssetManager from '@mappedin/mappedin-js/renderer/internal/Mappedin.AssetManager';
    import { TTileManagerOptions } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager';
    import { TShowWatermarkOptions } from '@mappedin/mappedin-js/renderer/private/controllers/WatermarkController';
    /**
        * @internal
        */
    const setAssetManager: <T extends DefaultAssetManager>(am: T) => void;
    export { setAssetManager, DefaultAssetManager as AssetManager };
    export type { TMappedinDirective, IAction, IActionArrival, IActionDeparture, IActionExitVortex, IActionTakeVortex, IActionTurn, } from '@mappedin/mappedin-js/get-venue/MappedinDirections';
    export type { TMappedinInitializeOptions };
    export * from '@mappedin/mappedin-js/renderer/MapView.types';
    export type { MapView } from '@mappedin/mappedin-js/renderer/public/MapView';
    export type { TSafeAreaInsets, TCameraTargets, TFocusOnCameraOptions, TCameraTransform, TCameraInteractionsSetOptions, TCameraAnimationOptions, default as CameraController, } from '@mappedin/mappedin-js/renderer/private/controllers/CameraController';
    export type { TGetVenueOptions, TGetVenueBundleOptions, TGetVenueMVFOptions, TGetVenueMakerOptions, TShowVenueOptions, TMappedinOfflineSearchOptions, TMappedinOfflineSearchResult, TMappedinOfflineSearchSuggestions, TMappedinOfflineAllSearchMatch, TMappedinOfflineSearchAllOptions, TDirectionToOptions, TPicture, TImage, TColor, TGalleryImage, TOpeningHours, TPhone, TSiblingGroup, TSocial, TState, TGeoReference, TPolygonRanking, TOperationHoursMap, TAccessors, } from '@mappedin/mappedin-js/get-venue';
    export { Mappedin, MappedinDirections, MappedinLocation, MappedinPolygon, MappedinNode, MappedinCategory, MappedinMap, MappedinEvent, MappedinMapGroup, MappedinVenue, MappedinVortex, MappedinRankings, MappedinNavigatable, MappedinCoordinate, OfflineSearch, MAP_RENDER_MODE, setFetchFn, MappedinCollectionType, MappedinLocationState, } from '@mappedin/mappedin-js/get-venue';
    /**
        * Export this only so our internal pre-built products can use it. We don't want to document it for external developers.
        */
    export { CustomerAnalytics } from '@mappedin/mappedin-js/get-venue';
    /**
        * Exported but marked as @internal.
        */
    export { BundleAssetManager } from '@mappedin/mappedin-js/renderer/bundle-asset-manager';
    /**
        * @deprecated Use {@link OutdoorView} instead.
        * Enable Tile Manager to render outdoor tiles around the venue. Must be called before {@link showVenue}.
        *
        * @example
        * ```ts
        * __enableTileManager({
        * 	provider: new AzureOutdoorContextProvider(
        * 		venue.options.language,
        * 		256,
        * 		"Your Azure API Key",
        * 		undefined //Omitted when using API Key.
        * 	)
        * });
        * ```
        */
    export function __enableTileManager(options?: TTileManagerOptions): void;
    /**
        * @hidden
        * @internal
        *
        * Show a Mappedin logo in the 3D scene. Must be called before {@link showVenue}.
        */
    export function __showWatermark(options?: TShowWatermarkOptions): void;
    export type { TTileManagerOptions, TILE_RENDER_MODES } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager';
    export { AzureOutdoorContextProvider, OpenStreetMapOutdoorContext, } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Outdoor-Context.provider';
    export type { IOutdoorContextProvider } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Outdoor-Context.provider';
}

declare module '@mappedin/mappedin-js/renderer/public/MapView' {
    import '../internal/Mappedin.css';
    import { Mappedin, MappedinCoordinate, MappedinLocation, MappedinMap, MappedinNode, MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    import { E_SDK_EVENT_PAYLOAD, TCreateMarkerOptions, TLabelAllLocationFlatLabelOptions, TLabelAllLocationFloatingLabelOptions, TMapViewOptions, TPathOptions, TCreateTooltipCommonOptions, TCreateTooltipOptions, TAOConfiguration, TAntialiasConfiguration } from '@mappedin/mappedin-js/renderer/MapView.types';
    import { E_SDK_EVENT, STATE } from '@mappedin/mappedin-js/renderer/MapView.enums';
    import SmartTooltip from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartTooltip';
    import { Marker } from '@mappedin/mappedin-js/renderer/private/controllers/MarkersController';
    import { PubSub } from '@mappedin/mappedin-js/renderer/internal';
    import Journey from '@mappedin/mappedin-js/renderer/public/api/Journey';
    import { TGetPolygonsAtCoordinateOptions } from '@mappedin/mappedin-js/renderer';
    import { IFlatLabels } from '@mappedin/mappedin-js/renderer/public/api/FlatLabels';
    import { IFloatingLabels } from '@mappedin/mappedin-js/renderer/public/api/FloatingLabels';
    import { Markers } from '@mappedin/mappedin-js/renderer/public/api/Markers';
    import { Paths } from '@mappedin/mappedin-js/renderer/public/api/Paths';
    import { BlueDot } from '@mappedin/mappedin-js/renderer/public/api/BlueDot';
    import { Camera } from '@mappedin/mappedin-js/renderer/public/api/Camera';
    import { Exporter } from '@mappedin/mappedin-js/renderer/public/api/Exporter';
    import { StackedMaps } from '@mappedin/mappedin-js/renderer/public/api/StackedMaps';
    import OutdoorView from '@mappedin/mappedin-js/renderer/public/api/OutdoorView';
    import { Layers } from '@mappedin/mappedin-js/renderer/public/api/Layers';
    import { DynamicFocus } from '@mappedin/mappedin-js/renderer/public/api/DynamicFocus';
    /**
        * Primary API class for controlling and interacting with a 3D map.
        */
    export class MapView extends PubSub<E_SDK_EVENT_PAYLOAD, E_SDK_EVENT> {
            #private;
            /**
                * API for representing sets of directions on the map.
                */
            Journey: Journey;
            /**
                * API for controlling the camera in the scene.
                */
            Camera: Camera;
            /**
                * API for controlling flat labels.
                */
            FlatLabels: IFlatLabels<void>;
            /**
                * API for exporting the scene.
                *
                * @hidden
                */
            Exporter: Exporter;
            /**
                * API for controlling floating labels.
                */
            FloatingLabels: IFloatingLabels;
            /**
                * API for adding 2D markers.
                */
            Markers: Markers;
            /**
                * API for drawing arbitrary paths.
                */
            Paths: Paths;
            /**
                * API for handling a user's position on the map.
                */
            BlueDot: BlueDot;
            /**
                * The options that the mapView was instantiated with.
                */
            options: TMapViewOptions;
            /**
                * @experimental
                * API for showing multiple maps as a vertical stack.
                */
            StackedMaps: StackedMaps;
            /**
                * @experimental
                * API to control outdoor context rendering.
                */
            OutdoorView: OutdoorView;
            /**
                * @experimental
                * API to control layer visibility.
                */
            Layers: Layers;
            /**
                * @experimental
                * API to dynamically set the map focus as you pan over map groups.
                */
            DynamicFocus?: DynamicFocus;
            /**
                * @hidden
                */
            constructor(container: HTMLElement, venue: Mappedin, options?: TMapViewOptions & {
                    onFirstMapLoaded: () => void;
            });
            /**
                * Label all locations using 2D floating labels (with options {@link TLabelAllLocationFloatingLabelOptions}),
                * or flat 3D labels on top of the polygons themselves (with options {@link TLabelAllLocationFlatLabelOptions})
                *
                * @deprecated Please use {@link FloatingLabels.labelAllLocations} or {@link FlatLabels.labelAllLocations} instead.
                * This may be removed in a future version of the SDK. The array this returns is now always empty.
                */
            labelAllLocations(options?: TLabelAllLocationFloatingLabelOptions | TLabelAllLocationFlatLabelOptions): never[];
            /**
                * Get the nearest {@link MappedinNode} on a map to an XY-coordinate on the screen.
                * This can be useful for generating directions from an arbitrary point on the map.
                *
                * ```
                * // Get the nearest node on map[0] to (100,100)
                * const nearestNode = mapView.getNearestNodeByScreenCoordinates(100, 100, mapView.venue.maps[0]);
                * const destination = mapView.venue.locations.find((l) => l.name === "Apple")!;
                *
                * // Find out how to get from that node to Apple
                * const directions = nearestNode.directionsTo(destination);
                * ```
                *
                * @param x The x position of a coordinate on the screen.
                * @param y The y position of a coordinate on the screen.
                * @param mapOrMapId The {@link MappedinMap} the node should belong to.
                */
            getNearestNodeByScreenCoordinates(x: number, y: number, mapOrMapId?: MappedinMap | MappedinMap['id']): MappedinNode;
            /**
                * Subscribe a function to an {@link E_SDK_EVENT}.
                *
                * ```ts
                * // Set a polygon to be red when it is clicked
                * const mapClickHandler = ({ polygons }: E_SDK_EVENT_PAYLOAD["CLICK"]) => {
                * 	if (polygons.length > 0) {
                * 		mapView.setPolygonColor(polygons[0], 'red');
                * 	}
                * }
                * mapView.on(E_SDK_EVENT.CLICK, mapClickHandler);
                * ```
                *
                * @param eventName An {@link E_SDK_EVENT} which, when fired, will call the provided
                * function.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of {@link E_SDK_EVENT_PAYLOAD}.
                */
            on: PubSub<E_SDK_EVENT_PAYLOAD, E_SDK_EVENT>['on'];
            /**
                * Unsubscribe a function previously subscribed with {@link on} from
                * and {@link E_SDK_EVENT}.
                *
                * ```ts
                * mapView.on(E_SDK_EVENT.CLICK, mapClickHandler);
                *
                * ...
                *
                * // Something changed and I no longer want this event
                * mapView.off(E_SDK_EVENT.CLICK, mapClickHandler);
                * ```
                *
                * @param eventName An {@link E_SDK_EVENT} to which the provided function was previously
                * subscribed.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                */
            off: PubSub<E_SDK_EVENT_PAYLOAD, E_SDK_EVENT>['off'];
            /**
                * Set state of the mapView to one of {@link STATE}.
                *
                * @param state The {@link STATE} to set the SDK to.
                */
            setState(state: STATE): Promise<void>;
            /**
                * The current {@link STATE} on the mapView.
                */
            get state(): STATE;
            /**
                * The {@link Mappedin} data this mapView is using.
                */
            get venue(): Mappedin;
            /**
                * The HTML element that the mapView is rendered into.
                */
            get container(): HTMLElement;
            /**
                * The current {@link MappedinMap} being displayed.
                */
            get currentMap(): MappedinMap;
            /**
                * Prevent any polygons from showing a hover effect and being clicked on.
                * See also {@link addInteractivePolygon} and {@link addInteractivePolygonsForAllLocations}.
                *
                * ```ts
                * mapView.removeAllInteractivePolygons()
                * ```
                */
            removeAllInteractivePolygons(): void;
            /**
                * Change the currently displayed {@link MappedinMap} to a new one.
                *
                * ```ts
                * await mapView.setMap(mapView.venue.maps[1]);
                * ```
                *
                * @param mapOrMapId The {@link MappedinMap} to display.
                * @returns A promise that resolves when the map is fully switched.
                */
            setMap(mapOrMapId: MappedinMap | string): Promise<null>;
            /**
                * Given a {@link MappedinPolygon}, set it to a specific color.
                *
                * ```ts
                * // Find the polygons of the Apple store and change them to blue
                * const location = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * for (const polygon of location.polygons) {
                * 	mapView.setPolygonColor(polygon, "#0000ff");
                * }
                * ```
                *
                * @param polygon The {@link MappedinPolygon} to change the color of.
                * @param color A hexidecimal color string to use as the new color.
                */
            setPolygonColor(polygon: MappedinPolygon, color: string): void;
            /**
                * Resets a {@link MappedinPolygon} back to it's original color. See also {@link clearAllPolygonColors} and
                * {@link setPolygonColor}. If the user is hovering over a polygon, it will still
                * have the hover color set by {@link setHoverColor}.
                *
                * ```ts
                * mapView.setPolygonColor(polygon, "#0000ff");
                *
                * ...
                *
                * // Reset the polygon color
                * mapView.clearPolygonColor(polygon);
                * ```
                *
                * @param polygonOrPolygonId The {@link MappedinPolygon} to reset the color of.
                */
            clearPolygonColor(polygonOrPolygonId: MappedinPolygon | string): void;
            /**
                * Resets all {@link MappedinPolygon} instances back to their original colors. See also {@link clearPolygonColor} and
                * {@link setPolygonColor}. If the user is hovering over a polygon, it will still
                * have the hover color set by {@link setHoverColor}.
                *
                * ```ts
                * mapView.clearAllPolygonColors();
                * ```
                */
            clearAllPolygonColors(): void;
            /**
                * @experimental
                * Sets a color that the outline of a {@link MappedinPolygon} instance will receive.
                * If no color is set the outline will default to red (#ff0000). See also {@link addPolygonOutline},
                * {@link removePolygonOutline} and {@link removeAllPolygonOutlines}.
                *
                * ```ts
                * mapView.setPolygonOutlineColor("#0000ff");
                * ```
                *
                * @param color The color to set the outline to.
                */
            setPolygonOutlineColor(color: string): void;
            /**
                * @experimental
                * Given a {@link MappedinPolygon}, the polygon will be outlined. The outline color of the polygon is
                * set using {@link setPolygonOutlineColor}, the default color is red (#ff0000). See also
                * {@link removePolygonOutline} and {@link removeAllPolygonOutlines}.
                *
                * ```ts
                * // Find the polygons of the Apple store and change them to blue
                * const location = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * for (const polygon of location.polygons) {
                * 	mapView.addPolygonOutline(polygon);
                * }
                * ```
                *
                * @param polygon The {@link MappedinPolygon} to outline.
                */
            addPolygonOutline(polygon: MappedinPolygon): void;
            /**
                * @experimental
                * Removes the outline on a {@link MappedinPolygon}. See also {@link setPolygonOutlineColor},
                * {@link addPolygonOutline} and {@link removeAllPolygonOutlines}.
                *
                * ```ts
                * mapView.setPolygonOutlineColor("#0000ff");
                * mapView.addPolygonOutline(polygon);
                *
                * ...
                *
                * // Remove the outline from the polygon
                * mapView.removePolygonOutline(polygon);
                * ```
                *
                * @param polygon The {@link MappedinPolygon} to remove the outline of.
                */
            removePolygonOutline(polygon: MappedinPolygon): void;
            /**
                * @experimental
                * Removes outlines on all {@link MappedinPolygon} instances. See also {@link setPolygonOutlineColor},
                * {@link addPolygonOutline} and {@link removePolygonOutline}.
                *
                * ```ts
                * mapView.setPolygonOutlineColor("#0000ff");
                * mapView.addPolygonOutline(polygon1);
                * mapView.addPolygonOutline(polygon2);
                *
                * ...
                *
                * // Remove the outline from all polygons
                * mapView.removeAllPolygonOutlines();
                * ```
                */
            removeAllPolygonOutlines(): void;
            /**
                * Makes a {@link MappedinPolygon} interactive. This means it will receive a hover effect and
                * respond to the `CLICK` {@link E_SDK_EVENT}. See also {@link on} and {@link addInteractivePolygonsForAllLocations}.
                *
                * ```ts
                * // Make all washroom polygons clickable
                * const washroom = mapView.venue.find((l) => l.name === "Washroom")!;
                * for (const polygon of washroom.polygons) {
                * 	mapView.addInteractivePolygon(polygon);
                * }
                *
                * // Now they will be populated in click events
                * mapView.on(E_SDK_EVENT.CLICK, ({ polygons }) -> {
                * 	if (polygons.length > 0) {
                * 		console.log("Clicked on a washroom!");
                * 	}
                * })
                * ```
                *
                * @param polygonOrPolygonId The {@link MappedinPolygon} to make interactive.
                */
            addInteractivePolygon(polygonOrPolygonId: MappedinPolygon | string): void;
            /**
                * Makes all {@link MappedinPolygon} instances with an attached {@link MappedinLocation} interactive.
                * This means they will receive a hover effect and respond to the `CLICK` {@link E_SDK_EVENT}. See also
                * {@link on} and {@link addInteractivePolygon}.
                *
                * ```ts
                * mapView.addInteractivePolygonsForAllLocations();
                *
                * // Now all polygons with locations can be clicked
                * mapView.on(E_SDK_EVENT.CLICK, ({ polygons }) => {
                * 	if (polygons.length > 0) {
                * 		for (const polygon of polygons) {
                * 			console.log(`clicked on ${polygon.locations[0].name}`)
                * 		}
                * 	}
                * });
                * ```
                */
            addInteractivePolygonsForAllLocations(options?: {
                    /**
                        * A list of Location types to skip. All locations of this type will be exluded from becoming interactive
                        */
                    excludeTypes?: string[];
                    /**
                        *  An array of Location objects. Overrides the default of making all locations interactive, and instead applies to only the locations specified here.
                        */
                    locations?: MappedinLocation[];
            }): void;
            /**
                * Makes a polygon no longer hoverable/clickable. See also {@link addInteractivePolygon} and
                * {@link addInteractivePolygonsForAllLocations}.
                *
                * @param polygonOrPolygonId  The {@link MappedinPolygon} to make no longer interactive.
                */
            removeInteractivePolygon(polygonOrPolygonId: MappedinPolygon | string): void;
            /**
                * Attach any HTML to a {@link MappedinNode} or {@link MappedinCoordinate}, and have the marker interact and collide with smart labels and tooltips
                * @deprecated use {@link Markers.add} instead.
                */
            createMarker(nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, options?: TCreateMarkerOptions): Marker;
            /**
                * Remove Marker
                * @deprecated use {@link Markers.remove} instead.
                */
            removeMarker(markerOrMarkerId: Marker | Marker['id']): void;
            /**
                * Removes all Markers (from all Maps, not just the current one).
                * @deprecated use {@link Markers.removeAll} instead.
                */
            removeAllMarkers(): void;
            /**
                * Remove all tooltips created with {@link createTooltip} or {@link createCustomTooltip}.
                *
                * ```ts
                * mapView.removeAllTooltips();
                * ```
                */
            removeAllTooltips(): void;
            /**
                * Create a tooltip with default styling that the MapView will attempt to position in 3D space. The tooltip will be anchored
                * to a specified node or coordinate in one of eight anchor orientations.
                *
                * The possible anchor types are `top`, `bottom`, `left`, `right`, `topLeft`, `topRight`, `bottomLeft`, and `bottomRight`. This
                * describes the position of the tooltip relative to the node or coordinate to which it is attached.
                *
                * The tooltip is rendered into the DOM with the following structure.
                *
                * ```jsx
                * <div class="mappedin-tooltip tooltip--anchor-bottom-left">
                * 	<div class="mappedin-tooltip__content">
                * 		{contentHtml}
                * 	</ div>
                * </ div>
                * ```
                *
                * The `.mappedin-tooltip` element controls the position and has a class in the form of `.tooltip--anchor-{type}` that indicates
                * the current anchor type.
                *
                * @param nodeOrCoordinate A {@link MappedinNode} or {@link MappedinCoordinate} the tooltip is attached to.
                * @param contentHtml Stringified HTML content to render within the tooltip.
                * @param options {@link TCreateTooltipOptions} for rendering the tooltip
                */
            createTooltip(
            /**
                * Node or Coordinate to attach the tooltip to
                */
            nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, options?: TCreateTooltipOptions): SmartTooltip;
            /**
                * Create a tooltip with no default styling that the MapView will attempt to position in 3D space. The tooltip will be anchored
                * to a specified node or coordinate in one of eight anchor orientations.
                *
                * The possible anchor types are `top`, `bottom`, `left`, `right`, `topLeft`, `topRight`, `bottomLeft`, and `bottomRight`. This
                * describes the position of the tooltip relative to the node or coordinate to which it is attached.
                *
                * Unlike {@link createTooltip}, a custom tooltip is rendered without any additional wrappers, leaving styling entirely up to the
                * external developer. The top-most element will be injected with a class in the form of `.tooltip--anchor-{type}` that indicates
                * the current anchor type.
                *
                * @param nodeOrCoordinate A {@link MappedinNode} or {@link MappedinCoordinate} the tooltip is attached to.
                * @param contentHtml Stringified HTML content to render within the tooltip. The contents must be `position: absolute` in order to interact with the collision engine.
                * @param selector A CSS selector string that allows the SDK to target the tooltip. This is required because we do not inject any default styling.
                * @param options {@link TCreateTooltipCommonOptions} for rendering the tooltip
                */
            createCustomTooltip(
            /**
                * Node or Coordinate to attach the tooltip to
                */
            nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, selector: string, options?: TCreateTooltipCommonOptions): SmartTooltip;
            /**
                * Removes a Tooltip you have added previously.
                *
                * @param tooltipOrTooltipId A Tooltip or Tooltip id that has previously been returned from {@link MapView.createTooltip}.
                */
            removeTooltip(tooltipOrTooltipId: SmartTooltip | SmartTooltip['id']): void;
            /**
                * Let any image attached to a Polygon attached to a Location flip 180 degrees with the camera
                * so it's always upright. See also {@link enableImageFlippingForPolygon}.
                *
                * ```ts
                * mapView.enableImageFlippingForAllLocations();
                * ```
                */
            enableImageFlippingForAllLocations(options?: {
                    /**
                        * A list of Location types to skip, if for some reason there are Locations that have logos that shouldn't flip.
                        */
                    excludeTypes?: string[];
                    /**
                        * An array of Location objects, or Location IDs. If excludeTypes is not sufficient you can explicitly set the Locations you are marking to flip. You can also call {@link MapView.enableImageFlippingForPolygon} manually for every polygon you care about instead.
                        */
                    locations?: MappedinLocation[] | string[];
            }): void;
            /**
                * Mark a specific {@link MappedinPolygon} so, if it has an image, it rotates with the camera.
                * See also {@link enableImageFlippingForAllLocations}.
                *
                * ```ts
                * // Enable image flipping for locations with type "Anchor"
                * const anchorStores = mapView.venue.locations.filter((l) => l.type === "Anchor");
                * for(const store of anchorStores) {
                * 	for(const polygon of anchorStores.polygons) {
                * 		mapView.enableImageFlippingForPolygon(polygon);
                * 	}
                * }
                * ```
                *
                * @param polygon The {@link MappedinPolygon} to enable image flipping for.
                */
            enableImageFlippingForPolygon(polygon: MappedinPolygon): void;
            /**
                * Disable image flipping that was enabled with {@link enableImageFlippingForPolygon} or
                * {@link enableImageFlippingForAllLocations}.
                */
            disableImageFlippingForAllPolygons(): void;
            /**
                * @deprecated Use {@link Paths.add} instead.
                *
                * Draws an entire path. It takes a list of Nodes and will break them into separate pathSegments on every map change, putting the resultant segment on the right Map.
                *
                * @param path An array of Nodes, probably from a Node's {@link MappedinNode.directionsTo} call.
                * @return An array of pathSegment ids.
                */
            drawPath(path: MappedinNode[], options?: TPathOptions): string;
            /**
                * @deprecated Use {@link Paths.remove} instead.
                *
                * Remove a path by id
                */
            removePath(pathId: string): void;
            /**
                * @deprecated Use {@link Paths.removeAll} instead.
                *
                * Removes all pathSegments from all Maps.
                */
            removeAllPaths(): void;
            /**
                * Sets the color of empty space in the scene. Useful for matching the aesthetics of the
                * surrounding website of application. Otherwise the container element will be white where
                * there is no map visible.
                *
                * ```ts
                * // Make the background a dark grey
                * mapView.setBackgroundColor("#050505");
                * ```
                *
                * @param color A hexidecimal color string to use.
                * @param alpha A number between 0 and 1 representing opacity.
                */
            setBackgroundColor(color: string, alpha?: number): void;
            /**
                * Sets the color that all {@link MappedinPolygon} instances will receive when they are
                * beneath a cursor. This only applies to interactive polygons set using {@link addInteractivePolygon}
                * or {@link addInteractivePolygonsForAllLocations}. Hover colors set by {@link setPolygonHoverColor} will take
                * precedence over this value.
                *
                * ```ts
                * // Make all location polygons interactive and have a red hover color
                * mapView.addInteractivePolygonsForAllLocations()
                * mapView.setHoverColor("#ff0000");
                * ```
                */
            setHoverColor(color: string): void;
            /**
                * Sets a color that a {@link MappedinPolygon} instance will receive when it is beneath a cursor.
                * This will take precedence over the value set by {@link setHoverColor} and only applies to an interactive polygon set using {@link addInteractivePolygon}
                * or {@link addInteractivePolygonsForAllLocations}. See also {@link clearPolygonHoverColor} and {@link clearAllPolygonHoverColors}.
                *
                * ```ts
                * // Make polygon interactive and have a red hover color
                * mapView.addInteractivePolygon(polygon);
                * mapView.setPolygonHoverColor(polygon, "#ff0000");
                * ```
                */
            setPolygonHoverColor(polygon: MappedinPolygon, color: string): void;
            /**
                * Resets a {@link MappedinPolygon} back to it's original hover color or the default hover color set by
                * {@link setHoverColor}. See also {@link clearAllPolygonHoverColors} and {@link setPolygonHoverColor}.
                *
                * ```ts
                * mapView.setPolygonHoverColor(polygon, "#ff0000");
                *
                * ...
                *
                * // Reset polygon to origin hover color
                * mapView.clearPolygonHoverColor(polygon);
                * ```
                */
            clearPolygonHoverColor(polygon: MappedinPolygon): void;
            /**
                * Resets all {@link MappedinPolygon} instances back to their original hover colors or the default hover color set by
                * {@link setHoverColor}. See also {@link clearPolygonHoverColor} and {@link setPolygonHoverColor}.
                *
                * ```ts
                * mapView.setPolygonHoverColor(polygon1, "#ff0000");
                * mapView.setPolygonHoverColor(polygon1, "#00ff00");
                *
                * ...
                *
                * mapView.clearAllPolygonHoverColors();
                * ```
                */
            clearAllPolygonHoverColors(): void;
            /**
                * @deprecated This should no longer need to be called externally and is now a no-op.
                */
            tryRendering(_renderMode?: any): void;
            /**
                * Finds the main {@link MappedinLocation} associated with a {@link MappedinPolygon}.
                * This means a location attached to the polygon that has no parents, or, if there
                * are none of those, a location nearest the top of some hierarchy that does have the
                * polygon attached.
                *
                * This means if there are multiple hierarchies of locations attached to the polygon,
                * the one that gets returned is not guaranteed to be what you want.
                *
                * ```
                * // Log the primary location of a clicked polygon
                * mapView.on(E_SDK_EVENT.CLICK, ({ polygons }) => {
                * 	if (polygons.length > 0) {
                * 		for(const polygon of polygons) {
                * 			console.log(mapView.getPrimaryLocationForPolygon(polygon));
                * 		}
                * 	}
                * });
                * ```
                *
                * @param polygon The {@link MappedinPolygon} you want the primary location of.
                */
            getPrimaryLocationForPolygon(polygon: MappedinPolygon): MappedinLocation;
            /**
                * Finds all {@link MappedinPolygon} instances that contain the specified {@link MappedinCoordinate}.
                * If multiple polygons are stacked on top of each other, the array of polygons returned will be
                * in the order of top to bottom.
                *
                * By default, this only considers interactive polygons set through {@link addInteractivePolygon} or
                * {@link addInteractivePolygonsForAllLocations}. This behaviour can be changed by passing
                * `options.includeNonInteractive`.
                *
                * ```ts
                * const polygons = mapView.getPolygonsAtCoordinate(coordinate);
                * ```
                *
                * @param coordinate The {@link MappedinCoordinate} to check.
                * @param options
                * @returns An array of {@link MappedinPolygon} instances intersecting the given coordinate.
                */
            getPolygonsAtCoordinate(coordinate: MappedinCoordinate, options?: TGetPolygonsAtCoordinateOptions): MappedinPolygon[];
            /**
                * Finds all {@link MappedinPolygon} instances that intersect the specified XY-coordinate on screen.
                * If multiple polygons are stacked on top of each other, the array of polygons returned will be
                * in the order of top to bottom.
                *
                * By default, this only considers interactive polygons set through {@link addInteractivePolygon} or
                * {@link addInteractivePolygonsForAllLocations}. This behaviour can be changed by passing
                * `options.includeNonInteractive`.
                *
                * ```ts
                * const polygons = mapView.getPolygonsAtScreenCoordinate(100, 100);
                * ```
                *
                * @param x The x value of a screen coordinate
                * @param y The y value of a screen coordinate
                * @param options
                * @returns An array of {@link MappedinPolygon} instances intersecting the given coordinate.
                */
            getPolygonsAtScreenCoordinate(x: number, y: number, options?: TGetPolygonsAtCoordinateOptions): MappedinPolygon[];
            /**
                * Create a {@link MappedinCoordinate} on a given {@link MappedinMap} from an XY-coordinate on screen.
                *
                * @param x	The x value of a screen coordinate.
                * @param y The y value of a screen coordinate.
                * @param map The {@link MappedinMap} the coordinate should belong to.
                * @returns A {@link MappedinCoordinate} on the given map.
                */
            getMappedinCoordinateAtScreenCoordinate(x: number, y: number, map: MappedinMap): MappedinCoordinate;
            setAmbientOcclusionSettings(settings: TAOConfiguration): void;
            setAntialiasSettings(settings: TAntialiasConfiguration): void;
            /**
                * Destroy the mapView instance and reclaim memory.
                *
                * NOTE: this does not destroy the instance of {@link Mappedin} that was passed in. For applications that
                * require destroying and re-creating the mapView, it is recommended to keep the {@link Mappedin} object
                * around.
                *
                * ```ts
                * mapView.destroy();
                * ```
                */
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/get-venue' {
    import type { TGetVenueOptions, TVenueMetadata } from '@mappedin/mappedin-js/get-venue/Mappedin.types';
    import { Mappedin } from '@mappedin/mappedin-js/get-venue/Mappedin';
    import { defaultThings } from '@mappedin/mappedin-js/get-venue/default-things';
    import { GET_VENUE_EVENT } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * This is how we can avoid bundling in node-fetch (via isomorphic fetch),
        * which keeps popping up in security advisories
        * This is a pattern that most isomorphic libraries appear to use,
        * where when running in node, you can pass your own fetch function
        * as one is not provided by Node.js.
        *
        */
    export function isomorphicFetch(): Window['fetch'];
    /**
        * Overwrite the internal `fetch` function with your own. Typically for use in Node.js and Jest.
        *
        * @example
        * ```js
        * const { getVenue } = require("@mappedin/mappedin-js/lib/node/index");
        * setFetchFn(require("node-fetch-commonjs"));
        * ```
        *
        */
    export function setFetchFn(fetchFn: any): void;
    /** Classes */
    export { MappedinCollectionType, MappedinNavigatable, MappedinNode, MappedinLocation, MappedinPolygon, MappedinCategory, MappedinDirections, MappedinDestinationSet, MappedinVortex, MappedinVenue, MappedinRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, Mappedin, } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * @internal
        * @hidden
        *
        * Export this only so our internal pre-built products can use it. We don't want to document it for external developers.
        */
    export { default as CustomerAnalytics } from '@mappedin/mappedin-js/get-venue/Mappedin.CustomerAnalytics';
    export type { TMappedinDirective } from '@mappedin/mappedin-js/get-venue/MappedinDirections';
    export type { IDirectionsResult } from '@mappedin/mappedin-js/navigator';
    export type { TOperationHoursMap } from '@mappedin/mappedin-js/get-venue/MappedinLocation';
    export type { TMappedinCoordinateOptions } from '@mappedin/mappedin-js/get-venue/MappedinCoordinate';
    export type { TDirectionToOptions, TTHINGS, TAccessors } from '@mappedin/mappedin-js/get-venue/internal';
    export { OfflineSearch } from '@mappedin/mappedin-js/get-venue/Mappedin.OfflineSearch';
    export type { TMappedinOfflineSearchOptions, TMappedinOfflineSearchResult, TMappedinOfflineSearchSuggestions, TMappedinOfflineAllSearchMatch, TMappedinOfflineSearchAllOptions, } from '@mappedin/mappedin-js/get-venue/Mappedin.OfflineSearch';
    export { defaultThings };
    /** API data types */
    export type { TLocationType, TNode, TImage, TLogo, TGalleryImage, TPhone, TSocial, TColor, TVortex, TPicture, TOpeningHours, TSiblingGroup, TState, TCategory, TEvent, TGeoReference, TMap, TMapGroup, TBuilding, TLocation, TPolygon, TPolygonRanking, TVenue, TMappedinAPI, } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    export type { TGetVenueOptions } from '@mappedin/mappedin-js/get-venue/Mappedin.types';
    import { MAP_RENDER_MODE } from '@mappedin/mappedin-js/get-venue/Mappedin.types';
    import { ParsedMVF } from '@mappedin/mvf';
    export type TShowVenueOptions = {
            /**
                * Sets the initial background color of the map, including while loading.
                *
                */
            backgroundColor?: string;
            /**
                * The opacity of the initial background color.
                */
            backgroundAlpha?: number;
            /**
                * Whether or not to display default styled Floating Labels initially
                */
            labelAllLocationsOnInit?: boolean;
            /**
                * The id of the first map to show on map load
                */
            firstMapId?: string;
            loadOptions?: {
                    /**
                        * Set the map render strategy in order to optimize FPS
                        *
                        * @beta
                        */
                    mapRenderStrategy?: MAP_RENDER_MODE;
            };
            /**
                * @experimental
                * Enable outdoor context. Requires multi-buffer rendering to be enabled
                */
            outdoorContext?: {
                    enabled?: boolean;
                    url?: string;
                    authURL?: string;
            };
            /**
                * @experimental
                * Enable multi-buffer rendering
                *
                * Multi-buffer rendering should improve performance but may cause issues on older GPUs/browsers
                * @default false
                */
            multiBufferRendering?: boolean;
            /**
                * @experimental
                * Journey path will be visible through other objects. Note: this is on by default, but requires the
                * `multiBufferRendering` option (which is off by default) to be turned on.
                * @default true
                */
            xRayPath?: boolean;
    };
    export { MAP_RENDER_MODE, GET_VENUE_EVENT };
    /**
        * @internal
        */
    export function getVenueMVF(userOptions: TGetVenueMVFOptions): Promise<Mappedin>;
    /**
        * @experimental
        * Get venue data for a map created in Mappedin Maker.
        * @param userOptions
        * @example
        * ```ts
        * const mappedin = await getVenueMaker({
        * 	key: '<Your Maker Key>',
        * 	secret: '<Your Maker Secret>',
        * 	mapId: '<Your Maker Map ID>',
        * });
        * ```
        * @returns {@link Mappedin} object with data from the Maker map.
        */
    export function getVenueMaker(userOptions: TGetVenueMakerOptions): Promise<Mappedin>;
    /**
        * Get Venue Data for a Mappedin Venue
        */
    export function getVenue(userOptions: TGetVenueOptions): Promise<Mappedin>;
    export function getVenueMetadata(userOptions: TGetVenueOptions): Promise<TVenueMetadata>;
    /**
        * @internal
        */
    export function __setGetVenueMock(fn: any): void;
    export type TGetVenueBundleOptions = TGetVenueOptions & {
            bundleBaseUri?: string;
            version?: string;
            /**
                * Parse bundle and convert images to blobs. Disabled in React Native
                * @private
                */
            shouldPopulateBundledImagesAsBlobs?: boolean;
    };
    /** @internal */
    export type TGetVenueMVFOptions = TGetVenueBundleOptions & {
            onMVFParsed?: (mvf: ParsedMVF) => void;
            /**
                * Override initial MVF data
                */
            override?: Partial<Pick<ParsedMVF, 'styles.json'>>;
    };
    /**
        * @experimental
        * Options for {@link getVenueMaker}.
        */
    export type TGetVenueMakerOptions = {
            /**
                * Maker auth key.
                */
            key: string;
            /**
                * Maker auth secret.
                */
            secret: string;
            /**
                * Maker map ID.
                */
            mapId: string;
            /**
                * Optionally provide a custom base URL for the Maker map API request.
                */
            bundleBaseUri?: string;
            /**
                * Optionally provide a custom base URL for the Maker auth token request.
                */
            authBaseUri?: string;
            /**
                * Whether or not to emit analytics events.
                * @default true
                */
            emitAnalyticsEvents?: boolean;
            /**
                * Callback for when the Maker map data has been fetched and parsed as Mappedin Venue Format (MVF) data. This occurs before the {@link Mappedin} object is hydrated.
                * @param mvf Parsed MVF data.
                */
            onMVFParsed?: (mvf: ParsedMVF) => void;
    };
    /**
        * @deprecated
        * Fetching an offline Venue bundle
        * It is possible to download the venue bundle with all assets built in, which allows for caching/offline solutions.
        * Note 1: This requires enabling from Mappedin's Customer Solutions team.
        * Note 2: This may behave a lot slower for large venues, especially those with many images. We are actively working on improving load times.
        */
    export function getVenueBundle(userOptions: TGetVenueBundleOptions): Promise<Mappedin>;
    /**
        * Get the bundle URL and updated_at time.
        * @internal
        */
    export function getVenueBundleURL(userOptions: TGetVenueBundleOptions): Promise<{
            url: string;
            updated_at: string;
    }>;
    /**
        * Download a bundle and return a Mappedin instance
        * @internal
        */
    export function downloadBundle(userOptions: any, { url, updated_at }: {
            url: any;
            updated_at: any;
    }): Promise<Mappedin>;
    /**
        * Get the bundle URL and updated_at time.
        * @internal
        */
    export function getVenueMVFURL(userOptions: TGetVenueBundleOptions): Promise<{
            url: string;
            updated_at: string;
    }>;
    /**
        * @internal
        */
    export function downloadVenueBundleMVF(options: TGetVenueBundleOptions): Promise<Uint8Array>;
    export function getMakerAccessToken(userOptions: TGetVenueMakerOptions): Promise<{
            access_token: string;
            expires_in: number;
    }>;
    export function getMakerBundleURL(userOptions: TGetVenueMakerOptions, token: string): Promise<{
            url: string;
            updated_at: string;
    }>;
    export function downloadMakerMVF(userOptions: TGetVenueMakerOptions): Promise<Uint8Array>;
    /**
        * Returns a {@link Mappedin} object hydrated with JSON data.
        * @param {string|Object} mappedinSerializableData A JSON string or object representing a venue.
        * @param {boolean} shouldPopulateBundledImagesAsBlobs
        * @returns {Mappedin} A new Mappedin object with data from the mappedinSerializableData parameter.
        */
    export function hydrateVenue(mappedinSerializableData: any, shouldPopulateBundledImagesAsBlobs?: boolean): Promise<Mappedin>;
    /**
        * @internal
        * Returns a {@link Mappedin} object hydrated with MVF data.
        */
    export function hydrateVenueMVF(mvfData: ParsedMVF): Promise<Mappedin>;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.core' {
    import FakeGeolocation from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/fake-geolocation';
    import { IStateMachine } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.StateMachine';
    import { E_BLUEDOT_MARKER_STATE, E_BLUEDOT_STATE, E_BLUEDOT_STATE_REASON } from '@mappedin/mappedin-js/renderer/MapView.enums';
    import PositionSmoothing from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/position-smoothing';
    import { PubSub, IPubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
    import { MappedinMap, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    import { TGeolocationObject } from '@mappedin/mappedin-js/renderer/MapView.types';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { BlueDotManager } from '@mappedin/mappedin-js/renderer/internal';
    export const DEFAULT_BLUE_DOT_COLOR = "#2266ff";
    export interface IPositionUpdater extends IPubSub {
            /**
                * Function that emits position updates
                */
            update: (position: TGeolocationObject) => void;
            /**
                * Optional function to start listening
                */
            start?: (options?: any) => void;
            /**
                * Optional function to stop listening
                */
            stop?: () => void;
            /**
                * Function that emits an error in retrieving position
                */
            throwError?: (err: string) => void;
    }
    export class PositionUpdater extends PubSub implements IPositionUpdater {
            update: (position: TGeolocationObject) => void;
            throwError: (err: any) => void;
    }
    export type TEnableBlueDotOptions = {
            /**
                * Show Bearing
                * @defaultValue false
                */
            showBearing?: boolean;
            /**
                * For venues that do not provide level updates, assume the user is always on the default map
                * If this is false, and no level information is found from position updates, blueDotUpdate events will
                * not include the nearest node
                * This should probably be set true for single floor venues that have no level information in position updates
                *
                * @defaultValue false
                */
            allowImplicitFloorLevel?: boolean;
            /**
                * Smooth incoming position updates. Set to false if smoothing happens outside the SDK
                * @defaultValue true
                */
            smoothing?: boolean;
            /**
                * Custom positionUpdater
                * @defaultValue undefined
                */
            positionUpdater?: IPositionUpdater;
            /**
                * Override the default color of the Blue Dot. We interpolate other colors, (such as aura and bearing) from this base color
                * @defaultValue '#2266ff'
                */
            baseColor?: string;
            /**
                * Whether to use the rotated view while following the user's position.
                * @defaultValue false
                */
            useRotationMode?: boolean;
    };
    export type TUserData = {
            state: E_BLUEDOT_STATE;
            position: TGeolocationObject | null;
            map: MappedinMap | null;
            bearing: any;
            nearestNode: any;
            forceBlueDot: boolean;
    };
    export interface IBlueDotCore extends IPubSub {
            positionUpdater: IPositionUpdater | null;
            positionSmoothing: PositionSmoothing;
            locationUncertainTimeoutPeriod: number;
            fallbackToGPSTimeoutPeriod: number;
            enableBlueDot: (options?: TEnableBlueDotOptions) => void;
            disableBlueDot: () => void;
            enableBlueDotOptions: TEnableBlueDotOptions;
            enabled: boolean;
            state: TBlueDotStateChange;
            /**
            Whether blue dot should be allowed with missing floor level information.
             */
            forceBlueDot: boolean;
            /**
            The state machine for the current state of the blue dot.
             */
            stateMachine: IStateMachine;
            /**
            The map the user's device is currently on.
             */
            userMap: MappedinMap | null;
            /**
            The position of the user's device.
             */
            userPosition: TGeolocationObject | null;
            /**
            The nearest node to the user's position.
             */
            nearestNode: any;
            /**
            The direction the user is moving.
             */
            bearing: any;
            /**
            Everything in one object, for convenience.
             */
            userData: TUserData | null;
    }
    export type TBlueDotPositionUpdate = {
            /**
                * The {@link MappedinMap} Blue Dot position is on
                */
            map?: MappedinMap;
            /**
                * The nearest {@link MappedinNode} to the Blue Dot position
                */
            nearestNode?: MappedinNode;
            /**
                * Actual position of Blue Dot (post smoothing, if smoothing is enabled)
                */
            position?: TGeolocationObject;
            /**
                * Current Blue Dot bearing
                */
            bearing?: number;
    };
    export type TBlueDotStateChange = {
            /**
                * What we currently know about the user's position, and how confident we are.
                */
            name: E_BLUEDOT_STATE;
            /**
                * Visiblity state of the Blue Dot marker
                */
            markerVisibility?: E_BLUEDOT_MARKER_STATE;
            /**
                * Reason why Blue Dot may be in the current state
                */
            reason?: E_BLUEDOT_STATE_REASON;
            /**
                * Additional message to complement the reason
                */
            message?: GeolocationPositionError | string;
    };
    export const FALLBACK_TO_GPS_TIMEOUT = 10000;
    type TBlueDotProps = {
            data: any;
            core: ICore;
            manager: BlueDotManager;
    };
    export type TLatLonProps = [number, number];
    const BlueDot: {
            ({ data, core, manager }: TBlueDotProps): IBlueDotCore;
            FakeGeolocation: typeof FakeGeolocation;
    };
    export default BlueDot;
}

declare module '@mappedin/mappedin-js/renderer/MapView.types' {
    import type { Mappedin, MappedinCoordinate, MappedinLocation, MappedinMap, MappedinNode, MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    import type { TFloatingLabelAppearance } from '@mappedin/mappedin-js/renderer/internal/Mappedin.FloatingLabel';
    import type { TEnableBlueDotOptions, TBlueDotPositionUpdate, TBlueDotStateChange } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.core';
    import type { Euler, Object3D, Vector3 } from 'three';
    import type { Path } from '@mappedin/mappedin-js/renderer/private/controllers/PathsController';
    import { TOOLTIP_ANCHOR } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartTooltip';
    import { GEOLOCATION_STATUS, COLLISION_RANKING_TIERS, STATE, MARKER_ANCHOR, E_SDK_EVENT, E_BLUEDOT_EVENT, E_CAMERA_EVENT, MAP_RENDER_MODE, CAMERA_EASING_MODE, E_MAP_CHANGED_REASON } from '@mappedin/mappedin-js/renderer/MapView.enums';
    import { TOutdoorViewControllerOptions } from '@mappedin/mappedin-js/renderer/private/controllers/OutdoorViewController';
    export type { TEnableBlueDotOptions, TFloatingLabelAppearance };
    /** @internal */
    export type Without<T, U> = {
            [P in Exclude<keyof T, keyof U>]?: never;
    };
    /** @internal */
    export type XOR<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
    /**
    An extension of the GeolocationPosition type.
    https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPosition
     */
    export type TGeolocationObject = {
            timestamp: number;
            type?: GEOLOCATION_STATUS;
            positionIndex?: number;
            coords: {
                    latitude: number;
                    longitude: number;
                    accuracy: number;
                    floorLevel?: number;
            };
            /**
                * override bluedot bearing
                */
            bearing?: number;
    };
    export type { TBlueDotPositionUpdate, TBlueDotStateChange };
    export type TPathOptions = {
            /**
                * Path Colour
                * @defaultValue #00b800
                */
            color?: string;
            /**
                * Colour of path pulse
                * @defaultValue '#ffffff'
                */
            pulseColor?: string;
            /**
                * Number of iterations to pulse to indicate direction
                * @defaultValue 1
                */
            pulseIterations?: number;
            /**
                * How many milliseconds to wait before starting the next pulse after the current pulse travels the entirety of the path
                * @defaultValue 750
                */
            pulsePauseDuration?: number;
            /**
                * Radius of path at nearest zoom, in metres
                * @defaultValue 1.8
                */
            nearRadius?: number;
            /**
                * Radius of path at furthest zoom, in metres
                * @defaultValue 2.3 times nearRadius
                */
            farRadius?: number;
            /**
                * Zoom level where the path size is `nearRadius`
                * @defaultValue 375
                */
            nearZoom?: number;
            /**
                * Zoom level where the path size is `farRadius`tions.nearRadius
                * @defaultValue 10000
                */
            farZoom?: number;
            /**
                * Duration of path drawing
                * @defaultValue 1500
                */
            drawDuration?: number;
            /**
                * Show arrows on path
                * @defaultValue true
                */
            displayArrowsOnPath?: boolean;
            /**
                * Flatten the path to a 2D line
                * @defaultValue false
                */
            flattenPath?: boolean;
            /**
                * Show an animated pulse indicating the direction of travel.
                * @defaultValue true
                */
            showPulse?: boolean;
            /**
                * Animate the drawing of the path in the direction of travel.
                * @defaultValue true
                */
            animateDrawing?: boolean;
            /**
                * Whether the path should be clickable.
                * @defaultValue false
                */
            interactive?: boolean;
            /**
                * @experimental
                *
                * @defaultValue false
                * The path will be adjusted vertically to the tallest polygon altitude.
                */
            adjustedAltitude?: boolean;
            /**
                * @experimental
                *
                * The maximum altitude of the path in meters
                * @defaultValue Infinite
                */
            maxAdjustedAltitude?: number;
            /**
                * @experimental
                *
                * @defaultValue -Infinite
                * The minimum altitude of the path in meters
                */
            minAdjustedAltitude?: number;
    };
    export type TConnectionProps = {
            /**
                * Connection type, "escalator", "elevator", etc
                */
            type: any;
            /**
                * Direction "up" or "down" or null if on the same floor
                */
            direction?: string;
            /**
                * Depending on the direction of the journey, the map name of the destination map or where a connection enters the map
                */
            toMapName?: string;
            /**
                * Icon to use for the connection, can be wrapped in SVG and <g> for styling
                *
                * @example:
                * <svg
                            height="16"
                            viewBox="0 0 36 36"
                            width="16"
                    >
                    <g fill="white">
                            ${icon}
                    </g>
                    </svg>
                *
                *
                */
            icon?: string;
            /**
                * Whether the user is entering or exiting the connection
                */
            isEntering?: boolean;
    };
    export type TConnectionTemplateFn = ({ direction, type, toMapName }: TConnectionProps) => string;
    export type TMarkerTemplateProps = {
            icon: string;
            location?: MappedinLocation;
    };
    export type TMarkerTemplateFn = ({ icon, location }: TMarkerTemplateProps) => string;
    /**
        * Configure the behaviour of a {@link Journey}.
        */
    export type TJourneyOptions = {
            /**
                * What color to highlight departure and destination polygons
                * Pass false to disable
                * @default '#7babc8'
                */
            polygonHighlightColor?: string | false;
            /**
                * Path Options
                */
            pathOptions?: TPathOptions;
            /**
                * Path Options for the non-current path in multi-destination mode.
                */
            inactivePathOptions?: TPathOptions;
            /**
                * Function that returns an HTML template to use as a connection tooltips (elevators, escalators, etc)
                */
            connectionTemplate?: TConnectionTemplateFn;
            /**
                * Function that returns an HTML template to use as a destination marker.
                * Override with null | undefined to disable
                */
            destinationMarkerTemplate?: TMarkerTemplateFn;
            /**
                * Function that returns an HTML template to use as a departure marker.
                * Override with null | undefined to disable
                */
            departureMarkerTemplate?: TMarkerTemplateFn;
            /**
                * Path Options for map to map vertical paths.
                */
            connectionPathOptions?: TPathOptions;
    };
    export const labelThemes: {
            lightOnDark: {
                    text: {
                            foregroundColor: string;
                            backgroundColor: string;
                            numLines: number;
                            lineHeight: number;
                            size: number;
                            maxWidth: number;
                    };
                    marker: {
                            foregroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            backgroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            size: number;
                    };
                    margin: number;
            };
            darkOnLight: {
                    text: {
                            foregroundColor: string;
                            backgroundColor: string;
                            numLines: number;
                            lineHeight: number;
                            size: number;
                            maxWidth: number;
                    };
                    marker: {
                            foregroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            backgroundColor: {
                                    active: string;
                                    inactive: undefined;
                            };
                            size: number;
                    };
                    margin: number;
            };
    };
    export type TPadding = {
            top: number;
            left: number;
            bottom: number;
            right: number;
    };
    /**
        * Options for controlling the behavior of a {@link Marker}.
        */
    export type TCreateMarkerOptions = {
            /**
                * The rank of the Marker used when comparing colliders to determine which should be shown.
                */
            rank?: COLLISION_RANKING_TIERS | number;
            /**
                * The anchor point of the Marker.
                */
            anchor?: MARKER_ANCHOR;
            /**
                * Whether the Marker should be clickable and included in {@link E_SDK_EVENT.CLICK} events.
                * @default false
                */
            interactive?: boolean;
            /**
                * Optional layer to attach the {@link Marker} to.
                */
            layer?: string;
    };
    /**
        * Configurations for an animation
        */
    export type TAnimationOptions = {
            /**
                * Animation duration in milliseconds
                */
            duration?: number;
            /**
                * Mode for easing in and out of the animation.
                */
            easing?: CAMERA_EASING_MODE;
    };
    /**
        * @internal
        */
    export type TCreateTooltipInternalOptions = {
            id?: string;
            nodeOrCoordinate: MappedinNode | MappedinCoordinate;
            html?: string;
            contentHtml?: string;
            selector?: string;
            options?: TCreateTooltipCommonOptions | TCreateTooltipOptions;
            interactive?: boolean;
    };
    export type TCreateTooltipCommonOptions = {
            /**
                * An object used to disable certain anchor positions from being used.
                */
            enabledAnchorTypes?: TOOLTIP_ANCHOR;
            /**
                * Default (starting) anchor for tooltips
                */
            defaultAnchorType?: keyof TOOLTIP_ANCHOR;
            /**
                * The rank of the object used when comparing colliders to determine which should be shown.
                */
            collisionRank?: COLLISION_RANKING_TIERS;
            /**
                * Optional layer to attach the Tooltip to.
                */
            layer?: string;
    };
    export type TCreateTooltipOptions = TCreateTooltipCommonOptions & {
            /**
                * The distance in pixels to offset the Tooltip from the anchor point.
                */
            padding?: number;
            /**
                * Whether the Tooltip should be clickable and included in {@link E_SDK_EVENT.CLICK} events.
                * @default false
                */
            interactive?: boolean;
    };
    export type TCreateTextTooltipOptions = TCreateTooltipCommonOptions & {
            /**
                * Instead of passing html pass in plain text to be displayed in the tooltip
                */
            text: string;
            /**
                * The distance in pixels to offset the Tooltip from the anchor point.
                */
            padding?: number;
    };
    export type TCreateCustomInnerHTMLTooltipOptions = TCreateTooltipCommonOptions & {
            /**
                * Use mappedin's default tooltip styling with custom inner html content
                */
            contentHtml: string;
            /**
                * The distance in pixels to offset the Tooltip from the anchor point.
                */
            padding?: number;
    };
    export type TCreateCustomTooltipOptions = TCreateTooltipCommonOptions & {
            /**
                * Pass in custom html for your marker, if using this method you must also pass in a selector for your content.
                */
            html: string;
            /**
                * Used in conjuction with the html property to select the div for repositioning
                */
            selector: string;
    };
    export type TCreateThreeDMarkerOptions = {
            /**
                * map to add the marker to
                */
            mapOrMapId: MappedinMap | MappedinMap['id'];
            /**
                * the marker object to add to the scene
                */
            object: Object3D;
            /**
                * if provided, sets the object's position on the map
                */
            position?: Vector3;
            /**
                * if provided, sets the object's rotation relative to the map
                */
            rotation?: Euler;
            /**
                * if provided, sets the object's scale relative to the map
                */
            scale?: Vector3;
    };
    export type TGetPolygonsAtCoordinateOptions = {
            /**
                * Specifies whether polygons that cannot be interacted with should be
                * included in the results. Default is `false`.
                */
            includeNonInteractive?: boolean;
    };
    export type TMapViewOptions = {
            /**
                * @experimental
                *
                * Enable ambient occlusion. Only works in single buffer mode and when device supports WebGL2.
                * @default false
                */
            aoEnabled?: TAOConfiguration['aoEnabled'];
            /**
                * @experimental
                *
                * Change the quality of ambient occlusion in the scene. Greater quality means less noise, but worse performance.
                * @default 'medium'
                */
            aoQuality?: TAOConfiguration['aoQuality'];
            /**
                * @experimental
                *
                * Change the resolution of ambient occlusion. Lower resolution will see significant performance improvement at the cost
                * of visual artifacting.
                * @default 'half'
                */
            aoResolution?: TAOConfiguration['aoResolution'];
            /**
                * Background color of the map as a string e.g. `#2e2e2e`.
                */
            backgroundColor?: string;
            /**
                * The opacity of the initial background color.
                */
            backgroundAlpha?: number;
            /**
                * Controls whether antialiasing is on. Defaults to `true`, as long as devicePixelRatio is 1. This is very expensive on high resolution screens.
                * @default true
                */
            antialias?: TAntialiasConfiguration['antialias'];
            /**
                * @experimental
                *
                * Controls the antialiasing quality. Greater quality means less artifacts(less aliasing), but worse performance.
                * @default 'medium'
                */
            antialiasQuality?: TAntialiasConfiguration['antialiasQuality'];
            disableHover?: boolean;
            disableZoomOnMapSizeChange?: boolean;
            loadOptions?: {
                    /**
                        * By default, the SDK will merge all geometries by material to reduce the number of draw calls to the GPU
                        * To rever back to using a single geometry for every polygon, pass `MAP_RENDER_MODE.MULTI_GEOMETRY`
                        */
                    mapRenderStrategy?: MAP_RENDER_MODE;
                    async?: boolean;
                    zoomOverrides?: {
                            zoomMultiplier?: number;
                            focusZoomFactorPolygon?: number;
                            blueDotFollowingZoomFactor?: number;
                    };
                    /**
                        * @experimental
                        *
                        * Specify a list of layers that contain outdoor geometry
                        */
                    outdoorGeometryLayers?: string[];
            };
            /**
                * Settings for experimental vector tile -based outdoor context
                * Requires `multiBufferRendering` to be enabled.
                * @experimental
                */
            outdoorView?: TOutdoorViewControllerOptions & {
                    enabled?: boolean;
            };
            /**
                * @experimental
                */
            dynamicFocus?: {
                    /**
                        * The Dynamic Focus Map to always be visible.
                        */
                    baseMap?: MappedinMap;
                    /**
                        * Mercator Zoom level where the indoors are fully visible.
                        */
                    indoorsFullyVisibleZoomLevel?: number;
                    /**
                        * Mercator Zoom level when the outdoors geometry is fully visible.
                        */
                    buildingFullyVisibleZoomLevel?: number;
                    /**
                        * Level at which the map is "set", and colliders become visible.
                        */
                    setMapAtZoomLevel?: number;
                    /**
                        * Whether we should preload the default maps of each building.
                        * This will incur a cost up-front, but make transitions smoother.
                        * @default false
                        */
                    preloadDefaultMaps?: boolean;
                    /**
                        * An array of base map layer names which should remain active when the focus has changed to a building map.
                        * This could include outdoor {@link FloatingLabel}s or {@link Marker}s that are attached to the base map.
                        */
                    keepLayersActiveOnBaseMap?: string[];
            };
            /**
                * @experimental
                * Defines which layers are visible or adds zoom based opacity interpolation
                */
            layerGroups?: {
                    /**
                        * Layer names
                        */
                    layers: string[];
                    /**
                        * Whether the layer should be visible
                        */
                    visible?: boolean;
                    /**
                        * Interpolates opacity based on zoom level
                        *
                        * Note: Mercator zoom level values are clamped
                        *
                        * @example
                        * 1. Simple interpolation
                        *
                        * Keep layers visible until zoom level 17, then fade out until zoom level 18 when they become invisible
                        *
                        * ```ts
                        * opacityInterpolation: [
                        *   {
                        *     zoomLevel: 17,
                        *     opacity: 1
                        *   },
                        *   {
                        *     zoomLevel: 18,
                        *     opacity: 0,
                        *   }
                        * ]
                        * ```
                        *
                        * @example
                        * 2. Advanced interpolation
                        *
                        * The following will keep the layers invisible until zoom level 18, keep them visible until zoom level 18,
                        * and begin fading and invisible at zoom level 19
                        *
                        * `inputZoomLevel` defines Mercator zoom level steps which correspond with `outputOpacity` opacity values
                        *
                        * ```ts
                        * opacityInterpolation: {
                        *   inputZoomLevel: [17, 18, 18, 19],
                        *   outputOpacity: [0, 1, 1, 0],
                        * }
                        * ```
                        *
                        */
                    opacityInterpolation?: {
                            /**
                                * Clamped mercator zoom value in range [0, 22]
                                */
                            zoomLevel: number;
                            /**
                                * Opacity output value in range [0, 1]
                                */
                            opacity: number;
                    }[] | {
                            /**
                                * Clamped mercator zoom values in range [0, 22]
                                */
                            inputZoomLevel: number[];
                            /**
                                * Opacity output values in range [0, 1]
                                */
                            outputOpacity: number[];
                    };
            }[];
            /**
                * First map to be rendered
                */
            firstMap?: MappedinMap | string;
            /**
                * @experimental
                *
                * Multi-buffer rendering should improve performance but may cause issues on older GPUs/browsers
                * @default false
                */
            multiBufferRendering?: boolean;
            /**
                * @experimental
                *
                * Journey path will be visible through other objects. Note: this is on by default, but requires the
                * `multiBufferRendering` option (which is off by default) to be turned on.
                * @default true
                */
            xRayPath?: boolean;
            /**
                * True if the `opacity` argument to `setBackgroundColor` should be considered.
                * @default true
                */
            alpha?: boolean;
            onWebGLContextCreationError?: () => void;
            onWebGLContextLost?: () => void;
            onWebGLContextRestored?: () => void;
            onWebGLRendererError?: () => void;
    };
    export type TMapViewOptionsLegacy = {
            /**
                * Background color of the map as a string e.g. `"#2e2e2e"`.
                */
            backgroundColor?: string;
            /**
                * The opacity of the initial background color.
                */
            backgroundAlpha?: number;
            /**
                * Controls whether antialiasing is on. Defaults to true, as long as devicePixelRatio is 1. This is very expensive on high resolution screens.
                * @default true
                */
            antialias?: boolean;
            markerWorldIslandSplit?: boolean;
            /**
                * A callback executed with the 3D files have been downloaded for the first Map, and are starting to load into memory. The MapView is fully functional at this point, but some things will still be popping in.
                */
            onDataLoaded?: (venue?: Mappedin) => void;
            /**
                * A callback executed when the first map is fully loaded. This means onDataLoaded has already been fired (if specified) and then all the textures and other resources have finished popping in.
                */
            onFirstMapLoaded?: (venue?: Mappedin) => void;
            /**
                * If you would like to completely disable the hover effect (if you are on a touch screen for example), set this to true.
                * @default false;
                */
            disableHover?: boolean;
            disableZoomOnMapSizeChange?: boolean;
            loadOptions?: {
                    mode?: 'json' | 'obj';
                    zoomOverrides?: {
                            zoomMultiplier: unknown;
                            focusZoomFactorPolygon: unknown;
                    };
            };
            /**
                * First map to be rendered
                */
            firstMap?: MappedinMap | string;
            /**
                * @beta
                */
            multiBufferRendering?: boolean;
            /**
                * True if the `opacity` argument to `setBackgroundColor` should be considered.
                * @default true
                */
            alpha?: boolean;
            onWebGLContextCreationError?: () => void;
            onWebGLContextLost?: () => void;
            onWebGLContextRestored?: () => void;
            onWebGLRendererError?: () => void;
    };
    /**
        * Control how a flat label looks
        */
    export type TFlatLabelOptions = {
            text: string;
            /**
                * Set this if you want to label an arbitrary part of the Map. You will need to specify height as well.
                */
            canvasBounds?: {
                    /**
                        * The x coordinate for the TextLabel anchor.
                        */
                    x: number;
                    /**
                        * The y coordinate for the TextLabel anchor.
                        */
                    y: number;
                    /**
                        * The horizontal space we have to fit the TextLabel.
                        */
                    width: number;
                    /**
                        * The vertical space we have to fit the TextLabel.
                        */
                    height: number;
                    /**
                        * Whether the TextLabel should be anchored against the (x,y), or the opposite (horizontal) side of the box, or in the middle. It is * always vertically centered.
                        */
                    align: 'left' | 'right' | 'center';
            };
    };
    /**
        * Control how a flat label looks
        */
    export type TFlatLabelAppearance = {
            /**
                * By default this is the upper bounds of the Polygon. If you don't have a Polygon, or want a custom height for some reason, you can set this.
                */
            height?: number;
            /**
                * The amount of space to leave before starting the text in pixels
                * @default 5
                */
            margin?: number;
            /**
                * Optional color in hexadecimal string e.g. `#2e2e2e`.
                */
            color?: string;
            /**
                * Optional hover color in hexadecimal string e.g. `#2e2e2e`.
                */
            hoverColor?: string;
            /**
                * Size of the font in pixels.
                * @default 12
                */
            fontSize?: number;
            /**
                * A CSS style string font, e.g. "sans-serif". You can specify your own font via @font-face rule with a font family, and then include that here.
                */
            font?: string;
            /**
                * The minimum percentage we can shrink the label to if it won't fit within the bounds at 100%. If it doesn't fit at that level, it won't be created.
                * @default 0.25
                */
            scaleMin?: number;
            /**
                * How much to decrement the scale each time it doesn't fit, so we don't end up with too many different font sizes on screen at once. If you are only labeling a few {@link MappedinPolygon}s rather than everything,
                * you can set this and and scaleMin to 0.1 to fit everything except really long names perfectly.
                * @default 0.25
                */
            scaleStep?: number;
    };
    export type TFloatingLabelPolygonOptions = {
            text: string;
            scale?: number;
            /**
                * The rank of the FloatingLabel used when comparing colliders to determine which should be shown.
                */
            rank?: COLLISION_RANKING_TIERS | number;
            /**
                * Customize the appearance of the Floating Labels and their pins.
                */
            appearance?: TFloatingLabelAppearance;
            /**
                * Group analytics based ranking by {@link MappedinCategory.sortOrder} value.
                * @default false
                */
            groupRankingByCategory?: boolean;
    };
    export type TAddFlatLabelOptions = {
            appearance?: TFlatLabelAppearance;
    };
    /**
        * Options for creating a new {@link FloatingLabels | FloatingLabel} with {@link FloatingLabels.add}.
        */
    export type TAddFloatingLabelOptions = {
            scale?: number;
            /**
                * The rank of the FloatingLabel used when comparing colliders to determine which should be shown.
                */
            rank?: COLLISION_RANKING_TIERS | number;
            /**
                * Customize the appearance of the FloatingLabel and its pin
                */
            appearance?: TFloatingLabelAppearance;
            /**
                * Group analytics based ranking by {@link MappedinCategory.sortOrder} value
                * @default false
                */
            groupRankingByCategory?: boolean;
            /**
                * Whether the FloatingLabel should be clickable and included in {@link E_SDK_EVENT.CLICK} events.
                * @default false
                */
            interactive?: boolean;
            /**
                * Optional layer to attach the FloatingLabel to.
                * If not provided, this will be empty or the layer of the {@link MappedinPolygon} that the label is attached to.
                */
            layer?: string;
    };
    export type TLabelAllLocationCommonOptions = {
            /**
                * Exclude specific location types from labeling
                */
            excludeTypes?: string[];
            /**
                * A custom sort function to use for sorting locations
                */
            sortFunction?: (a: MappedinLocation, b: MappedinLocation) => number;
            /**
                * Locations to label - otherwise, use current venue object
                */
            locations?: MappedinLocation[];
            /**
                * Custom translation map for location states
                */
            translationMap?: {
                    [key in string]: string;
            };
            /**
                * Display label despite the {@link MappedinPolygon} having an image on it. Often these images represent store logos.
                * @default false
                */
            createDespiteImage?: boolean;
    };
    /**
        * @deprecated
        */
    export type TLabelAllLocationFloatingLabelOptions = TLabelAllLocationCommonOptions & {
            /**
                * Use Flat Labels
                * @default false
                */
            flatLabels?: false | undefined;
            /**
                * Customize the appearance of the Floating Labels and their pins
                */
            appearance?: TFloatingLabelAppearance;
            /**
                * Make label interactive
                */
            interactive?: boolean;
    };
    /**
        * @deprecated
        *
        * Use {@link FlatLabels.add} or {@link FloatingLabels.add} to get more fine tuned control when labelling
        * all locations.
        */
    export type TLabelAllLocationFlatLabelOptions = TLabelAllLocationCommonOptions & {
            /**
                * Use Flat Labels
                * @default false
                */
            flatLabels: true;
            appearance?: TFlatLabelAppearance;
    };
    /**
        * Options for controlling bulk location labelling
        */
    export type TFloatingLabelAllLocationsOptions = TLabelAllLocationCommonOptions & {
            appearance?: TFloatingLabelAppearance;
            interactive?: boolean;
            /**
                * Group analytics based ranking by {@link MappedinCategory.sortOrder} value
                * @default false
                */
            groupRankingByCategory?: boolean;
    };
    /**
        * Options for controlling bulk location labelling
        */
    export type TFlatLabelAllLocationsOptions = TLabelAllLocationCommonOptions & {
            appearance?: TFlatLabelAppearance;
    };
    /**
        * @internal
        */
    export type changeListenerFn<PAYLOAD> = (update: PAYLOAD) => void;
    /**
        * Information about a clicked {@link Marker} or Tooltip
        */
    export type ClickEventPayload = {
            /**
                * Id of the Marker or Tooltip that was clicked
                */
            id: string;
            /**
                * Marker or Tooltip node (if available)
                */
            node?: MappedinNode;
            /**
                * Marker or Tooltip coordinate (if available)
                */
            coordinate?: MappedinCoordinate;
    };
    /**
        * Information about a clicked {@link FloatingLabels | FloatingLabel}
        */
    export type FloatingLabelClickEventPayload = {
            text?: string;
    } & Omit<ClickEventPayload, 'coordinate'>;
    export type TAntialiasConfiguration = {
            antialias?: boolean;
            antialiasQuality?: 'low' | 'medium' | 'high' | 'ultra';
    };
    export type TAOConfiguration = {
            aoEnabled?: boolean;
            aoQuality?: string;
            aoSamples?: number;
            aoRadius?: number;
            denoiseSamples?: number;
            denoiseRadius?: number;
            intensity?: number;
            denoiseIterations?: number;
            renderMode?: number;
            color?: string;
            gammaCorrection?: boolean;
            logarithmicDepthBuffer?: boolean;
            screenSpaceRadius?: boolean;
            aoResolution?: 'half' | 'full';
            depthAwareUpsampling?: boolean;
            autoRenderBeauty?: boolean;
    };
    export type TMapClickEvent = {
            /**
                * The latitude / longitude of where the user clicked the map.
                * Both components may be NaN if unable to compute these components.
                */
            position: {
                    latitude: number;
                    longitude: number;
            };
            /**
                * A list of {@link MappedinPolygon}s corresponding to every polygon that a user's
                * click passed through. These are in order of first to last intersected.
                * Will be empty if no interactive polygons were clicked.
                */
            polygons: MappedinPolygon[];
            /**
                * A list of {@link MappedinMap}s corresponding to every map that a user's
                * click passed through. These are in order of first to last intersected.
                * Will be empty if no maps were clicked.
                */
            maps: MappedinMap[];
            /**
                * Indicates whether the user clicked close to the Blue Dot object on the
                * map, if present. If Blue Dot is disabled, this will always be false.
                */
            nearBlueDot: boolean;
            /**
                * Information about the {@link FloatingLabels} that a user's click passed through. Will be empty if no {@link FloatingLabels} were clicked.
                */
            floatingLabels: FloatingLabelClickEventPayload[];
            /**
                * Information about the {@link Marker}s that a user's click passed through. Will be empty if no {@link Marker}s were clicked.
                */
            markers: ClickEventPayload[];
            /**
                * Information about the Tooltips that a user's click passed through. Will be empty if no Tooltips were clicked.
                */
            tooltips: ClickEventPayload[];
            /**
                * A list of {@link Path}s that a user's click passed through. These are in order of first
                * to last intersected. Will be empty if no {@link Path}s were clicked.
                */
            paths?: Path[];
    };
    /**
        * Arguments that get passed to listeners of an {@link E_SDK_EVENT}.
        */
    export type E_SDK_EVENT_PAYLOAD = {
            [E_SDK_EVENT.CLICK]: TMapClickEvent;
            [E_SDK_EVENT.STATE_CHANGE]: STATE;
            [E_SDK_EVENT.POLYGON_CLICKED]: MappedinPolygon;
            [E_SDK_EVENT.NOTHING_CLICKED]: undefined;
            [E_SDK_EVENT.OUTDOOR_VIEW_LOADED]: undefined;
            [E_SDK_EVENT.MAP_CHANGED]: MappedinMap;
            [E_SDK_EVENT.MAP_CHANGED_WITH_REASON]: {
                    map: MappedinMap;
                    reason?: E_MAP_CHANGED_REASON;
            };
    };
    /**
        * Arguments that get passed to listeners of an {@link E_BLUEDOT_EVENT}.
        */
    export type E_BLUEDOT_EVENT_PAYLOAD = {
            /**
                * Emitted when the BlueDot position updates
                */
            [E_BLUEDOT_EVENT.POSITION_UPDATE]: TBlueDotPositionUpdate;
            /**
                * Emitted when the BlueDot state changes
                */
            [E_BLUEDOT_EVENT.STATE_CHANGE]: TBlueDotStateChange;
    };
    /**
        * Arguments that get passed to listeners of an {@link E_CAMERA_EVENT}.
        */
    export type CAMERA_EVENT_PAYLOAD = {
            [E_CAMERA_EVENT.USER_INTERACTION_START]: void;
            [E_CAMERA_EVENT.USER_INTERACTION_END]: void;
            [E_CAMERA_EVENT.CHANGED]: {
                    tilt: number;
                    position: MappedinCoordinate;
                    zoom: number;
                    rotation: number;
            };
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            [E_CAMERA_EVENT.POSITION_CHANGED]: MappedinCoordinate;
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            [E_CAMERA_EVENT.ZOOM_CHANGED]: number;
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            [E_CAMERA_EVENT.ROTATION_CHANGED]: number;
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            [E_CAMERA_EVENT.TILT_CHANGED]: number;
    };
    export type { default as BlueDotController } from '@mappedin/mappedin-js/renderer/private/controllers/BlueDotController';
    export type { default as Journey } from '@mappedin/mappedin-js/renderer/public/api/Journey';
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/MarkersController' {
    import { MappedinCoordinate, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, TCreateMarkerOptions, TAnimationOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { InternalMarker } from '@mappedin/mappedin-js/renderer/internal';
    import TWEEN from '@tweenjs/tween.js';
    /**
        * A marker containing some HTML content.
        */
    export class Marker {
            #private;
            /**
                * @internal
                */
            constructor(internalMarker: InternalMarker);
            /**
                * A generated ID for this marker.
                */
            get id(): string;
            /**
                * The container element for this marker. This element's position is automatically updated.
                */
            get containerEl(): HTMLDivElement | null;
            /**
                * The content that was provided when creating this marker.
                */
            get contentEl(): HTMLDivElement | null;
            /**
                * Force an update on the Marker. Call this if the contents of the Marker have changed since
                * it was created. Otherwise, the Marker may still collide as if it were the original size.
                */
            update(): void;
    }
    class MarkersController {
            #private;
            markersMap: Map<string, {
                    marker: Marker;
                    internalMarker: InternalMarker;
            }>;
            animations: Map<string, {
                    tween: TWEEN.Tween;
                    resolver: () => void;
            }>;
            constructor(core: ICore);
            /**
                * Creates a new internal marker
                */
            create(nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, options?: TCreateMarkerOptions): InternalMarker;
            /**
                * @internal
                *
                * Create an internal marker and add to collision engine. Typically used for internal purposes. Internal markers are not affected
                * by adding or removing using the public API.
                */
            addInternal(nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, options?: TCreateMarkerOptions): InternalMarker;
            /**
                * Create a new Marker, containing some HTML, at the specified position
                * @param nodeOrCoordinate the position for the Marker
                * @param contentHtml the content to show in the Marker
                * @param options options for the display of the Marker
                * @returns the Marker object that was created.
                */
            add(nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, options?: TCreateMarkerOptions): Marker;
            updateMap(internalMarker: InternalMarker, from: string, to: string): void;
            /**
                * Moves a Marker to a new position instantaneously.
                * @param markerOrMarkerId the Marker to move
                * @param target the new position for this Marker
                * @param updateCollisionEngine whether or not to update the collision engine after setting new position
                */
            setPosition(markerOrMarkerId: InternalMarker | Marker | Marker['id'], target: MappedinNode | MappedinCoordinate, updateCollisionEngine?: boolean): void;
            /**
                * Moves a Marker to a new position over time.
                * @param markerOrMarkerId the Marker to move
                * @param target the new position for this Marker
                * @param options the options for how this movement should be animated
                */
            animate(markerOrMarkerId: Marker | Marker['id'], target: MappedinCoordinate | MappedinNode, options?: TAnimationOptions): Promise<void>;
            /**
                * Removes a Marker.
                * @param markerOrMarkerId the Marker to be removed
                */
            remove(markerOrMarkerId: Marker | Marker['id']): void;
            /**
                * Remove all Markers from all maps.
                */
            removeAll(): void;
    }
    export default MarkersController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/PathsController' {
    import { MappedinNode, MappedinCoordinate } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, TPathOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { ANIMATION_TWEENS } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @hidden
        * @internal
        */
    export type TPathOptionsInternal = TPathOptions & {
            curve?: typeof ANIMATION_TWEENS;
            drawConnectionSegments?: boolean;
            connectionPathOptions?: TPathOptions & {
                    curve?: typeof ANIMATION_TWEENS;
            };
    };
    /**
        * @hidden
        * @internal
        */
    export type TInternalPathSegment = {
            id: string;
            nodes: (MappedinNode | MappedinCoordinate)[];
            mapId?: string;
            isConnectionPathSegment?: boolean;
            reset: () => void;
            resetPulse: () => void;
            object: any;
            tween: any;
            pulseTween: any;
            endPauseTween?: any;
            arrowAnimationTween: any;
    };
    /**
        * An object containing information that was used to draw a path on the map.
        */
    export class Path {
            #private;
            constructor(internalPathObject: InternalPath);
            /**
                * A generated ID for this path object
                */
            get id(): string;
            /**
                * A {@link MappedinNode}[] representing the nodes in the path
                */
            get nodes(): MappedinNode[];
            /**
                * A {@link MappedinCoordinate}[] representing the coordinates in the path
                */
            get coordinates(): MappedinCoordinate[];
    }
    /**
        * @hidden
        * @internal
        *
        * Represents all the segments created for a single call to drawPath()
        */
    export class InternalPath {
            id: string;
            nodes: MappedinNode[];
            coordinates: MappedinCoordinate[];
            pathSegments: TInternalPathSegment[];
            options: TPathOptionsInternal;
            constructor(path: (MappedinNode | MappedinCoordinate)[], pathSegments: TInternalPathSegment[], options: TPathOptionsInternal);
    }
    /**
        * @hidden
        * @internal
        */
    class PathsController {
            #private;
            constructor(core: ICore);
            pathSegments: Map<string, TInternalPathSegment>;
            pathsById: Map<string, {
                    path: Path;
                    internalPath: InternalPath;
            }>;
            pathsByMeshId: Map<string, {
                    path: Path;
                    internalPath: InternalPath;
            }>;
            connectionsPathMeshes: any;
            getPathLength(path: any): number;
            /**
                *	Draws path in 3D space
                *
                *	Draws an entire path. It takes a list of nodes and will break them into separate path segments on every man change, putting the resultant segment on the right map.
                *
                *	If you have a special use case (like off graph nodes, or venues with same map vortexes) use the drawPathSegment function.
                *
                * 	@method drawPath
                *	@param path {[MappedinNode]} An array of Nodes, probably from a Node's {{#crossLink "MappedinNode/directionsTo:method"}}{{/crossLink}} call.
                *	@param [options] {Object} Options for path drawing
                *	@param [options.color='#ff834c'] {String} Path Colour
                *	@param [options.pulseColor='#ffffff'] {String} Colour of path pulse
                *	@param [options.pulseIterations=1] {Number} Number of iterations to pulse to indicate direction, also accepts 'Infinity'
                *	@param [options.pulsePauseDuration=750] {Number} How many milliseconds to wait before starting the next pulse after the current pulse travels the entirety of the path
                *	@param [options.nearRadius=1.8] {Number} Radius of path at nearest zoom
                *	@param [options.farRadius=options.nearRadius] {Number} Radius of path at furthest zoom
                *	@param [options.nearZoom=375] {Number} Zoom level where the path size is `nearRadius`
                *	@param [options.farZoom=10000] {Number} Zoom level where the path size is `farRadius`
                *	@param [options.drawDuration=1200] {Number} Duration of path drawing
                *	@param [options.curve=TWEEN.Easing.Cubic.InOut] {Object} Path animation curve
                *
                *	// NOTE: These options are disabled
                *	@param [options.drawConnectionSegments=true] Draw map-to-map connection segments
                *	@param [options.connectionPathOptions] {Object} Options for floor-to-floor connection paths
                *	@param [options.connectionPathOptions.color='#ff834c'] {String} Path Colour
                *	@param [options.connectionPathOptions.pulseColor='#ffffff'] {String} Colour of path pulse
                *	@param [options.connectionPathOptions.pulseIterations=Infinity] {Number} Number of iterations to pulse to indicate direction
                *	@param [options.connectionPathOptions.nearRadius=1.8] {Number} Radius of path at nearest zoom
                *	@param [options.connectionPathOptions.farRadius=options.connectionPathOptions.nearRadius] {Number} Radius of path at furthest zoom
                *	@param [options.connectionPathOptions.nearZoom=375] {Number} Zoom level where the path size is `nearRadius`
                *	@param [options.connectionPathOptions.farZoom=10000] {Number} Zoom level where the path size is `farRadius`
                *	@param [options.connectionPathOptions.drawDuration=600] {Number} Duration of path drawing
                *	@param [options.connectionPathOptions.curve=TWEEN.Easing.Cubic.InOut] {Object} Connection Path animation curve
                *
                * @returns {Array} Array of Tween segments representing paths drawn on screen
                */
            drawPath(path: (MappedinNode | MappedinCoordinate)[], options?: TPathOptionsInternal): Path;
            /**
                * Redraw an existing path with optional new options. This avoids changing its ID or reference.
                */
            redrawPath(path: Path, options?: TPathOptionsInternal): void;
            removePath(pathOrPathId: Path | string): void;
            hideConnectionSegments(): void;
            showConnectionSegments(): void;
            removeAllPaths(): void;
    }
    export default PathsController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/FloatingLabelsController' {
    import { InternalFloatingLabel } from '@mappedin/mappedin-js/renderer/internal';
    import type { ICore, TFloatingLabelAllLocationsOptions, TAddFloatingLabelOptions, TFloatingLabelAppearance } from '@mappedin/mappedin-js/renderer/internal';
    import { MappedinPolygon, MappedinCoordinate, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    /**
        * A floating label that is attached to a node or coordinate on the map.
        */
    export class FloatingLabel {
            #private;
            /**
                * @hidden
                * @internal
                */
            constructor(internalFloatingLabel: InternalFloatingLabel);
            /**
                * The ID of this label.
                */
            get id(): string;
            /**
                * The text of this label.
                */
            get text(): string | undefined;
            /**
                * The {@link TFloatingLabelAppearance} options of this label with defaults.
                */
            get appearance(): Required<TFloatingLabelAppearance>;
            /**
                * The {@link MappedinNode} or {@link MappedinCoordinate} that this label is attached to.
                */
            get nodeOrCoordinate(): MappedinNode | MappedinCoordinate;
            /**
                * The collision rank of this label.
                */
            get rank(): number;
            /**
                * @hidden
                * @internal
                */
            __updateInstance(internalFloatingLabel: InternalFloatingLabel): void;
            /**
                * Object representation of this label.
                */
            toJSON(): {
                    id: string;
                    text: string | undefined;
                    appearance: Required<TFloatingLabelAppearance>;
                    nodeOrCoordinate: any;
                    rank: number;
            };
    }
    class FloatingLabelsController {
            #private;
            core: ICore;
            internalFloatingLabels: Record<string, InternalFloatingLabel>;
            internalFloatingLabelsByNodeOrCoordinate: WeakMap<MappedinNode | MappedinCoordinate, InternalFloatingLabel>;
            floatingLabels: Record<string, FloatingLabel>;
            constructor(core: ICore);
            addLabel(target: MappedinPolygon, text: string, options?: TAddFloatingLabelOptions): FloatingLabel[];
            addLabel(target: MappedinNode | MappedinCoordinate, text: string, options?: TAddFloatingLabelOptions): FloatingLabel;
            removeLabel(target: MappedinPolygon | MappedinNode | MappedinCoordinate, bulk?: boolean): void;
            setPriority(target: MappedinPolygon | MappedinNode | MappedinCoordinate, rank: number): void;
            resetPriority(target: MappedinPolygon | MappedinNode | MappedinCoordinate): void;
            removeAllLabels(): void;
            setAppearance(target: MappedinPolygon | MappedinNode | MappedinCoordinate, appearance: TFloatingLabelAppearance): void;
            labelAllLocations(options?: TFloatingLabelAllLocationsOptions): FloatingLabel[];
    }
    export default FloatingLabelsController;
}

declare module '@mappedin/mappedin-js/navigator' {
    import NavigationGraph from '@mappedin/mappedin-js/navigator/NavigationGraph';
    import Navigator from '@mappedin/mappedin-js/navigator/Navigator';
    export { ACTION_TYPE, BEARING_TYPE } from '@mappedin/mappedin-js/navigator/Directive';
    export { Navigator, NavigationGraph };
    export type { IDirectionsResult, TSimplifyDirectionsOptions } from '@mappedin/mappedin-js/navigator/Navigator';
    export { E_MESSAGES } from '@mappedin/mappedin-js/navigator/Navigator';
    export { E_SDK_LOG_LEVEL, setLoggerLevel } from '@mappedin/mappedin-js/--/common/Mappedin.Logger';
}

declare module '@mappedin/mappedin-js/renderer/public/api/FlatLabels' {
    import { MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    import FlatLabelsController from '@mappedin/mappedin-js/renderer/private/controllers/FlatLabelsController';
    import { TFlatLabelAllLocationsOptions, TAddFlatLabelOptions, TFlatLabelAppearance } from '@mappedin/mappedin-js/renderer/MapView.types';
    /**
        * API to add and remove flat labels on the map.
        */
    export interface IFlatLabels<T = void> {
            /**
                * Add a flat label to the polygons associated with all locations on the venue.
                * The text is automatically determined based on location data.
                *
                * ```ts
                * // Draw red labels on all polygons with a location
                * mapView.FlatLabels.labelAllLocations({
                * 	appearance: {
                * 		color: 'red',
                * 	}
                * });
                * ```
                * @param options
                */
            labelAllLocations(options?: TFlatLabelAllLocationsOptions): T;
            /**
                * Add a flat label to a single polygon.
                *
                * ```ts
                * // Label the apple store with the label "Apple Store"
                * const location = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * mapView.FlatLabels.add(location.polygons[0], "Apple Store");
                * ```
                *
                * @param polygon The {@link MappedinPolygon} to label.
                * @param text The text to display on the label.
                * @param options
                */
            add(polygon: MappedinPolygon, text: string, options?: TAddFlatLabelOptions): T;
            /**
                * Remove a flat label from a single polygon.
                *
                * ```ts
                * mapView.FlatLabels.add(polygon, "Label");
                *
                * ...
                *
                * // Remove the label currently on this polygon
                * mapView.FlatLabels.remove(polygon);
                * ```
                *
                * @param polygon The {@link MappedinPolygon} with a label to remove.
                */
            remove(polygon: MappedinPolygon): T;
            /**
                * Remove all flat labels from the venue.
                *
                * ```ts
                * mapView.FlatLabels.add(polygon1, "Label 1");
                * mapView.FlatLabels.add(polygon2, "Label 2");
                *
                * ...
                *
                * // Remove all labels from all polygons
                * mapView.FlatLabels.removeAll();
                * ```
                */
            removeAll(): T;
            /**
                * Update the appearance attributes of an already-existing label. If the
                * provided polygon does not have a label already, this is a no-op.
                *
                * ```ts
                * mapView.FlatLabels.setAppearance(polygon, {
                * 	color: 'blue',
                * 	font: 'times',
                * });
                * ```
                *
                * @param polygon The {@link MappedinPolygon} with a label to update.
                * @param appearance The new {@link TFlatLabelAppearance} settings to apply to the polygon's label.
                */
            setAppearance(polygon: MappedinPolygon, appearance: TFlatLabelAppearance): T;
            /**
                * Set the hover text color for all Flat Labels. To set hover color for all polygons,
                * see {@link MapView.setHoverColor}.
                *
                * ```ts
                * // Make all flat labels turn red on hover
                * mapView.FlatLabels.setHoverColorForAll('#ff0000');
                * ```
                *
                * @param color A hexidecimal string representing the hover color.
                */
            setHoverColorForAll(color: string): T;
    }
    export class FlatLabels implements IFlatLabels {
            #private;
            /**
                * @hidden
                */
            constructor(controller: FlatLabelsController);
            labelAllLocations(options?: TFlatLabelAllLocationsOptions): void;
            add(polygon: MappedinPolygon, text: string, options?: TAddFlatLabelOptions): void;
            remove(polygon: MappedinPolygon): void;
            removeAll(): void;
            setAppearance(polygon: MappedinPolygon, appearance: TFlatLabelAppearance): void;
            setHoverColorForAll(color: string): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/public/api/FloatingLabels' {
    import { MappedinCoordinate, MappedinNode, MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    import { TAddFloatingLabelOptions, TFloatingLabelAllLocationsOptions, TFloatingLabelAppearance } from '@mappedin/mappedin-js/renderer/MapView.types';
    import FloatingLabelsController, { type FloatingLabel } from '@mappedin/mappedin-js/renderer/private/controllers/FloatingLabelsController';
    /**
        * Helper for handling a generic when the type could be either an array or promise.
        *
        * 1. If the type is an array, return the array.
        *
        * ```ts
        * type A = ArrayablePromise<string[]> // string[]\
        * ```
        *
        * 2. If the type is a void promise, return the void promise.
        *
        * ```ts
        * type B = ArrayablePromise<Promise<void>> // Promise<void>
        * ```
        *
        * 3. If the type is a non void promise, return the promise's resolved type wrapped in an array.
        *
        * ```ts
        * type C = ArrayablePromise<Promise<string>> // Promise<string[]>
        * ```
        */
    type PromisableArray<T> = T extends Promise<infer G> ? Promise<G extends void ? void : G[]> : T[];
    /**
        * API to add and remove floating labels on the map.
        */
    export interface IFloatingLabels<T = FloatingLabel> {
            /**
                * Add a floating label to one entrance node of each polygons associated with all
                * locations on the venue. The text is automatically determined based on location data.
                *
                * ```ts
                * // Draw red labels with black outlines on an entrance node of all polygons with a location
                * mapView.FloatingLabels.labelAllLocations({
                * 	appearance: {
                * 		text: {
                * 			foregroundColor: 'red',
                * 			backgroundColor: 'black',
                * 		}
                * 	}
                * });
                * ```
                * @param options
                */
            labelAllLocations(options?: TFloatingLabelAllLocationsOptions): PromisableArray<T>;
            /**
                * Add a floating label to a single polygon or node. When labelling a polygon,
                * all entrance nodes of that polygon receive a label.
                *
                * ```ts
                * // Label the apple store with the label "Apple Store"
                * const location = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * mapView.FloatingLabels.add(location.nodes[0], "Apple Store");
                * ```
                *
                * @param polygonOrNode The {@link MappedinPolygon} or {@link MappedinNode} or {@link MappedinCoordinate} to label.
                * @param text The text to display on the label.
                * @param options
                */
            add(polygonOrNode: MappedinPolygon, text: string, options?: TAddFloatingLabelOptions): PromisableArray<T>;
            add(polygonOrNode: MappedinNode | MappedinCoordinate, text: string, options?: TAddFloatingLabelOptions): T;
            add(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate, text: string, options?: TAddFloatingLabelOptions): PromisableArray<T> | T;
            /**
                * Update the appearance attributes of an already-existing label. If the
                * provided polygon or node does not have a label already, this is a no-op.
                *
                * ```ts
                * mapView.FloatingLabels.setAppearance(node, {
                * 	text: {
                * 		size: 25,
                * 	}
                * });
                * ```
                *
                * @param polygonOrNode The {@link MappedinPolygon} or {@link MappedinNode} or {@link MappedinCoordinate} with a label to update.
                * @param appearance The new {@link TFlatLabelAppearance} settings to apply to the polygon's label.
                */
            setAppearance(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate, appearance: TFloatingLabelAppearance): void;
            /**
                * Remove a floating label from a single polygon or node.
                *
                * ```ts
                * mapView.FloatingLabels.add(polygon, "Label");
                *
                * ...
                *
                * // Remove the label currently on this polygon's first entrance
                * mapView.FloatingLabels.remove(polygon.entrances[0]);
                * ```
                *
                * @param polygonOrNode The {@link MappedinPolygon} or {@link MappedinNode} or {@link MappedinCoordinate} with a label to remove.
                */
            remove(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate): void;
            /**
                * Remove all floating labels from the venue.
                *
                * ```ts
                * mapView.FloatingLabels.add(polygon, "Label 1");
                * mapView.FloatingLabels.add(node, "Label 2");
                *
                * ...
                *
                * // Remove all labels from all polygons
                * mapView.FloatingLabels.removeAll();
                * ```
                */
            removeAll(): void;
            /**
                * Updates the priority of an existing floating label (or labels, in the case
                * of a polygon). This controls whether it is preferred over other labels
                * during collisions.
                *
                * ```ts
                * // Polygon 1's label should always show above polygon 2's label
                * mapView.FloatingLabels.setPriority(polygon0, 0);
                * mapView.FloatingLabels.setPriority(polygon1, 1);
                * ```
                *
                * @param polygonOrNode The {@link MappedinPolygon} or {@link MappedinNode} or {@link MappedinCoordinate} with a label to update.
                */
            setPriority(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate, priority: number): void;
            /**
                * Resets the priority of an existing floating label (or labels, in the case
                * of a polygon)
                *
                * ```ts
                * mapView.FloatingLabels.setPriority(polygon0, 0);
                * mapView.FloatingLabels.setPriority(polygon1, 1);
                *
                * ...
                *
                * // Labels should now behave as they did by default
                * mapView.FloatingLabels.resetPriority();
                * ```
                *
                * @param polygonOrNode The {@link MappedinPolygon} or {@link MappedinNode} or {@link MappedinCoordinate} with a label to update.
                */
            resetPriority(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate): void;
    }
    export class FloatingLabels implements IFloatingLabels {
            #private;
            /**
                * @hidden
                */
            constructor(controller: FloatingLabelsController);
            labelAllLocations(options?: TFloatingLabelAllLocationsOptions | undefined): FloatingLabel[];
            add(polygonOrNode: MappedinPolygon, text: string, options?: TAddFloatingLabelOptions | undefined): FloatingLabel[];
            add(polygonOrNode: MappedinNode | MappedinCoordinate, text: string, options?: TAddFloatingLabelOptions | undefined): FloatingLabel;
            setAppearance(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate, appearance: TFloatingLabelAppearance): void;
            remove(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate): void;
            removeAll(): void;
            setPriority(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate, priority: number): void;
            resetPriority(polygonOrNode: MappedinPolygon | MappedinNode | MappedinCoordinate): void;
    }
    export {};
}

declare module '@mappedin/mappedin-js/renderer/public/api/Camera' {
    import { E_CAMERA_DIRECTION } from '@mappedin/mappedin-js/renderer/MapView.enums';
    import CameraController, { TCameraAnimationOptions, TCameraInteractionsSetOptions, TCameraTargets, TCameraTransform, TFocusOnCameraOptions } from '@mappedin/mappedin-js/renderer/private/controllers/CameraController';
    /**
        * API to control and respond to the state of the camera within the scene.
        */
    export class Camera {
            #private;
            /**
                * @hidden
                */
            constructor(controller: CameraController);
            /**
                * Subscribe a function to be called when an {@link E_CAMERA_EVENT} is fired.
                *
                * ```ts
                * const cameraChangedHandler = ({ tilt, position, zoom, rotation }) => {
                * 	// Do something with the new values
                * };
                * mapView.Camera.on(E_CAMERA_EVENT.CHANGED, cameraChangedHandler);
                * ```
                *
                * @param eventName An {@link E_CAMERA_EVENT} that is fired when the camera changes.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of {@link CAMERA_EVENT_PAYLOAD}.
                */
            on: CameraController['on'];
            /**
                * Unsubscribe a function that was previously subscribed with {@link on}.
                *
                * ```ts
                * mapView.Camera.on(E_CAMERA_EVENT.CHANGED, cameraChangedHandler);
                *
                * ...
                *
                * // Something changed and I no longer want this event to fire
                * mapView.Camera.off(E_CAMERA_EVENT.CHANGED, cameraChangedHandler);
                * ```
                *
                * @param eventName An {@link E_CAMERA_EVENT} that is fired when the camera changes.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                */
            off: CameraController['off'];
            /**
                * The current camera animation, if any. Resolves when the animation finishes.
                */
            get currentAnimation(): Promise<undefined> | undefined;
            /**
                * Current Camera zoom (in meters)
                */
            get zoom(): number;
            /**
                * Current Camera rotation (in radians) from north
                */
            get rotation(): number;
            /**
                * Current camera tilt angle (in radians), relative to a top-down view.
                *
                * ex: 0 means the camera is facing top-down, π/2 means the camera is
                * facing directly from the side.
                */
            get tilt(): number;
            /**
                * Get the minimum distance (in meters) the camera is allowed to get to the ground.
                */
            get minZoom(): number;
            /**
                * Set the minimum distance (in meters) the camera is allowed to get to the ground.
                */
            set minZoom(meters: number);
            /**
                * Get the maximum distance (in meters) the camera is allowed to get from the ground.
                */
            get maxZoom(): number;
            /**
                * Set the maximum distance (in meters) the camera is allowed to get from the ground.
                */
            set maxZoom(meters: number);
            /**
                * Get the current maximum tilt angle (in radians) the camera is allowed to use.
                */
            get maxTilt(): number;
            /**
                * Sets the maximum tilt angle (in radians) the camera is allowed to use.
                *
                * Tilt angle must be between 0 and π/2 radians. It will be clamped within
                * this range if it exceeds it on either end.
                *
                * As tilt angle approaches π/2 radians, this will impact overall touch controls
                * and should be used sparingly.
                */
            set maxTilt(radians: number);
            /**
                * Get the current camera position, which is at the center of the map.
                * @returns the position as a coordinate
                */
            get position(): import("../..").MappedinCoordinate;
            /**
                * Enable or disable the ability for the user to interact with the camera (e.g. pan, zoom, tilt, etc).
                * This does not affect programmatic camera controls, such as {@link set} and {@link focusOn}.
                *
                * ```ts
                * // The user can no longer interact to move the camera
                * mapView.Camera.interactions.disable();
                *
                * // The user can now interact to move the camera again
                * mapView.Camera.interactions.enable();
                * ```
                */
            interactions: {
                    /**
                        * Enable or disable specific user interactions.
                        *
                        * ```ts
                        * mapView.Camera.interactions.set({ zoom: false });
                        * ```
                        *
                        * @param options An object defining the interactions to switch on or off.
                        *
                        */
                    set: (options: TCameraInteractionsSetOptions) => void;
                    /**
                        * Enable all user interactions.
                        */
                    enable: () => void;
                    /**
                        * Disable all user interactions.
                        */
                    disable: () => void;
            };
            /**
                * Define an area of the screen that is safe for the camera. Anything outside the safe area is
                * assumed to be covered in some way (e.g. by UI) meaning the camera will not place
                * any map elements there when calling {@link focusOn}.
                *
                * ```ts
                * // The top 100px of the canvas are covered by a UI element
                * mapView.Camera.setSafeAreaInsets({ top: 100, left: 0, bottom: 0, right: 0});
                * mapView.Camera.focusOn({ nodes });
                * ```
                *
                * @param insets An object defining a number of pixels from the top, left, bottom, and right of
                * the screen. Only the area within the padding defined by these pixels is considered safe.
                */
            setSafeAreaInsets(insets: {
                    top: number;
                    left: number;
                    bottom: number;
                    right: number;
            }): void;
            /**
                * Retrieve the values previously set by {@link setSafeAreaInsets}.
                *
                * @returns An object defining a number of pixels from the top, left, bottom, and right of
                * the screen.
                */
            getSafeAreaInsets(): import("../..").TPadding;
            /**
                * Animate the camera to focus on a collection of targets. To control where the targets should
                * be placed on screen, either specify `safeAreaInsets` on the {@link TFocusOnCameraOptions}
                * or call {@link setSafeAreaInsets}.
                *
                * ```ts
                * const location = mapView.venue.locations.find((l) => l.name === "My Location")!;
                *
                * mapView.Camera.focusOn({
                * 	polygons: location.polygons,
                * 	nodes: location.nodes,
                * });
                * ```
                *
                * @param targets A collection of things that the camera will place into view at the end of the
                * animation.
                * @param options
                * @returns a Promise that resolves when the animation finishes, or rejects when it is cancelled.
                */
            focusOn(targets: TCameraTargets, options?: TFocusOnCameraOptions & TCameraAnimationOptions): Promise<any>;
            /**
                * Instantaneously set the camera's transform to be in a new configuration. See also {@link animate}.
                *
                * ```ts
                * const coord = mapView.venue.maps[0].createCoordinate(33.66107, 31.83911);
                *
                * // Place the camera top-down at a specified coordinate
                * mapView.Camera.set({
                * 	tilt: 0,
                * 	position: coord,
                * });
                * ```
                *
                * @param transform The new transform of the camera.
                */
            set(transform: TCameraTransform): void;
            /**
                * Convert a Mercator Zoom Level to altitude, which can be used in the Camera APIs
                */
            convertZoomLevelToAltitude(zoomLevel: number): any;
            /**
                * Convert the altitude returned by getZoom into Mercator Zoom level
                */
            convertAltitudeToZoomLevel(altitude: number): any;
            /**
                * Smoothly transition the camera's transform to be in a new configuration. See also {@link set}.
                *
                * ```ts
                * const coord = mapView.venue.maps[0].createCoordinate(33.66107, 31.83911);
                *
                * // Animate the camera to be top-down at a specified coordinate
                * mapView.Camera.animate({
                * 	tilt: 0,
                * 	position: coord,
                * });
                * ```
                *
                * @param transform The new transform of the camera.
                * @param options
                * @returns a Promise that resolves when the animation finishes, or rejects when it is cancelled.
                */
            animate(transform: TCameraTransform, options?: TCameraAnimationOptions): Promise<undefined>;
            /**
                * Moves the Camera view in a relative direction by a given distance in meters.
                *
                * ```ts
                * // Move the camera 50 meters up relative to the camera frame
                * mapView.Camera.translate(E_CAMERA_DIRECTION.UP, 50);
                * ```
                *
                * @returns a Promise that resolves when the translation animation finishes, or rejects when it is cancelled.
                */
            translate(direction: E_CAMERA_DIRECTION, distance: number, options?: TCameraAnimationOptions): Promise<unknown>;
            /**
                * Cancel the currently active Camera animation.
                */
            cancelAnimation(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/public/api/BlueDot' {
    import { BlueDotController, TEnableBlueDotOptions } from '@mappedin/mappedin-js/renderer/MapView.types';
    /**
        * API to enable and respond to user position updates.
        */
    export class BlueDot {
            #private;
            /**
                * @hidden
                */
            constructor(controller: BlueDotController);
            /**
                * Subscribe a function to be called when an {@link E_BLUEDOT_EVENT} is fired.
                *
                * ```ts
                * const blueDotChangeHandler = ({ map, nearestNode, position, bearing }) => {
                * 	// Do something with the new values
                * };
                * mapView.BlueDot.on(E_BLUEDOT_EVENT.POSITION_UPDATE, blueDotChangeHandler);
                * ```
                *
                * @param eventName An {@link E_BLUEDOT_EVENT} that is fired when the blue dot changes.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of {@link E_BLUEDOT_EVENT_PAYLOAD}.
                */
            on: BlueDotController['on'];
            /**
                * Unsubscribe a function that was previously subscribed with {@link on}.
                *
                * ```ts
                * mapView.BlueDot.on(E_BLUEDOT_EVENT.POSITION_UPDATE, blueDotChangeHandler);
                *
                * ...
                *
                * // Something changed and I no longer want this event to fire
                * mapView.BlueDot.off(E_BLUEDOT_EVENT.POSITION_UPDATE, blueDotChangeHandler);
                * ```
                *
                * @param eventName An {@link E_BLUEDOT_EVENT} that is fired when the blue dot changes.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                */
            off: BlueDotController['off'];
            /**
                * Enables Blue Dot. A blue dot will appear on the map that responds to the device's geolocation
                * updates. It then emits {@link TBlueDotStateChange} and {@link TBlueDotPositionUpdate} events
                * via {@link E_BLUEDOT_EVENT}.
                *
                * ```ts
                * // Enable blue dot
                * mapView.BlueDot.enable();
                *
                * // Disable blue dot
                * mapView.BlueDot.disable();
                * ```
                *
                * @param options
                */
            enable(options?: TEnableBlueDotOptions): void;
            /**
                * Disables Blue Dot that was enabled with {@link enable} and stops emitting events.
                *
                * ```ts
                * // Enable blue dot
                * mapView.BlueDot.enable();
                *
                * // Disable blue dot
                * mapView.BlueDot.disable();
                * ```
                */
            disable(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/public/api/Markers' {
    import { TAnimationOptions } from '@mappedin/mappedin-js/renderer';
    import { MappedinCoordinate, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    import { TCreateMarkerOptions } from '@mappedin/mappedin-js/renderer/internal';
    import MarkersController, { Marker } from '@mappedin/mappedin-js/renderer/private/controllers/MarkersController';
    /**
        * API to control adding 2D markers to the scene.
        */
    export class Markers {
            #private;
            /**
                * @hidden
                */
            constructor(markersController: MarkersController);
            /**
                * An array of {@link Marker} instances that currently exist.
                */
            get markers(): Marker[];
            /**
                * Create a new {@link Marker}, containing some HTML, at the specified position.
                *
                * ```ts
                * mapView.Markers.add(coordinate, `
                * 	<div
                * 		id="my-marker"
                * 		style="width:100px;height:40px;background:red;"
                * 	>
                * 		My Marker
                * 	</div>
                * `);
                * ```
                *
                * @param nodeOrCoordinate The {@link MappedinNode} or {@link MappedinCoordinate} to
                * which the marker is pinned.
                * @param contentHtml Stringified HTML content to render inside the Marker.
                * @param options
                * @returns The {@link Marker} object that was created.
                */
            add(nodeOrCoordinate: MappedinNode | MappedinCoordinate, contentHtml: string, options?: TCreateMarkerOptions): Marker;
            /**
                * Moves an existing {@link Marker} to a new position instantaneously. See
                * also {@link animate}.
                *
                * ```ts
                * const marker = mapView.Markers.add(...);
                *
                * // Move the marker to a new coordinate
                * mapView.Markers.setPosition(marker, newCoordinate);
                * ```
                *
                * @param markerOrMarkerId The {@link Marker} to move.
                * @param target The {@link MappedinNode} or {@link MappedinCoordinate} to
                * which the marker should be moved.
                */
            setPosition(markerOrMarkerId: Marker | Marker['id'], target: MappedinNode | MappedinCoordinate): void;
            /**
                * Moves an existing {@link Marker} to a new position smoothly over time.
                *
                * ```ts
                * const marker = mapView.Markers.add(...);
                *
                * // Animate the marker to a new coordinate over 500ms
                * mapView.Markers.animate(marker, newCoordinate, {
                * 	duration: 500
                * });
                * ```
                *
                * @param markerOrMarkerId The {@link Marker} to move.
                * @param target The {@link MappedinNode} or {@link MappedinCoordinate} to
                * which the marker should be moved.
                * @param options
                */
            animate(markerOrMarkerId: Marker | Marker['id'], target: MappedinCoordinate | MappedinNode, options?: TAnimationOptions): Promise<void>;
            /**
                * Removes an existing {@link Marker}.
                *
                * ```ts
                * const marker = mapView.Markers.add(...);
                *
                * ...
                *
                * // The marker is no longer needed
                * mapView.Markers.remove(marker);
                * ```
                *
                * @param markerOrMarkerId the {@link Marker} to be removed.
                */
            remove(markerOrMarkerId: Marker | Marker['id']): void;
            /**
                * Remove all {@link Marker} instances from all maps.
                *
                * ```ts
                * mapView.Markers.removeAll();
                * ```
                */
            removeAll(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/public/api/Paths' {
    import { MappedinCoordinate, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    import { TPathOptions } from '@mappedin/mappedin-js/renderer/internal';
    import PathsController, { Path } from '@mappedin/mappedin-js/renderer/private/controllers/PathsController';
    /**
        * API to add and remove paths from maps. See also {@link Journey}.
        */
    export class Paths {
            #private;
            /**
                * @hidden
                */
            constructor(pathsController: PathsController);
            /**
                * An array of all {@link Path} instances that are currently drawn.
                */
            get paths(): Path[];
            /**
                * Takes an array of {@link MappedinNode} instances and draws an {@link Path} with
                * path segments on each map corresponding to the nodes on that map.
                *
                * ```ts
                * const departure = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * const destination = mapView.venue.locations.find((l) => l.name === "Cleo")!;
                * const directions = departure.directionsTo(destination);
                *
                * // Draw the above directions as a path on the map
                * mapView.Paths.add(directions.path);
                * ```
                *
                * @param nodes A {@link MappedinNode} array, probably from a {@link MappedinDirections} instance.
                * @param options
                */
            add(nodes: (MappedinNode | MappedinCoordinate)[], options?: TPathOptions): Path;
            /**
                * Remove a {@link Path} from all maps it exists on.
                *
                * ```ts
                * const path = mapView.Paths.add(nodes);
                *
                * ...
                *
                * // The path is no longer needed
                * mapView.Paths.remove(path);
                * ```
                *
                * @param path The {@link Path} instance to be removed.
                */
            remove(path: Path): void;
            /**
                * Remove all {@link Path} instances from all maps.
                */
            removeAll(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/public/api/StackedMaps' {
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import { STACKED_MAPS_STATE, StackedMapsController, TCameraTransform } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @experimental
        * API for showing multiple maps involved in a {@link Journey} as a vertical stack.
        */
    export class StackedMaps {
            #private;
            /**
                * @hidden
                */
            constructor(markersController: StackedMapsController);
            /**
                * @experimental
                * Enable Stacked Maps. A {@link Journey} must be drawn beforehand or this method will fail.
                * Use {@link showOverview} to expand the maps vertically after enabling.
                *
                * Upon enabling, map state will become {@link STATE.STACKED | STACKED} and Stacked Maps state will become {@link STACKED_MAPS_STATE.ACTIVE | ACTIVE}.
                *
                * @example
                * ```ts
                * // Create a Journey
                * const startLocation = mapView.venue.locations.find(...);
                * const endLocation = mapView.venue.locations.find(...);
                * mapView.Journey.draw(startLocation.directionsTo(endLocation));
                *
                * // Enable and show Stacked Maps Overview
                * mapView.StackedMaps.enable({
                *		verticalDistanceBetweenMaps: 150
                * });
                * mapView.StackedMaps.showOverview();
                * ```
                *
                * @returns Promise when all animations are complete.
                */
            enable: (opts?: {
                    verticalDistanceBetweenMaps?: number;
            }) => Promise<void>;
            /**
                * @experimental
                *
                * Disable Stacked Maps and zoom in to the current map. Stacked Maps state will become {@link STACKED_MAPS_STATE.INACTIVE | INACTIVE}.
                *
                * @example
                * ```ts
                * mapView.StackedMaps.disable();
                * ```
                *
                * @returns Promise when all animations are complete.
                */
            disable: () => Promise<void>;
            /**
                * @experimental
                *
                * Expand the maps in the current {@link Journey} vertically and add vertical paths between connections.
                * Stacked Maps must be enabled beforehand and state will become {@link STACKED_MAPS_STATE.OVERVIEW | OVERVIEW}.
                *
                * @example
                * ```ts
                * mapView.Journey.draw(...)
                * mapView.StackedMaps.enable();
                * mapView.StackedMaps.showOverview();
                * ```
                *
                * @returns Promise when all animations are complete.
                */
            showOverview: () => Promise<void>;
            /**
                * @experimental
                *
                * Scroll the camera to a specific map in {@link STACKED_MAPS_STATE.OVERVIEW | OVERVIEW} state.
                *
                * @example
                * ```ts
                * // Zoom into a clicked map if Stacked Maps is in Overview state
                * mapView.on(E_SDK_EVENT.CLICK, ({ maps }) => {
                * 	if (maps.length <= 0) return;
                * 	if (mapView.StackedMaps.state === STACKED_MAPS_STATE.OVERVIEW) {
                * 		mapView.StackedMaps.scrollToMap(maps[0]);
                * 	}
                * });
                * ```
                *
                * @returns Promise when all animations are complete.
                */
            scrollToMap: (map: MappedinMap) => Promise<void>;
            /**
                * @experimental
                *
                * Scroll and zoom into a specific map in {@link STACKED_MAPS_STATE.OVERVIEW | OVERVIEW} state. Stacked Maps state will become {@link STACKED_MAPS_STATE.ZOOMED_IN | ZOOMED_IN}.
                *
                * @example
                * ```ts
                * // Zoom into a clicked map if Stacked Maps is in Overview state
                * mapView.on(E_SDK_EVENT.CLICK, ({ maps }) => {
                * 	if (maps.length <= 0) return;
                * 	if (mapView.StackedMaps.state === STACKED_MAPS_STATE.OVERVIEW) {
                * 		mapView.StackedMaps.zoomInToMap(maps[0]);
                * 	}
                * });
                * ```
                *
                * @returns Promise when all animations are complete.
                */
            zoomInToMap: (map: MappedinMap, cameraTransform?: TCameraTransform) => Promise<void>;
            /**
                * @experimental
                *
                * Get the current state of Stacked Maps.
                *
                * @returns The current {@link STACKED_MAPS_STATE}
                */
            get state(): STACKED_MAPS_STATE;
    }
}

declare module '@mappedin/mappedin-js/renderer/public/api/OutdoorView' {
    import { OutdoorViewController } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @experimental
        * API to control outdoor view rendering. Outdoor view can be enabled when
        * initializing the {@link MapView} with `outdoorView: { enabled: true }` in {@link TMapViewOptions}.
        * @example
        * ```typescript
        * const mapView = await showVenue(document.getElementById('mappedin-map'), venue, {
        * 	multiBufferRendering: true,
        * 	outdoorView: {
        * 		enabled: true,
        *	},
        * });
        * ```
        */
    export class OutdoorView {
            #private;
            /**
                * @private
                */
            constructor(outdoorViewController: OutdoorViewController | undefined);
            /**
                * @experimental
                * @param style A style object conforming to the [Maplibre Style Spec](https://maplibre.org/maplibre-style-spec/)
                * @returns
                */
            setStyle(style: any): void;
            /**
                * @experimental
                * A position definition for the attribution control to be placed, can be in one of the corners of the map.
                *
                * @param {string} style A position definition
                * @returns
                */
            setAttributionPosition(position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'): void;
            /**
                * Show the outdoor view. Outdoor view must first be enabled in {@link TMapViewOptions} during {@link showVenue}.
                * See also {@link hide}.
                */
            show(): void;
            /**
                * Hide the outdoor view. Outdoor view must first be enabled in {@link TMapViewOptions} during {@link showVenue}.
                * See also {@link show}.
                */
            hide(): void;
    }
    export default OutdoorView;
}

declare module '@mappedin/mappedin-js/renderer/public/api/DynamicFocus' {
    import { MappedinMap, MappedinMapGroup } from '@mappedin/mappedin-js/get-venue';
    import { DynamicFocusSceneManager } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @experimental
        * API to dynamically set the map focus as you pan over map groups. Dynamic Focus can be enabled when
        * initializing the {@link MapView} with base map set in {@link TMapViewOptions}
        * @example
        * ```typescript
        * const mapView = await showVenue(document.getElementById('mappedin-map'), venue, {
        * 	dynamicFocus: {
        * 		baseMap: venue.maps[0],
        *		},
        * });
        * ```
        */
    class DynamicFocus {
            #private;
            /**
                * @hidden
                */
            constructor(dynamicFocusSceneManager: DynamicFocusSceneManager);
            /**
                * @experimental
                * Controls whether the map should be set when the user pans over to it.
                *
                * @example
                * ```ts
                * if (mapView.DynamicFocus) {
                *	mapView.DynamicFocus.setMapOnUserInteraction = false;
                * }
                * ```
                */
            set setMapOnUserInteraction(value: boolean);
            /**
                * @experimental
                * Returns the current boolean value whether the map should be set when the user pans over it.
                *
                * @example
                * ```ts
                * if(mapView.DynamicFocus && mapView.DynamicFocus.setMapOnUserInteraction) {
                * 	mapView.DynamicFocus.setMapOnUserInteraction = false;
                * }
                * ```
                */
            get setMapOnUserInteraction(): boolean;
            /**
                * @experimental
                * Force Dynamic Focus to evaluate and set the current map based on camera position.
                *
                * @example
                * ```ts
                * // Animate the camera to focus on a building
                * await mapView.Camera.focusOn({
                * 	polygons: venue.locations.find(l => l.name === 'Building')?.polygons,
                * });
                * // Force Dynamic Focus update
                * mapView.DynamicFocus?.update();
                * ```
                */
            update(): void;
            /**
                * Set the default map for a map group. This map will be set when the user pans over the map group.
                */
            setDefaultMapForMapGroup(mapGroup: MappedinMapGroup, map: MappedinMap): void;
            /**
                * Reset the default map for a map group. This map will be set when the user pans over the map group.
                */
            resetDefaultMapForMapGroup(mapGroup: MappedinMapGroup): void;
    }
    export { DynamicFocus };
}

declare module '@mappedin/mappedin-js/renderer/public/api/Layers' {
    import { Feature, FeatureCollection, GeoJsonProperties, Polygon } from 'geojson';
    import { LayerController, MappedinMap } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @experimental
        * API to control per-map layer management, visibility and interpolations.
        */
    export class Layers {
            #private;
            /**
                * @private
                */
            constructor(layerController: LayerController | undefined);
            /**
                * @experimental
                * Returns a mapping of all layers for a map, and whether they are visible or not.
                */
            getAllLayersForMap(map: MappedinMap): Promise<{
                    [layerName: string]: boolean;
            }>;
            /**
                * @experimental
                * Re-renders the map only showing the layers specified in the array. This will discard any polygons that have been highlighted.
                */
            showLayers(layers: string[]): void;
            /**
                * @experimental
                * Adds a GeoJSON Feature or FeatureCollection to the map as a layer. The layer name must be unique
                */
            addGeoJSONLayer(layerName: string, featureOrFeatureCollection: Feature<Polygon, GeoJsonProperties | null> | FeatureCollection<Polygon, GeoJsonProperties | null>): Promise<void> | undefined;
    }
    export default LayerController;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartTooltip' {
    import './Mappedin.SmartTooltip.scss';
    import { HTMLCollider, COLLISION_RANKING_TIERS } from '@mappedin/mappedin-js/renderer/internal';
    import type { IHTMLCollider, TColliderPosition, TColliderStrategy } from '@mappedin/mappedin-js/renderer/internal';
    /**
        *
        * A Tooltip is an html element that attempts to orient itself around an anchor in 3D space. It will always maintain the same size on the screen, but will attempt to change its orientation based on other colliders in the scene.
        *
        * Make your own and add it directly to the map with {{#crossLink "MapView/createTooltip:method"}}{{/crossLink}}, or use the constructor and add it when you want.
        *
        * You will need to specify at least `options.position` and one of `options.html` and `options.selector` OR `options.contentHtml`.
        *
        *
        * @class Tooltip
        *
        * @constructor
        * @param options {Object} Passes on options (e.g. html, text, position, map, padding, defaultAnchorType, enabledAnchorTypes, collisionRank) to MapView.Tooltip's options argument.
        * @param [options.html] Pass in custom html for your marker, if using this method you must also pass in a selector for your content.
        * @param [options.selector] Used in conjuction with the html property to select the div for repositioning
        * @param [options.contentHtml] Use mappedin's default tooltip styling with custom inner html content
        * @param [options.text] Instead of passing html pass in plain text to be displayed in the tooltip
        * @param [options.position] should be something you got from {{#crossLink "MapView/getPositionPolygon:method"}}{{/crossLink}} or {{#crossLink "MapView/getPositionNode:method"}}{{/crossLink}}.
        * @param [options.map] The map ID where the tooltip should be displayed
        * @param [options.defaultAnchorType] The default orientation to place the tooltip.
        * @param [options.padding] The distance in pixel to offset the tooltip from the anchor point.
        * @param [options.enabledAnchorTypes] An object used to disable certain anchor positions from being used.
        * @param [options.collisionRank]  The rank of the object used when comparing colliders to determine which should be shown.
        */
    export type TSmartTooltipOptions = {
            html?: string;
            contentHtml?: string;
            text?: string;
            position: TColliderPosition;
            selector?: string;
            map: string;
            padding?: number;
            collisionRank?: COLLISION_RANKING_TIERS;
            defaultAnchorType?: string;
            enabledAnchorTypes?: {
                    [type: string]: boolean;
            };
            interactive?: boolean;
            layer?: string;
    };
    type TTooltipStyle = {
            top?: string;
            left?: string;
    };
    /**
        * An object that defines which anchors are enabled for a tooltip. An anchor is a direction, relative
        * to a position, where a tooltip may appear. For example, a tooltip with a `right` anchor will appear
        * to the right of its position.
        */
    export type TOOLTIP_ANCHOR = {
            top?: boolean;
            left?: boolean;
            topLeft?: boolean;
            right?: boolean;
            topRight?: boolean;
            bottom?: boolean;
            bottomLeft?: boolean;
            bottomRight?: boolean;
    };
    class SmartTooltip extends HTMLCollider implements IHTMLCollider {
            #private;
            className: string;
            _el: Element | null;
            style: TTooltipStyle;
            position: TColliderPosition;
            /**
                * @private
                * cached container class number to avoid recommutation per update
                */
            containerClassesLength: number;
            constructor(options: TSmartTooltipOptions);
            updateClassName: (className: any) => void;
            get strategies(): TColliderStrategy[];
            colliderDidMount(): void;
            /**
                * @internal
                */
            updateDimensionsImmediately(): void;
            setAction(action: any): void;
            colliderDidNotFindAHome(): void;
            colliderDidGoOffscreen(): void;
            colliderDidUpdateVisiblity(): void;
            /**
                * @private
                * @param interactive - whether the tooltip should be interactive or not
                */
            updateInteractive(interactive: boolean): void;
            /**
                * Used in creation of container element. If we specify the tooltip to be interactive, we want to
                * make containerEl non-interactive so the click events register on the canvas eventually calls collider detection on the collision engine.
                *
                * @param tooltipInteractive
                * @returns
                */
            static getContainerElClasses(tooltipInteractive: boolean): string;
    }
    export default SmartTooltip;
}

declare module '@mappedin/mappedin-js/renderer/MapView.enums' {
    export enum GEOLOCATION_STATUS {
            SUCCESS = 0
    }
    export enum COLLISION_RANKING_TIERS {
            /** @internal */
            OPTIONAL_MINIMUM = 0,
            /** @internal */
            OPTIONAL_MAXIMUM = 1,
            MEDIUM = 2,
            HIGH = 3,
            /**
                * Always display collider, regardless of collisions
                */
            ALWAYS_VISIBLE = 4
    }
    export enum E_BLUEDOT_STATE_REASON {
            /**
                * Positions we are receiving indicate we are outside the venue
                */
            OUTSIDE_MAP = 0,
            /**
                * BlueDot is enabled, but we haven't received any positions
                */
            NO_POSITIONS_PROVIDED = 1,
            /**
                * Web Only: Error returned by geolocation provider
                */
            GEOLOCATION_PROVIDER_ERROR = 2,
            /**
                * Errors provided by custom location providers
                */
            CUSTOM_GEOLOCATION_PROVIDER_ERROR = 3
    }
    /**
    What we currently know about the user's position and how confident we are.
     */
    export enum E_BLUEDOT_STATE {
            /**
                * Not listening to Blue Dot position updates
                */
            NOT_LISTENING = 0,
            /**
                * Listenign for listening to position updates but have not yet received a position
                */
            LISTENING = 1,
            /**
                * Received relevant positions and user is in the venue
                */
            HAS_POSITION = 2,
            /**
                * We've received a relevant position, and we have enough information to determine
                * which floor the user is on - either because we received a floor level, the venue
                * only has one floor or we're allowing implicit floor level detection.
                */
            HAS_INDOOR_POSITION = 3,
            /**
                * We are uncertain about the user's position, likely because we haven't received
                * a relevant position in a while. Blue Dot will be rendered grey to indicate uncertainty of the actual position.
                */
            LOCATION_UNCERTAIN = 4
    }
    /**
        * Visual States of the BlueDot
        */
    export enum E_BLUEDOT_MARKER_STATE {
            /**
                * Blue Dot is hidden
                */
            HIDDEN = 0,
            /**
                * Blue Dot is transparent indicating the position is on a different floor
                */
            GHOST = 1,
            /**
                * Blue Dot is visible and opaque indicating accurate positioning on the current floor
                */
            NORMAL = 2,
            /**
                * Blue Dot is grayed out due to uncertainty about user's location, most likely due to not receiving recent position updates.
                */
            UNCERTAIN = 3
    }
    /**
        * @enum The state of the {@link MapView}.
        */
    export enum STATE {
            /**
                * The map is in exploration mode where the user controls the camera position.
                */
            EXPLORE = "explore",
            /**
                * Follows user's current location by keeping the camera centered on the Blue Dot.
                */
            FOLLOW = "follow",
            /**
                * FOLLOW WITH ROTATION provides turn by turn navigation while following user's location
                */
            STACKED = "STACKED"
    }
    export enum MARKER_ANCHOR {
            CENTER = 0,
            TOP = 1,
            LEFT = 2,
            BOTTOM = 3,
            RIGHT = 4
    }
    export enum E_SDK_EVENT {
            /**
                * Emitted when the map is clicked or tapped on a touch screen.
                */
            CLICK = "CLICK",
            /**
                * Emitted when the {@link STATE | SDK state} changes.
                */
            STATE_CHANGE = "STATE_CHANGE",
            /**
                * @deprecated
                * Use E_SDK_EVENT.CLICK instead. Emitted when an interactive {@link MappedinPolygon | polygon} is clicked
                */
            POLYGON_CLICKED = "POLYGON_CLICKED",
            /**
                * @deprecated
                * Use E_SDK_EVENT.CLICK instead. Emitted when nothing (outside of interactive polygons) is clicked
                */
            NOTHING_CLICKED = "NOTHING_CLICKED",
            /**
                * Emitted when the map is changed
                */
            MAP_CHANGED = "MAP_CHANGED",
            /**
                * Emitted when the map is changed, plus the context in which it was changed. This is typically so developers can
                * determine why the map was changed, such as a user clicking a connection, or the blue dot detecting a floor change, among others.
                * See {@link E_MAP_CHANGED_REASON}.
                */
            MAP_CHANGED_WITH_REASON = "MAP_CHANGED_WITH_REASON",
            /**
                * Emitted when the outdoor view is ready. All currently requested tiles have loaded, and all fade and transition
                * animations have completed. {@link showVenue} is resolved when the indoor map is ready even if the outdoor tiles are not yet loaded.
                * Use this event to create a loading screen that ensures outdoor view is fully loaded and rendered.
                * @experimental
                */
            OUTDOOR_VIEW_LOADED = "OUTDOOR_VIEW_LOADED"
    }
    /**
        * @enum
        */
    export enum E_BLUEDOT_EVENT {
            /**
                * Emitted when the BlueDot position changes
                */
            POSITION_UPDATE = "POSITION_UPDATE",
            /**
                * Emitted when the BlueDot state changes
                */
            STATE_CHANGE = "STATE_CHANGE"
    }
    /**
        * @enum
        */
    export enum E_CAMERA_EVENT {
            USER_INTERACTION_START = "USER_INTERACTION_START",
            USER_INTERACTION_END = "USER_INTERACTION_END",
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            ZOOM_CHANGED = "ZOOM_CHANGED",
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            ROTATION_CHANGED = "ROTATION_CHANGED",
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            TILT_CHANGED = "TILT_CHANGED",
            /**
                * @deprecated Use E_CAMERA_EVENT.CHANGED instead
                */
            POSITION_CHANGED = "POSITION_CHANGED",
            /**
                * Fires when camera state changes, including position, tilt, zoom and rotation
                */
            CHANGED = "CHANGED"
    }
    export { MAP_RENDER_MODE } from '@mappedin/mappedin-js/get-venue';
    export enum E_CAMERA_DIRECTION {
            UP = "up",
            DOWN = "down",
            LEFT = "left",
            RIGHT = "right"
    }
    export enum SAFE_AREA_INSET_TYPE {
            PIXELS = "pixels",
            PORTIONS = "portions"
    }
    export const ANIMATION_TWEENS: {
            linear: any;
            'ease-in': any;
            'ease-out': any;
            'ease-in-out': any;
    };
    export enum CAMERA_EASING_MODE {
            LINEAR = "linear",
            EASE_IN = "ease-in",
            EASE_OUT = "ease-out",
            EASE_IN_OUT = "ease-in-out"
    }
    /**
        * @experimental
        */
    export enum STACKED_MAPS_STATE {
            /**
                * Stacked maps are active, and ready to be expanded
                */
            ACTIVE = "ACTIVE",
            /**
                * Stacked maps are inactive, and a single map is displayed at a time
                */
            INACTIVE = "INACTIVE",
            /**
                * Stacked maps are expanded, and all maps in a journey are displayed in a stack
                */
            OVERVIEW = "OVERVIEW",
            /**
                * Stacked maps are active, but we're viewing a single map in a journey
                */
            ZOOMED_IN = "ZOOMED_IN"
    }
    /**
        * A reason why the SDK changed the map. See {@link E_SDK_EVENT.MAP_CHANGED_WITH_REASON}.
        */
    export enum E_MAP_CHANGED_REASON {
            /**
                * When in Dynamic Focus mode, and the user pans or zooms to a map
                */
            DYNAMIC_FOCUS_USER_INTERACTION = "dynamic-focus-user-interaction",
            /**
                * When BlueDot is in FOLLOW mode, and the level changes
                */
            BLUE_DOT_LEVEL_TRANSITION = "blue-dot-level-transition",
            /**
                * When clicking on the default Journey connection markers
                */
            JOURNEY_CONNECTION_CLICK = "journey-connection-click"
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.AssetManager' {
    import { Texture } from 'three';
    import type { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    /**
      * @internal
      */
    export default class DefaultAssetManager {
        textureLoader: any;
        loadMapPolygons(map: MappedinMap): Promise<any>;
        loadImage(url: string): Promise<Texture>;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager' {
    import { Box3 } from 'three';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { MappedinCoordinate, MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import Object3D from '@mappedin/mappedin-js/renderer/internal/object3D.destroy';
    import { Tile } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.Tile';
    import { IOutdoorContextProvider } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Outdoor-Context.provider';
    /**
        * @deprecated Use {@link OutdoorView} instead.
        */
    export enum TILE_RENDER_MODES {
            NORMAL = 0,
            AGGRESSIVE = 1
    }
    export const TILE_COLOR = "#f0f0f1";
    /**
        * @deprecated Use {@link OutdoorView} instead.
        */
    export type TTileManagerOptions = {
            tileRenderMode?: TILE_RENDER_MODES;
            provider: IOutdoorContextProvider;
            /**
                * How many times bigger the bounding box should be than the map's longest side
                */
            boundingBoxMultiplier?: number;
    };
    export class TileManager {
            #private;
            static ENABLED: boolean;
            static OPTIONS: TTileManagerOptions;
            tileSize: number;
            token: string;
            apiKey?: string;
            tileRenderMode: TILE_RENDER_MODES;
            currentAbortController: AbortController;
            attributionEl: HTMLDivElement;
            outdoorContextProvider: IOutdoorContextProvider;
            constructor(core: ICore);
            createAttributionEl(): void;
            renderVisibleTiles: () => void;
            _renderVisibleTiles(): void;
            cachedZoomLevel: number;
            visible: boolean;
            fadeOut(): Promise<void>;
            fadeIn(): Promise<void>;
            fetchTiles(): void;
            zoomLevelToAltitudeMap: number[][];
            plane: Object3D;
            tiles: Tile[];
            maskMeshBoundingBox: Box3;
            fetchTilesForZoomLevel(zoomLevel: number): Promise<void>;
            /**
                * This function populates a layer of tiles starting from the center clockwise
                *
                * Here's an example of layer = 1
                *
                * [ ][ ][ ][ ][ ]
                * [ ][1][2][3][ ]
                * [ ][8][X][4][ ]
                * [ ][7][6][5][ ]
                * [ ][ ][ ][ ][ ]
                */
            populateLayer(layerId: number | undefined, center: MappedinCoordinate, zoomLevel: number, metersPerTile: number, referenceMap: MappedinMap): void;
            checkIfTileIsInBoundingBox(tile: Tile): any;
    }
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/WatermarkController' {
    import { ICore } from '@mappedin/mappedin-js/renderer/private/Core.interface';
    import { Sprite } from 'three';
    type TPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'center' | 'top' | 'bottom' | 'left' | 'right';
    export type TShowWatermarkOptions = {
        padding?: number;
        position?: TPosition;
        scale?: number;
        onClick?: () => void;
    };
    class WatermarkController {
        #private;
        static ENABLED: boolean;
        static OPTIONS: Required<TShowWatermarkOptions>;
        object: Sprite;
        constructor(core: ICore);
        show: () => void;
        hide: () => void;
        resize: () => void;
    }
    export default WatermarkController;
}

declare module '@mappedin/mappedin-js/get-venue/MappedinDirections' {
    import { IDirectionsResult } from '@mappedin/mappedin-js/navigator';
    import { ACTION_TYPE, BEARING_TYPE } from '@mappedin/mappedin-js/navigator/Directive';
    import type { MappedinNode, MappedinVortex, MappedinMap, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    export interface IActionDeparture {
            type: ACTION_TYPE.DEPARTURE;
    }
    export interface IActionArrival {
            type: ACTION_TYPE.ARRIVAL;
    }
    export interface IActionTakeVortex {
            type: ACTION_TYPE.TAKEVORTEX;
            toMap: MappedinMap;
            fromMap: MappedinMap;
    }
    export interface IActionExitVortex {
            type: ACTION_TYPE.EXITVORTEX;
            toMap: MappedinMap;
            fromMap: MappedinMap;
    }
    export interface IActionTurn {
            type: ACTION_TYPE.TURN;
            bearing: BEARING_TYPE;
            referencePosition?: string;
    }
    export type IAction = IActionArrival | IActionDeparture | IActionTurn | IActionTakeVortex | IActionExitVortex;
    /** this is the "overloaded" version of the directive, with get-venue classes instead of stubs */
    export type TMappedinDirective = {
            node: MappedinNode;
            /**
                * Distance from the last instruction to the current. Useful for turn by turn navigation
                */
            distance: number;
            instruction: string;
            action?: IAction;
            atLocation?: MappedinVortex;
            type?: BEARING_TYPE;
    };
    /**
        * Directions Object
        */
    export class MappedinDirections {
            #private;
            /**
                * Total Distance
                */
            distance: number;
            path: MappedinNode[];
            instructions: TMappedinDirective[];
            constructor(mappedin: Mappedin, directions: IDirectionsResult);
            toJSON(): IDirectionsResult;
    }
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/CameraController' {
    import { MappedinNode, MappedinPolygon, MappedinCoordinate } from '@mappedin/mappedin-js/get-venue';
    import type { TAnimationOptions, ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { PubSub, CAMERA_EVENT_PAYLOAD, E_CAMERA_EVENT, E_CAMERA_DIRECTION, SAFE_AREA_INSET_TYPE } from '@mappedin/mappedin-js/renderer/internal';
    export type TSafeAreaInsets = {
            top: number;
            left: number;
            bottom: number;
            right: number;
            type?: SAFE_AREA_INSET_TYPE;
    };
    /**
        * Things that the camera can be positioned to focus on.
        */
    export type TCameraTargets = {
            nodes?: MappedinNode[];
            polygons?: MappedinPolygon[];
            coordinates?: MappedinCoordinate[];
    };
    /**
        * Options that change the behaviour of {@link Camera.focusOn}
        */
    export type TFocusOnCameraOptions = {
            /**
                * Whether the current zoom level should be changed to better place the targets in view.
                */
            changeZoom?: boolean;
            /**
                * The minimum zoom level the camera is allowed to change to when focusing on targets.
                * Useful to prevent the camera from zooming in too far if the target is a single {@link MappedinNode}
                * or {@link MappedinCoordinate}.
                */
            minZoom?: number;
            /**
                * The maximum zoom level the camera is allowed to change to when focusing on targets.
                */
            maxZoom?: number;
            /**
                * Specify the rotation the camera makes during the focusing animation.
                */
            rotation?: number;
            /**
                * Specify the tilt the camera makes during the focusing animation.
                */
            tilt?: number;
            /**
                * Specify a safe area of the screen only that applies only to this {@link Camera.focusOn} call.
                * See also {@link Camera.setSafeAreaInsets}.
                */
            safeAreaInsets?: TSafeAreaInsets;
            /**
                * Whether {@link Camera.minZoom} and {@link Camera.maxZoom} should be recalculated during the focusing animation.
                */
            updateZoomLimits?: boolean;
    };
    /**
        * A configuration of the camera in space.
        */
    export type TCameraTransform = {
            /**
                * Distance (in meters) from the target
                */
            zoom?: number;
            /**
                * Angle (in radians) of the camera to the ground. 0 means the camera is top-down.
                */
            tilt?: number;
            /**
                * Angle (in radians) the camera is rotated from north.
                */
            rotation?: number;
            /**
                * A position in 3D space.
                */
            position?: MappedinCoordinate | MappedinNode;
    };
    export type TCameraAnimationOptions = TAnimationOptions;
    /**
        * The configuration for camera interactions on or off.
        */
    export type TCameraInteractionsSetOptions = {
            /**
                * Enable or disable pan controls.
                */
            pan?: boolean;
            /**
                * Enable or disable zoom controls.
                */
            zoom?: boolean;
            /**
                * Enable or disable rotation and tilt controls.
                * See {@link Camera.maxTilt} for controlling the range of tilt.
                */
            rotationAndTilt?: boolean;
    };
    /**
        * The Camera object specifies a view of the map and allows manipulation of that view.
        * @internal
        */
    class CameraController extends PubSub<CAMERA_EVENT_PAYLOAD, E_CAMERA_EVENT> {
            #private;
            core: ICore;
            currentAnimation?: Promise<undefined>;
            /**
                *
                * @private
                */
            constructor(core: ICore);
            get zoom(): number;
            get rotation(): number;
            get tilt(): number;
            get minZoom(): number;
            set minZoom(meters: number);
            get maxZoom(): number;
            set maxZoom(meters: number);
            get maxTilt(): number;
            set maxTilt(radians: number);
            get position(): MappedinCoordinate;
            interactions: {
                    set: (options: TCameraInteractionsSetOptions) => void;
                    enable: () => void;
                    disable: () => void;
            };
            setSafeAreaInsets(insets: {
                    top: number;
                    left: number;
                    bottom: number;
                    right: number;
            }): void;
            convertZoomLevelToAltitude(zoomLevel: number): any;
            convertAltitudeToZoomLevel(altitude: number): any;
            getSafeAreaInsets(): import("../../MapView.types").TPadding;
            /**
                * Focus the Camera view on a collection of targets and animate to that state.
                * @returns a Promise that resolves when the animation finishes, or rejects when it is cancelled.
                */
            focusOn(targets: TCameraTargets, options?: TFocusOnCameraOptions & TCameraAnimationOptions): Promise<any>;
            /**
                * Set the Camera's view to a new state.
                */
            set(positionOptions: TCameraTransform): void;
            /**
                * Animate the Camera's view to smoothly transition to a new state over time.
                *
                * @returns a Promise that resolves when the animation finishes, or rejects when it is cancelled.
                */
            animate(config: TCameraTransform, options?: TCameraAnimationOptions): Promise<undefined>;
            /**
                * Moves the Camera view in a relative direction by a given distance in meters.
                * @returns a Promise that resolves when the translation animation finishes, or rejects when it is cancelled.
                */
            translate(direction: E_CAMERA_DIRECTION, distance: number, options?: TCameraAnimationOptions): Promise<unknown>;
            /**
                * Cancel the currently active Camera animation.
                */
            cancelAnimation(): void;
    }
    export default CameraController;
}

declare module '@mappedin/mappedin-js/renderer/bundle-asset-manager' {
    import type { Texture } from 'three';
    import { Mappedin, MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import { AssetManager } from '@mappedin/mappedin-js/renderer/internal';
    /**
      * @internal
      */
    export class BundleAssetManager extends AssetManager {
        venueData: Mappedin;
        constructor(venueData: Mappedin);
        loadMapPolygons(map: MappedinMap): Promise<Record<string, any>>;
        loadImage(url: string): Promise<Texture>;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/outdoor-context/Outdoor-Context.provider' {
    /**
        * @deprecated Use {@link OutdoorView} instead.
        * The universal outdoor context interface
        */
    export interface IOutdoorContextProvider {
            /**
                * Returns the appropriate tile at coordinate
                */
            fetchTile(tileX: number, tileY: number, zoom: number, signal: AbortSignal): Promise<Response>;
            /**
                * Fetch attribution for the current tiles
                * format: [SouthwestCorner_Longitude, SouthwestCorner_Latitude, NortheastCorner_Longitude, NortheastCorner_Latitude]
                */
            fetchAttribution?(zoomLevel: number, bounds: [number, number, number, number]): Promise<Response>;
    }
    /**
        * @deprecated Use {@link OutdoorView} instead.
        * Azure maps outdoor context class
        */
    export class AzureOutdoorContextProvider implements IOutdoorContextProvider {
            lang: string;
            apiKey?: string;
            token?: string;
            tileSize: number;
            tilesetId: string;
            constructor(lang?: string, tileSize?: 256 | 512, apiKey?: string, token?: string);
            makeURL(x: number, y: number, zoom: number): string;
            /**
                * Fetch attribution for the current tiles
                * format: [SouthwestCorner_Longitude, SouthwestCorner_Latitude, NortheastCorner_Longitude, NortheastCorner_Latitude]
                */
            fetchAttribution(zoomLevel: number, bounds: [number, number, number, number]): Promise<Response>;
            /**
                * Returns the appropriate tile at coordinate
                */
            fetchTile(tileX: number, tileY: number, zoom: number, signal: AbortSignal): Promise<Response>;
    }
    /**
        * @deprecated Use {@link OutdoorView} instead.
        * Google maps outdoor context class
        */
    export class GoogleOutdoorContextProvider implements IOutdoorContextProvider {
            apiKey: string;
            sessionToken: string;
            lang: string;
            constructor(lang: string | undefined, apiKey: string);
            makeURL(x: number, y: number, zoom: number): string;
            /**
                * Returns the Google session token
                */
            fetchSessionToken(): Promise<void>;
            /**
                * Returns the appropriate tile at coordinate
                */
            fetchTile(tileX: number, tileY: number, zoom: number, signal: any): Promise<Response>;
    }
    /**
        * @deprecated Use {@link OutdoorView} instead.
        * OpenStreetMap maps outdoor context class
        */
    export class OpenStreetMapOutdoorContext implements IOutdoorContextProvider {
            makeURL(x: number, y: number, z: number, customServer?: string): string;
            /**
                * Returns the appropriate tile at coordinate
                */
            fetchTile(tileX: number, tileY: number, zoom: number, signal: any, customServer?: string): Promise<Response>;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal' {
    import { Texture } from 'three';
    import { STATE } from '@mappedin/mappedin-js/renderer/MapView.enums';
    import { TMapClickEvent } from '@mappedin/mappedin-js/renderer/MapView.types';
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    export { MappedinMap, Mappedin, MappedinCoordinate, MappedinPolygon, MappedinNode, MappedinLocation, MappedinVenue, } from '@mappedin/mappedin-js/get-venue';
    export type { TEnableBlueDotOptions, TFloatingLabelAppearance, TGeolocationObject, TPathOptions, TConnectionProps, TConnectionTemplateFn, TMarkerTemplateProps, TMarkerTemplateFn, TJourneyOptions, TPadding, TCreateMarkerOptions, TAnimationOptions, TCreateTooltipInternalOptions, TCreateTooltipCommonOptions, TCreateTooltipOptions, TCreateTextTooltipOptions, TCreateCustomInnerHTMLTooltipOptions, TCreateCustomTooltipOptions, TCreateThreeDMarkerOptions, TGetPolygonsAtCoordinateOptions, TMapViewOptions, TMapViewOptionsLegacy, TFlatLabelOptions, TFlatLabelAppearance, TFloatingLabelPolygonOptions, TAddFlatLabelOptions, TAddFloatingLabelOptions, TLabelAllLocationCommonOptions, TLabelAllLocationFloatingLabelOptions, TLabelAllLocationFlatLabelOptions, TFloatingLabelAllLocationsOptions, TFlatLabelAllLocationsOptions, changeListenerFn, TMapClickEvent, E_SDK_EVENT_PAYLOAD, E_BLUEDOT_EVENT_PAYLOAD, CAMERA_EVENT_PAYLOAD, } from '@mappedin/mappedin-js/renderer/MapView.types';
    export { labelThemes } from '@mappedin/mappedin-js/renderer/MapView.types';
    export { GEOLOCATION_STATUS, COLLISION_RANKING_TIERS, E_BLUEDOT_STATE_REASON, E_BLUEDOT_STATE, E_BLUEDOT_MARKER_STATE, STATE, MARKER_ANCHOR, E_SDK_EVENT, E_BLUEDOT_EVENT, E_CAMERA_EVENT, E_CAMERA_DIRECTION, SAFE_AREA_INSET_TYPE, CAMERA_EASING_MODE, MAP_RENDER_MODE, ANIMATION_TWEENS, STACKED_MAPS_STATE, } from '@mappedin/mappedin-js/renderer/MapView.enums';
    export { default as JSONSceneLoader } from '@mappedin/mappedin-js/renderer/internal/json-scene-loader';
    export { default as RENDER } from '@mappedin/mappedin-js/renderer/internal/Mappedin.RenderTasks';
    export { FrameUpdate, FrameTask, TaskScheduler } from '@mappedin/mappedin-js/get-venue/Mappedin.TaskScheduler';
    export { default as SceneManager } from '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.SceneManager';
    export { default as DynamicFocusSceneManager } from '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.DynamicFocusSceneManager';
    export { PubSub } from '@mappedin/mappedin-js/get-venue/pub-sub.typed';
    export { default as MapObject } from '@mappedin/mappedin-js/renderer/internal/Mappedin.MapObject';
    export { default as CAMERA_LAYER } from '@mappedin/mappedin-js/renderer/internal/Mappedin.CameraLayers';
    export { default as AssetManager } from '@mappedin/mappedin-js/renderer/internal/Mappedin.AssetManager';
    export { BundleAssetManager } from '@mappedin/mappedin-js/renderer/bundle-asset-manager';
    /**
        * Internal Events and Payloads
        */
    export enum INTERNAL_EVENT {
            ON_FIRST_MAP_LOADED = 0,
            TEXTURE_LOADED = 1,
            RENDER = 2,
            RENDER_NOW = 3,
            UPDATE_FLIPPABLES = 4,
            SET_SCENE_MAP = 5,
            SET_SCENE_START = 6,
            SET_SCENE = 7,
            SCENE_VISIBLITY_CHANGED = 8,
            CAMERA_MOVING = 9,
            SET_BLUE_DOT_SIZE_FROM_ZOOM = 10,
            PUBLISH_BLUE_DOT = 11,
            SET_STATE_SILENT = 12,
            BLUE_DOT_UPDATE_POSITION = 13,
            BLUE_DOT_SET_FOLLOWING = 14,
            CLEAR_MOUSE = 15,
            MAP_CLICK = 16,
            USER_ZOOM = 17,
            USER_ZOOM_BEGIN = 18,
            USER_ROTATE = 19,
            USER_ROTATE_BEGIN = 20,
            USER_PAN = 21,
            USER_PAN_BEGIN = 22,
            USER_TILT = 23,
            USER_MULTI_BEGIN = 24,
            USER_MULTI_END = 25,
            FOCUSON_BEGIN = 26,
            USER_HANDS_ON = 27,
            USER_HANDS_OFF = 28,
            JOURNEY_CREATED = 29,
            JOURNEY_DESTROYED = 30,
            OUTDOOR_VIEW_LOADED = 31,
            LAYER_VISIBILITY_CHANGED = 32
    }
    export type INTERNAL_EVENT_PAYLOAD = {
            [INTERNAL_EVENT.SET_SCENE_START]: undefined;
            [INTERNAL_EVENT.SET_SCENE_MAP]: undefined;
            [INTERNAL_EVENT.ON_FIRST_MAP_LOADED]: undefined;
            [INTERNAL_EVENT.TEXTURE_LOADED]: Texture;
            [INTERNAL_EVENT.OUTDOOR_VIEW_LOADED]: undefined;
            [INTERNAL_EVENT.RENDER]: undefined;
            [INTERNAL_EVENT.RENDER_NOW]: undefined;
            [INTERNAL_EVENT.UPDATE_FLIPPABLES]: undefined | boolean;
            [INTERNAL_EVENT.SET_SCENE]: {
                    context?: string;
            };
            [INTERNAL_EVENT.CAMERA_MOVING]: any;
            [INTERNAL_EVENT.SET_BLUE_DOT_SIZE_FROM_ZOOM]: number;
            [INTERNAL_EVENT.PUBLISH_BLUE_DOT]: undefined;
            [INTERNAL_EVENT.CLEAR_MOUSE]: undefined;
            [INTERNAL_EVENT.SET_STATE_SILENT]: {
                    state: STATE;
            };
            [INTERNAL_EVENT.BLUE_DOT_UPDATE_POSITION]: {
                    x: number;
                    y: number;
            };
            [INTERNAL_EVENT.BLUE_DOT_SET_FOLLOWING]: boolean;
            [INTERNAL_EVENT.MAP_CLICK]: TMapClickEvent;
            [INTERNAL_EVENT.USER_ZOOM]: undefined;
            [INTERNAL_EVENT.USER_ZOOM_BEGIN]: undefined;
            [INTERNAL_EVENT.USER_ROTATE_BEGIN]: undefined;
            [INTERNAL_EVENT.USER_MULTI_BEGIN]: undefined;
            [INTERNAL_EVENT.USER_PAN_BEGIN]: undefined;
            [INTERNAL_EVENT.USER_ROTATE]: undefined;
            [INTERNAL_EVENT.USER_MULTI_END]: undefined;
            [INTERNAL_EVENT.FOCUSON_BEGIN]: undefined;
            [INTERNAL_EVENT.USER_HANDS_ON]: undefined;
            [INTERNAL_EVENT.USER_HANDS_OFF]: undefined;
            [INTERNAL_EVENT.USER_PAN]: undefined;
            [INTERNAL_EVENT.USER_TILT]: undefined;
            [INTERNAL_EVENT.LAYER_VISIBILITY_CHANGED]: MappedinMap;
            [INTERNAL_EVENT.JOURNEY_CREATED]: undefined;
            [INTERNAL_EVENT.JOURNEY_DESTROYED]: undefined;
            [INTERNAL_EVENT.SCENE_VISIBLITY_CHANGED]: undefined;
    };
    /**
        * Factories
        */
    export { Atlas, FlatLabel } from '@mappedin/mappedin-js/renderer/internal/Mappedin.LabelAtlas.js';
    export { default as HoverLabel } from '@mappedin/mappedin-js/renderer/internal/Mappedin.HoverLabel';
    export { default as BaseCollider } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider';
    export { default as InternalFloatingLabel } from '@mappedin/mappedin-js/renderer/internal/Mappedin.FloatingLabel';
    export { default as HTMLCollider } from '@mappedin/mappedin-js/renderer/internal/Mappedin.HTMLCollider';
    export { Marker } from '@mappedin/mappedin-js/renderer/private/controllers/MarkersController';
    export { default as SmartTooltip } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartTooltip';
    export { default as InternalMarker } from '@mappedin/mappedin-js/renderer/internal/Mappedin.Marker';
    export { ThreeJSMarkerHandle } from '@mappedin/mappedin-js/renderer/internal/Mappedin.MapObject';
    export { default as MapViewScene } from '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.Scene';
    export { default as MapViewStackScene } from '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.StackScene';
    export { default as Element } from '@mappedin/mappedin-js/renderer/internal/Mappedin.Element';
    export { default as FlippableImage } from '@mappedin/mappedin-js/renderer/internal/Mappedin.FlippableImage';
    export { default as Building } from '@mappedin/mappedin-js/renderer/private/scene-manager/dynamic-focus-scene-manager/building';
    export { default as DynamicFocusScene } from '@mappedin/mappedin-js/renderer/private/scene-manager/dynamic-focus-scene-manager/dynamic-focus-scene';
    /**
        * Controllers/Managers
        */
    export { default as PathsController, Path } from '@mappedin/mappedin-js/renderer/private/controllers/PathsController';
    export { default as FloatingLabelsController } from '@mappedin/mappedin-js/renderer/private/controllers/FloatingLabelsController';
    export { default as FlatLabelsController } from '@mappedin/mappedin-js/renderer/private/controllers/FlatLabelsController';
    export { default as PolygonColorsController } from '@mappedin/mappedin-js/renderer/private/controllers/PolygonColorsController';
    export { default as PolygonHoverColorsController } from '@mappedin/mappedin-js/renderer/private/controllers/PolygonHoverColorsController';
    export { default as MarkersController } from '@mappedin/mappedin-js/renderer/private/controllers/MarkersController';
    export { default as PolygonInteractionController } from '@mappedin/mappedin-js/renderer/private/controllers/PolygonInteractionController';
    export { default as TooltipsController } from '@mappedin/mappedin-js/renderer/private/controllers/TooltipsController';
    export { default as PolygonStatesController } from '@mappedin/mappedin-js/renderer/private/controllers/PolygonStatesController';
    export { default as PolygonImagesController } from '@mappedin/mappedin-js/renderer/private/controllers/PolygonImagesController';
    export { default as ThreeDMarkersController } from '@mappedin/mappedin-js/renderer/private/controllers/ThreeDMarkersController';
    export { default as BlueDotController } from '@mappedin/mappedin-js/renderer/private/controllers/BlueDotController';
    export { default as BlueDotManager } from '@mappedin/mappedin-js/renderer/internal/blue-dot-manager';
    export { default as CameraController } from '@mappedin/mappedin-js/renderer/private/controllers/CameraController';
    export { default as EventSystem } from '@mappedin/mappedin-js/renderer/private/controllers/EventSystem';
    export { default as ClosedPolygonManager } from '@mappedin/mappedin-js/renderer/internal/Mappedin.ClosedPolygonManager';
    export { default as BinaryAssetManager } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BinaryAssetManager';
    export { default as SmartCollisionEngine } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollisionEngine';
    export { default as BillboardManager } from '@mappedin/mappedin-js/renderer/private/controllers/BillboardManager';
    export { default as StackedMapsController } from '@mappedin/mappedin-js/renderer/private/controllers/StackedMapsController';
    export { MultiBufferRenderer } from '@mappedin/mappedin-js/renderer/internal/Mappedin.Renderer';
    export { JourneyController } from '@mappedin/mappedin-js/renderer/private/controllers/JourneyController';
    export { default as OutdoorViewController } from '@mappedin/mappedin-js/renderer/private/controllers/OutdoorViewController';
    export { default as ExportController } from '@mappedin/mappedin-js/renderer/private/controllers/ExportController';
    export { default as WatermarkController } from '@mappedin/mappedin-js/renderer/private/controllers/WatermarkController';
    export { default as LayerController } from '@mappedin/mappedin-js/renderer/private/controllers/LayerController';
    /**
        * Types
        */
    export type { TSceneTransitionOptions } from '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.SceneManager';
    export type { IPositionUpdater, IBlueDotCore } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.core';
    export type { TSafeAreaInsets, TCameraTargets, TFocusOnCameraOptions, TCameraTransform, TCameraAnimationOptions, } from '@mappedin/mappedin-js/renderer/private/controllers/CameraController';
    export type { TColliderPosition } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider';
    export type { ICollider, TColliderStrategy } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider';
    export { EColliderAction } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider';
    export type { IHTMLCollider } from '@mappedin/mappedin-js/renderer/internal/Mappedin.HTMLCollider';
    export { COLLIDER_STRATEGY_LOW_PRIORITY } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollisionEngine';
    export { default as BlueDotCore } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.core';
    export { default as BlueDotUI } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.ui';
    export { default as CameraControls } from '@mappedin/mappedin-js/renderer/internal/Mappedin.CameraControls.js';
    export { default as Renderer } from '@mappedin/mappedin-js/renderer/internal/Mappedin.Renderer.js';
    export { determineStartingMap, getObject, getObjectId } from '@mappedin/mappedin-js/renderer/internal/utils';
    export { default as MapManager } from '@mappedin/mappedin-js/renderer/internal/Mappedin.MapManager';
    export { default as DebugUI } from '@mappedin/mappedin-js/renderer/internal/Mappedin.DebugUI';
    export { DebugUIScalarSlider, DebugUIColorPicker } from '@mappedin/mappedin-js/renderer/internal/Mappedin.DebugUIControl';
    export type { Collider, ColliderQuadTree } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollisionEngine';
    export { MapView } from '@mappedin/mappedin-js/renderer/public/MapView';
    export { setAssetManager } from '@mappedin/mappedin-js/renderer';
    export { default as Logger } from '@mappedin/mappedin-js/--/common/Mappedin.Logger';
    export { TileManager, TILE_COLOR } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager';
    export type { ICore } from '@mappedin/mappedin-js/renderer/private/Core.interface';
    export * from '@mappedin/mappedin-js/renderer/private/Core';
}

declare module '@mappedin/mappedin-js/renderer/public/api/Journey' {
    import { TJourneyOptions } from '@mappedin/mappedin-js/renderer';
    import { MappedinDirections } from '@mappedin/mappedin-js/get-venue';
    import { JourneyController } from '@mappedin/mappedin-js/renderer/private/controllers/JourneyController';
    import { Path } from '@mappedin/mappedin-js/renderer/private/controllers/PathsController';
    import { ICore } from '@mappedin/mappedin-js/renderer/private/Core.interface';
    /**
        * API to control drawing a set of directions. See also {@link Paths}.
        */
    class Journey {
            #private;
            /**
                * @private
                */
            constructor(core: ICore);
            /**
                * Draw a Journey based on directions. Example usage:
                *
                * ```ts
                * const startLocation = mapView.venue.locations.find(location => location.name === "Cleo");
                * const endLocation = mapView.venue.locations.find(location => location.name === "American Eagle");
                *
                * const directions = startLocation.directionsTo(endLocation);
                * mapView.Journey.draw(directions);
                * ```
                *
                * Use options to set connection (such as elevators and escalators) HTML tooltip template,
                * departure and destination marker templates, path style and polygon higlight color. If
                * no options are set, sane defaults are used to draw markers, tooltips and polygon highlights.
                *
                * @param directions A single instance or an array of {@link MappedinDirections} used for the Journey.
                * @param options
                */
            draw(directions: MappedinDirections | MappedinDirections[], options?: TJourneyOptions): JourneyController;
            /**
                * Set the step of a multipart Journey. Requires {@link draw} to have been called with an array
                * of {@link MappedinDirections}. An active step receives different styling.
                *
                * ```ts
                * // A multi destination set of directions
                * const departure = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * const destination1 = mapView.venue.locations.find((l) => l.name === "Cleo")!;
                * const destination2 = mapView.venue.locations.find((l) => l.name === "KFC")!;
                * const destinationSet = new MappedinDestinationSet([destination1, destination2]);
                * const directions = departure.directionsTo(destinationSet);
                *
                * // By default step 0 is active, meaning Apple to Cleo
                * mapView.Journey.draw(directions);
                *
                * // Activate the step of the Journey from Cleo to KFC
                * mapView.Journey.setStep(1);
                * ```
                *
                * @param step The step of the Journey to mark as active.
                */
            setStep(step: number): void;
            /**
                * Set the step using a {@link Path} instance. Requires {@link draw} to have been called with an array
                * of {@link MappedinDirections}. An active step receives different styling. This is most commonly
                * used to activate a step when a path has been clicked.
                *
                * ```ts
                * // A multi destination set of directions
                * const departure = mapView.venue.locations.find((l) => l.name === "Apple")!;
                * const destination1 = mapView.venue.locations.find((l) => l.name === "Cleo")!;
                * const destination2 = mapView.venue.locations.find((l) => l.name === "KFC")!;
                * const destinationSet = new MappedinDestinationSet([destination1, destination2]);
                * const directions = departure.directionsTo(destinationSet);
                *
                * // Make sure that the paths are all interactive
                * mapView.Journey.draw(directions, {
                * 	pathOptions: { interactive: true },
                * 	inactivePathOptions: { interactive: true },
                * });
                *
                * // Listen for a path being clicked
                * mapView.on(E_SDK_EVENT.CLICK, ({ path }) => {
                * 	if (path != null) {
                * 		mapView.Journey.setStepByPath(path);
                * 	}
                * });
                * ```
                *
                * @param path A {@link Path} instance that corresponds to a step in the Journey.
                */
            setStepByPath(path: Path): void;
            /**
                * Clear the current Journey drawn by {@link draw}.
                *
                * ```ts
                * mapView.Journey.clear();
                * ```
                */
            clear(): void;
    }
    export default Journey;
}

declare module '@mappedin/mappedin-js/renderer' {
    import { MapView } from '@mappedin/mappedin-js/renderer/public/MapView';
    import { getVenue, getVenueMVF, getVenueBundle, getVenueMaker, Mappedin, downloadBundle, getVenueBundleURL, downloadVenueBundleMVF, MappedinDestinationSet, MappedinMap, TGetVenueBundleOptions, TGetVenueOptions, hydrateVenue } from '@mappedin/mappedin-js/get-venue';
    import { PositionUpdater } from '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.core';
    import type { TMapViewOptions } from '@mappedin/mappedin-js/renderer/MapView.types';
    export { E_SDK_LOG_LEVEL, setLoggerLevel } from '@mappedin/mappedin-js/--/common/Mappedin.Logger';
    export type { Marker } from '@mappedin/mappedin-js/renderer/private/controllers/MarkersController';
    export type { Path } from '@mappedin/mappedin-js/renderer/private/controllers/PathsController';
    export type { FloatingLabel } from '@mappedin/mappedin-js/renderer/private/controllers/FloatingLabelsController';
    export { BEARING_TYPE, ACTION_TYPE } from '@mappedin/mappedin-js/navigator';
    export type { IDirectionsResult, TSimplifyDirectionsOptions, E_MESSAGES as E_GET_DIRECTIONS_MESSAGES, } from '@mappedin/mappedin-js/navigator';
    /**
        * APIs for TypeDoc
        */
    export type { IFlatLabels, FlatLabels } from '@mappedin/mappedin-js/renderer/public/api/FlatLabels';
    export type { IFloatingLabels, FloatingLabels } from '@mappedin/mappedin-js/renderer/public/api/FloatingLabels';
    export type { Camera } from '@mappedin/mappedin-js/renderer/public/api/Camera';
    export type { BlueDot } from '@mappedin/mappedin-js/renderer/public/api/BlueDot';
    export type { Markers } from '@mappedin/mappedin-js/renderer/public/api/Markers';
    export type { Paths } from '@mappedin/mappedin-js/renderer/public/api/Paths';
    export type { StackedMaps } from '@mappedin/mappedin-js/renderer/public/api/StackedMaps';
    export type { OutdoorView } from '@mappedin/mappedin-js/renderer/public/api/OutdoorView';
    export type { DynamicFocus } from '@mappedin/mappedin-js/renderer/public/api/DynamicFocus';
    export type { Layers } from '@mappedin/mappedin-js/renderer/public/api/Layers';
    export type { TOOLTIP_ANCHOR } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartTooltip';
    export type TMappedinInitializeOutput = {
            mapView: MapView;
            venue: Mappedin;
    };
    type _TGetVenueOptions = TGetVenueOptions & {
            useVenueBundle?: false | undefined;
    };
    type _TGetVenueBundleOptions = TGetVenueBundleOptions & {
            useVenueBundle: true;
    };
    type TMappedinInitializeOptions = {
            mapView?: TMapViewOptions;
            venue: _TGetVenueOptions | _TGetVenueBundleOptions;
            firstMapSelector?: (venue: Mappedin) => MappedinMap | MappedinMap['id'];
    };
    /**
        *
        * @param el HTML Element where the mapView should be placed
        * @param venue Venue Object returned by {@link getVenue}
        * @param options MapView Options
        * @returns
        */
    function showVenue<T extends Mappedin>(el: HTMLElement, venue: T, options?: TMapViewOptions): Promise<MapView>;
    export { COLLISION_RANKING_TIERS, STATE, E_SDK_EVENT, E_BLUEDOT_STATE_REASON, E_BLUEDOT_MARKER_STATE, E_BLUEDOT_EVENT, E_BLUEDOT_STATE, E_CAMERA_EVENT, E_CAMERA_DIRECTION, SAFE_AREA_INSET_TYPE, ANIMATION_TWEENS, CAMERA_EASING_MODE, STACKED_MAPS_STATE, MARKER_ANCHOR, GEOLOCATION_STATUS, E_MAP_CHANGED_REASON, } from '@mappedin/mappedin-js/renderer/MapView.enums';
    export { getVenue, getVenueMVF, getVenueBundle, getVenueMaker, showVenue, downloadBundle, getVenueBundleURL, downloadVenueBundleMVF, hydrateVenue, PositionUpdater, MappedinDestinationSet, };
    import DefaultAssetManager from '@mappedin/mappedin-js/renderer/internal/Mappedin.AssetManager';
    import { TTileManagerOptions } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager';
    import { TShowWatermarkOptions } from '@mappedin/mappedin-js/renderer/private/controllers/WatermarkController';
    /**
        * @internal
        */
    const setAssetManager: <T extends DefaultAssetManager>(am: T) => void;
    export { setAssetManager, DefaultAssetManager as AssetManager };
    export type { TMappedinDirective, IAction, IActionArrival, IActionDeparture, IActionExitVortex, IActionTakeVortex, IActionTurn, } from '@mappedin/mappedin-js/get-venue/MappedinDirections';
    export type { TMappedinInitializeOptions };
    export * from '@mappedin/mappedin-js/renderer/MapView.types';
    export type { MapView } from '@mappedin/mappedin-js/renderer/public/MapView';
    export type { TSafeAreaInsets, TCameraTargets, TFocusOnCameraOptions, TCameraTransform, TCameraInteractionsSetOptions, TCameraAnimationOptions, default as CameraController, } from '@mappedin/mappedin-js/renderer/private/controllers/CameraController';
    export type { TGetVenueOptions, TGetVenueBundleOptions, TGetVenueMVFOptions, TGetVenueMakerOptions, TShowVenueOptions, TMappedinOfflineSearchOptions, TMappedinOfflineSearchResult, TMappedinOfflineSearchSuggestions, TMappedinOfflineAllSearchMatch, TMappedinOfflineSearchAllOptions, TDirectionToOptions, TPicture, TImage, TColor, TGalleryImage, TOpeningHours, TPhone, TSiblingGroup, TSocial, TState, TGeoReference, TPolygonRanking, TOperationHoursMap, TAccessors, } from '@mappedin/mappedin-js/get-venue';
    export { Mappedin, MappedinDirections, MappedinLocation, MappedinPolygon, MappedinNode, MappedinCategory, MappedinMap, MappedinEvent, MappedinMapGroup, MappedinVenue, MappedinVortex, MappedinRankings, MappedinNavigatable, MappedinCoordinate, OfflineSearch, MAP_RENDER_MODE, setFetchFn, MappedinCollectionType, MappedinLocationState, } from '@mappedin/mappedin-js/get-venue';
    /**
        * Export this only so our internal pre-built products can use it. We don't want to document it for external developers.
        */
    export { CustomerAnalytics } from '@mappedin/mappedin-js/get-venue';
    /**
        * Exported but marked as @internal.
        */
    export { BundleAssetManager } from '@mappedin/mappedin-js/renderer/bundle-asset-manager';
    /**
        * @deprecated Use {@link OutdoorView} instead.
        * Enable Tile Manager to render outdoor tiles around the venue. Must be called before {@link showVenue}.
        *
        * @example
        * ```ts
        * __enableTileManager({
        * 	provider: new AzureOutdoorContextProvider(
        * 		venue.options.language,
        * 		256,
        * 		"Your Azure API Key",
        * 		undefined //Omitted when using API Key.
        * 	)
        * });
        * ```
        */
    export function __enableTileManager(options?: TTileManagerOptions): void;
    /**
        * @hidden
        * @internal
        *
        * Show a Mappedin logo in the 3D scene. Must be called before {@link showVenue}.
        */
    export function __showWatermark(options?: TShowWatermarkOptions): void;
    export type { TTileManagerOptions, TILE_RENDER_MODES } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager';
    export { AzureOutdoorContextProvider, OpenStreetMapOutdoorContext, } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Outdoor-Context.provider';
    export type { IOutdoorContextProvider } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Outdoor-Context.provider';
}

declare module '@mappedin/mappedin-js/renderer/public/api/Exporter' {
    import { ExportController } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @hidden
        */
    export type TGLTFExportOptions = {
            onlyVisible?: boolean;
            binary?: boolean;
            scale?: number;
    };
    /**
        * API to export the scene.
        *
        * @hidden
        */
    export class Exporter {
            #private;
            /**
                * @hidden
                * @internal
                */
            constructor(controller: ExportController);
            /**
                * Exports the current scene as a GLTF file.
                *
                * @hidden
                */
            getCurrentSceneGLTF(userOptions: TGLTFExportOptions): Promise<Blob>;
    }
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.types' {
    export type TGetVenueOptions = {
            accessToken?: string;
            clientId?: string;
            clientSecret?: string;
            baseUrl?: string;
            includeHidden?: boolean;
            noAuth?: boolean;
            perspective?: string;
            language?: string;
            headers?: {
                    [key in string]: string;
            };
            venue: string;
            things?: any;
            useDraftData?: boolean;
            platformString?: string;
            emitAnalyticsEvents?: boolean;
            secure?: boolean;
            preloadMapGeometry?: boolean;
    };
    export type TGetVenueOptionsInternal = {
            baseUrl?: string;
            supplementaryUrl?: string;
            noAuth?: boolean;
            includeHidden?: boolean;
            apiGateway?: string;
            authorization?: string;
            things?: any;
            headers?: any;
    };
    export type TVenueMetadata = {
            languages: {
                    name: string;
                    code: string;
            }[];
            hasSecureAssets: boolean;
    };
    export enum MAP_RENDER_MODE {
            /** Each polygon, its geometry and mesh are sent to the GPU every render frame.
                * This was the default rendering mode before 4.0.17
                */
            MULTI_GEOMETRY = "MULTI_GEOMETRY",
            /** Polygons' geometries are grouped by material and merged together, resulting in far fewer
                * draw calls to the GPU. Default rendering mode since 4.0.17
                */
            SINGLE_GEOMETRY = "SINGLE_GEOMETRY"
    }
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin' {
    import { Navigator } from '@mappedin/mappedin-js/navigator';
    import type { TGetVenueOptions, TGetVenueOptionsInternal } from '@mappedin/mappedin-js/get-venue/Mappedin.types';
    import type { MappedinNode, MappedinPolygon, MappedinLocation, MappedinCategory, MappedinVortex, MappedinVenue, MappedinTheme, MappedinRankings, MappedinLocationRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinMapGroup, GET_VENUE_PAYLOAD } from '@mappedin/mappedin-js/get-venue/internal';
    import { TAccessors, GET_VENUE_EVENT } from '@mappedin/mappedin-js/get-venue/internal';
    import { IAnalytics } from '@mappedin/mappedin-js/get-venue/Mappedin.CustomerAnalytics';
    import { ParsedMVF } from '@mappedin/mvf';
    import { ParsedMVFv1 } from '@mappedin/mappedin-js/get-venue/Mappedin.MVF.types';
    import { PubSub } from '@mappedin/mappedin-js/get-venue/pub-sub.typed';
    export const defaultOptions: TGetVenueOptionsInternal & TGetVenueOptions;
    export class Mappedin extends PubSub<GET_VENUE_PAYLOAD, GET_VENUE_EVENT> {
            #private;
            perspective: any;
            things: any;
            options: any;
            updatedAt?: string;
            categories: MappedinCategory[];
            locations: MappedinLocation[];
            vortexes: MappedinVortex[];
            maps: MappedinMap[];
            nodes: MappedinNode[];
            polygons: MappedinPolygon[];
            venue: MappedinVenue;
            events: MappedinEvent[];
            mapGroups: MappedinMapGroup[];
            themes: MappedinTheme[];
            locationStates: MappedinLocationState[];
            rankings?: MappedinRankings;
            currentLanguage: {
                    name: string;
                    code: string;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _categoriesById?: {
                    [id: string]: MappedinCategory;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationsById?: {
                    [id: string]: MappedinLocation;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _vortexesById?: {
                    [id: string]: MappedinVortex;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapsById?: {
                    [id: string]: MappedinMap;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _nodesById?: {
                    [id: string]: MappedinNode;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _polygonsById?: {
                    [id: string]: MappedinPolygon;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _eventsById?: {
                    [id: string]: MappedinEvent;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapGroupsById?: {
                    [id: string]: MappedinMapGroup;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationStatesById?: {
                    [id: string]: MappedinLocationState;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationRankingsById?: {
                    [id: string]: MappedinLocationRankings;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _rankingsById?: {
                    [id: string]: MappedinRankings;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _categoriesByExternalId?: {
                    [id: string]: MappedinCategory;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationsByExternalId?: {
                    [id: string]: MappedinLocation;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _vortexesByExternalId?: {
                    [id: string]: MappedinVortex;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapsByExternalId?: {
                    [id: string]: MappedinMap;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _nodesByExternalId?: {
                    [id: string]: MappedinNode;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _polygonsByExternalId?: {
                    [id: string]: MappedinPolygon;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _eventsByExternalId?: {
                    [id: string]: MappedinEvent;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapGroupsByExternalId?: {
                    [id: string]: MappedinMapGroup;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationStatesByExternalId?: {
                    [id: string]: MappedinLocationState;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationRankingsByExternalId?: {
                    [id: string]: MappedinLocationRankings;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _rankingsByExternalId?: {
                    [id: string]: MappedinRankings;
            };
            getCollectionItemById<T extends keyof TAccessors, I extends string>(name: T, id: I): TAccessors[T] | null;
            /**
                * @hidden
                * @internal
                */
            hydrateFromMVF(mvfData: ParsedMVF): Promise<undefined>;
            /**
                * @hidden
                * @internal
                */
            hydrateFromMVFv1(mvfData: ParsedMVFv1): Promise<undefined>;
            /**
                * Change the language of the venue. This will trigger a re-fetch of the venue data and emit a
                * {GET_VENUE_EVENT.LANGUAGE_CHANGED} event.
                *
                * @param languageCode The language code to change to
                * @param cache Whether or not to cache the current language so it doesn't need to be re-fetched
                */
            changeLanguage(languageCode: string, cache?: boolean): Promise<void>;
            /**
                *
                * @experimental Hydrate the Mappedin instance using a response from either {@link Mappedin.toString}, {@link getVenueBundle} or by downloading the bundle manually
                * @param mappedinSerializableData Mappedin data that was serialized or exported as JSON
                * @param shouldPopulateBundledImagesAsBlobs Takes the scenes and images from a bundle and maps them as blobs to where they exist as URLs in the bundle. False by default
                */
            hydrate(mappedinSerializableData: string | Record<string, unknown>, shouldPopulateBundledImagesAsBlobs?: boolean): Promise<undefined>;
            images: any;
            imageBinaries?: Map<string, Uint8Array>;
            scenes: any;
            fetch(): Promise<void>;
            /**
                * @deprecated Use {@link hydrateVenue} instead
                */
            constructor(options: TGetVenueOptionsInternal & TGetVenueOptions);
            analytics: IAnalytics;
            /**
                * @hidden
                */
            navigator?: Navigator;
            /**
                * Export venue data to JSON (for storage, encryption, etc)
                */
            toJSON(): any;
            /**
                * Export venue data to String
                */
            toString(): string;
    }
}

declare module '@mappedin/mappedin-js/get-venue/default-things' {
    export const defaultThings: {
        venue: string[];
        nodes: string[];
        vortexes: string[];
        polygons: string[];
        locations: string[];
        categories: string[];
        maps: string[];
        mapGroups: string[];
        themes: string[];
        rankings: string[];
    };
}

declare module '@mappedin/mappedin-js/get-venue/internal' {
    import { MappedinNavigatable } from '@mappedin/mappedin-js/get-venue/MappedinNavigatable';
    import { MappedinNode } from '@mappedin/mappedin-js/get-venue/MappedinNode';
    import { MappedinPolygon } from '@mappedin/mappedin-js/get-venue/MappedinPolygon';
    import { MappedinLocation } from '@mappedin/mappedin-js/get-venue/MappedinLocation';
    import { MappedinCategory } from '@mappedin/mappedin-js/get-venue/MappedinCategory';
    import { MappedinDirections } from '@mappedin/mappedin-js/get-venue/MappedinDirections';
    import { MappedinDestinationSet } from '@mappedin/mappedin-js/get-venue/MappedinDestinationSet';
    import { MappedinVortex } from '@mappedin/mappedin-js/get-venue/MappedinVortex';
    import { MappedinVenue } from '@mappedin/mappedin-js/get-venue/MappedinVenue';
    import { MappedinTheme } from '@mappedin/mappedin-js/get-venue/MappedinTheme';
    import { MappedinRankings } from '@mappedin/mappedin-js/get-venue/MappedinRankings';
    import { MappedinLocationRankings } from '@mappedin/mappedin-js/get-venue/MappedinLocationRankings';
    import { MappedinEvent } from '@mappedin/mappedin-js/get-venue/MappedinEvent';
    import { MappedinLocationState } from '@mappedin/mappedin-js/get-venue/MappedinLocationState';
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue/MappedinMap';
    import { MappedinCoordinate } from '@mappedin/mappedin-js/get-venue/MappedinCoordinate';
    import { MappedinMapGroup } from '@mappedin/mappedin-js/get-venue/MappedinMapGroup';
    export { MappedinNavigatable, MappedinNode, MappedinPolygon, MappedinLocation, MappedinCategory, MappedinDirections, MappedinDestinationSet, MappedinVortex, MappedinVenue, MappedinTheme, MappedinRankings, MappedinLocationRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, };
    export * from '@mappedin/mappedin-js/get-venue/utils';
    export { default as MappedinCache } from '@mappedin/mappedin-js/get-venue/Mappedin.cache';
    export enum MappedinCollectionType {
        CATEGORY = "categories",
        EVENT = "events",
        LOCATION = "locations",
        MAPGROUP = "mapGroups",
        MAP = "maps",
        NODE = "nodes",
        POLYGON = "polygons",
        VORTEX = "vortexes"
    }
    export type TAccessors = {
        [MappedinCollectionType.CATEGORY]: MappedinCategory;
        [MappedinCollectionType.EVENT]: MappedinEvent;
        [MappedinCollectionType.LOCATION]: MappedinLocation;
        [MappedinCollectionType.MAPGROUP]: MappedinMapGroup;
        [MappedinCollectionType.MAP]: MappedinMap;
        [MappedinCollectionType.NODE]: MappedinNode;
        [MappedinCollectionType.POLYGON]: MappedinPolygon;
        [MappedinCollectionType.VORTEX]: MappedinVortex;
    };
    export const THINGS: {
        categories: typeof MappedinCategory;
        locations: typeof MappedinLocation;
        vortexes: typeof MappedinVortex;
        maps: typeof MappedinMap;
        nodes: typeof MappedinNode;
        polygons: typeof MappedinPolygon;
        venue: typeof MappedinVenue;
        events: typeof MappedinEvent;
        mapGroups: typeof MappedinMapGroup;
        themes: typeof MappedinTheme;
        locationStates: typeof MappedinLocationState;
        rankings: typeof MappedinRankings;
    };
    export type TTHINGS = keyof typeof THINGS;
    export type { TDirectionToOptions } from '@mappedin/mappedin-js/get-venue/MappedinNavigatable';
    export enum GET_VENUE_EVENT {
        LANGUAGE_CHANGED = 0
    }
    export type GET_VENUE_PAYLOAD = {
        [GET_VENUE_EVENT.LANGUAGE_CHANGED]: {
            name: string;
            code: string;
        };
    };
    export { Mappedin } from '@mappedin/mappedin-js/get-venue/Mappedin';
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.CustomerAnalytics' {
    import { MappedinNavigatable, MappedinLocation, MappedinCategory } from '@mappedin/mappedin-js/get-venue/internal';
    type AnalyticsUserPosition = {
            bluedotTimestamp: number;
            latitude: number;
            longitude: number;
            floorLevel?: number;
            accuracy: number;
    };
    type AnalyticsOptions = {
            clientId?: string;
            clientSecret?: string;
            accessToken?: string;
            noAuth?: boolean;
            venue: string;
            testMode?: boolean | string;
            context?: string;
            platformString?: string;
    };
    interface IAnalytics {
            locationSelected(location: MappedinLocation): void;
            categorySelected(category: MappedinCategory): void;
            /**
                * @hidden
                * @internal
                * @deprecated
                */
            getDirections(start: MappedinNavigatable, end: MappedinNavigatable): void;
    }
    interface IInternalAnalytics extends IAnalytics {
            track(target: string, query: any): void;
            mapViewLoaded(type: '2d' | '3d', forced: boolean, benchmark: number, reason: string): void;
            getSessionID(): string;
            getDeviceID(): string;
            setGeolocationMode(mode: boolean): void;
            trackBlueDotEvent(blueDotEvent: Record<string, unknown>): void;
            trackSearch(searchAnalyticsObject: Record<string, unknown>): void;
            trackSearchSuggest(searchAnalyticsObject: Record<string, unknown>): void;
    }
    /**
        * @internal
        * @hidden
        * A singleton class to access the Mappedin Analytics platform. Correct usage will improve Smart Search results, and lead to more accurate insights.
        * This will be created for you as part of Mappedin.{{#crossLink "Mappedin/initialize:method"}}{{/crossLink}}, but you can also create one manually. You are mostly going to use `locationSelected`.
        *
        * @type {any}
        */
    class Analytics implements IInternalAnalytics {
            #private;
            static instance: Analytics | null;
            /**
                * The static method to create a singleton instance of the Analytics class.
                * @class Analytics
                * @param options {Object} A list of configuration options for the Analytics API.
                *	@param [options.clientId] {String} The same key you are using for getVenue. Handled automatically in Mapview.initialize()
                *	@param [options.clientSecret] {String} The same secret you are using for getVenue. Handled automatically in Mapview.initialize()
                *	@param [options.venue] {String} The same venue slug you are using for getVenue. Handled automatically in MapView.initialize()
                *	@param [options.context] {String} The context to pass with the analytics request. Defaults to "websdk".
                *	@param [options.noAuth] {Boolean} Whether authentication should not be sent with analytics requests.
                *	@param [options.testMode] {Boolean} Whether analytics events should be dropped because this is running in a test environment.
                * @returns {Analytics} The singleton instance of the Analytics class.
                */
            static create(options: AnalyticsOptions): Analytics;
            track(target: string, query: Record<string, any>): void;
            /**
                * This method should be called whenever the user's position changes. This information will be sent when a track call is made.
                * @param position {AnalyticsUserPosition} The user's current position.
                */
            updateAnalyticsUserPosition(position: Omit<AnalyticsUserPosition, 'bluedotTimestamp'> | undefined): void;
            /**
                * Whenever a location is selected, you should fire this event. What "selected" means can vary by venue,
                * but a good rule of thumb is that you fire the event whenever you would show the location's details.
                * Typically this is when the user taps it's polygon on the map, picks it from search results or a category list.
                * or deep links directly into the map.
                * @method locationSelected
                * @param location {MappedinLocation} The location the user selected.
                */
            locationSelected(location: any): void;
            /**
                * Whenever a category is selected, you should fire this event.
                * @method categorySelected
                * @param category {MappedinCategory} The category the user selected.
                */
            categorySelected(category: any): void;
            mapViewLoaded(type: any, forced: any, benchmark: any, reason: any): void;
            /**
                * Whenever a user requests directions, you should fire this event.
                * @method getDirections
                * @param start {MappedinLocation} The start location for wayfinding.
                * @param end {MappedinLocation} The end location for wayfinding.
                */
            getDirections(start: any, end: any): void;
            getSessionID(): string;
            getDeviceID(): string;
            /**
                * @param mode {Boolean} Indicates whether the user's geolocation is enabled.
                */
            setGeolocationMode(mode: any): void;
            /**
                * Track an event.
                * @method trackBlueDotEvent
                * @param event {String}
                * event param should be a property of the {{#crossLink "Analytics/BLUEDOT_EVENT:property"}}{{/crossLink}} property.
                */
            trackBlueDotEvent(blueDotEvent: any): void;
            trackSearch(searchAnalyticsObject: any): void;
            trackSearchSuggest(searchAnalyticsObject: any): void;
            /**
                * Sets the current global context of the Analytics class.
                * @method setContext
                * @param context {String} The Analytics context to be set.
                * @hidden
                */
            static setContext(context: any): void;
            /**
                * Sets the current global context of the Analytics class to undefined.
                * @method clearContext
                * @hidden
                */
            static clearContext(): void;
            /**
                * Destroys the singleton instance of the Analytics class.
                * @method destroy
                * @hidden
                */
            static destroy(): void;
            /**
                * Enum of valid bluedot events.
                * Pass a property of this into the {{#crossLink "Analytics/trackBlueDotEvent:method"}}{{/crossLink}} method.
                * Valid properties are: ATTEMPT_BLUEDOT, FOUND_POSITION, FOUND_FLOOR.
                * @property BLUEDOT_EVENT {Object}
                * @example
                *   Analytics.trackBlueDotEvent(Analytics.BLUEDOT_EVENT.ATTEMPT_BLUEDOT)
                */
            static BLUEDOT_EVENT: {
                    ATTEMPT_BLUEDOT: string;
                    FOUND_POSITION: string;
                    FOUND_FLOOR: string;
            };
    }
    export type { IAnalytics };
    export default Analytics;
}

declare module '@mappedin/mappedin-js/get-venue/MappedinLocation' {
    import type { TLocation, TColor, TGalleryImage, TLogo, TOpeningHours, TPhone, TPicture, TSiblingGroup, TSocial } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    import type { MappedinNode, MappedinPolygon, MappedinCategory, MappedinLocationState, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import { MappedinNavigatable, MappedinDirections, MappedinDestinationSet, TDirectionToOptions } from '@mappedin/mappedin-js/get-venue/internal';
    export function getCurrentLocationState(location: MappedinLocation, states: MappedinLocationState[], date?: Date): MappedinLocationState | undefined;
    export type TOperationHoursMap = {
            [key in string]: TOpeningHours[];
    };
    /**
        * A {@link MappedinLocation} is something like a store or washroom on a {@link MappedinMap}. It has an ID and will be linked to zero or more {@link MappedinNode}s and {@link MappedinPolygon}s.
        *
        * A Location's Nodes and Polygons can be on multiple Maps, or in multiple non-adjacent places on the same Map.
        *  For example, all washroom at a given Venue could belong to one Location, or a department store could live on multiple floors. A Washroom Location might a have a few Polygons spread throughout the Venue for each one that exists, but a single store might just have one presence, and therefore one Polygon. Some Locations just have a single point and only have Nodes.
        *
        * A Location can have more properties (typically things like 'name', 'externalId', 'type', 'categories', 'description', 'logo', etc).
        *
        * The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Locations. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Location properties specified:
        *
        *	things: {
        *		venue: [],
        *		locations: ['venue', 'name', 'type', 'icon', 'logo', 'language', 'externalId', 'description', 'categories', 'phone', 'operationHours', 'social', 'tags', 'parents', 'sortOrder'],
        *		categories: [],
        *		maps: []
        * 	}
        *
        * @class MappedinLocation
        */
    export class MappedinLocation extends MappedinNavigatable {
            #private;
            states: TLocation['states'];
            id: string;
            name: string;
            type: string;
            description?: string;
            sortOrder?: number;
            logo?: TLogo;
            phone?: TPhone;
            social?: TSocial;
            color?: TColor;
            shortName?: string;
            detailsUrl?: string;
            tags?: string[];
            /**
                * @internal
                */
            toMap?: string;
            externalId?: string;
            showLabelWhenImagePresent?: boolean;
            showSmartLabelWhenImagePresent?: boolean;
            picture?: TPicture;
            operationHours?: TOpeningHours[] | undefined;
            siblingGroups?: TSiblingGroup[] | undefined;
            gallery?: TGalleryImage[] | undefined;
            amenity?: string | undefined;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Polygons this Location is attached to.
                *
                * @property polygons
                * @type [MappedinPolygon]
                */
            get polygons(): MappedinPolygon[];
            set polygons(polygons: MappedinPolygon[]);
            /**
                * Nodes this Location is attached to.
                *
                * @property nodes
                * @type [MappedinNode]
                */
            get nodes(): MappedinNode[];
            set nodes(nodes: MappedinNode[]);
            /**
                * Parent of this Location, if any. Used in cases where one Location is inside another, more "important" Location.
                *
                * @property parent
                * @type MappedinLocation
                */
            get parent(): MappedinLocation | undefined;
            set parent(parent: MappedinLocation | undefined);
            /**
                * Categories related to this location.
                *
                * @property categories
                * @type [MappedinCategory]
                */
            get categories(): MappedinCategory[];
            get state(): MappedinLocationState | undefined;
            clone(): MappedinLocation;
            get nodeOperationHours(): TOperationHoursMap;
            static hydrate(locations: any, mappedin: Mappedin): MappedinLocation[];
            static fetch(mappedin: Mappedin): Promise<MappedinLocation[]>;
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate distance between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinCoordinate' {
    import { MappedinNode, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { MappedinMap } from '@mappedin/mappedin-js/get-venue/internal';
    export type TMappedinCoordinateOptions = {
            map: MappedinMap;
            mappedin: Mappedin;
            x: number;
            y: number;
            lat?: undefined;
            lon?: undefined;
    } | {
            map: MappedinMap;
            mappedin: Mappedin;
            x?: undefined;
            y?: undefined;
            lat: number;
            lon: number;
    };
    /**
        * A {@link MappedinCoordinate} represents a coordinate on a map, created using lat/lon.
        *
        * @class MappedinCoordinate
        */
    export class MappedinCoordinate {
            #private;
            /**
                * The Map that the Node is located on.
                *
                * @property map {MappedinMap}
                */
            map: MappedinMap;
            /**
                *  X coordinate in Mappedin Units
                * @property x {number}
                */
            get x(): number;
            /**
                * Y coordinate in Mappedin Units
                * @property y {number}
                */
            get y(): number;
            /**
                * Latitude
                */
            get lat(): number;
            /**
                * Longitude
                */
            get lon(): number;
            /**
                * @internal
                */
            constructor(options: TMappedinCoordinateOptions);
            /**
                *
                * Calculate distance between a coordinate and a {@link MappedinNode} or {@link MappedinCoordinate}
                *
                * @param destination Destination to measure real distance to
                * @returns distance in meters
                */
            absoluteDistanceTo(destination: MappedinCoordinate): number;
            /**
                * Get Nearest Node to Coordinate, which can then be used for navigation
                */
            get nearestNode(): MappedinNode;
            toJSON(): {
                    x: number;
                    y: number;
                    map: MappedinMap;
                    lat: number;
                    lon: number;
            };
    }
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.OfflineSearch' {
    import type { SearchOptions } from 'minisearch';
    import { MappedinLocation, MappedinCategory, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    export const removeAccents: (it: string) => string;
    export type { SearchOptions };
    /**
        * A {@link OfflineSearch} is an offline search module
        *
        *
        * @class OfflineSearch
        */
    export type TMappedinOfflineSearchAllOptions = {
            /**
                * Array of stopwords to ignore when searching, default: english stopwords
                */
            stopWords?: string[];
            /**
                * Index location tags - typically better to use either tags or descriptions, depending on what's available
                * @default true
                */
            searchTags?: boolean;
            /**
                * Index location descriptions - typically better to use either tags or descriptions, depending on what's available
                * @default true
                */
            searchDescriptions?: boolean;
            /**
                * Also index all tags for every location in every category (caution: this may slow down indexing and search)
                * @default false
                */
            searchTagsInCategories?: boolean;
            /**
                * Also index all tags for every location in every category (caution: this may slow down indexing and search)
                * @default false
                */
            searchDescriptionsInCategories?: boolean;
            /**
                * Initialize Search with a previously indexed JSON string (outputted by OfflineSearch.toJSON())
                */
            jsonIndex?: string;
            /**
                * Use the location polygons' rank in weighing results
                */
            useLocationRank?: boolean;
            /**
                * Emit Analytics events when doing search
                * @default true when running in production
                */
            emitAnalyticsEvents?: boolean;
            /**
                * Fine tune search constants
                */
            constants: {
                    /**
                        * Fuzziness index for location names and tags
                        * @default 0.09
                        */
                    PRIMARY_INDEX_FUZZYNESS: number;
                    /**
                        * Multiplier for location names (1 by default)
                        * @default 1
                        */
                    PRIMARY_INDEX_WEIGHT: number;
                    /**
                        * Multiplier for descriptions
                        * @default 0.025
                        */
                    SECONDARY_INDEX_WEIGHT: number;
                    /**
                        * Multiplier for location names
                        * @default 1
                        */
                    LOCATION_NAME_WEIGHT: number;
                    /**
                        * Multiplier for category names
                        * @default 0.5
                        */
                    CATEGORY_NAME_WEIGHT: number;
                    /**
                        * Multiplier for category locations' descriptions
                        * @default 0.0005
                        */
                    CATEGORY_LOCATION_DESCRIPTION_WEIGHT: number;
                    /**
                        * Multiplier for category locations' tags
                        * @default 0.0005
                        */
                    CATEGORY_LOCATION_TAGS_WEIGHT: number;
                    /**
                        * Multiplier for category locations' names
                        * @default 0.01
                        */
                    CATEGORY_LOCATION_NAME_WEIGHT: number;
                    /**
                        * Multiplier for location tags
                        * @default 0.05
                        */
                    PRIMARY_INDEX_TAGS_NAME_WEIGHT: number;
                    /**
                        * Default rank when one isn't available in the data, default = 1
                        * @default 1
                        */
                    LOCATION_DEFAULT_RANK: number;
                    /**
                        * Ratio of Fuzzy Searches of Location names and tags relative to exact
                        * @default 0.01
                        */
                    RATIO_OF_FUZZY_TO_EXACT: number;
                    /**
                        * Ratio of Prefix Searches of Location names and tags relative to exact
                        * @default 0.2
                        */
                    RATIO_OF_PREFIX_TO_EXACT: number;
            };
    };
    export type TMappedinOfflineAllSearchMatch = {
            /**
                * The term that was found
                */
            term: string;
            /**
                * Term's weight
                */
            weight: number;
            /**
                * What field the search matched on
                */
            matchesOn: string;
            /**
                * The value of that field
                */
            value?: string;
    };
    export type TMappedinOfflineSearchOptions = Partial<TMappedinOfflineSearchAllOptions>;
    export type TMappedinOfflineSearchResult = {
            /**
                * Type describing the object
                */
            type: 'MappedinLocation' | 'MappedinCategory' | 'Custom';
            /**
                * Details on why the result was returned
                */
            matches: TMappedinOfflineAllSearchMatch[];
            /**
                * Found object
                */
            object: MappedinLocation | MappedinCategory | Record<string, unknown>;
            /**
                * Total score of the result
                */
            score: number;
    };
    export type TMappedinOfflineSearchSuggestions = {
            /**
                * Total number of suggestions generated
                */
            total: number;
            /**
                * List of suggestions
                */
            hits: {
                    /**
                        * Suggestion text
                        */
                    text: string;
            }[];
    };
    /**
        * A {@link OfflineSearch} is an offline search module. It can be initialized at any time by passing the {@link Mappedin} object and a set of {@link TMappedinOfflineSearchOptions} options.
        *
        *
        * @class Mappedin.OfflineSearch
        */
    export class OfflineSearch {
            #private;
            constructor(
            /**
                * Mappedin Venue Object, typically returned by `getVenue`/`showVenue`
                */
            mappedin: Mappedin, options?: TMappedinOfflineSearchOptions);
            /**
                * Get Suggestions for term
                */
            suggest(
            /**
                * Search term
                */
            term: string): Promise<TMappedinOfflineSearchSuggestions>;
            /**
                * Search for a term
                */
            search(
            /**
                * Search term
                */
            term: string): Promise<TMappedinOfflineSearchResult[]>;
            /**
                * Export search index to JSON for storage/caching - this would avoid having to re-index
                * on page reload
                */
            toJSON(): Promise<string>;
            /**
                * Add a custom query to the search index
                */
            addQuery(params: {
                    /**
                        * Query string to match for this object
                        */
                    query: string;
                    /**
                        * Object that is returned when query matches
                        */
                    object: MappedinLocation | MappedinCategory | Record<string, unknown>;
                    /**
                        * Optional weight to multiply by the score
                        */
                    weight?: number;
            }): Promise<void>;
    }
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.API.types' {
    /**
      * This file contains the API types for MappedinSDK - before they get turned into Classes
      */
    export type TLocationType = 'amenities' | 'tenant';
    export type TNode = {
        id: string;
        x: number;
        y: number;
        map: string;
        externalId?: string;
        paths: {
            node: string;
            map: string;
            weight?: number;
        }[];
        [propName: string]: any;
    };
    export type TImage = {
        original?: string;
        large?: string;
        '140x140'?: string;
        xxlarge?: string;
        xsmall?: string;
        '66x66'?: string;
        xlarge?: string;
        medium?: string;
        xxsmall?: string;
        small?: string;
    };
    export type TLogo = TImage;
    export type TGalleryImage = {
        image: TImage;
        caption?: string;
    };
    export type TPhone = {
        number?: string;
    };
    export type TSocial = {
        website?: string;
        twitter?: string;
        facebook?: string;
        instagram?: string;
    };
    export type TColor = {
        hex: string;
        opacity: number;
        rgba: string;
    };
    export type TVortex = {
        id: string;
        name: string;
        type: string;
        weight: number;
        multiplier: number;
        [propName: string]: any;
    };
    export type TPicture = {
        original?: string;
    };
    export type TOpeningHours = {
        '@type': string;
        opens: string;
        closes: string;
        dayOfWeek: string[];
        validFrom?: string;
        validThrough?: string;
    };
    export type TSiblingGroup = {
        label: string;
        siblings: string[];
    };
    export type TState = {
        type: string;
        start?: string;
        end?: string;
    };
    export type TCategory = {
        name?: string;
        externalId?: string;
        parents?: string[];
        id?: string;
        icon?: TPicture;
    };
    export type TEvent = {
        id: string;
        type: string;
        name: string;
        location?: string;
        description?: string;
        image?: TImage;
        startDate?: number;
        endDate?: number;
        showDate?: number;
    };
    export interface TGeoReference {
        target: {
            x: number;
            y: number;
        };
        control: {
            x: number;
            y: number;
        };
    }
    export interface TMap {
        id: string;
        name: string;
        shortName: string;
        elevation?: number;
        scale?: number;
        x_scale?: number;
        georeference?: TGeoReference[];
        [propName: string]: any;
    }
    export type TMapGroup = {
        name: string;
        id: string;
    };
    export type TBuilding = TLocation & {
        groupId: string;
    };
    export type TLocation = {
        id: string;
        name: string;
        type: string;
        nodes: {
            map: TMap['id'];
            node: TNode['id'];
        }[];
        polygons: {
            map: TMap['id'];
            id: TPolygon['id'];
        }[];
        categories: string[];
        description?: string;
        sortOrder?: number;
        logo?: TLogo;
        phone?: TPhone;
        social?: TSocial;
        color?: TColor;
        shortName?: string;
        detailsUrl?: string;
        parent?: string | null;
        tags?: string[];
        externalId?: string;
        picture?: TPicture;
        states?: TState[];
        operationHours?: TOpeningHours[] | undefined;
        siblingGroups?: TSiblingGroup[] | undefined;
        gallery?: TGalleryImage[] | undefined;
        [propName: string]: any;
    };
    export type TPolygon = {
        id: string;
        map: string;
        layer?: string;
        layerId?: string;
        externalId?: string;
        name?: string;
        entrances: {
            map: TMap['id'];
            id: TNode['id'];
        }[];
    };
    export type TPolygonRanking = {
        polygonId: string;
        entranceNodeId: string;
        score: number;
    };
    export type TLocationState = {
        id: string;
        name: string;
        value: string;
    };
    export type TVenue = {
        address?: string;
        city?: string;
        countrycode?: string;
        defaultMap?: string;
        externalId?: string;
        id?: string;
        latitude?: number;
        logo?: TLogo;
        longitude?: number;
        metadata?: any;
        name?: string;
        operationHours?: TOpeningHours[];
        postal?: string;
        slug?: string;
        state?: string;
        telephone?: string;
        tzid?: string;
        tzidOverride?: string;
        utcOffset?: string;
        website?: string;
    };
    export type TMappedinAPI = {
        nodes: TNode[];
        locations: TLocation[];
        categories: TCategory[];
        mapGroups: TMapGroup[];
        polygons: TPolygon[];
        maps: TMap[];
        themes: any;
        venue: TVenue;
        vortexes: TVortex[];
        locationStates?: TLocationState[];
        imageBinaries?: Map<string, Uint8Array>;
    };
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/fake-geolocation' {
    export default FakeGeolocation;
    class FakeGeolocation {
        constructor(options: any);
        active: boolean;
        positions: any[];
        positionIndex: number;
        timerList: any[];
        timeElapsed: number;
        startTime: number | undefined;
        startPos: number;
        endPos: number;
        smoothingType: any;
        isActive(): boolean;
        setCallbacks(success: any, error: any, options: any): void;
        watchPosition(success: any, error: any, options: any): void;
        sendPositionResponse(position: any): void;
        start(): void;
        pause(): void;
        speed: any;
        setPositions(positions: any): void;
        successCallback: any;
        errorCallback: any;
        options: any;
        clearWatch(): void;
        reset(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.StateMachine' {
    import { IPubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
    import { E_BLUEDOT_STATE, E_BLUEDOT_MARKER_STATE } from '@mappedin/mappedin-js/renderer/internal';
    /**
    What we just learned about the user's position.
     */
    export enum ACTION {
        gotPosition = 0,
        gotPositionWithFloor = 1,
        gotError = 2,
        timedOut = 3,
        disabledBlueDot = 4,
        enabledBlueDot = 5
    }
    export interface IStateMachine extends IPubSub {
        state: E_BLUEDOT_STATE;
        markerState: E_BLUEDOT_MARKER_STATE | undefined;
        transition: (action: ACTION) => void;
        reset: () => void;
    }
    export enum STATEMACHINE_EVENT {
        stateChanged = 0,
        markerStateChanged = 1
    }
    const StateMachine: () => IStateMachine & IPubSub;
    export default StateMachine;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/position-smoothing' {
    export namespace SMOOTHING_TYPE {
        let NONE: string;
        let KALMAN: string;
    }
    export default PositionSmoothing;
    class PositionSmoothing {
        constructor(levelFilter: any);
        smooth(pos: any): any;
        smoothingType: any;
        lastLocation: any;
        levelFilter: any;
        formatLocation(pos: any): {
            type: string;
            timestamp: any;
            coords: {
                latitude: any;
                longitude: any;
                accuracy: any;
                floorLevel: any;
            };
        };
        kalman(location: any, lastLocation: any): any;
        latitudeKF: any;
        longitudeKF: any;
        setSmoothingType(smoothingType: any): void;
        reset(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/pub-sub' {
    type TChangeEventData = {
        oldValue: any;
        newValue: any;
    };
    type TListenerFn = (data: TChangeEventData | any) => void;
    export interface IPubSub {
        publish: (eventName: any, data: TChangeEventData) => void;
        on: (eventName: any, listenerFn: TListenerFn) => void;
        off: (eventName: any, listenerFn: TListenerFn) => void;
        destroy: () => void;
        _subscribers: {
            [eventName in any]?: TListenerFn[];
        };
    }
    export class PubSub {
        _subscribers: any;
        publish(eventName: any, data: any): void;
        on(eventName: any, fn: any): void;
        off(eventName: any, fn: any): void;
        destroy(): void;
    }
    export function tinyObservable<T>(store: T): T & IPubSub;
    export {};
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.FloatingLabel' {
    import './Mappedin.FloatingLabel.scss';
    import { BaseCollider } from '@mappedin/mappedin-js/renderer/internal';
    import { TDrawFn } from '@mappedin/mappedin-js/renderer/internal/shave-text';
    import type { MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, ICollider, TColliderStrategy, TColliderPosition } from '@mappedin/mappedin-js/renderer/internal';
    type TStyle = {
            top?: number;
            left?: number;
            textLabelVisible?: boolean;
            pinVisibility: PINVISIBILITY;
            textAlign?: TEXTALIGN;
            cachedSymbol?: HTMLCanvasElement;
    };
    export interface ISmarterLabel extends ICollider {
            zoomProportion: number;
            contextConfigured: boolean;
            fillText?: TDrawFn;
            _cache: {
                    [key: string]: HTMLCanvasElement | OffscreenCanvas;
            };
            lines: number;
            style: TStyle;
            newStyle: TStyle;
            getCachedSymbol: (orientation: string, textAlign: TEXTALIGN, xCoordinate: number) => HTMLCanvasElement | OffscreenCanvas;
            draw: (context: CanvasRenderingContext2D) => void;
    }
    /**
        * Control how a floating label looks
        */
    export type TFloatingLabelAppearance = {
            /**
                * Margin around the label and marker. This will affect label density, with a mininum of 7px around
                * @default 6
                */
            margin?: number;
            text?: {
                    /**
                        * Number of lines to display when text spans multiple lines
                        */
                    numLines?: number;
                    /**
                        * Text size in pixels
                        */
                    size?: number;
                    /**
                        * Maxiumum width of text in pixels
                        */
                    maxWidth?: number;
                    /**
                        * Line height sets the height of a line box. It's commonly used to set the distance between lines of text
                        *
                        * @default 1.2
                        */
                    lineHeight?: number;
                    /**
                        * Text foreground color
                        */
                    foregroundColor?: string;
                    /**
                        * Text background color
                        */
                    backgroundColor?: string;
            };
            marker?: {
                    /**
                        * Size of the marker in pixels
                        * @deprecated Behavior when using this along with `iconVisibilityThreshold` and `icon` is undefined
                        */
                    size?: number;
                    foregroundColor?: {
                            /**
                                * Foreground color of the marker when it is active
                                */
                            active?: string;
                            /**
                                * Foreground color of the marker when it is inactive (grayed out due to being outranked by other labels around)
                                */
                            inactive?: string;
                    };
                    backgroundColor?: {
                            /**
                                * Background color of the marker when it is active
                                */
                            active?: string;
                            /**
                                * Background color of the marker when it is inactive (grayed out due to being outranked by other labels around)
                                */
                            inactive?: string;
                    };
                    /**
                        * Size of bounding box of SVG icon
                        */
                    iconSize?: number;
                    /**
                        * SVG of icon to place inside Floating Label
                        */
                    icon?: string;
                    /**
                        * Defines when the icon becomes visible relative to the current zoom level
                        * anything below 0 will result in icons never showing up
                        * 0 ensures icons show up at maxZoom (fully zoomed in)
                        * 1 ensures they always show up
                        */
                    iconVisibilityThreshold?: number;
            };
    };
    type TAppearanceFilledIn = {
            margin: number;
            text: {
                    numLines: number;
                    lineHeight: number;
                    size: number;
                    maxWidth: number;
                    foregroundColor: string;
                    backgroundColor: string;
            };
            marker: {
                    size: number;
                    foregroundColor: {
                            active: string;
                            inactive: string;
                    };
                    backgroundColor: {
                            active: string;
                            inactive: string;
                    };
                    iconSize?: number;
                    icon?: string;
                    iconVisibilityThreshold?: number;
            };
    };
    export type TFloatingLabelOptionsInternal = {
            id?: string;
            position: TColliderPosition;
            polygon?: MappedinPolygon;
            mapId: string;
            polygonHeight?: number;
            text?: string;
            shortText?: string;
            stateText?: string;
            rank?: number;
            scale?: number;
            /**
                * Customize the appearance of the Smart Label and its marker
                */
            appearance?: TFloatingLabelAppearance;
            createDespiteImage?: boolean;
            layer?: string;
            interactive?: boolean;
    };
    enum PINVISIBILITY {
            OPAQUE = 1,
            SEMI_TRANSPARENT = 0.5
    }
    enum TEXTALIGN {
            LEFT = "left",
            CENTER = "center",
            RIGHT = "right"
    }
    class InternalFloatingLabel extends BaseCollider implements ISmarterLabel {
            #private;
            lines: number;
            contextConfigured: boolean;
            fillText: TDrawFn | undefined;
            newStyle: {
                    pinVisibility: PINVISIBILITY;
            };
            static testId: number;
            style: TStyle;
            setColor: () => void;
            clearColor: () => void;
            zoomProportion: number;
            _cache: {};
            appearance: TAppearanceFilledIn;
            mapView: ICore;
            position: TColliderPosition;
            options: TFloatingLabelOptionsInternal;
            constructor(options: TFloatingLabelOptionsInternal, mapView: ICore);
            enable(updateEngine?: boolean): void;
            get totalTextBoxHeight(): number;
            get totalTextBoxWidth(): number;
            get totalMarkerSize(): any;
            get strategies(): TColliderStrategy[];
            getCachedSymbol(orientation: any, textAlign: any, xCoordinate: any): any;
            invalidate(): void;
            colliderDidMount(): void;
            colliderDidUpdatePosition(pos: any): void;
            colliderDidUpdateVisiblity(): void;
            colliderDidGoOutsideGrid(): void;
            colliderDidNotFindAHome(): void;
            disable(updateEngine?: boolean): void;
            static imagePromiseCache: {
                    [key in number]?: Promise<HTMLImageElement>;
            };
            get pinCanvasSize(): number;
            draw(context: CanvasRenderingContext2D): void;
    }
    export default InternalFloatingLabel;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/OutdoorViewController' {
    import './OutdoorViewController.scss';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { XOR } from '@mappedin/mappedin-js/renderer/MapView.types';
    export type TAttributionPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
    export type TOutdoorViewControllerOptionsWithHeaders = {
        url?: string;
        attributionPosition?: TAttributionPosition;
        customAttribution?: string | string[];
        headers: {
            [key: string]: string | null;
        };
    };
    export type TOutdoorViewControllerOptionsWithAuthURL = {
        url?: string;
        authURL?: string;
        customAttribution?: string | string[];
        attributionPosition?: TAttributionPosition;
    };
    export type TOutdoorViewControllerOptions = XOR<TOutdoorViewControllerOptionsWithHeaders, TOutdoorViewControllerOptionsWithAuthURL>;
    class OutdoorViewController {
        _attribution: any;
        core: ICore;
        map: any;
        enabled: boolean;
        hidden: boolean;
        url: string;
        authURL: string;
        headers?: TOutdoorViewControllerOptions['headers'];
        customAttribution?: string | string[];
        attributionPosition?: TAttributionPosition;
        loaded: boolean;
        constructor(core: ICore, options?: TOutdoorViewControllerOptions);
        module: any;
        load(): Promise<void>;
        get attributions(): any;
        hide(): void;
        show(): void;
        resize(): void;
        getRequestHeaders: () => Promise<TOutdoorViewControllerOptions['headers']>;
        render(): void;
        setStyle(style: any): void;
        setAttributionPosition(position: TAttributionPosition): void;
    }
    export default OutdoorViewController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/BlueDotController' {
    import type { IBlueDotCore, ICore, TEnableBlueDotOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { E_BLUEDOT_EVENT_PAYLOAD, E_BLUEDOT_EVENT, PubSub } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @hidden
        * @internal
        *
        * Blue Dot Layer used for controlling the Blue Dot and listening to Blue Dot state change and position update events. Use the {@link on}-method to set listeners for {@link TBlueDotStateChange} and {@link TBlueDotPositionUpdate} events.
        */
    class BlueDotController extends PubSub<E_BLUEDOT_EVENT_PAYLOAD, E_BLUEDOT_EVENT> {
            #private;
            core: ICore;
            blueDotCore: IBlueDotCore;
            /**
                * @private
                */
            constructor(core: ICore);
            enable(options?: TEnableBlueDotOptions): void;
            disable(): void;
    }
    export default BlueDotController;
}

declare module '@mappedin/mappedin-js/navigator/NavigationGraph' {
    import Edge from '@mappedin/mappedin-js/navigator/Edge';
    import IMap from '@mappedin/mappedin-js/navigator/interfaces/IMap';
    import INode from '@mappedin/mappedin-js/navigator/interfaces/INode';
    import IVortex from '@mappedin/mappedin-js/navigator/interfaces/IVortex';
    export function getMapScale(map: IMap): number;
    export function getAngle(origin: INode, destination: INode): number;
    class NavigationGraph {
        edges: {
            [propName: string]: Edge[];
        };
        nodesById: {
            [propName: string]: INode;
        };
        mapsById: {
            [propName: string]: IMap;
        };
        constructor({ nodes, vortexes, maps, showVortexNames, }: {
            nodes: INode[];
            vortexes: IVortex[];
            maps: IMap[];
            showVortexNames?: boolean;
        });
        /**
          * aStar takes one or more origin node ids, one or more destination node ids
          * and returns an array of nodes that define the shortest path from an origin
          * a destination.
          *
          * @param originIds array - of one or more node ids
          * @param destinationNodeIds array - of onr or more node ids
          * @param accessible boolean - optional, if true directions will only take accessible route, defaults to false
          * @param includedVortexIds set - optional, exclude all the vertexes matching the given IDs
          * @param excludedVortexIds set - optional, exclude all the vertexes matching the given IDs
          */
        aStar({ originIds, destinationNodeIds, accessible, includedVortexIds, excludedVortexIds, }: {
            originIds: string[];
            destinationNodeIds: string[];
            accessible: boolean;
            includedVortexIds?: Set<string>;
            excludedVortexIds?: Set<string>;
        }): Edge[];
        getDistance(origin: INode, destination: INode): number;
        getShortestEuclideanDistance(origin: INode, destinations: INode[]): number;
    }
    export default NavigationGraph;
}

declare module '@mappedin/mappedin-js/navigator/Navigator' {
    import Directive from '@mappedin/mappedin-js/navigator/Directive';
    import Edge from '@mappedin/mappedin-js/navigator/Edge';
    import { TCoordinate } from '@mappedin/mappedin-js/navigator/Navigator.utils';
    import ILocation from '@mappedin/mappedin-js/navigator/interfaces/ILocation';
    import IMap from '@mappedin/mappedin-js/navigator/interfaces/IMap';
    import INode from '@mappedin/mappedin-js/navigator/interfaces/INode';
    import IPolygon from '@mappedin/mappedin-js/navigator/interfaces/IPolygon';
    import IVortex from '@mappedin/mappedin-js/navigator/interfaces/IVortex';
    export enum E_MESSAGES {
            NO_VALID_PATH = "No Valid Path Available"
    }
    export function differenceBetweenAngles(a: any, b: any): number;
    export interface IDirectionsResult {
            distance: number;
            path: INode[];
            instructions: Directive[];
    }
    /**
        * @experimental
        * Configuration options for directions simplifying.
        */
    export type TSimplifyDirectionsOptions = {
            /**
                * Enable or disable simplifying.
                */
            enabled: boolean;
            /**
                * The radius of the buffer around the path.
                * @default 1.8
                */
            bufferRadius?: number;
    };
    class Navigator {
            constructor({ locations, nodes, vortexes, maps, polygons, showVortexNames, }: {
                    locations: ILocation[];
                    nodes: INode[];
                    vortexes: IVortex[];
                    maps: IMap[];
                    polygons?: IPolygon[];
                    showVortexNames?: boolean;
            });
            getClosestLocationInRay(startingEdge: Edge, angleThreshold?: number, distanceThreshold?: number): ILocation | null;
            /**
                * getDirections takes one or more origin node ids, one or more destination node ids
                * and returns a distance, array of directives, and an array of nodes that define the
                * path to take.
                *
                * The returned directives array defines nodes, vortexes, and locations along the path
                * along with text directions.
                *
                * @param originIds array - of one or more node ids
                * @param destinationNodeIds array - of onr or more node ids
                * @param accessible boolean - optional, if true directions will only take accessible route, defaults to false
                * @param departFrom ILocation - optional, id and name of a location to represent start of journey
                * @param arriveAt ILocation - optional, id and name of a location to represent end of journey
                * @param includedVortexIds set - optional, exclude all the vertexes matching the given IDs
                * @param excludedVortexIds set - optional, exclude all the vertexes matching the given IDs
                */
            getDirections({ originIds, destinationNodeIds, accessible, departFrom, arriveAt, includedVortexIds, excludedVortexIds, simplify, }: {
                    originIds: string[];
                    includedVortexIds?: Set<string>;
                    excludedVortexIds?: Set<string>;
                    destinationNodeIds: string[];
                    accessible: boolean;
                    departFrom?: ILocation;
                    arriveAt?: ILocation;
                    simplify?: TSimplifyDirectionsOptions;
            }): IDirectionsResult;
            /**
                * Iterates through each N step node and determines if a direct line to the next M step node intersects any polygons.
                * If it doesn't, remove all steps between the two.
                */
            simplifySteps(steps: Edge[], geometryEdges: TCoordinate[][], bufferRadius: number): Edge[];
    }
    export default Navigator;
}

declare module '@mappedin/mappedin-js/navigator/Directive' {
    import ILocation from '@mappedin/mappedin-js/navigator/interfaces/ILocation';
    import IMap from '@mappedin/mappedin-js/navigator/interfaces/IMap';
    import INode from '@mappedin/mappedin-js/navigator/interfaces/INode';
    export enum ACTION_TYPE {
        DEPARTURE = "Departure",
        TAKEVORTEX = "TakeVortex",
        EXITVORTEX = "ExitVortex",
        TURN = "Turn",
        ARRIVAL = "Arrival"
    }
    export enum BEARING_TYPE {
        STRAIGHT = "Straight",
        RIGHT = "Right",
        SLIGHTRIGHT = "SlightRight",
        LEFT = "Left",
        SLIGHTLEFT = "SlightLeft"
    }
    export enum VORTEX_DIRECTION_TYPE {
        UP = "up",
        DOWN = "down",
        NONE = "none"
    }
    interface IActionDeparture {
        type: ACTION_TYPE.DEPARTURE;
    }
    interface IActionArrival {
        type: ACTION_TYPE.ARRIVAL;
    }
    interface IActionTakeVortex {
        type: ACTION_TYPE.TAKEVORTEX;
        toMap: IMap;
        fromMap: IMap;
        direction: VORTEX_DIRECTION_TYPE;
    }
    interface IActionExitVortex {
        type: ACTION_TYPE.EXITVORTEX;
        toMap: IMap;
        fromMap: IMap;
    }
    interface IActionTurn {
        type: ACTION_TYPE.TURN;
        bearing: BEARING_TYPE;
        referencePosition?: string;
    }
    export type IAction = IActionArrival | IActionDeparture | IActionTurn | IActionTakeVortex | IActionExitVortex;
    class Directive {
        node?: INode;
        instruction: string;
        action?: IAction;
        atLocation?: ILocation;
        type?: BEARING_TYPE;
        distance: number;
        constructor({ origin, action, distance, atLocation, instruction, }: {
            origin?: INode;
            action?: IAction;
            distance?: number;
            atLocation?: ILocation;
            instruction?: string;
        });
    }
    export default Directive;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/FlatLabelsController' {
    import { TAddFlatLabelOptions, TFlatLabelAllLocationsOptions, TFlatLabelAppearance, ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { FlatLabel } from '@mappedin/mappedin-js/renderer/internal';
    import { MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    export type FlatLabelRenderObject = TAddFlatLabelOptions & {
        polygon: MappedinPolygon;
        text: string;
        shortText?: string;
        stateText?: string;
        distance?: number;
        showLabelWhenImagePresent?: boolean;
    };
    class FlatLabelsController {
        #private;
        core: ICore;
        constructor(core: ICore);
        flatLabels: {
            [key in MappedinPolygon['id']]: FlatLabel;
        };
        labeledPolygons: {};
        labelAllLocations(options?: TFlatLabelAllLocationsOptions): FlatLabel[];
        labelPolygon(polygonOrPolygonId: MappedinPolygon | MappedinPolygon['id'], text: string, options?: TAddFlatLabelOptions): FlatLabel;
        removeLabel(polygonOrPolygonId: MappedinPolygon | MappedinPolygon['id']): void;
        setAppearance(polygon: MappedinPolygon, appearance: TFlatLabelAppearance): void;
        setHoverColorForAll(color: string): void;
        removeAllLabels(): void;
    }
    export default FlatLabelsController;
}

declare module '@mappedin/mappedin-js/renderer/internal/object3D.destroy' {
    export default Object3D;
}

declare module '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.Tile' {
    import { Texture, Mesh, MeshBasicMaterial } from 'three';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { MappedinCoordinate, MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import { TileManager } from '@mappedin/mappedin-js/renderer/internal/outdoor-context/Mappedin.TileManager';
    export class Tile {
        #private;
        center: MappedinCoordinate;
        zoomLevel: number;
        mesh: Mesh;
        material: MeshBasicMaterial;
        texture: Texture;
        cache: {
            tileXY?: {
                tileX: number;
                tileY: number;
            };
            tileBoundingBoxInLatLon?: number[];
        };
        get tileXY(): {
            tileX: number;
            tileY: number;
        };
        get tileBoundingBoxInLatLon(): number[];
        constructor(center: MappedinCoordinate, zoomLevel: number, tileManager: TileManager, core: ICore, currentAbortController: AbortController);
        rendered: boolean;
        discardTexture(): void;
        applyTexture(): void;
        render(metersPerTile: number, referenceMap: MappedinMap): Mesh;
    }
}

declare module '@mappedin/mappedin-js/renderer/private/Core.interface' {
    import { Color, Vector2, Vector3, Mesh } from 'three';
    import type { TPadding, TGetPolygonsAtCoordinateOptions, TMapViewOptions, TileManager, BillboardManager, StackedMapsController, SmartCollisionEngine, OutdoorViewController, LayerController } from '@mappedin/mappedin-js/renderer/internal';
    import { BlueDotController, CameraController, STATE, MappedinMap, Mappedin, MappedinCoordinate, MappedinPolygon, MappedinNode, changeListenerFn, RENDER, INTERNAL_EVENT_PAYLOAD, INTERNAL_EVENT, TaskScheduler, SceneManager, PubSub, FlatLabel, MapObject, PathsController, FloatingLabelsController, FlatLabelsController, PolygonColorsController, MarkersController, PolygonInteractionController, TooltipsController, PolygonStatesController, PolygonImagesController, ThreeDMarkersController, ExportController, EventSystem } from '@mappedin/mappedin-js/renderer/internal';
    import Tween, { Easing } from '@tweenjs/tween.js';
    import WatermarkController from '@mappedin/mappedin-js/renderer/private/controllers/WatermarkController';
    import PolygonHoverColorsController from '@mappedin/mappedin-js/renderer/private/controllers/PolygonHoverColorsController';
    import { E_MAP_CHANGED_REASON } from '@mappedin/mappedin-js/renderer/MapView.enums';
    export type TFocusOptionsLegacy = {
            /**
                * An array of Nodes to focus in on
                */
            nodes?: (MappedinNode | MappedinNode['id'])[];
            /**
                * An array of Polygons to focus on. It's the center of the bounds of all Polygons, designed to fit everything into view.
                */
            polygons?: (MappedinPolygon | MappedinPolygon['id'])[];
            /**
                * The duration (in ms) the focus animation should last for.
                * @defaultValue `100`
                */
            duration?: number;
            /**
                * Whether to zoom the camera in or out, or just pan it.
                * @defaultValue `true`
                */
            changeZoom?: boolean;
            /**
                * The animation curve to use for zooming in. Uses the animateCamera one by default.
                */
            curve?: typeof Easing;
            /**
                * Camera tilt between 0 (top-down) to 1 (from the side)
                */
            tilt?: number;
            /**
                * Rotation in degrees
                */
            rotation?: number;
            /**
                * You can overide the {{#crossLink "MapView/focusZoomFactor:property"}}{{/crossLink}} for a specific {{#crossLink "MapView/focusOn:method"}}{{/crossLink}} call, rather than globally, if you like.
                */
            focusZoomFactor?: number;
            /**
                * Sets a floor for how close you can zoom in on the scene. If it's lower than mapView.controls.minZoom, it's ignored.
                * @defaultValue: 0
                */
            minZoom?: number;
            maxZoom?: number;
            /**
                * Whether {@link Camera.minZoom} and {@link Camera.maxZoom} should be recalculated during the focusing animation.
                */
            updateZoomLimits?: boolean;
            padding?: TPadding;
            points?: any[];
            boundingBox?: any;
            callback: () => void;
            cancelledCallback?: () => void;
    };
    /**
        * Ben Liu, 2023/03/29
        *
        * This causes the generation of the index.d.ts file to break entirely for some reason.
        *
        * TODO: Figure out why
        */
    export interface ICore extends PubSub<INTERNAL_EVENT_PAYLOAD, INTERNAL_EVENT> {
            /**
                * Controllers
                */
            eventSystem: EventSystem;
            floatingLabels: FloatingLabelsController;
            flatLabels: FlatLabelsController;
            paths: PathsController;
            polygonColors: PolygonColorsController;
            polygonHoverColors: PolygonHoverColorsController;
            polygonInteraction: PolygonInteractionController;
            polygonStates: PolygonStatesController;
            polygonImages: PolygonImagesController;
            markers: MarkersController;
            tooltips: TooltipsController;
            threeDMarkers: ThreeDMarkersController;
            blueDot: BlueDotController;
            camera: CameraController;
            tileManager: TileManager;
            billboardManager: BillboardManager;
            stackedMaps: StackedMapsController;
            outdoorViewController?: OutdoorViewController;
            exportController: ExportController;
            watermark: WatermarkController;
            layerController: LayerController;
            state: STATE;
            options: TMapViewOptions & {
                    onDataLoaded?: (data: Mappedin) => void;
                    onFirstMapLoaded?: (data: Mappedin) => void;
            };
            currentPath?: MappedinNode[];
            referenceMap: MappedinMap;
            taskScheduler: TaskScheduler;
            sceneManager: SceneManager | undefined;
            loadOptions?: TMapViewOptions['loadOptions'];
            imageFlippingEnabled: boolean;
            imageFlippingCache: Record<any, any>;
            cachedPadding: TPadding;
            getCameraFrameForPoints: any;
            polygonMeshesById: Record<string, Mesh>;
            textLabelsByPolygonId: Record<string, FlatLabel>;
            renderer: any;
            scene: any;
            cameraParameters: Vector2;
            resolution: Vector2;
            determineNewLabelSize: any;
            visibleMapsInCurrentScene: MappedinMap[];
            visibleLayersInCurrentScene: {
                    [mapId: string]: MappedinPolygon['layer'][];
            };
            visibleMapObjectsInCurrentScene: MapObject[];
            mapSetInProgress: Promise<undefined>;
            mapSetResolved: (...args: any[]) => any;
            on<EVENT_NAME extends keyof INTERNAL_EVENT_PAYLOAD>(eventName: EVENT_NAME, fn: (payload: INTERNAL_EVENT_PAYLOAD[EVENT_NAME] extends {
                    data: null;
            } ? INTERNAL_EVENT_PAYLOAD[EVENT_NAME]['data'] : INTERNAL_EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            off<EVENT_NAME extends keyof INTERNAL_EVENT_PAYLOAD>(eventName: EVENT_NAME, fn: changeListenerFn<INTERNAL_EVENT_PAYLOAD[EVENT_NAME]>): void;
            publish<EVENT_NAME extends keyof INTERNAL_EVENT_PAYLOAD>(eventName: EVENT_NAME, payload?: INTERNAL_EVENT_PAYLOAD[EVENT_NAME]): void;
            /**
                * Manual camera controls for MapView. Generally you should be using the functions on MapView like {{#crossLink "MapView/focusOn:method"}}{{/crossLink}},
                * but if you have some cool animations in mind, you can do it with the {{#crossLink "CameraControls"}}{{/crossLink}}.
                * Some of the functions don't do anything in 2D.
                *
                */
            controls: any;
            /**
                * The Venue data this MapView is using.
                *
                * @property venue {MappedinVenue}
                * @final
                */
            readonly venue: Mappedin;
            /**
                * The div MapView is using.
                *
                * @property container {Div}
                * @final
                */
            readonly container: HTMLElement;
            /**
                * The ID of the Map currently being displayed.
                *
                */
            readonly currentMap: string | null;
            /**
                * Change this factor to influence how much the camera zooms in on a {@link IMapView3D.focusOn} call.
                *
                * @property focusZoomFactor {Integer}
                * @default 3
                */
            focusZoomFactor: number;
            /**
                * Returns the value you should call {@link CameraControls.setZoom} on to fit the Polygon exactly.
                *
                * @return The zoom level that will fit the Polygon
                */
            getZoomLevelForPolygon(props: {
                    /**
                        * The Polygon or Polygon ID to get the zoom level for
                        */
                    polygonOrPolygonId: MappedinPolygon | string;
            }): number;
            /**
                * Returns the value you should call {@link CameraControls.setZoom} on to fit the {@link IMapView3D.currentMap} exactly.
                *
                * @return The zoom level that will fit the {@link IMapView3D.currentMap}.
                */
            getZoomLevelForCurrentMap(): number;
            /**
                * Returns the angle that points to north, in radians, from the default orientation.
                *
                * @return The angle to north from the default orientation, in radians.
                */
            getNorth(): number;
            /**
                * Takes an element on the DOM and rotates it such that the top is pointing north. It will rotate with the camera, staying locked
                * on north. If you would like to align it do a different direction, or a different side of the element, pass in an offset. This
                * is how you would do a compass rose.
                *
                * This will modify your element's transform.
                *
                * @param element The element on the page to rotate.
                * @param offset The amount to offset the rotation by, in radians.
                *
                */
            lockNorth(element: HTMLElement, offset?: number): void;
            /**
                * Stops the MapView from trying to rotate your element with the camera. Do this if you remove the element, or want to stop it from rotating.
                * @param element The node to stop rotating. It won't reset the transform, just leave it as is.
                */
            unlockNorth(element: HTMLElement): void;
            /**
                * Returns all polygons that contain the specified MappedinCoordinate.
                *
                * @param coordinate The MappedinCoordinate to check
                * @param hoverableMeshChildren
                * @param options {@link TGetPolygonsAtCoordinateOptions}
                */
            getPolygonsAtScreenCoordinate(x: number, y: number, options?: TGetPolygonsAtCoordinateOptions): MappedinPolygon[];
            /**
                * Returns all polygons at the specified screen coordinate.
                *
                * @param coordinate The Vector2 coordinate to check
                * @param hoverableMeshChildren
                * @param options {@link TGetPolygonsAtCoordinateOptions}
                */
            getPolygonsAtCoordinate(coordinate: MappedinCoordinate, options?: TGetPolygonsAtCoordinateOptions): MappedinPolygon[];
            currentInteractionEvent: INTERNAL_EVENT | undefined;
            interactivePolygons: Record<string, boolean>;
            /**
                * An object containing polygon ids and their hover colors.
                */
            polygonHoverColorsById: Record<string, Color>;
            highlightedPolygons: Record<string, string>;
            /**
                * An object containing all outlined polygons.
                */
            outlinedPolygons: Map<string, MappedinPolygon>;
            cameraPlane: any;
            getPositionLatLon(lat: number, lon: number, map?: MappedinMap | string | null): Vector3;
            currentScale: number;
            getPositionPolygon(polygon: MappedinPolygon | string): Vector3;
            /**
                * Takes an x/y pair in Mappedin coordinate space and gives you a Vector3 in scene space
                * @param nodeOrCoordinate a node or coordinate
                */
            convertTo3DMapPosition(nodeOrCoordinate: MappedinCoordinate | MappedinNode): Vector3;
            /**
                * Converts a Vector-like object into a MappedinCoordinate for a map.
                * @param position an object with x and y, like a Vector3
                * @param mapClass An optional map; otherwise, the current map will be used.
                */
            convert3DMapPositionToCoordinate(position: {
                    x: number;
                    y: number;
            }, mapClass?: MappedinMap): MappedinCoordinate;
            /**
                * Converts a 2D x,y screen position into a 3D MappedinCoordinate using projection
                */
            convertScreenCoordinateToMapCoordinate(x: number, y: number, map: MappedinMap): MappedinCoordinate;
            setPadding(padding: {
                    top: number;
                    left: number;
                    bottom: number;
                    right: number;
            }): void;
            smartCollisionEngine: SmartCollisionEngine;
            mapObjects: Map<MappedinMap['id'], MapObject>;
            /**
                * The scene only renders when something has changed. This should be something a 3rd party developer doesn't need to worry about,
                * but if you are doing something weird, or have your own special tween for something, you will want to call this function.
                * You can call it as often as you want, it just sets a flag that we need to render again, and renders a few frames if we weren't already doing that.
                * Ignored in 2D.
                */
            tryRendering(renderMode?: RENDER): void;
            setMapReason?: E_MAP_CHANGED_REASON;
            setMap(mapOrMapId: MappedinMap | string): Promise<null>;
            setMapWithReason(mapOrMapId: MappedinMap | string, context: E_MAP_CHANGED_REASON): Promise<null>;
            getPositionNode(node: MappedinNode): Vector3;
            cameraObject: any;
            setBackgroundColor(color: string, alpha?: number): void;
            mapManager: any;
            focusOn(focusOptions: TFocusOptionsLegacy): Tween;
            canvasWidth: number;
            canvasHeight: number;
            setState(state: STATE): Promise<void>;
            getNearestNodeByScreenCoordinate(x: number, y: number, mapOrMapId?: MappedinMap | MappedinMap['id']): MappedinNode;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/json-scene-loader' {
    import { Element } from '@mappedin/mappedin-js/renderer/internal';
    import DefaultAssetManager from '@mappedin/mappedin-js/renderer/internal/Mappedin.AssetManager';
    import { MappedinMap, MappedinPolygon } from '@mappedin/mappedin-js/renderer';
    import { MAP_RENDER_MODE } from '@mappedin/mappedin-js/renderer/MapView.enums';
    class JSONSceneLoader {
        defaultExtrudeSettings: {
            amount: number;
            bevelEnabled: boolean;
        };
        materials: {};
        scale: number;
        assetManager: DefaultAssetManager;
        setAssetManager<T extends DefaultAssetManager>(am: T): void;
        overlayHeight: number;
        /**
        Takes in either an object containing polygons and generates a 3D scene based
        on it, or a string URL to fetch those polygons from.
         **/
        load(polygons: string | MappedinPolygon[], mapClass: MappedinMap, mapLoadingStrategy?: MAP_RENDER_MODE): Promise<{
            container: any;
            elements: (Element | null)[];
            visibleLayers: Set<unknown>;
        }>;
        _build(polygons: MappedinPolygon[], mapClass: MappedinMap, mapLoadingStrategy?: MAP_RENDER_MODE): Promise<{
            container: any;
            elements: (Element | null)[];
            visibleLayers: Set<unknown>;
        }>;
    }
    const _default: JSONSceneLoader;
    export default _default;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.RenderTasks' {
    /**
      * Tasks that can be submitted to the renderer. The `STATIC_AND_ANIMATED` task
      * is equivalent to a full re-render.
      */
    enum RENDER {
        ANIMATED = "animated",
        ALWAYS_ON_TOP = "always_on_top",
        ALL = "all",
        TWEEN = "tween",
        COMPOSITE = "composite"
    }
    export default RENDER;
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.TaskScheduler' {
    /**
        * A function that can be submitted to the Task Scheduler to run each frame for
        * some provided number of frames. A single update can be repeatedly submitted;
        * if the number of frames left on the update is less than `frameCount`, it will
        * be reset to `frameCount`.
        *
        * @class FrameUpdate
        * @private
        */
    export class FrameUpdate {
            /**
                * Create a new frame update that can be submitted to a scheduler.
                * 	@constructor
                *	@param [options] {Object} Options for the update
                *	@param [options.callback] {function}
                *		The actual function to run every time this update is scheduled for
                *		a frame.
                *	@param [options.frameCount=1] {number}
                *		How many frames this update should run for when it's submitted to
                *		a scheduler
                *	@param [options.ordering=0] {number}
                *		An ordering value that's used to determine the order in which
                *		frame updates will be run within a frame; larger numbers will
                *		be run first
                *	@param [options.supersededBy=[]] {[FrameUpdate]}
                *		If this update is scheduled to run in a frame, but another update in
                *		the provided list is also scheduled to run on that frame, then
                *		this update will not be run.
                *	@param [options.name=undefined] {string}
                *		If provided, an arbitrary name for logging purposes.
                *	@param [options.userdata] {Any}
                *		Arbitrary data that you can store along with this update.
                */
            constructor(options: {
                    callback: (...args: any[]) => any;
                    frameCount?: number;
                    ordering?: number;
                    supersededBy?: Set<any>;
                    name: string;
                    userdata?: Record<string, any>;
            });
            _callback: (...args: any[]) => any;
            _frameCount: number;
            _ordering: number;
            _supersededBy: Set<any>;
            name: string;
            _remainingFrameCount: number;
            _lastFrameTime: number;
            userdata?: Record<string, any>;
            /**
                * Return the amount of time that this frame update took to execute during
                * its most recent execution, in milliseconds. If called during this frame
                * update, the value returned will be for the previous invocation. If called
                * before this frame update has been executed at least once, the returned
                * value is unspecified.
                *
                * @method lastFrameTime
                * @return {number} the previous frame time, in milliseconds
                */
            getLastFrameTime(): number;
    }
    /**
        * A task that can be submitted to the Task Scheduler to be run every time
        * there is a frame update with spare time in the frame.
        *
        * @class FrameTask
        * @private
        */
    export class FrameTask {
            /**
                * Create a new frame task that can be submitted to a scheduler.
                * 	@constructor
                *	@param [options] {Object} Options for the task
                *	@param [options.callback] {function}
                *		The actual function to run when this task is scheduled.
                *	@param [options.group=null] {FrameTaskGroup}
                *		If provided, a group to which this task will be added when scheduled
                *	@param [options.priority=0] {number}
                *		Tasks with higher priority will be taken from the queue before tasks
                *		with a lower priority.
                *	@param [options.postponeOnAdd=false] {number}
                *		If true, this task will not be run until `resumeTask` is called on the
                *		scheduler.
                *	@param [options.name=undefined] {string}
                *		If provided, an arbitrary name for logging purposes.
                *	@param [options.userdata] {Any}
                *		Arbitrary data that you can store along with this task.
                */
            constructor(options: {
                    userdata?: Record<string, any>;
                    priority?: number;
                    group?: FrameTaskGroup;
                    postponeOnAdd?: number | boolean;
                    name: string;
                    lastFrameTime?: number;
                    callback: (...args: any[]) => any;
            });
            _postponed: number | boolean;
            userdata: Record<string, any>;
            _priority: number;
            _group: FrameTaskGroup | null;
            name: string;
            _lastFrameTime: number;
            _callback: (...args: any[]) => any;
            _complete: boolean;
            _scheduled: boolean;
            _cancelled: boolean;
            /**
                * Return true if this task has been run at least once.
                *
                * @method isComplete
                * @return {boolean}
                */
            isComplete(): boolean;
            /**
                * Return the amount of time that this frame task took to execute,
                * in milliseconds. If this task has not yet completed, the returned value
                * is unspecified.
                *
                * @method lastFrameTime
                * @return {number} the frame time, in milliseconds
                */
            getLastFrameTime(): number;
    }
    /**
        * A group of tasks that must all be completed before the group is considered
        * complete. The tasks will be automatically garbage collected so that references
        * to the task don't linger.
        *
        * @class FrameTaskGroup
        * @private
        */
    export class FrameTaskGroup {
            /**
                * Create a new frame task group.
                *
                * 	@constructor
                *	@param [options] {Object} Options for the task group
                *	@param [options.onComplete] {function}
                *		A callback that will be triggered once every task in this group
                *		has been completed. This callback may schedule a task, and the
                *		scheduler will run that task in the same frame, if there is still
                *		frame time for it.
                *	@param [options.priority=0] {number}
                *		The priority of all the tasks in this group.
                *	@param [options.postponeOnAdd=false] {number}
                *		If true, tasks from this task group will not be run until `resumeTask`
                *		is called on the scheduler with this group.
                *	@param [options.name=undefined] {string}
                *		If provided, an arbitrary name for logging purposes.
                *	@param [options.userdata] {Any}
                *		Arbitrary data that you can store along with this task group.
                */
            constructor(options: {
                    onComplete?: (...args: any[]) => any;
                    priority?: number;
                    userdata: Record<string, any>;
                    postponeOnAdd: number | boolean;
                    name: string;
            });
            _postponed: number | boolean;
            _onComplete: (...args: any[]) => any;
            _priority: number;
            userdata: Record<string, any>;
            name: string;
            _tasks: Set<any>;
            _scheduledTasks: Set<any>;
            _scheduled: boolean;
            _cancelled: boolean;
            /**
                * Return true if every task in this group has been run at least once.
                * @method isComplete
                * @return {boolean}
                */
            isComplete(): boolean;
            /**
                * Return a list of tasks in this group. This will be a copy of the
                * underlying task group, so it's safe to mutate the group while
                * iterating over this array.
                *
                * @method tasks
                * @return {[FrameTask]} list of tasks in this group
                */
            getTasks(): any[];
            /**
                * Empty this task group. This will trivially satisfy `isComplete`.
                *
                * @method clear
                */
            clear(): void;
            /**
                * Return one arbitrary incomplete task from this group, or undefined if
                * there are none.
                *
                * @method _popTask
                * @return {FrameTask} arbitrary scheduled task
                * @private
                */
            _popTask(): any;
    }
    /**
        * A timer for the task scheduler that uses real wall-time to determine if there's
        * enough remaining time in a frame to execute another task.
        *
        * @class RealTimeTimer
        * @private
        */
    export class RealTimeTimer {
            _maxMillisecondsPerFrame: number;
            _time: number;
            /**
                * @constructor
                * @param [options] {Object} Options for the timer
                * @param [options.maxMillisecondsPerFrame]
                *     If the time since the beginning of the frame has been less than
                *     or equal to this value, then another task may be executed
                */
            constructor(options?: {
                    maxMillisecondsPerFrame?: number;
            });
            /**
                * Begin timing a frame.
                *
                * @method beginFrame
                */
            beginFrame(): void;
            /**
                * If true, there is enough time remaining to execute another task.
                *
                * @method hasTimeRemaining
                * @return {boolean}
                */
            hasTimeRemaining(): boolean;
    }
    /**
        * A timer that ticks every time `hasTimeRemaining` is called.
        *
        * @class FixedTimer
        * @private
        */
    export class FixedTimer {
            _ticks: number;
            maxTasksPerFrame: number;
            /**
                * @constructor
                * @param [options] {Object} Options for the timer
                * @param [options.maxTasksPerFrame=5]
                *     The number of tasks that will be exceuted in a single update call.
                *     Can be modified as the `maxTasksPerFrame` property on this boject.
                */
            constructor(options?: {
                    maxTasksPerFrame?: number;
            });
            /**
                * Begin timing a frame.
                *
                * @method beginFrame
                */
            beginFrame(): void;
            /**
                * If true, there is enough time remaining to execute another task.
                *
                * @method hasTimeRemaining
                * @return {boolean}
                */
            hasTimeRemaining(): boolean;
    }
    /**
        * A class that handles scheduling tasks to be performed within the time
        * constraints of frame updates, triggered using `requestAnimationFrame`.
        *
        * Tasks can either be scheduled once per frame (called "frame updates"), or
        * to execute as many times per frame as there is room for after processing
        * all frame updates (called "frame tasks").
        *
        * Posted tasks will always run during the same frame, assuming there's time to
        * process them. However, an update or task that posts an update will not run
        * that update until the next frame.
        *
        * @class TaskScheduler
        * @private
        */
    export class TaskScheduler {
            /**
                * Construct a new `TaskScheduler` with no tasks scheduled.
                *
                * @constructor
                * @param [options] {Object} Options for the scheduler
                * @param [options.timer=new RealTimeTimer()]
                *     Timer that determines whether there is sufficient time left in a frame
                *     to continue executing tasks
                * @param [options.performance=false]
                *     If true, this task scheduler will annotate tasks and frame updates with
                *     performance information.
                */
            constructor(options?: {
                    timer?: RealTimeTimer;
                    performance?: boolean;
            });
            _raf?: (callback: FrameRequestCallback) => number;
            _timer: RealTimeTimer;
            _performance: boolean;
            _scheduledUpdatesByOrdering: Multimap;
            _scheduledTasksByPriority: Multimap;
            _postponedTasks: Set<any>;
            _requestAnimationFrameHandle: number | null;
            _updatesToRunThisFrame: any[];
            _lastFrameTime: number;
            _updatesRunLastFrame: Set<any>;
            /**
                * Empty the task scheduler's queue. All tasks in it will be cancelled.
                *
                * @method clear
                */
            clear(): void;
            /**
                * Destroy this task scheduler and remove all tasks from it.
                *
                * @method destroy
                */
            destroy(): void;
            /**
                * Schedule this task scheduler to execute updates and tasks on the next
                * available animation frame.
                *
                * @method requestAnimationFrame
                */
            requestAnimationFrame(): void;
            /**
                * Run all scheduled updates, and re-schedule another animation frame if any
                * scheduled updates still exist. If any scheduled update specifies
                * `shouldRunTasksAfterCompletion`, this will also run queued tasks until the
                * frame time runs out.
                *
                * @method update
                * @param timestamp {number} the current animation time, as returned from
                * `performance.now()`; will be automatically filled in by
                * `requestAnimationFrame` when it triggers this as a callback
                */
            update(timestamp: number): void;
            /**
                * Execute all tasks that are currently pending, without regard for the
                * available frame time.
                *
                * @method flushTasks
                */
            flushTasks(): void;
            /**
                * Return the amount of time elapsed during the last completed frame update,
                * in milliseconds. This value is unspecified if the task scheduler's
                * `update` method has not yet run or if the scheduler has been cleared.
                * If called during a frame update, this will
                * return the time elapsed during the previous frame update.
                *
                * @method lastFrameTime
                * @return {number} time elapsed during last frame update, in milliseconds
                */
            getLastFrameTime(): number;
            /**
                * Return a set containing every update that was run during the previous
                * frame update. This will be empty if the task scheduler's `update` method
                * has not yet been run or if the scheduler has been cleared.
                */
            getUpdatesRunLastFrame(): Set<any>;
            _executeOneTask(timestamp: number): void;
            /**
                * Schedule an update to be run for the next `update.frameCount` frames. If
                * the update already exists in the scheduler, the update's frame count will
                * be refreshed to `update.frameCount`. This will also schedule an animation
                * frame to begin processing the update.
                *
                * @method scheduleUpdate
                * @param task {FrameUpdate} the update to schedule
                */
            scheduleUpdate(update: FrameUpdate): void;
            /**
                * Schedule a task to be run during a frame update. This will also schedule
                * an animation frame to begin processing the task queue.
                *
                * @method scheduleTask
                * @param task {FrameTask} the task to schedule
                */
            scheduleTask(task: FrameTask): void;
            /**
                * If the given update is in the queue, remove it.
                *
                * @method cancelUpdate
                * @param task {FrameUpdate} the update to cancel
                */
            cancelUpdate(update: FrameUpdate): void;
            /**
                * If the given task or group is in the queue, remove it. Cancelling a
                * completed task is a no-op.
                *
                * Canceling an individual task will also remove it from its task group, if
                * it isn't already complete.
                *
                * @method cancelTask
                * @param task {FrameTask or FrameTaskGroup} the task to cancel
                */
            cancelTask(task: FrameTask | FrameTaskGroup): void;
            /**
                * Set the provided task or group not to run, until it's resumed using `resumeTask`.
                *
                * Tasks that are in a group can't be postponed individually; instead, call
                * `postponeTask` with the entire group.
                *
                * @method postponeTask
                * @param task {FrameTask or FrameTaskGroup} the task to postpone
                */
            postponeTask(task: FrameTask | FrameTaskGroup): void;
            /**
                * Allow a postponed task or task group to resume processing. This will also
                * request an animation frame to allow the resumed task to be processed.
                *
                * Tasks that are in a group can't be resumed individually; instead, call
                * `resumeTask` with the entire group.
                *
                * @method resumeTask
                * @param task {FrameTask or FrameTaskGroup} the task to resume
                */
            resumeTask(task: FrameTask | FrameTaskGroup): void;
            /**
                * Change the priority of the given scheduled task or task group.
                *
                * @method setTaskPriority
                * @param task {FrameTask or FrameTaskGroup} the task whose priority will be changed
                * @param priority {number} the priority to assign the task
                */
            setTaskPriority(task: FrameTask | FrameTaskGroup, priority: number): void;
    }
    /**
        * A map that maps a numeric key to a set of values.
        *
        * For use in the scheduler, we also maintain a sorted list of keys.
        *
        * @class Multimap
        * @private
        */
    class Multimap {
            /**
                * @method constructor
                */
            constructor();
            _map: Map<any, any>;
            _size: number;
            _sortedKeys: any[];
            /**
                * Return true if the set for the given key contains the provided value.
                *
                * @method has
                * @param key {number} the key whose set to check
                * @param value {Any} the value to check
                */
            has(key: number, value: any): any;
            /**
                * Return the list of elements at the given key. Make sure not to modify
                * it, as it will mess up the total element count.
                *
                * @method get
                * @param key {number}
                * @param value {Set(Any)}
                */
            get(key: number): any;
            /**
                * @method insert
                * @param key {number} the key to which another value will be added
                * @param value {Any} the value to add to the key's set
                */
            insert(key: number, value: any): void;
            /**
                * @method delete
                * @param key {number} the key at which the value is stored
                * @param value {Any} the value to delete
                */
            delete(key: number, value: any): void;
            /**
                * Remove and return an arbitrary value from the set at the given key.
                *
                * @method pop
                * @param key {number} the key from which to remove a value
                * @return {Any} arbitrary value from the given key's set, or undefined if
                * the set at the given key is empty.
                */
            pop(key: number): any;
            /**
                * Remove and return an arbitrary value from the set corresponding to
                * the key with the highest numeric value, using the javascript `<`
                * operator.
                *
                * @method popFromMaxKey
                * @return {Any} arbitrary value from the highest key's set, or undefined
                * if the map is empty
                */
            popFromMaxKey(): any;
            /**
                * Return an iterator over every value in this multimap, at every key.
                * Mutating the multimap during iteration will result in undefined
                * behaviour.
                *
                * @method values
                * @return {Iterator} iterator over the values in the map
                */
            values(): {
                    [Symbol.iterator]: () => any;
                    next: () => any;
            };
            /**
                * A list of keys in this set, sorted by numeric value. Not cloned,
                * for efficiency's sake, so please don't mutate it.
                *
                * @method keys
                * @return {[number]} sorted list of numeric keys in the map
                */
            keys(): any[];
            /**
                * The number of elements in this multimap, equal to the sum of the sizes
                * of each key's set of values.
                *
                * @property size {number} number of elements in this multimap
                */
            get size(): number;
    }
    export {};
}

declare module '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.SceneManager' {
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, TCameraAnimationOptions, TFocusOnCameraOptions, TCameraTargets } from '@mappedin/mappedin-js/renderer/internal';
    import { MapObject, MapViewScene } from '@mappedin/mappedin-js/renderer/internal';
    export type TSceneTransitionOptions = {
            /**
                * Map to set as active during the transition. This will decide where the camera will be positioned, as well as which
                * colliders are enabled.
                */
            activeMap?: MappedinMap;
            verticalDistanceBetweenMaps?: number;
            /**
                * Whether to auto focus on the active map or leave the camera where it is.
                * For single building venues, this should look the same way it did with MapManager
                * For multi-building venues, this means the camera will not pan over to where the active map
                * is relative to the world, which may look like broken behavior.
                * @default true
                */
            autoFocusOnActiveMap?: boolean;
            /**
                * Where to focus the camera during transition to Scene. Will focus to fit the map if not provided.
                * Currently, will discard any targets that are not on the active map.
                */
            focusOn?: {
                    targets?: TCameraTargets;
                    options?: TFocusOnCameraOptions & TCameraAnimationOptions;
            };
    };
    class SceneManager {
            core: ICore;
            currentScene: MapViewScene;
            /**
                * MapObjects that have been loaded and positioned in the scene
                */
            processedMapObjects: Set<MapObject>;
            constructor(core: ICore, startingScene: MapViewScene);
            get currentMap(): MappedinMap;
            renderGrid(): void;
            transitionTo(scene: MapViewScene, transitionOptions?: TSceneTransitionOptions): Promise<void>;
    }
    export default SceneManager;
}

declare module '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.DynamicFocusSceneManager' {
    import { MappedinMap, MappedinMapGroup } from '@mappedin/mappedin-js/get-venue';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { MapViewScene, DynamicFocusScene } from '@mappedin/mappedin-js/renderer/internal';
    class DynamicFocusSceneManager {
        dynamicFocusScene: DynamicFocusScene;
        core: ICore;
        constructor(core: ICore, baseMap: MappedinMap);
        panBounds: any;
        mapShouldSetOnUserInteraction: boolean;
        get currentScene(): {
            resize: () => void;
            currentMap: MappedinMap;
            mapObjects: Map<string, import("../../internal/Mappedin.MapObject").default>;
        };
        get currentMap(): MappedinMap;
        setDefaultMapForMapGroup(mapGroup: MappedinMapGroup, map: MappedinMap): void;
        resetDefaultMapForMapGroup(mapGroup: MappedinMapGroup): void;
        determineTargetMap(): void;
        update(): void;
        transitionTo(scene?: MapViewScene): Promise<void>;
    }
    export default DynamicFocusSceneManager;
}

declare module '@mappedin/mappedin-js/get-venue/pub-sub.typed' {
    export class PubSub<EVENT_PAYLOAD, EVENT extends keyof EVENT_PAYLOAD> {
            /**
                * @private
                */
            _subscribers: any;
            /**
                * @private
                */
            publish<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, data?: EVENT_PAYLOAD[EVENT_NAME]): void;
            on<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, fn: (payload: EVENT_PAYLOAD[EVENT_NAME] extends {
                    data: null;
            } ? EVENT_PAYLOAD[EVENT_NAME]['data'] : EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            off<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, fn: (payload: EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            /**
                * @private
                */
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.MapObject' {
    import { Group, Box3, Mesh, MeshLambertMaterial, Object3D, Vector3 } from 'three';
    import { FrameTaskGroup } from '@mappedin/mappedin-js/get-venue/Mappedin.TaskScheduler';
    import { Element, FlippableImage, MappedinMap, TaskScheduler, FlatLabel, SmartTooltip, ICore, InternalFloatingLabel, TCreateThreeDMarkerOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { PubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
    /**
        * Some preset priorities for tasks.
        */
    export const TASK_PRIORITY: {
            VISIBLE_MAP_HIGH: number;
            VISIBLE_MAP_LOW: number;
            VISIBLE_MAP_MARKER: number;
            ASYNC_MAP_HIGH: number;
            ASYNC_MAP_LOW: number;
            ASYNC_MAP_MARKER: number;
            MAP_LOADED: number;
    };
    export const RENDER_ORDER: {
            MAP_ELEMENT: number;
            BUILDING_OUTLINE: number;
            MAP_HOVER: number;
            POLYGON_IMAGE: number;
    };
    export function convertToShortHandInterpolation(interpolation: any[]): any;
    export const SCENE_FROM_LIVE_JSON = false;
    type InterpolationFunctionType = (zoomLevel: number) => any;
    export class LayerGroup {
            mergedObjectsGroup: Group;
            hoverObjectsGroup: Group;
            objectsByMaterials: Map<MeshLambertMaterial, Element[]>;
            hoverableMeshChildren: Mesh;
            _isVisible: boolean;
            needsUpdate: boolean;
            userData: any;
            opacity: number;
            core: ICore;
            mapObject: MapObject;
            name: string;
            layers: string[];
            interpolationFn: InterpolationFunctionType | null;
            opacityInterpolation?: {
                    zoomLevel: number;
                    opacity: number;
            }[] | {
                    inputZoomLevel: number[];
                    outputOpacity: number[];
            };
            set isVisible(value: boolean);
            get isVisible(): boolean;
            constructor(mapObject: MapObject, name: string, layers: string[], visible: boolean);
            dispose(): void;
            setOpacity(opacity: any): void;
    }
    export interface LoadOptions {
            async?: boolean;
            taskScheduler: TaskScheduler;
            mapRenderStrategy?: string;
    }
    interface BoundingBox {
            min: Vector3;
            max: Vector3;
    }
    interface FadeOptions {
            onComplete?: () => void;
            duration: number;
    }
    class MapObject extends PubSub {
            _flippableImagedById: any;
            _started: boolean;
            _loaderPromise: Promise<MapObject>;
            _promiseResolve: (value?: void | PromiseLike<void> | MapObject) => void;
            _showCount: number;
            _taskScheduler: TaskScheduler;
            _highPriorityTasks: FrameTaskGroup;
            _lowPriorityTasks: FrameTaskGroup;
            _markerTasks: FrameTaskGroup;
            _mapLoadedTasks: FrameTaskGroup;
            _visibilityLatch: boolean | null;
            _objLoadedComplete: boolean;
            _hoverableMeshChildren: Mesh[];
            imageMeshesById: Record<string, Mesh>;
            visible: boolean;
            objectsDictionary: Record<string, Mesh>;
            north: number;
            mapScale: number | null;
            object: Object3D;
            labels: Set<InternalFloatingLabel>;
            tooltips: Set<SmartTooltip>;
            markers: Set<unknown>;
            box: Box3;
            textObjects: FlatLabel[];
            labelBatchCreator: null;
            imagesToFlip: (typeof FlippableImage)[];
            seenByCamera: boolean;
            threeJSMarkers: Map<ThreeJSMarkerHandle, {
                    object: Object3D;
            }>;
            core: ICore;
            mapClass: MappedinMap;
            polygonMeshesById: Record<string, Mesh>;
            loadMethod: string;
            loadAsync: boolean;
            id: string;
            mapRenderingStrategy: string;
            needsUpdate: boolean;
            layerGroups: Map<string, LayerGroup>;
            loadedLayerNames: string[];
            loadedElements: Element[];
            boundingBox: BoundingBox | undefined;
            elements: Element[];
            loadMethodUsed: string;
            mapLoaded: any;
            constructor(mapClass: MappedinMap, polygonMeshesById: Record<string, Mesh>, showCount: number, core: ICore, loadOptions: LoadOptions);
            fade(layerGroupName: string | string[], { direction, onComplete, duration }: {
                    direction?: string | undefined;
                    onComplete?: (() => void) | undefined;
                    duration?: number | undefined;
            }): {
                    start: () => Promise<void>;
            };
            /**
                * Fade a layer group or number of layer groups in
                * @param {string|string[]} layerGroupNames
                * @returns
                */
            fadeIn(layerGroupNames?: string | string[], options?: FadeOptions): {
                    start: () => Promise<void>;
            };
            /**
                * Fade a layer group or number of layer groups out
                * @param {string|string[]} layerGroupNames
                * @returns
                */
            fadeOut(layerGroupNames?: string | string[], options?: FadeOptions): {
                    start: () => Promise<void>;
            };
            renderLayerGroup(include?: string[], exclude?: string[]): void;
            processLayers(allLayers: string[], include?: string[], exclude?: string[]): string[];
            processLayerGroup(name?: string, include?: string[], exclude?: string[], visible?: boolean, elements?: Element[], defaultRenderOrder?: number): LayerGroup;
            get hoverableMeshChildren(): Mesh[];
            _objLoadedMerged(object: Object3D): Promise<void>;
            _objLoaded(object: Object3D): void;
            loadPolygonNow(polygonId: string): void;
            _addElementToScene(element: Element): void;
            /** *
            Load the map, if it's not already loaded. Returns the old promise if it's already done, so you can safely call it whenever needed.
    
            If needed, this could be modified to
    
            Returns a Promise that will be Done when the OBJ, MTL and textures have been downloaded, and the objectsDictionary has been generated.
    
             **/
            load(): Promise<MapObject>;
            _dispose(objectToDispose: Object3D): void;
            destroy(): void;
            add(childObjectToAdd: Object3D): void;
            /**
                * Convert lat/lon to local map position vector
                */
            getPositionLatLon(lat: number, lon: number): Vector3;
            /**
                * Previously, each map was centered around 0,0,0 and scaled to fit the map.
                * With scene manager, each map is positioned and scaled relative to the base map/world
                * Since most 3D objects (like blue dot) are added to the map via `getPositionLatLon`, they already
                * have the map's matrix applied, on top of being affected as a child of the map's own transform
                * This method inverts the map's matrix to resolve the double matrix application issue.
                * TODO: investigate a better way to handle this
                */
            addToObject(child: Object3D): void;
            /**
                * Translates objects that are added to the map (such as blue dot), assuming they are added via `getPositionLatLon`,
                * or `convertTo3DMapPosition`, where the map's matrix has already been applied.
                */
            translateChild(child: Object3D, position: Vector3): void;
            getMapScale(): number;
            getNorth(): number;
            enableImageFlipping(polygonId: string, rotation?: number): void;
            disableAllImageFlipping(): void;
            /**
                * Return true if this map has been loaded to the point where it can be
                * manipulated as a complete object. In synchronous mode, this requires all
                * loading tasks to be completed, but in async mode, only high-priority
                * tasks (adding polygons to the world) have to be completed.
                */
            isReady(): boolean;
            /**
                * Return true if this map has been loaded to the point where the only tasks
                * remaining are marker tasks.
                */
            isFullyLoaded(): boolean;
            /**
                * A function that should be called when the map is made visible, in order
                * to kick off its tasks.
                */
            onVisible(): void;
            /**
                * A function that should be called when the map is made invisible, in order
                * to postpone its tasks.
                */
            onInvisible(): void;
            /**
                * Queue a task on this map that will be executed when the high and low
                * priority tasks have been processed.
                */
            addPendingMarkerTask(marker: string, callback: (...args: any[]) => any): void;
            /**
                * Queue a task on this map that must be completed before the map will be
                * considered `isReady` in synchronous loading mode.
                */
            addPendingLowPriorityTask(name: string, callback: (...args: any[]) => any): void;
            /**
                * Queue a task on this map that will be queued when the map is loaded, or
                * immediately if the map has already been loaded.
                */
            addPendingMapLoadedTask(name: string, callback: (...args: any[]) => any): void;
            /**
                * Queue a task on this map that must be completed before the map will be
                * considered `isReady`, and will be evaluated before any low-priority
                * tasks.
                */
            _addPendingHighPriorityTask(name: string, callback: (...args: any[]) => any): void;
            /**
                * Add a ThreeJS marker to this map object. This should be called through
                * the `MapView3D`.
                *
                * @method addThreeJSMarker
                * @param {Object} options
                * @param {Object3D} [options.object] the marker object to add to the scene
                * @param {Vector3} [options.position=null] if provided, sets the object's position on the map
                * @param {Euler} [options.rotation=null] if provided, sets the object's rotation relative to the map
                * @param {Vector3} [options.scale=null] if provided, sets the object's scale relative to the map
                * @return {ThreeJSMarkerHandle} a unique identifier for the marker
                */
            addThreeJSMarker(options: TCreateThreeDMarkerOptions): ThreeJSMarkerHandle;
            /**
                * Remove the given `ThreeJSMarker` from this map.
                *
                * @method removeThreeJSMarker
                * @param {ThreeJSMarkerHandle} markerHandle the marker to remove
                * @return {boolean} true if the marker existed on the map and was removed;
                *		false if the marker does not exist on the map
                */
            removeThreeJSMarker(markerHandle: ThreeJSMarkerHandle): boolean;
            /**
                * Remove all `ThreeJSMarker` from this map.
                *
                * @method removeThreeJSMarker
                */
            _removeThreeJSMarkers(): void;
            removeLabels(): void;
            /**
                * Called when a task group that may be required for map loading completes,
                * to see if all the relevant task groups have been completed.
                */
            _checkIfLoaded(): void;
            /**
                * Called when the root ThreeJS object has been created, and child elements
                * may be added.
                */
            _onRootObjectCreated(): void;
            _popinChildObjects(): void;
    }
    /**
        * A handle to a 3D marker added to a map.
        *
        * @class ThreeJSMarkerHandle
        */
    export class ThreeJSMarkerHandle {
            _deleted: boolean;
            _mapId: string | null;
            _object: Object3D;
            constructor(args: {
                    mapId: string;
                    object: Object3D;
            });
            /**
                * Return the ThreeJS object associated with this marker, so that it
                * can be moved around, scaled, etc.
                *
                * @property {Object3D} object
                */
            get object(): Object3D;
            _destroy(): void;
    }
    export default MapObject;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.CameraLayers' {
    export default CAMERA_LAYER;
    namespace CAMERA_LAYER {
        let STATIC: number;
        let ANIMATED: number;
        let ALWAYS_ON_TOP: number;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.HoverLabel' {
    export default HoverLabel;
    /**
      * @type {any}
      */
    let HoverLabel: any;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider' {
    import SmartCollisionEngine from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollisionEngine';
    import { Rectangle } from '@mappedin/mappedin-js/renderer/internal/quad-tree';
    import { MappedinCoordinate, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    export type TRange = [number, number, number, number];
    type TCustomCollider<T> = ICollider & T;
    export type TColliderStrategyProps = {
        x: number;
        y: number;
        totalHeight?: number;
        totalWidth?: number;
    };
    export type TColliderStrategy = {
        name: string;
        getBoundingBox: (TColliderStrategyProps: any) => TRange;
        onStrategySelected: (collider: TCustomCollider<any>) => void;
    };
    export type TGetBoundingBox = ({ x, y }: {
        x: any;
        y: any;
    }) => [number, number, number, number];
    export type TDimensions = {
        width: number;
        height: number;
    };
    export enum EColliderAction {
        'initial' = 0,
        'show' = 1,
        'hide' = 2
    }
    export type TColliderPosition = {
        nodeOrCoordinate: MappedinNode | MappedinCoordinate;
        height?: number;
    };
    export type TBoudingBox = [string, Rectangle, (collider: TCustomCollider<any>) => void, TGetBoundingBox][];
    export interface ICollider {
        dimensions: TDimensions;
        screenPosition: [number, number];
        getBoundingBoxForCurrentStrategy?: TGetBoundingBox;
        options?: Record<string, unknown>;
        mapId: string;
        visible: boolean;
        rank: number;
        id: string;
        layer: string;
        _bboxes?: TBoudingBox;
        offscreen?: boolean;
        setAction: (action: EColliderAction) => void;
        action?: EColliderAction;
        position: TColliderPosition | null;
        __engine?: SmartCollisionEngine;
        enable: () => void;
        disable: () => void;
        enabled: boolean;
        promote?: () => void;
        demote?: () => void;
        setPriority?: (rank: number) => void;
        resetPriority?: () => void;
        readonly strategies: TColliderStrategy[];
        colliderDidMount?: () => void;
        colliderDidNotFindAHome?: () => void;
        colliderDidGoOffscreen?: () => void;
        colliderDidGoOutsideGrid?: () => void;
        colliderDidUpdateVisiblity?: () => void;
        colliderDidUpdatePosition?: (prop: [x: number, y: number]) => void;
    }
    class BaseCollider implements ICollider {
        __engine?: SmartCollisionEngine;
        _initialRank: number;
        screenPosition: [number, number];
        enabled: boolean;
        options: any;
        mapId: string;
        id: string;
        action: EColliderAction;
        getBoundingBoxForCurrentStrategy: undefined | TGetBoundingBox;
        rank: number;
        visible: boolean;
        offscreen: boolean;
        position: TColliderPosition | null;
        dimensions: {
            width: number;
            height: number;
        };
        layer: string;
        _bboxes: TBoudingBox | undefined;
        flipIfNeeded(): void;
        constructor(options: any);
        setPosition(position: MappedinNode | MappedinCoordinate, updateCollisionEngine?: boolean): void;
        setPriority(rank: any): void;
        setAction(action: any): void;
        resetPriority(): void;
        promote(): void;
        demote(): void;
        get strategies(): TColliderStrategy[];
        removeSelf(): void;
        enable(): void;
        disable(): void;
        colliderDidUpdatePosition(pos: any): void;
        colliderDidNotFindAHome(): void;
        colliderDidMount(): void;
        colliderDidUpdateVisiblity(): void;
    }
    export default BaseCollider;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.HTMLCollider' {
    import BaseCollider, { ICollider } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider';
    export type TRange = [number, number, number, number];
    export type TDimensions = {
        width: number;
        height: number;
    };
    export interface IHTMLCollider extends ICollider {
        containerEl: any;
        contentEl: any;
    }
    class HTMLCollider extends BaseCollider {
        #private;
        contentEl: null | HTMLDivElement;
        containerEl: null | HTMLDivElement;
        ready: boolean;
        removeSelf(): void;
        enable(): void;
        disable(): void;
        colliderDidGoOffscreen(): void;
        colliderDidNotFindAHome(): void;
        colliderDidUpdatePosition(pos: any): void;
        updateDimensions(): void;
        /**
          * @internal
          */
        updateDimensionsImmediately(): void;
        colliderDidMount(): void;
        colliderDidUpdateVisiblity(): void;
    }
    export default HTMLCollider;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.Marker' {
    import './Mappedin.Marker.scss';
    import { COLLISION_RANKING_TIERS, HTMLCollider, MARKER_ANCHOR } from '@mappedin/mappedin-js/renderer/internal';
    import type { TColliderStrategy, IHTMLCollider, TColliderPosition } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @hidden
        * @internal
        */
    export type TSmartMarkerOptions = {
            contentHtml?: string;
            position: TColliderPosition;
            mapId: string;
            id?: string;
            anchor?: MARKER_ANCHOR;
            collisionRank?: COLLISION_RANKING_TIERS;
            layer?: string;
    };
    type TTooltipStyle = {
            top?: string;
            left?: string;
    };
    /**
        * @hidden
        * @internal
        */
    class InternalMarker extends HTMLCollider implements IHTMLCollider {
            _el: Element | null;
            style: TTooltipStyle;
            polygon: any;
            position: TColliderPosition;
            constructor(options: TSmartMarkerOptions);
            get strategies(): TColliderStrategy[];
            colliderDidMount(): void;
            setAction(action: any): void;
            colliderDidNotFindAHome(): void;
            colliderDidUpdatePosition(pos: any): void;
            colliderDidGoOffscreen(): void;
            colliderDidUpdateVisiblity(): void;
    }
    export default InternalMarker;
}

declare module '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.Scene' {
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, SceneManager, TSceneTransitionOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { MapObject } from '@mappedin/mappedin-js/renderer/internal';
    class MapViewScene {
            #private;
            maps: MappedinMap[];
            mapObjectsArray: MapObject[];
            transitionOptions: TSceneTransitionOptions | undefined;
            object: any;
            currentMap: MappedinMap;
            mapObjects: Map<MappedinMap['id'], MapObject>;
            constructor(maps: MappedinMap[], core: ICore);
            get mapObjectsByMapGroup(): {
                    [x: string]: MapObject[];
            };
            /**
                * Determine each maps position and rotation relative to the refernce map
                */
            determineMapPositionAndRotation(map: MappedinMap): {
                    position: any[];
                    scale: number[];
                    rotation: number[];
            };
            /**
                * Convenience function to initialize scene (for stacked maps)
                */
            prepare(sceneManager: SceneManager, transitionOptions?: TSceneTransitionOptions): Promise<void>;
            /**
                * Override this method if works need to be done when the window is resized
                */
            resize(): void;
            focusOnCurrentMap(transitionOptions?: TSceneTransitionOptions, isStartingScene?: boolean): Promise<unknown>;
            preRender(transitionOptions?: TSceneTransitionOptions): Promise<Promise<MapObject>[]>;
            /**
                * Override this method when unmounting a scene
                */
            unmount(): void;
            postRender(): void;
    }
    export default MapViewScene;
}

declare module '@mappedin/mappedin-js/renderer/private/scene-manager/MapView.StackScene' {
    import { Box3, BoxHelper, Mesh } from 'three';
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, SceneManager, TSceneTransitionOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { MapObject, MapViewScene } from '@mappedin/mappedin-js/renderer/internal';
    export const DEFAULT_VERTICAL_DISTANCE_BETWEEN_MAPS = 50;
    class MapViewStackScene extends MapViewScene {
        #private;
        containerBoxHelper: Box3;
        viewportBox: Box3;
        currentMapWrapperMesh: Mesh;
        currentMapWrapperBoxHelper: BoxHelper;
        viewportMesh: Mesh;
        stackContainerMesh: Mesh;
        currentMinTilt: number;
        constructor(maps: MappedinMap[], core: ICore);
        lockControls(): void;
        unlockControls(): void;
        createStackBoundingBox(): void;
        focusOnStackBox(transitionOptions?: TSceneTransitionOptions): Promise<unknown>;
        unmount(): void;
        computeMapZ(mo: MapObject, index: number, transitionOptions?: TSceneTransitionOptions): number;
        prepare(sceneManager: SceneManager, transitionOptions?: TSceneTransitionOptions): Promise<void>;
        postRender(): void;
        expandMaps(mapObjects: MapObject[], transitionOptions: TSceneTransitionOptions): {
            start: () => Promise<void[]>;
        };
        contractMaps(currentMapObject?: MapObject): {
            start: () => Promise<void[]>;
        };
        scrollToMap: (map: MappedinMap, duration?: number) => Promise<unknown>;
        updateFrame: (val: any) => void;
        resize(): void;
        labels: Map<MapObject, Mesh>;
        createMapLabels: () => void;
        updateLabels: () => void;
        destroyLabels: () => void;
    }
    export default MapViewStackScene;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.Element' {
    import { MeshLambertMaterial, Mesh, ExtrudeGeometry, Group } from 'three';
    import { PubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
    import { AssetManager, MappedinMap, MappedinPolygon } from '@mappedin/mappedin-js/renderer';
    import { MAP_RENDER_MODE } from '@mappedin/mappedin-js/renderer/MapView.enums';
    class Element extends PubSub {
        polygon: MappedinPolygon;
        mapClass: MappedinMap;
        container: Group;
        visible: boolean;
        mode: MAP_RENDER_MODE;
        static defaultMaterial: MeshLambertMaterial;
        static hoverMeshMaterial: any;
        assetManager: AssetManager;
        imageVisible: boolean;
        labelVisible: boolean;
        boundingBox: {
            min: {
                x: number;
                y: number;
                z: number;
            };
            max: {
                x: number;
                y: number;
                z: number;
            };
        };
        polygonHeight: number;
        geometry: ExtrudeGeometry;
        mesh: Mesh;
        material: MeshLambertMaterial | MeshLambertMaterial[];
        labelMesh?: Mesh;
        imageMesh?: Mesh;
        sortScore: number | null;
        static materials: {
            [key in string]: MeshLambertMaterial | MeshLambertMaterial[];
        };
        static defaultExtrudeSettings: {
            depth: number;
            bevelEnabled: boolean;
        };
        static scale: number;
        static overlayHeight: number;
        static getDefaultMaterial(): MeshLambertMaterial;
        static getWeightedCenter(vertices: any): any;
        static getBoundingCentre(vertices: any): {
            x: number;
            y: number;
        };
        static _makeFromCoords(className: any, coords: any, mapClass: any): any;
        static _setPolygonDefaults(poly: any): any;
        constructor(poly: MappedinPolygon, mapClass: MappedinMap, container: Group, assetManager: any, mapLoadingStrategy?: MAP_RENDER_MODE);
        getBoundingBox(): {
            min: {
                x: number;
                y: number;
                z: number;
            };
            max: {
                x: number;
                y: number;
                z: number;
            };
        };
        load(): Promise<this>;
        _addLabel(poly: MappedinPolygon, mapClass: MappedinMap): void;
        static imagesLoadingInProgress: Map<string, Promise<[Texture, MeshLambertMaterial]>>;
        _addImage(polygon: MappedinPolygon, mapClass: MappedinMap): void;
        static _normalizeColor(color: any): number;
        static _getMaterial(color: string, opacity: number, map: MappedinMap['id']): any;
        static _clip(vertices: any, offset: any): any;
    }
    export default Element;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.FlippableImage' {
    export default FlippableImage;
    /**
      * @type {any}
      */
    let FlippableImage: any;
}

declare module '@mappedin/mappedin-js/renderer/private/scene-manager/dynamic-focus-scene-manager/building' {
    import { Object3D } from 'three';
    import { MappedinMap, MappedinMapGroup } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, MapObject } from '@mappedin/mappedin-js/renderer/internal';
    import { LayerGroup } from '@mappedin/mappedin-js/renderer/internal/Mappedin.MapObject';
    class Building {
            layerGroup: LayerGroup;
            mapGroup: MappedinMapGroup;
            defaultMap: MappedinMap;
            activeMap?: MappedinMap;
            visibleMap?: MappedinMap;
            readonly startingMap: MappedinMap;
            baseMap: MappedinMap;
            object: Object3D;
            mapObjects: MapObject[];
            constructor(core: ICore, mapGroup: MappedinMapGroup, layerGroup: LayerGroup, startingMap: MappedinMap, baseMap: MappedinMap);
            loading: boolean;
            activeMapOpacity: number;
            buildingOpacity: number;
            animating: boolean;
            /**
                * Set the opacity of the currently active map in the building
                */
            setActiveMapOpacity(opacity: number, duration?: number): void;
            tweenActiveMapOpacity(targetOpacity: number, duration?: number): void;
            /**
                * Set the opacity of the building outline
                */
            setBuildingOutlineOpacity(opacity: number): void;
            get activeMapObject(): MapObject | undefined;
            get visibleMapObject(): MapObject | undefined;
            get defaultMapObject(): MapObject;
            get baseMapObject(): MapObject;
            state: string;
            /**
                * The building is in view, so we should have the correct map loaded and ready to be displayed
                */
            onInView(): void;
            /**
                * The building is out of view, so we can safely reset the map to the default map
                */
            onOutOfView(): void;
            setMap(map: MappedinMap): Promise<void>;
    }
    export default Building;
}

declare module '@mappedin/mappedin-js/renderer/private/scene-manager/dynamic-focus-scene-manager/dynamic-focus-scene' {
    import { Object3D, Box3, Raycaster } from 'three';
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import type { ICore, MapObject } from '@mappedin/mappedin-js/renderer/internal';
    import { Building } from '@mappedin/mappedin-js/renderer/internal';
    import { LayerGroup } from '@mappedin/mappedin-js/renderer/internal/Mappedin.MapObject';
    class DynamicFocusScene {
        buildings: Building[];
        object: Object3D;
        panBounds: Box3;
        loaded: boolean;
        baseMapObject: MapObject;
        raycasters: Raycaster[];
        baseMap: MappedinMap;
        options: {
            indoorsFullyVisibleZoomLevel: number;
            buildingFullyVisibleZoomLevel: number;
            setMapAtZoomLevel: number;
            baseMap: MappedinMap;
            preloadDefaultMaps: boolean;
            keepLayersActiveOnBaseMap: string[];
        };
        constructor(core: ICore, baseMap: MappedinMap);
        resize: () => void;
        buildRaycasters(): void;
        updateRaycasters(): void;
        /**
          * Expand the pan bounds to the base map bounds
          * In dynamic focus mode, these bounds will be retained no matter which building or map is visible
          */
        expandToBaseMapBounds(): void;
        load(): Promise<void>;
        currentMap: MappedinMap;
        setMap(map: MappedinMap, fromUserInteraction?: boolean): Promise<void>;
        buildingVisiblityMap: Map<Building, boolean>;
        buildingsByPolygonId: Map<string, Building>;
        get buildingsInView(): Building[];
        determineBuildingsInView(): Building[];
        /** Given zoom and camera position, let's figure out the currently active map */
        determineCurrentMap(): MappedinMap | undefined;
        setOpacities(buildingsInView?: Building[], centerMap?: MappedinMap): void;
        createBuildings(buildingGeometries: [string, LayerGroup][]): Promise<Building[]>;
    }
    export default DynamicFocusScene;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/PolygonColorsController' {
    import { MappedinPolygon } from '@mappedin/mappedin-js/renderer';
    import { ICore } from '@mappedin/mappedin-js/renderer/private/Core.interface';
    type SetPolygonColorParam = [MappedinPolygon | string, string, {
        highlighted?: boolean;
        visible?: boolean;
    }?];
    class PolygonColorsController {
        #private;
        constructor(core: ICore);
        /**
          * Given a polygon, set it to a specific color.
          * @param color - color value in hex
          */
        setPolygonColor(...params: SetPolygonColorParam): Promise<void>;
        clearPolygonColor(polygon: any): void;
        clearAllPolygonColors(): void;
        setPolygonOutlineColor(color: string): void;
        addPolygonOutline(polygon: MappedinPolygon): void;
        removePolygonOutline(polygon: MappedinPolygon): void;
        removeAllPolygonOutlines(): void;
    }
    export default PolygonColorsController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/PolygonHoverColorsController' {
    import { MappedinPolygon } from '@mappedin/mappedin-js/renderer';
    import { ICore } from '@mappedin/mappedin-js/renderer/private/Core.interface';
    class PolygonHoverColorsController {
        #private;
        constructor(core: ICore);
        setPolygonHoverColor(polygonOrPolygonId: MappedinPolygon | string, color: string): void;
        clearPolygonHoverColor(polygonOrPolygonId: MappedinPolygon | string): void;
        clearAllPolygonHoverColors(): void;
    }
    export default PolygonHoverColorsController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/PolygonInteractionController' {
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    class PolygonInteractionController {
        #private;
        constructor(core: ICore);
        addInteractivePolygon(polygon: any): void;
        addInteractivePolygonsForAllLocations(options: any): void;
        removeInteractivePolygon(polygon: any): void;
        removeAllInteractivePolygons(): void;
    }
    export default PolygonInteractionController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/TooltipsController' {
    import { ICore, TCreateTooltipCommonOptions, TCreateTooltipOptions, SmartTooltip } from '@mappedin/mappedin-js/renderer/internal';
    import { MappedinNode, MappedinCoordinate } from '@mappedin/mappedin-js/get-venue';
    class TooltipsController {
            #private;
            constructor(core: ICore);
            createTooltip(nodeOrCoordinate: MappedinNode | MappedinCoordinate, 
            /**
                * Html that will be placed inside a wrapper with its own styling in the tooltip
                */
            contentHtml: string, options?: TCreateTooltipOptions): SmartTooltip;
            createCustomTooltip(nodeOrCoordinate: MappedinNode | MappedinCoordinate, 
            /**
                * Html that will be displayed by the tooltip without any added styling
                */
            contentHtml: string, selector: string, options?: TCreateTooltipCommonOptions): SmartTooltip;
            /**
                * Removes a {@link Tooltip} you have added previously.
                *
                * @param tooltip {Tooltip} A Tooltip that has previously been returned from {@link IMapView3D.createTooltip}.
                */
            removeTooltip(tooltipOrTooltipId: SmartTooltip | SmartTooltip['id']): void;
            removeAllTooltips(): void;
    }
    export default TooltipsController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/PolygonStatesController' {
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    class PolygonStatesController {
        #private;
        constructor(core: ICore);
        updateClosedStateForPolygon(options: any): void;
        openAllPolygons(): void;
        destroy(): void;
    }
    export default PolygonStatesController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/PolygonImagesController' {
    import { MappedinPolygon } from '@mappedin/mappedin-js/get-venue';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    class PolygonImagesController {
        #private;
        constructor(core: ICore);
        enableImageFlippingForAllLocations(options: any): void;
        enableImageFlippingForPolygon(polygon: MappedinPolygon): void;
        disableImageFlippingForAllPolygons(): void;
    }
    export default PolygonImagesController;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/ThreeDMarkersController' {
    import { ThreeJSMarkerHandle } from '@mappedin/mappedin-js/renderer/internal';
    import type { ICore, TCreateThreeDMarkerOptions } from '@mappedin/mappedin-js/renderer/internal';
    class ThreeDMarkersController {
        #private;
        constructor(core: ICore);
        createThreeJSMarker(options: TCreateThreeDMarkerOptions): ThreeJSMarkerHandle;
        removeThreeJSMarker(markerHandle: ThreeJSMarkerHandle): boolean;
        removeAllThreeJSMarkers(): void;
    }
    export default ThreeDMarkersController;
}

declare module '@mappedin/mappedin-js/renderer/internal/blue-dot-manager' {
    export const DEFAULT_MIN_RADIUS: 8;
    export const DEFAULT_MAX_RADIUS: 65;
    export const DEFAULT_RADIUS_UPDATE_INTERVAL: 3;
    export default BlueDotManager;
    /**
        * @private
        * An interface for showing a position (typically the user's position) on a 3D map.
        *
        * @class BlueDotManager
        */
    class BlueDotManager extends PubSub {
            /**
                * @param [options.minRadius] The ring around the blue dot will only be drawn if `options.radius` is greater than or equal to this value, in metres. Must be >= 0.
                * @param [options.radiusUpdateInterval] The width of radius update steps, in metres. For example, if interval is 3 and assume `minRadius` is 8, then the radius will be updated on 8, 11, 14, 17, etc. Must be >= 0.
                */
            constructor({ threeDMarkerLayer, core, minRadius, maxRadius, radiusUpdateInterval, radiusTweenOptions, }?: {
                    threeDMarkerLayer: any;
                    core: any;
                    minRadius?: number | undefined;
                    maxRadius?: number | undefined;
                    radiusUpdateInterval?: number | undefined;
                    radiusTweenOptions?: {
                            duration: number;
                            easing: any;
                    } | undefined;
            });
            threeDMarkerLayer: any;
            core: any;
            minRadius: number;
            maxRadius: number;
            radiusUpdateInterval: number;
            radiusTweenOptions: {
                    duration: number;
                    easing: any;
            };
            /**
                * The current state of the 3D blue dots. Null if blue dot is not currently being displayed.
                */
            state: any;
            /**
                * The last known radius that was set, in the original metres units.
                */
            prevRadius: any;
            /**
                * Used to animate the blue dot accuracy ring size change.
                */
            radiusTween: any;
            /**
                * The last known bearing angle that was set, in degrees.
                */
            prevBearing: any;
            /**
                * Used to animate the blue dot bearing angle change.
                */
            bearingTween: any;
            /**
            The current zoom level, so new dots can be added at the proper size.
             */
            currentX: any;
            /**
                * Calculates the new radius given the candidate value as well as other relevant parameters. @see constructor
                * @param {number} candidateRadius
                */
            computeNewRadius(candidateRadius: number): number;
            updateBlueDotSize(): void;
            setBlueDotSizeFromZoom(cameraX: any): void;
            /**
                * Update the state of the 3D blue dot, creating blue dots if necessary.
                *
                * @method update
                * @param {Object} options
                * @param {Coordinates} options.coordinates The lat-long coordinates for the blue dot. Follows the Coordinates Web API.
                * @param {string} [options.mode]
                * @param {number} [options.bearing] The angle in degrees around the blue dot at which the bearing indicator should appear.
                * @param {number} options.radius The outer radius of the blue dot, in metres.
                * @param {string} [options.mapId] The primary map of the blue dot. Specify this or options.map.
                * @param {MapObject} [options.map] The primary map of the blue dot. Specify this or options.mapId.
                * @param {number} [options.minRadius] The ring around the blue dot will only be drawn if `options.radius` is greater than or equal to this value. Must be >= 0.
                * @param {number} [options.minRadiusDelta] The minimum amount by which the radius must change in order for the blue dot ring radius to be updated. Must be >= 0.
                * @param {string} [options.baseColor] Base Color of Active Blue Dot that we use to interpolate into other variants
                */
            update(options: {
                    coordinates: Coordinates;
                    mode?: string | undefined;
                    bearing?: number | undefined;
                    radius: number;
                    mapId?: string | undefined;
                    map?: any;
                    minRadius?: number | undefined;
                    minRadiusDelta?: number | undefined;
                    baseColor?: string | undefined;
            }): void;
            blueDots: {
                    handle: any;
                    radius: any;
                    dotObject: any;
                    bearing: any;
            }[] | undefined;
            positionTween: any;
            currentPositionLatLon: any;
            animateBearing(fromBearing: any, toBearing: any): void;
            setBearing(bearing: any): void;
            getBlueDotForMap(mapOrMapId: any): any;
            /**
                * Remove the 3D blue dot from the maps.
                *
                * @method cleanup
                */
            cleanup(): void;
    }
    import { PubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/EventSystem' {
    import { Object3D, Color } from 'three';
    import type { ICore, MappedinPolygon, Collider } from '@mappedin/mappedin-js/renderer/internal';
    import { BlueDotManager, Path } from '@mappedin/mappedin-js/renderer/internal';
    class EventSystem {
        core: ICore;
        blueDotManager?: BlueDotManager;
        rendererDomElement: any;
        currentHover: string | null;
        hoverLabel: any;
        hoverColor: Color;
        options: {
            disableHover: boolean;
        };
        constructor(core: ICore);
        setBlueDotManager: (blueDotManager: any) => void;
        touchCount: number;
        zoomOut(): void;
        zoomIn(event: any): void;
        onPointerMove: (event: any) => void;
        onPointerUp: (event: any) => void;
        /**
          * We've confirmed that a map click has occured, so handle that here
          */
        handleMapClick(event: any): void;
        onPointerDown: (event: any) => void;
        incrementTouches: (event: any) => void;
        decrementTouches: (event: any) => void;
        clearMouse: () => void;
        getMousePos: (event: any) => {
            x: any;
            y: any;
        };
        getScaledMousePos: (event: any) => {
            x: number;
            y: number;
        };
        cursorPos: {
            x: number;
            y: number;
        };
        mouse: {
            x: number;
            y: number;
        };
        mouseDownStart: {
            time: number;
            clientX: number;
            clientY: number;
        };
        scaledCursorPos: {
            x: number;
            y: number;
        };
        hasTouched: boolean;
        calculateMouseCoordinates: (event: any) => void;
        getMouseRayIntersects: (objects: Object3D | Object3D[]) => any;
        detectCollidersUnderMouse: () => Collider[];
        detectPolygonsUnderMouse: () => string[];
        detectPathsUnderMouse: () => Path[];
        detectWatermarkUnderMouse: () => boolean;
        detectMapsUnderMouse: () => any;
        getMouseMapPosition: () => {
            x: number;
            y: number;
        };
        checkMouseIntersectsBlueDot: () => boolean;
        doHoverEffect: () => void;
        onPolygonHoverOut: (polygonId: string) => false | undefined;
        onPolygonHoverOver: (polygon: MappedinPolygon | string) => false | undefined;
        setHoverColor: (color: string) => void;
        destroy(): void;
    }
    export default EventSystem;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.ClosedPolygonManager' {
    export default ClosedPolygonManager;
    class ClosedPolygonManager {
        constructor({ scene, getPolygonMeshFromId, tryRendering }: {
            scene: any;
            getPolygonMeshFromId: any;
            tryRendering: any;
        });
        scene: any;
        getPolygonMeshFromId: any;
        tryRendering: any;
        stencilSheet: any;
        polygonsMarkedAsClosed: {};
        onMapChanged(map: any): void;
        currentMap: any;
        dispose(): void;
        markPolygonAsClosed(polygonId: any): void;
        markPolygonAsOpen(polygonId: any): void;
        markAllPolygonsAsOpen(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.BinaryAssetManager' {
    import { Texture } from 'three';
    /**
        * This asset manager is used when loading a venue from MVF.
        * It requires the MVF's image and model binaries to be passed in upon instantiation.
        * This allows delaying the creation of Blobs and Object URLs until loading the map.
        */
    export default class BinaryAssetManager {
            textureLoader: any;
            data: Map<string, Uint8Array>;
            constructor(data: Map<string, Uint8Array>);
            /**
                * This should never be used- map polygons are never sent in binary format.
                */
            loadMapPolygons(): Promise<void>;
            loadImage(url: string): Promise<Texture>;
    }
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollisionEngine' {
    import './Mappedin.SmartCollisionEngine.scss';
    import { TRange, TColliderPosition } from '@mappedin/mappedin-js/renderer/internal/Mappedin.SmartCollider';
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    import { Rectangle, QuadTree } from '@mappedin/mappedin-js/renderer/internal/quad-tree';
    import { InternalFloatingLabel, InternalMarker, SmartTooltip } from '@mappedin/mappedin-js/renderer/internal';
    export type Collider = InternalMarker | SmartTooltip | InternalFloatingLabel;
    export type ColliderQuadTree = QuadTree<{
            collider: Collider;
    }>;
    export const COLLIDER_STRATEGY_LOW_PRIORITY = "LOW_PRIORITY";
    class SmartCollisionEngine {
            #private;
            colliderCanvas: HTMLCanvasElement;
            debugCanvas: HTMLCanvasElement;
            colliderCanvasContext: CanvasRenderingContext2D;
            debugCanvasContext: CanvasRenderingContext2D;
            collisionEngineContainerEl: HTMLDivElement;
            stepsX: any;
            stepsY: any;
            totalWidth: any;
            totalHeight: any;
            project: any;
            colliders: Map<string, Collider>;
            offscreenRanges: TRange[];
            get sortedColliders(): Collider[];
            initialized: boolean;
            core: ICore;
            screen: Rectangle;
            debouncedUpdate: () => void;
            constructor(core: ICore);
            updateStartEvents: {
                    [key: string]: boolean;
            };
            updateEndEvents: {
                    [key: string]: boolean;
            };
            beginUpdate(): void;
            init: (container: HTMLDivElement, projectFn: (position: TColliderPosition, mapId: MappedinMap['id']) => {
                    x: number;
                    y: number;
            }) => void;
            handleBeginUpdate: (args: any) => void;
            handleEndUpdate: (args: any) => void;
            qtree: QuadTree;
            interactiveCollidersQTree: ColliderQuadTree;
            recompute: () => void;
            draw: () => void;
            reposition: () => void;
            add: (colliderId: string, collider: Collider) => void;
            remove: (colliderId: string) => void;
            updateMap: (colliderId: string, from: string, to: string) => void;
            update: () => void;
            resize: (container: any) => void;
            destroy: () => void;
    }
    /**
        * Determines collider visibility based on the current mapId, dynamicFocus options, and visibleLayersInCurrentScene.
        * 1. If the collider is on the base map and has a layer included in keepLayersActiveOnBaseMap, show it.
        * 2. Otherwise, if the collider is on the current map and has a layer included in visibleLayersInCurrentScene, show it.
        * 3. Otherwise, if the collider has no layer and is on the current map, show it.
        * 4. Otherwise, hide it.
        */
    export function isColliderVisible(collider: Collider, mapId: string, dynamicFocusOptions: ICore['options']['dynamicFocus'], visibleLayersInCurrentScene: ICore['visibleLayersInCurrentScene']): boolean;
    /**
        * Determines if a collider should be shown on the base map, even when the dynamicFocus has setMap to a different map.
        * Collider must have an assigned layer included in the keepLayersActiveOnBaseMap option & matching mapId to the base map.
        */
    export function shouldKeepActiveOnBaseMap(collider: Collider, dynamicFocusOptions: ICore['options']['dynamicFocus']): boolean;
    export default SmartCollisionEngine;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/BillboardManager' {
    import { Object3D } from 'three';
    class BillboardManager {
        orbit: Object3D;
        billboards: Map<string, [Object3D, string]>;
        constructor(orbit: Object3D);
        add(object: Object3D, axis?: string): void;
        remove(sprite: Object3D): void;
        update(): void;
        destroy(): void;
    }
    export default BillboardManager;
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/StackedMapsController' {
    import { MappedinDirections, MappedinMap, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    import { STACKED_MAPS_STATE, MapViewScene, MapViewStackScene, CAMERA_EASING_MODE } from '@mappedin/mappedin-js/renderer/internal';
    import type { ICore, TCameraTransform } from '@mappedin/mappedin-js/renderer/internal';
    enum ACTION {
        enable = "enable",
        disable = "disable",
        showOverview = "showOverview",
        zoomInToMap = "zoomInToMap",
        scrollToMap = "scrollToMap"
    }
    type TTargetTransitionFunction = ((options: TParams) => () => Promise<void>) | ((options: TParams) => void);
    type TParams = {
        map: MappedinMap;
    } | {
        directions: MappedinDirections | MappedinDirections[];
    } | {
        stackScene: MapViewStackScene;
        directions: MappedinDirections | MappedinDirections[];
        verticalDistanceBetweenMaps?: number;
    } | {
        stackScene: MapViewStackScene;
        verticalDistanceBetweenMaps?: number;
        map: MappedinMap;
        nodes: MappedinNode[];
    } | {
        stackScene: MapViewStackScene;
        map: MappedinMap;
        nodes: MappedinNode[];
        rotation: number;
        cameraTransform?: TCameraTransform;
        verticalDistanceBetweenMaps?: number;
    };
    type TActionFn = [STACKED_MAPS_STATE, TTargetTransitionFunction[]];
    type TState = {
        [stateName in STACKED_MAPS_STATE]?: {
            actions: {
                [actionName in ACTION]?: TActionFn;
            };
        };
    };
    export type TInternalTransitionOptions = {
        animate?: boolean;
    };
    class StackedMapsController {
        #private;
        options: {
            verticalDistanceBetweenMaps?: number;
        };
        enabled: boolean;
        stackScene: MapViewStackScene;
        directions: MappedinDirections | MappedinDirections[];
        constructor(core: ICore);
        needsUpdate: boolean;
        currentState: STACKED_MAPS_STATE;
        mapsInJourney: MappedinMap[];
        getZoomIntoMapOptions: (params: TParams) => (MapViewScene | {
            activeMap: MappedinMap;
            focusOn: {
                targets: {
                    nodes: MappedinNode[];
                };
                options: {
                    zoom?: number | undefined;
                    tilt: number;
                    rotation: number;
                    position?: MappedinNode | import("../../internal").MappedinCoordinate | undefined;
                    easing: CAMERA_EASING_MODE;
                };
            };
        })[] | undefined;
        getDisableOptions: (params: TParams) => (MapViewScene | {
            activeMap: MappedinMap;
        })[] | undefined;
        getShowOverviewOptions: (params: TParams) => (MapViewStackScene | {
            activeMap: MappedinMap;
            focusOn: {
                options: {
                    tilt: number;
                    duration: number;
                };
            };
            verticalDistanceBetweenMaps: number | undefined;
        })[] | undefined;
        getScrollToMapOptions: (params: TParams) => (MapViewStackScene | {
            focusOn: {
                targets: {
                    nodes: MappedinNode[];
                };
                options: {
                    tilt: number;
                    easing: CAMERA_EASING_MODE;
                };
            };
            activeMap: MappedinMap;
        })[] | undefined;
        getEnableOptions: (params: TParams) => void;
        getShowOverviewTransition: (options: any, inTransit?: boolean) => () => Promise<void>;
        getZoomInToMapTransition: (options: any) => () => Promise<void>;
        getScrollToMapTransition: (options: any, inTransit?: boolean) => () => Promise<void>;
        getDisableTransition: (options: any) => () => Promise<void>;
        getEnableTransition: () => () => void;
        states: TState;
        transition(currentState: STACKED_MAPS_STATE, actionName: ACTION): TTargetTransitionFunction[] | void;
        exec(transitions: TTargetTransitionFunction[] | void, params: TParams): Promise<void>;
        disable: () => Promise<void>;
        enable: (opts?: {
            verticalDistanceBetweenMaps?: number;
        }) => Promise<void>;
        get nodesInJourney(): MappedinNode[];
        showOverview: () => Promise<void>;
        scrollToMap: (map: MappedinMap) => Promise<void>;
        zoomInToMap: (map: MappedinMap, cameraTransform?: TCameraTransform) => Promise<void>;
        get currentMap(): MappedinMap;
    }
    export default StackedMapsController;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.Renderer' {
    /**
        * A class that controls the rendering resources for a canvas output.
        *
        * @class Renderer
        * @private
        */
    export default class Renderer {
            /**
                * 	@constructor
                *	@param renderOptions {Object} Options for rendering
                *	@param [options.multiBufferRendering=false] {boolean}
                *		Whether to use a multi-buffer renderer
                *	@param [options.alpha=true] {boolean}
                *		If true, will allow for a semi-transparent background
                *	@param [options.antialias=false] {boolean}
                *		If true, will attempt to antialias rendering if supported
                *	@param [options.backgroundColor='#ffffff'] {Color | string}
                *		The color that will be displayed behind the scene
                *	@param [options.backgroundAlpha=1.0] {number}
                *		The opacity of the background color
                * 	@param [options.xRayPath=true] {boolean}
                * 		If true, journey path will be visible through other objects
                *	@param [options.onWebGLContextCreationError=null] {function}
                *		A callback that will be triggered if WebGL context creation fails
                *	@param [options.onWebGLContextLost=null] {function}
                *		A callback that will be triggered if the WebGL context is killed
                *	@param [options.onWebGLContextRestored=null] {function}
                *		A callback that will be triggered when three.js reacquires a WebGL context
                *	@param [options.onWebGLRendererError=null] {function}
                *		A callback that will be triggered if the renderer throws an error
                */
            constructor(renderOptions: any);
            contextLost: boolean;
            implementation: SingleBufferRenderer | MultiBufferRenderer;
            onWebGLContextCreationError: any;
            onWebGLContextLost: any;
            onWebGLContextRestored: any;
            webGLContextCreationErrorListener: any;
            webGLContextLostListener: any;
            webGLContextRestoredListener: any;
            shouldConsiderAlpha: any;
            antialias: any;
            /**
                * Dispose of any resources and connections allocated by the renderer.
                *
                * @method destroy
                */
            destroy(): void;
            /**
                * Render the scene to the provided framebuffer. A null framebuffer will
                * render to the default canvas.
                *
                * @method render
                * @param renderTask {RENDER}
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            render(renderTask: RENDER, renderTarget: null, scene: Scene, sceneCamera: Camera): void;
            /**
                * Return the maximum supported anisotropy of this renderer.
                *
                * @method getMaxAnisotropy
                * @return {number}
                */
            getMaxAnisotropy(): number;
            /**
                * Return the size of the renderer's target.
                *
                * @method getBufferSize
                * @return {Vector2}
                */
            getBufferSize(): Vector2;
            /**
                * Return the WebGL context associated with this renderer, to ensure
                * other objects that use WebGL will put their textures in the same
                * context.
                *
                * @method context
                * @return {WebGLRenderingContext} context used by this renderer
                */
            getContext(): WebGLRenderingContext;
            /**
                * Preload a texture, I think. Not actually sure what this does. TODO.
                *
                * @method preloadTexture
                * @param texture {Texture}
                */
            preloadTexture(texture: Texture): void;
            /**
                * Set the renderer and all its internal buffers to the provided width and
                * height in pixels.
                *
                * @method setBufferSize
                * @param width {number}
                * @param height {number}
                */
            setBufferSize(width: number, height: number): void;
            get backgroundColor(): any;
            get backgroundAlpha(): number | undefined;
            /**
                * Set the color and opacity that will be drawn behind the scene.
                *
                * @method setBackgroundColor
                * @param color {Color}
                * @param alpha {number}
                */
            setBackgroundColor(color: Color, alpha?: number): void;
            /**
                * Assign an outdoor context to this renderer, which will be included as
                * part of the `STATIC` rendering pass.
                *
                * @method setMapboxOutdoorContext
                * @param {MapboxOutdoorContext} mapboxOutdoorContext context to draw
                */
            setMapboxOutdoorContext(mapboxOutdoorContext: MapboxOutdoorContext): void;
            domElement(): any;
            isAvailable(): boolean;
            disposeOfRenderLists(): void;
            reportWebGlContextCreationError(e: any): void;
            reportWebGlContextLost(e: any): void;
            reportWebGLContextRestored(): void;
            /**
                * Sometimes we have to use WebGL 1 because of a regression in Chrome
                * due to some unknown performance bug in Apple's OpenGL Angle backend on MacBook+Radeon GPU.
                * The official recommendation is to turn on Metal backed ANGLE in your Chrome's about:flags.
                * We can't force our users to do it, so we have to support both WebGL 1 & WebGL 2
                * See: https://bugs.chromium.org/p/chromium/issues/detail?id=1245448
                * The Method returns target WebGL version based on the hardware configuration.
                *
                * @param context WebGL context
                * @returns {1|2} WebGL version
                */
            getTargetWebGLVersion(context: any): 1 | 2;
            /**
                *
                * @param options
                * @returns {SingleBufferRenderer|MultiBufferRenderer}
                */
            getRenderer(options: any): SingleBufferRenderer | MultiBufferRenderer;
    }
    /**
        * A legacy renderer that renders all the elements in the scene to a single
        * buffer. Does not support things like transparent paths behind polygons
        * natively, but can potentially fake it.
        *
        * 2019/07/10 Terence Dickson
        * Generally has worse performance under average loads compared to the
        * multi-buffer renderer, as the multi-buffer renderer can avoid re-rendering
        * the entire map if only animated elements on the map have changed.
        *
        * @class SingleBufferRenderer
        * @private
        */
    class SingleBufferRenderer {
            constructor(renderOptions: any, targetWebGLVersion?: number);
            options: any;
            core: any;
            renderer: any;
            effectComposer: EffectComposer | undefined;
            backgroundColor: any;
            backgroundAlpha: number;
            mapboxOutdoorContext: any;
            /**
                * Dispose of the renderer.
                */
            destroy(): void;
            /**
                * Re-render the scene. This ignores the `renderTask` argument, as all
                * re-renders in the single-buffer renderer are full re-renders.
                *
                * @method render
                * @param renderTask {RENDER}
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            render(renderTask: RENDER, renderTarget: null, scene: Scene, sceneCamera: Camera): void;
            /**
                * Set the size of the renderer.
                *
                * @method setBufferSize
                * @param width {number}
                * @param height {number}
                */
            setBufferSize(width: number, height: number): void;
            width: number | undefined;
            height: number | undefined;
            /**
                * Set the color and opacity that will be drawn behind the scene.
                *
                * @method setBackgroundColor
                * @param color {Color}
                * @param alpha {number}
                */
            setBackgroundColor(color: Color, alpha: number): void;
            /**
                * Assign an outdoor context to this renderer.
                *
                * @method setMapboxOutdoorContext
                * @param {MapboxOutdoorContext} mapboxOutdoorContext context to draw
                */
            setMapboxOutdoorContext(mapboxOutdoorContext: MapboxOutdoorContext): void;
    }
    /**
        * Our new renderer that renders static elements to one buffer and animated
        * elements to another buffer, allowing only the latter buffer to be
        * re-rendered if the camera isn't moving. There is also a third buffer that
        * can be used to render elements that must appear always on top.
        *
        * Does not yet support antialiasing.
        *
        * 2019/07/10 Terence Dickson
        * Generally has better performance under average loads compared to the
        * single-buffer renderer, but does not work on IE 11.
        *
        * @class MultiBufferRenderer
        * @private
        */
    export class MultiBufferRenderer {
            constructor(renderOptions: any, targetWebGLVersion?: number);
            effectComposer: null;
            outdoorsVisible: boolean;
            options: any;
            renderer: any;
            core: any;
            journeyOpacity: number | undefined;
            backgroundColor: any;
            backgroundAlpha: number | undefined;
            mapboxOutdoorContext: any;
            staticSceneRenderTarget: any;
            animatedSceneRenderTarget: any;
            alwaysOnTopSceneRenderTarget: any;
            outdoorViewRenderTarget: any;
            populateRenderTarget(renderTarget: any): void;
            createOutdoorViewTexture(): void;
            outdoorViewTexture: any;
            outdoorViewTextureProps: any;
            setupEffectComposer(): void;
            setOutdoorViewTexture(texture: any): void;
            /**
                * Dispose of the renderer and its buffers.
                */
            destroy(): void;
            /**
                * Render the provided scene using the given camera, re-rendering only
                * the animated parts.
                *
                * @method renderAnimated
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            renderAnimated(renderTarget: null, scene: Scene, sceneCamera: Camera): void;
            /**
                * Render the provided scene using the given camera, re-rendering only
                * the parts that should appear on top of all other elements.
                *
                * @method renderAlwaysOnTop
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            renderAlwaysOnTop(renderTarget: null, scene: Scene, sceneCamera: Camera): void;
            /**
                * Render all of the scene layers, then combine them.
                *
                * @method renderAll
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            renderAll(renderTarget: null, scene: Scene, sceneCamera: Camera): void;
            /**
                * Re-render the scene, depending on which parts of the scene have been
                * invalidated.
                *
                * @method render
                * @param renderTarget {null or WebGLRenderTarget}
                * @param scene {Scene}
                * @param sceneCamera {Camera}
                */
            render(renderTask: any, renderTarget: null, scene: Scene, sceneCamera: Camera): void;
            /**
                * Set the size of the renderer, composer, and all its internal buffers.
                *
                * @method setBufferSize
                * @param width {number}
                * @param height {number}
                */
            setBufferSize(width: number, height: number): void;
            width: number | undefined;
            height: number | undefined;
            /**
                * Set the color and opacity that will be drawn behind the scene.
                *
                * @method setBackgroundColor
                * @param color {Color}
                * @param alpha {number}
                */
            setBackgroundColor(color: Color, alpha: number): void;
            /**
                * Assign an outdoor context to this renderer.
                *
                * @method setMapboxOutdoorContext
                * @param {MapboxOutdoorContext} mapboxOutdoorContext context to draw
                */
            setMapboxOutdoorContext(mapboxOutdoorContext: MapboxOutdoorContext): void;
            setOutdoorViewController(outdoorViewController: any): void;
            outdoorViewController: any;
            toggleOutdoorViewVisiblity(visible: any): void;
    }
    import { RENDER } from '@mappedin/mappedin-js/renderer/internal';
    import { EffectComposer } from '@mappedin/mappedin-js/renderer/internal/Mappedin.EffectComposer';
    export {};
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/JourneyController' {
    import type Directive from '@mappedin/mappedin-js/navigator/Directive';
    import type INode from '@mappedin/mappedin-js/navigator/interfaces/INode';
    import { Path } from '@mappedin/mappedin-js/renderer/internal';
    import type { ICore, TJourneyOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { MappedinDirections } from '@mappedin/mappedin-js/get-venue';
    export type TMappedinDirections = {
        distance: number;
        path: INode[];
        instructions: Directive[];
    };
    /**
      *
      * The Journey class represents a journey from point A to point B. This includes any intermediate connections, such as stairs or elevators.
      * The idea is to provide a higher level API with enough hooks to customize the experience. Also, to ensure only 1 journey is allowed at once.
      * This version does not support "stacked view" - but that can be added in the future
      *
      * @internal
      */
    export class JourneyController {
        #private;
        distance: number;
        accessible: boolean;
        activeDirections: MappedinDirections;
        get isMultiFloor(): boolean;
        get mapsInJourney(): (import("../../internal").MappedinMap | undefined)[];
        get buildingsInJourney(): {};
        get mapIdsInvolvedInJourney(): string[];
        constructor(directions: MappedinDirections | MappedinDirections[], options: TJourneyOptions | undefined, core: ICore);
        setStep: (step: any) => void;
        setStepByPath: (path: Path) => void;
        static instance: JourneyController | null;
        static create(directions: MappedinDirections | MappedinDirections[], options: any, core: ICore): JourneyController;
        destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/ExportController' {
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    /**
        * @hidden
        */
    export type TGLTFExportOptions = {
            onlyVisible?: boolean;
            binary?: boolean;
            scale?: number;
    };
    /**
        * API for exporting the scene.
        *
        * @hidden
        */
    export default class ExportController {
            #private;
            core: ICore;
            constructor(core: ICore);
            /**
                * Exports the current scene as a GLTF file.
                */
            getCurrentSceneGLTF(userOptions: TGLTFExportOptions): Promise<Blob>;
    }
}

declare module '@mappedin/mappedin-js/renderer/private/controllers/LayerController' {
    import type { ICore } from '@mappedin/mappedin-js/renderer/private/Core.interface';
    import { MappedinMap } from '@mappedin/mappedin-js/get-venue';
    import { Feature, FeatureCollection, GeoJsonProperties, Polygon } from 'geojson';
    class LayerController {
            #private;
            constructor(core: ICore);
            /**
                * Show a set of layers on the current map, and hide all other layers. This also hides any colliders associated with the hidden layers.
                */
            showLayers(layers: string[]): void;
            getAllLayersForMap(map: MappedinMap): Promise<{
                    [layerName: string]: boolean;
            }>;
            /**
                * Return a list of all visible layers for a map, this will NOT trigger a map load, and is mainly used internally
                * which is why its synchronous
                */
            getVisibleLayersForLoadedMap(map: MappedinMap): string[] | undefined;
            addGeoJSONLayer(layerName: string, featureOrFeatureCollection: Feature<Polygon, GeoJsonProperties | null> | FeatureCollection<Polygon, GeoJsonProperties | null>): Promise<void>;
    }
    export default LayerController;
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.BlueDot/Mappedin.BlueDot.ui' {
    import { IBlueDotCore, BlueDotManager } from '@mappedin/mappedin-js/renderer/internal';
    import { IPubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
    import type { ICore } from '@mappedin/mappedin-js/renderer/internal';
    enum ZOOM_CONDITION {
        EXPIRED = 0,
        IN_PROGRESS = 1,
        COMPLETED = 2
    }
    export interface IBlueDotUI extends IPubSub {
        blueDotTooltips: any[];
        setBlueDotPosition: () => void;
        showBlueDotBearing: () => void;
        addGhostMarkers: () => void;
        addLocationUncertainMarkersAndTooltips: () => void;
        addBlueDotMarker: () => void;
        removeTooltips: () => void;
        removeBlueDot: () => void;
        centerBlueDot: () => void;
        endFollowing: () => void;
        zoomCondition: ZOOM_CONDITION;
        isFollowing: boolean;
        useRotationMode: boolean;
    }
    type TBlueDotUIProps = {
        core: ICore;
        blueDotManager: BlueDotManager;
        controller: IBlueDotCore;
        data: any;
    };
    const BlueDotUI: ({ core, blueDotManager, controller }: TBlueDotUIProps) => IBlueDotUI;
    export default BlueDotUI;
}

declare module '@mappedin/mappedin-js/renderer/internal/utils' {
    import { Box3, Vector3, Object3D, Material } from 'three';
    import { Mappedin, MapObject, MappedinMap, TMapViewOptions } from '@mappedin/mappedin-js/renderer/internal';
    import { Camera } from '@mappedin/mappedin-js/renderer/public/api/Camera';
    /**
        *	Utils function listing
        *
        * - scrubMaterial
        * - getObjectID
        * - getObject
        * - getBoundingBox
        * - getBiggestBoundingBox
        * - upackBoundingBox
        * - getMapScale
        * - throttle -> taken from lodash.js
        * - getProjectionScaleFactor
        * - getZoom
        */
    export function isGatewayKey(key: string): boolean;
    export function getCombinedBoundingBox(objects: Object3D[]): Box3;
    export function getMapsBoundingBox(maps: MapObject[], mapPadding: number): Box3;
    export function scrubMaterial(material: Material): void;
    /**
        * Takes a Mappedin Object or id and returns the ID, so our functions can take bottomRight
        * @template T extends string | {id: string}
        * @param {T} object - input can be object containing id or the id itself
        * @return {string}
        */
    export function getObjectId(object: any): string;
    /**
        * Takes a Mappedin object or ID and the array to look in and retuns the Object, so our functions can take both
        * @template K extends {id: string}
        * @template T extends K | string
        * @param {T} obj
        * @param {Array<K> | undefined} array
        * @returns {K | undefined}
        */
    export function getObject(obj: any, array: any[] | undefined): any;
    export function getBoundingBox(object: Object3D): Box3;
    /**
        * Function pushes the items of the second array onto the first array (inplace).
        * @template T
        * @param {Array.<T>} arr1 - base array
        * @param {Array.<T>} arr2 - array which items will be pushed to arr1
        */
    export function appendItems<T>(arr1: T[], arr2: T[]): void;
    export function getBiggestBoundingBox(objects: Object3D[]): {
            min: any;
            max: any;
    };
    export function unpackBoundingBox(boundingBox: Box3): Vector3[];
    export function getMapScale(map: MappedinMap): number;
    export function getNorth(map: MappedinMap): number;
    export function throttle<T>(func: () => void, wait: number, options?: any): () => void;
    export function debounce<T>(func: () => void, wait: number, immediate?: boolean): () => void;
    export function flatten(list: any[]): any[];
    export function uniq(arr: any[]): any[];
    export function toStyleString(styles: Record<string, string>): string;
    /**
    /*  getProjectionScaleFactor()
    /*  finds the scale ratio between screen coordinates and 3D coordinates (in X-Z plane)
    /*
                *                                    R
                *                                  /|
                *    C : Camera                  /  |
                *    PQ : Projection Plane     /    |
                *    OR : Origin             /      |
                *    F : FOV               /        |
                *                      Q /          |
                *                      /|           |
                *                    /  |           |
                *                  /    |           |
                *                /      |           |
                *              /        |           |
                *            / F/2      |           |
                *         C ------------P------------ O
                *
                *
                *   ProjectionScaleFactor = ( OR / PQ )
                *   PQ = canvasHeight / 2
                *   CQ = zoom
                *
                *   OR / C0 = tan(F/2)
                *   so OR = CO * tan(F/2)
                */
    export function getProjectionScaleFactor(FOV: number, canvasHeight: number, zoom: number): number;
    /** getZoom
        *
        *  C - Camera, OP -- picture plane (canvas), S - origin,
        *  QR - front side of maps Bounding Box, F: FOV
        *
        *                           Z-axis
        *                     R_____|______
        *                    /|     |     |
        *                  /  |     |     |
        *               P/    |     |     | maps BB
        *              /|     |     |     |
        *            /  |     |     |     |
        *          /    |     |     |     |
        *        / F    |E    |T    |S    |
        *    C /--------|-----|-----|-----|------ orthogonal to Y axis, midpoint of focus maps
        *      \        |     |     |     |
        *        \      |     |     |     |
        *          \    |     |     |     |
        *            \  |     |     |     |
        *              \|     |     |     |
        *               O\    |     |     |
        *                  \  |     |     |
        *                    \|_____|_____|
        *                     Q
        *
        *
        * We want to get CS, which is the camera zoom
        *
        */
    export function getZoom(focusBox: Box3, focusBoxHeight: number, FOV: number): number;
    interface CalculateTwoDProjectionsParams {
            maps: MapObject[];
            width: number;
            height: number;
            camera: Camera;
    }
    export function calculateTwoDProjections({ maps, width, height, camera }: CalculateTwoDProjectionsParams): {
            min: {
                    x: number;
                    y: number;
            };
            max: {
                    x: number;
                    y: number;
            };
    }[];
    export function splitLine(startNode: Vector3, endNode: Vector3, segments: number): Vector3[];
    export function isObject(item: any): boolean;
    export const determineStartingMap: (venue: Mappedin, options: TMapViewOptions) => MappedinMap;
    export function cyrb53(str: string, seed?: number): number;
    export function addMarginMultiplierToBoundingBox(bbox: Box3, multiplier: number): Box3;
    export function tweenPromise({ from, to, duration, easing, delay, onUpdate, onStart, onComplete, }: {
            from: any;
            to: any;
            duration?: number | undefined;
            easing?: any;
            delay?: number | undefined;
            onUpdate?: ((_: any) => void) | undefined;
            onStart?: (() => void) | undefined;
            onComplete?: (() => void) | undefined;
    }): {
            start(core: any): Promise<void>;
    };
    export const linearEase: (t: number) => number;
    export const quadEaseIn: (t: number) => number;
    export const quadEaseOut: (t: number) => number;
    export function interpolate(value: number, inputMin: number, inputMax: number, outputMin: number, outputMax: number, easeFunc?: (t: number) => number): number;
    export function interpolateMulti(value: number, inputRange: number[], outputRange: number[], easeFunc?: (t: number) => number): number;
    export {};
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.MapManager' {
    export default MapManager;
    class MapManager extends PubSub {
            constructor(polygonMeshesById: any, renderer: any, core: any, taskScheduler: any, loadOptions?: {});
            mapObjects: Map<any, any>;
            currentMap: undefined;
            object: any;
            _showCount: number;
            _mapObjectsSortedByElevationDirty: boolean;
            expanded: boolean;
            polygonMeshesById: any;
            core: any;
            renderer: any;
            loadOptions: {};
            addMap(mapClass: any, callback?: () => void): Promise<void>;
            setMap(mapClassOrId: any, callback: any): Promise<any>;
            removeMap(mapClassOrId: any): void;
            removeAllMaps(): void;
            loadMaps(maps: any, startingMap: any, onFirstMapLoaded?: () => void, onDataLoaded?: () => void, onError?: () => void): void;
            /**
             * Expand maps to display within view, typically used for multi-floor navigation. When passed a connection, maps included will not be displayed, instead, their 2d projection
             will be available in the resulting promise, which can be used to display a 2D component in the client-side app.
             *
             * @method expandMaps
             * @param mapIds {Array} Array of mapIds or mapObjects to display while expanded. For connections, pass &#123; connection: true, maps: [], connectionNodes: [], &#125;
             * @param  options {Object} Options object @optional
                    @param [options.focus=false] {Boolean} Focus the camera onto expanded maps
                    @param [options.debug=false] {Boolean} Display cubes around focus bounding box for debug info
                    @param [options.rotation=0] {Number} Rotation of scene relative to zero (degrees)
                    @param [options.duration=300] {Number} Duration of focus animation in ms
                    @returns {Promise} Promise that resolves to 2d screen projections of each layer/map (see example)
                    @example
            // expand maps with 3 connection maps in between
            expandMaps(
                    '55e89771d982bc06ca000000',
                            {
                                    connection: true,
                                    // connection nodes are an exit node from the '55e89771' man and entry node for the '55e9c73f' map
                                    connectionNodes: [{
                                            map: "55e89771",
                                            x: 6232,
                                            y: 4575
                                    }, {
                                            map: "55e9c73",
                                            x: 5945.000000000001,
                                            y: 4059.000000000001
                                    }],
                                    maps: [
                                            '55e9acbf',
                                            '55e8a9ed',
                                            '55e85e23'
                                    ]
                            },
                            '55e9c73f'
                     );
    
                     // resulting promise (sorted by elevation (top to bottom))
    
                     [
                            {
                                    min: { x: -100, y: -50 },
                                    max: { x: -100, y: -50 }
                            },
                            {
                                    min: { x: -100, y: -50 },
                                    max: { x: -100, y: -50 }
                            },
                            {
                                    min: { x: -100, y: -50 },
                                    max: { x: -100, y: -50 }
                            }
                     ]
             */
            expandMaps(mapsToExpand: any, options: any): Promise<any>;
            /**
             * Contract maps and display the current map
             *
             * @method contractMaps
             * @param  options {Object} Options object @optional
                    @param [options.focus] {Boolean} Focus the camera onto current map
                    @param [options.debug] {Boolean} Display cubes around focus bounding box for debug info
                    @param [options.duration=300] {Number} Duration of focus animation in ms
             */
            contractMaps(options?: any): Promise<any>;
            expandPanBounds(bounds: any): void;
            /**
                * This can be used to invoke a callback function for _every_ set map invocation.
                * @param {Function} cb callback function
                */
            addPersistentSetMapCallback(cb: Function): void;
            persistentSetMapCallbacks: any;
            setMapCallbacks: any[] | undefined;
            get mapObjectsSortedByElevation(): any[];
            _mapObjectsSortedByElevation: any[] | undefined;
            get visibleMaps(): any[];
            getCompoundBoundingBoxPoints(objects: any): Vector3[];
            multiFloorView: MultiFloorView | undefined;
            renderedMaps: any[] | undefined;
            projections: any[] | undefined;
            mapsFullyLoaded(callback?: () => void): Promise<void>;
            /**
                * Scroll maps up
                * This will shift maps down to show next one (above)
                */
            scrollMapsUp(): Promise<any>;
            /**
                * Scroll maps down
                * This will shift maps up to show next one (below)
                */
            scrollMapsDown(): Promise<any>;
            tiltMaps(tilt: any): void;
            resize(): void;
    }
    import { PubSub } from '@mappedin/mappedin-js/renderer/internal/pub-sub';
    import MultiFloorView from '@mappedin/mappedin-js/renderer/internal/Mappedin.MultiFloorView';
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.DebugUI' {
    /**
        * A DOM element that can be populated with performance information.
        *
        * @class DebugUI
        * @private
        */
    export default class DebugUI {
            _element: HTMLDivElement;
            _titleElement: HTMLSelectElement;
            _minimizeElement: HTMLButtonElement;
            _performancePanelElement: HTMLDivElement;
            _performanceEntries: Map<any, any>;
            _sortedPerformanceEntryNames: any[];
            _overviewGraph: LineGraph;
            _controlPanels: Map<any, any>;
            _sortedControlPanelNames: any[];
            _minimized: boolean;
            destroy(): void;
            /**
                * Return the DOM element used by this `DebugUI`, which may be
                * added as a child of any other DOM element to display it.
                *
                * @method element
                * @return {Element} the ui's root element
                */
            get element(): Element;
            /**
                * Log the given entries to this performance logger, and update the display
                * accordingly. If a given key isn't already being logged, an entry will be
                * added for it. If a key is being logged but isn't reported, it will be
                * treated as if it had a value of `0` reported.
                *
                * @method reportFramePerformance
                * @param {string -> number} entries the most recent recorded values for each
                *		named frame update
                */
            reportFramePerformance(entries: any): void;
            /**
                * Add the given controls to the given panels. More efficient than adding
                * controls one-by-one since it only recomputes positions after all controls
                * are added.
                *
                * @method addDebugControls
                * @param {category: string: [{name: string, description: string, control: DebugUIControl}]} categories
                *		a mapping from category to a list of control names and controls
                */
            addDebugControls(categories: any): void;
            /**
                * Add the given control to a panel.
                *
                * @method addDebugControl
                * @param {string} category the name of the panel the control will be put under
                * @param {string} name the name of the control
                * @param {string} description a description for the control (tooltip)
                * @param {DebugUIControl} control the control to add to the panel
                */
            addDebugControl(category: string, name: string, description: string, control: DebugUIControl): void;
            /**
                * Remove the given controls from the UI.
                *
                * @method removeDebugControls
                * @param {category: string: [name: string]} categories
                *		a mapping from category to a list of control names to remove
                */
            removeDebugControls(categories: any): void;
            /**
                * Remove the given control from a panel.
                *
                * @method removeDebugControl
                * @param {string} category the name of the panel the control will be put under
                * @param {string} name the name of the control
                */
            removeDebugControl(category: string, name: string): void;
            _addDebugControl(category: any, name: any, description: any, control: any): void;
            _removeDebugControl(category: any, name: any): void;
            _onMinimizeClicked(): void;
            _onCategoryChanged(): void;
    }
    /**
        * A graph on a HTML canvas element that will display the values in the given
        * time series.
        *
        * @class LineGraph
        * @private
        */
    class LineGraph {
            /**
                * Return a new `LineGraph` displaying information from the given list of
                * time series.
                *
                * @constructor
                * @param {[TimeSeries]} seriesList the list of time series that will be
                *		displayed on this graph.
                * @param {number} width the width of this canvas element, in pixels
                * @param {number} height the width of this canvas element, in pixels
                */
            constructor({ seriesList, width, height }: [TimeSeries]);
            _gradients: Map<any, any>;
            _canvas: HTMLCanvasElement;
            _context: CanvasRenderingContext2D | null;
            destroy(): void;
            /**
                * @method element
                * @return {Element} DOM element that can be added to display this graph
                */
            get element(): Element;
            /**
                * Clear this canvas and re-draw the time series lines.
                *
                * @method redraw
                */
            redraw(): void;
            /**
                * Set the list of time series that this graph displays.
                *
                * @method setSeriesList
                * @param {[TimeSeries]} series series to display
                */
            setSeriesList(series: [TimeSeries]): void;
            _seriesList: [TimeSeries] | undefined;
    }
    /**
        * A time series that averages values that are reported to it and inserts them
        * into a ring buffer.
        *
        * @class TimeSeries
        * @private
        */
    class TimeSeries {
            constructor({ windowSize, totalAccumulationCount, hue, }: {
                    windowSize?: number | undefined;
                    totalAccumulationCount?: number | undefined;
                    hue?: number | undefined;
            });
            windowSize: number;
            hue: number;
            _totalAccumulationCount: number;
            _ringBuffer: any[];
            _ringBufferLength: number;
            _ringBufferPointer: number;
            _accumulatorValue: number;
            _accumulatorCount: number;
            _changed: boolean;
            destroy(): void;
            /**
                * Incorporate the given value into the time series. This will accumulate up
                * to `LINE_GRAPH_ACCUMULATION_COUNT` values, at which point they will be
                * averaged and inserted into the time series. If the number of averaged entries
                * exceeds `LINE_GRAPH_WINDOW_SIZE`, the ring buffer will drop the oldest
                * entry.
                *
                * This will set the `changed()` flag if an accumulated value has been added
                * to the ring buffer.
                *
                * @method report
                * @param {number} value the value to add to the time series
                */
            report(value: number): void;
            /**
                * Return the entry at the given index in the ring buffer. The value
                * at `length - 1` is the most recently accumulated value.
                *
                * @method at
                * @param {number} i the index to retrieve
                * @return {number} the accumulated value at the given index
                */
            at(i: number): number;
            /**
                * @method maximumValue
                * @return {number} the maximum value in this time series
                */
            maximumValue(): number;
            /**
                * Return true if this time series has changed since the previous `report()`
                * invocation.
                *
                * @method changed
                * @return {boolean}
                */
            changed(): boolean;
            /**
                * Return the number of accumulated values in this time series. Will never
                * exceed `LINE_GRAPH_WINDOW_SIZE`.
                *
                * @return {number} number of accumulated entries
                */
            get length(): number;
    }
    export {};
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.DebugUIControl' {
    export class DebugUIScalarSlider {
        constructor({ minimum, maximum, step, current, onValueChanged }: {
            minimum: any;
            maximum: any;
            step: any;
            current: any;
            onValueChanged: any;
        });
        _minimum: any;
        _maximum: any;
        _step: any;
        _onValueChanged: any;
        _element: HTMLInputElement;
        destroy(): void;
        addValueChangedListener(listener: any): void;
        setValue(value: any): void;
        get element(): HTMLInputElement;
        get value(): string;
        get displayedValue(): string;
        get height(): number;
    }
    export class DebugUICheckbox {
        constructor({ current, onValueChanged }: {
            current: any;
            onValueChanged: any;
        });
        _onValueChanged: any;
        _element: HTMLDivElement;
        _titleElement: HTMLInputElement;
        destroy(): void;
        addValueChangedListener(listener: any): void;
        get element(): HTMLDivElement;
        get titleElement(): HTMLInputElement;
        get value(): boolean;
        get displayedValue(): "true" | "false";
        get height(): number;
        get titleElementWidth(): number;
    }
    export class DebugUIDropdown {
        constructor({ values, current, onValueChanged }: {
            values: any;
            current: any;
            onValueChanged: any;
        });
        _values: any;
        _onValueChanged: any;
        _element: HTMLSelectElement;
        destroy(): void;
        addValueChangedListener(listener: any): void;
        get element(): HTMLSelectElement;
        get value(): string;
        get displayedValue(): string;
        get height(): number;
    }
    export class DebugUIButton {
        constructor({ label, onClick }: {
            label: any;
            onClick: any;
        });
        _onClick: any;
        _element: HTMLButtonElement;
        destroy(): void;
        addValueChangedListener(): void;
        addClickListener(listener: any): void;
        get element(): HTMLButtonElement;
        get value(): string;
        get displayedValue(): string;
        get height(): number;
    }
    export class DebugUIColorPicker {
        constructor({ current, onValueChanged }: {
            current: any;
            onValueChanged: any;
        });
        _onValueChanged: any;
        _element: HTMLDivElement;
        _titleElement: HTMLDivElement;
        _color: any;
        _listeners: any[];
        _colorPickerMain: HTMLCanvasElement;
        _colorPickerBottomSlider: HTMLCanvasElement;
        _requestAnimationFrameHandle: number | null;
        _requestAnimationFrameUpdate(): void;
        _pickingMain: boolean;
        _pickingX: number;
        _pickingY: number;
        _moveListener: (e: any) => void;
        _upListener: any;
        _pickingBottomSlider: boolean;
        _bottomMoveListener: (e: any) => void;
        _bottomUpListener: any;
        _mode: string;
        _modeButtons: {};
        destroy(): void;
        _destroyed: boolean | undefined;
        addValueChangedListener(listener: any): void;
        setValue(color: any): void;
        _requestAnimationFrame(): void;
        _notify(): void;
        _updateMain(x: any, y: any): void;
        _updateBottomSlider(x: any): void;
        redraw(): void;
        get element(): HTMLDivElement;
        get titleElement(): HTMLDivElement;
        get value(): any;
        get displayedValue(): string;
        get height(): number;
        get titleElementWidth(): number;
    }
    export class DebugUIPanel {
        constructor({ name }: {
            name: any;
        });
        _name: any;
        _element: HTMLDivElement;
        _entries: any[];
        _height: number;
        destroy(): void;
        get element(): HTMLDivElement;
        get height(): number;
        addControl(name: any, description: any, control: any): void;
        removeControl(name: any): void;
        _updateLayout(): void;
    }
}

declare module '@mappedin/mappedin-js/renderer/private/Core' {
    import '../internal/externals/globalThisPolyfill';
    import { Color, Mesh, PerspectiveCamera, Scene, Vector2 } from 'three';
    import '../internal/object3D.destroy';
    import type { TGetPolygonsAtCoordinateOptions, TMapViewOptions, TPadding, MappedinPolygon } from '@mappedin/mappedin-js/renderer/internal';
    import { Renderer, TaskScheduler, MapManager, FlatLabel, SmartCollisionEngine, PubSub, INTERNAL_EVENT, INTERNAL_EVENT_PAYLOAD, MapView, STATE, MapObject, SceneManager, TileManager, PathsController, FloatingLabelsController, FlatLabelsController, PolygonColorsController, MarkersController, PolygonInteractionController, TooltipsController, PolygonStatesController, PolygonImagesController, ThreeDMarkersController, EventSystem, BlueDotController, CameraController, BillboardManager, StackedMapsController, OutdoorViewController, WatermarkController, PolygonHoverColorsController, ExportController, LayerController } from '@mappedin/mappedin-js/renderer/internal';
    import { Mappedin as IMappedin, MappedinCoordinate, MappedinMap, MappedinNode } from '@mappedin/mappedin-js/get-venue';
    import { E_MAP_CHANGED_REASON } from '@mappedin/mappedin-js/renderer/MapView.enums';
    export const raycaster: any;
    let Mappedin: any;
    /**
        * Some preset orderings for updates.
        */
    export const UPDATE_ORDERING: {
            BEFORE_CAMERA: number;
            CAMERA: number;
            AFTER_CAMERA: number;
            RENDER: number;
            AFTER_RENDER: number;
            AFTER_ALL_UPDATES: number;
    };
    type TCoreColors = {
            defaultHover2D: string;
            select: string;
            text: string;
            path: string;
            pathPulse: string;
            textSelect: string;
    };
    class Core extends PubSub<INTERNAL_EVENT_PAYLOAD, INTERNAL_EVENT> {
            #private;
            /**
                * Controllers
                */
            eventSystem: EventSystem;
            floatingLabels: FloatingLabelsController;
            flatLabels: FlatLabelsController;
            paths: PathsController;
            polygonColors: PolygonColorsController;
            polygonHoverColors: PolygonHoverColorsController;
            polygonInteraction: PolygonInteractionController;
            polygonStates: PolygonStatesController;
            polygonImages: PolygonImagesController;
            markers: MarkersController;
            tooltips: TooltipsController;
            threeDMarkers: ThreeDMarkersController;
            blueDot: BlueDotController;
            camera: CameraController;
            outdoorViewController?: OutdoorViewController;
            exportController: ExportController;
            watermark: WatermarkController;
            layerController: LayerController;
            options: TMapViewOptions & {
                    onDataLoaded?: (data: IMappedin) => void;
                    onFirstMapLoaded?: (data: IMappedin) => void;
            };
            currentPath?: MappedinNode[];
            state: STATE;
            imageFlippingCache: {};
            imageFlippingEnabled: boolean;
            MapView: MapView;
            type: string;
            container: HTMLDivElement;
            venue: IMappedin;
            colors: TCoreColors;
            loadOptions: TMapViewOptions['loadOptions'];
            smartCollisionEngine: SmartCollisionEngine;
            taskScheduler: TaskScheduler;
            renderer: Renderer;
            highlightedPolygons: Record<string, string>;
            outlinedPolygons: Map<string, MappedinPolygon>;
            scene: Scene;
            focusZoomFactor: number;
            cameraObject: PerspectiveCamera;
            polygonMeshesById: Record<string, Mesh>;
            textLabelsByPolygonId: Record<string, FlatLabel>;
            labelOrientationDelay: number;
            isWebGL2: boolean;
            interactivePolygons: Record<string, boolean>;
            polygonHoverColorsById: Record<string, Color>;
            mapManager: MapManager | undefined;
            sceneManager: SceneManager | undefined;
            mapObjects: Map<MappedinMap['id'], MapObject>;
            referenceMap: MappedinMap;
            currentInteractionEvent: INTERNAL_EVENT | undefined;
            resolution: Vector2;
            cameraParameters: Vector2;
            controls: typeof Mappedin.CameraControls;
            cameraPlane: Mesh;
            canvasWidth: number;
            canvasHeight: number;
            cachedPadding: TPadding;
            currentScale: number;
            rendererDomElement: HTMLCanvasElement;
            resolutionScale: number;
            outdoorGeometryLayers: string[];
            billboardManager: BillboardManager;
            stackedMaps: StackedMapsController;
            tileManager: TileManager;
            setMapReason?: E_MAP_CHANGED_REASON;
            get aspect(): number;
            /**
                * Get all maps that are "visible" in the scene.
                */
            get visibleMapsInCurrentScene(): MappedinMap[];
            get visibleMapObjectsInCurrentScene(): MapObject[];
            /**
                * Returns all currently visible layers
                */
            get visibleLayersInCurrentScene(): {};
            constructor(container: HTMLDivElement, venue: IMappedin, options: (TMapViewOptions & {
                    onDataLoaded?: ((data: IMappedin) => void) | undefined;
                    onFirstMapLoaded?: ((data: IMappedin) => void) | undefined;
            }) | undefined, MapView: MapView);
            get currentMap(): string | null;
            setState(state: STATE): Promise<void>;
            getPolygon: (polygon: any) => any;
            showEntireMap: (options: any) => any;
            resetPanBounds: () => void;
            focusOn: (options: any) => any;
            focusOnPolygon: (polygon: any, changeZoom: any, duration: any, curve: any) => any;
            focusOnPath: (path: any, polygons: any, changeZoom: any, duration: any, curve: any) => any;
            getCameraFrameForPoints: (pointCloud: any, horizontalFovFactor: any, verticalFovFactor: any, padding: any, ignoreZoom?: boolean, minZoom?: any, maxZoom?: any) => {
                    position: any;
                    zoom: any;
            };
            setPadding: (padding?: TPadding) => void;
            getZoomLevelForPolygon: (polygon: any) => any;
            getZoomLevelForCurrentMap: () => any;
            getZoomLevelForObject: (object: any) => any;
            resetCamera: (forceOrigin?: boolean) => void;
            /**
                * Gets a position (to anchor a {{#crossLink "Marker"}}{{/crossLink}} usually) from a latitude and longitude.
                *
                * @method getPositionLatLon
                * @param latitude {Number} Latitude of position
                * @param longitude {Number} Longitude of position
                * @returns A position you can use with a Marker either initially or to update later when the user (for example) moves
                */
            getPositionLatLon: (lat: number, lon: number, map?: string | MappedinMap | null) => any;
            lockNorth: (element: any, offset?: number) => void;
            unlockNorth: (element: any) => void;
            convertTo3DMapPosition: (nodeOrCoordinate: MappedinNode | MappedinCoordinate) => any;
            /**
                * Converts a 2D x,y screen position into a 3D MappedinCoordinate using projection
                */
            convertScreenCoordinateToMapCoordinate: (x: number, y: number, map: MappedinMap) => MappedinCoordinate | undefined;
            convert3DMapPositionToCoordinate: (coord: any, mapClass?: MappedinMap | null | undefined) => MappedinCoordinate | undefined;
            getPositionPolygon: (polygon: any) => any;
            getPositionNode: (node: any) => any;
            hideAllLabels: () => void;
            setBackgroundColor: (color: any, alpha: any) => void;
            setSize: (width: any, height: any) => void;
            getMapScale: () => number;
            getNorth: () => number;
            /**
                * The scene only renders when something has changed. This should be something a 3rd party developer doesn't need to worry about,
                * but if you are doing something weird, or have your own special tween for something, you will want to call this function.
                * You can call it as often as you want, it just sets a flag that we need to render again, and renders a few frames if we weren't already doing that.
                * @method tryRendering
                * @param [renderMode=RENDER.ALL] {RENDER} Which parts of the scene to re-render
                */
            tryRendering: (renderMode?: any) => void;
            /**
                * Display the performance characteristics and debug controls for this
                * MapView.
                *
                * @method showDebugUI
                */
            showDebugUI: () => void;
            /**
                * Hide the performance characteristics and debug controls for this
                * MapView.
                *
                * @method hideDebugUI
                */
            hideDebugUI: () => void;
            determineNewLabelSize: () => void;
            mapSetInProgress: Promise<undefined>;
            mapSetResolved: any;
            setMap: (map: string | MappedinMap) => Promise<null>;
            setMapWithReason: (map: string | MappedinMap, reason: E_MAP_CHANGED_REASON) => Promise<null>;
            getPolygonsAtScreenCoordinate: (x: number, y: number, options?: TGetPolygonsAtCoordinateOptions) => any;
            getPolygonsAtCoordinate: (coordinate: MappedinCoordinate, options?: TGetPolygonsAtCoordinateOptions) => any;
            getNearestNodeByScreenCoordinate(x: number, y: number, mapOrMapId?: MappedinMap | MappedinMap['id']): MappedinNode;
            /**
                * Destroys instance and frees resources
                *
                * @method destroy
                */
            destroy: () => void;
    }
    export default Core;
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.MVF.types' {
    import { MapId, ObstructionCollection, EntranceCollection, SpaceCollection, Style } from '@mappedin/mvf';
    import { FeatureCollection, MultiPolygon, Point, Polygon } from 'geojson';
    import { TImage, TMap, TNode, TOpeningHours, TPhone, TSiblingGroup, TSocial } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    export type WithIDs<T> = Map<string, T>;
    type ManifestFile = {
            type: 'file';
            name: string;
    };
    type ManifestFolder = {
            type: 'folder';
            name: string;
            children: ManifestFile[];
    };
    export type MVFStyle = Style & {
            type: string;
            width?: number;
    };
    export type MVFObstructionFeature = ObstructionCollection['features'][number];
    export type MVFEntranceFeature = EntranceCollection['features'][number];
    export type MVFSpaceFeature = SpaceCollection['features'][number];
    export type MVFv1PolygonLikeProperties = {
            id: string;
            altitude?: number;
            color?: string;
            externalId?: string | null;
            height?: number;
            opacity?: number;
            layer?: string;
            level: string;
            parent?: string | null;
    };
    export type MVFv1SpaceProperties = MVFv1PolygonLikeProperties & {
            entrances: {
                    level: TMap['id'];
                    id: TNode['id'];
            }[];
    };
    export type MVFv1ObstructionProperties = MVFv1PolygonLikeProperties;
    export type MVFv1ConnectionProperties = {
            id: string;
            /**
                * Indicates that a connection is accessible
                */
            accessible: boolean;
            /**
                * Array of node ids that this Connection connects with.
                */
            destinations: string[];
            level: string;
            multiplier: number;
            name: string;
            /**
                * Type of the connection such as `escalator` or `elevator`
                */
            type: string;
            weight: number;
    };
    export type MVFv1NodeProperties = {
            id: string;
            /**
                * Indicates that a node is accessible
                */
            accessible: boolean;
            /**
                * External id of a node is used to sync and connect to external systems to Mappedin data
                */
            externalId: string | null;
            level: string;
            multiplier: number;
            neighbors: string[];
            weight: number;
    };
    export type MVFv1LevelProperties = {
            id: string;
            abbreviation?: string;
            building?: string;
            elevation?: number;
            name: string;
    };
    export type MVFv1ManifestProperties = {
            /**
                * Name of the venue
                */
            name: string;
            folder_struct: (ManifestFolder | ManifestFile)[];
            /**
                * Mappedin Venue Format version number of the MVF bundle
                */
            version: string;
            /**
                * Timestamp when the MVF bundle was generated. E.g. `2022-02-25T16:26:09.908Z`
                */
            time: string;
    };
    export type MVFv1BuildingProperties = {
            id: string;
            name: string;
            venue: string;
    };
    export type MVFv1CategoryProperties = {
            id: string;
            name: string;
            picture?: TImage;
    };
    export type MVFv1LocationProperties = {
            id: string;
            address?: string | null;
            /**
                * Array of {@link MICategoryProperties | category} ids
                */
            categories: string[];
            /**
                * A text description of the location usually indicating what the location is used for
                */
            description?: string | null;
            /**
                * Email address to for contacting this location
                */
            email?: string | null;
            /**
                * External id used to connect Mappedin Location to an external system
                */
            externalId?: string | null;
            /**
                * Opening hours of the location
                */
            hours?: TOpeningHours[] | null;
            /**
                * Collection of links related to this location
                */
            links?: {
                    label: string;
                    url: string;
            }[] | null;
            logo?: TImage | null;
            /**
                * Name of the location. By default this is the string displayed in the location label
                */
            name: string;
            /**
                * Phone number for contacting this location
                */
            phone?: TPhone | null;
            picture?: TImage | null;
            services?: string | null;
            siblingGroups?: TSiblingGroup[] | null;
            /**
                * Social media links of the location
                */
            social?: TSocial | null;
            /**
                * Array of {@link MISpaceProperties | MVF Space} ids for this location
                */
            spaces?: {
                    id: string;
                    map: string;
            }[] | null;
            states?: {
                    type: string;
                    start?: string;
                    end?: string;
            }[] | null;
            type: string;
    };
    export type MVFv1ObstructionCollection = FeatureCollection<Polygon, MVFv1ObstructionProperties>;
    export type MVFv1SpaceCollection = FeatureCollection<Polygon, MVFv1SpaceProperties>;
    export type MVFv1ConnectionCollection = FeatureCollection<Point, MVFv1ConnectionProperties>;
    export type MVFv1NodeCollection = FeatureCollection<Point, MVFv1NodeProperties>;
    export type MVFv1LevelCollection = FeatureCollection<Polygon | MultiPolygon, MVFv1LevelProperties>;
    export type MVFv1ManifestCollection = FeatureCollection<Point, MVFv1ManifestProperties>;
    export type MVFv1BuildingCollection = FeatureCollection<Polygon, MVFv1BuildingProperties>;
    export type MVFv1CategoryCollection = FeatureCollection<null, MVFv1CategoryProperties>;
    export type MVFv1LocationCollection = FeatureCollection<null, MVFv1LocationProperties>;
    export type ParsedMVFv1 = {
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            space: {
                    [mapId: MapId]: MVFv1SpaceCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            obstruction: {
                    [mapId: MapId]: MVFv1ObstructionCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            level: {
                    [mapId: MapId]: MVFv1LevelCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            node: {
                    [mapId: MapId]: MVFv1NodeCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            connection: {
                    [mapId: MapId]: MVFv1ConnectionCollection | undefined;
            };
            'manifest.geojson': MVFv1ManifestCollection;
            'building.geojson': MVFv1BuildingCollection;
            'category.geojson': MVFv1CategoryCollection;
            'location.geojson': MVFv1LocationCollection;
    };
    export type RawMVFv1 = {
            'manifest.geojson': Uint8Array;
            'building.geojson': Uint8Array;
            'category.geojson': Uint8Array;
            'location.geojson': Uint8Array;
            level: Partial<Record<MapId, Uint8Array>>;
            node: Partial<Record<MapId, Uint8Array>>;
            space: Partial<Record<MapId, Uint8Array>>;
            obstruction: Partial<Record<MapId, Uint8Array>>;
            connection: Partial<Record<MapId, Uint8Array>>;
    };
    export {};
}

declare module '@mappedin/mappedin-js/get-venue/MappedinNavigatable' {
    import type { MappedinNode, MappedinPolygon, MappedinLocation } from '@mappedin/mappedin-js/get-venue/internal';
    import { MappedinDirections, MappedinDestinationSet, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import { TSimplifyDirectionsOptions } from '@mappedin/mappedin-js/navigator';
    export type TDirectionToOptions = {
            /**
                * If true directions will only take accessible routes
                * @default false
                */
            accessible?: boolean;
            /**
                * Include all the vortexes matching the given IDs
                */
            includedVortexIds?: string[];
            /**
                * Exclude all the vortexes matching the given IDs
                */
            excludedVortexIds?: string[];
            /**
                * @experimental
                * Apply line-of-sight simplifying to directions. This will attempt to remove unnecessary nodes between turns.
                */
            simplify?: TSimplifyDirectionsOptions;
    };
    export abstract class MappedinNavigatable {
            #private;
            constructor(mappedin: Mappedin);
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate distance between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinNode' {
    import type { MappedinPolygon, MappedinLocation, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { TOpeningHours } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    import { MappedinNavigatable, MappedinDirections, MappedinDestinationSet, MappedinMap, TDirectionToOptions } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * A {@link MappedinNode} represents a position, anchored to a specific {@link MappedinMap}.
        *
        * A Node can have more properties but usually the default is sufficient. The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Nodes. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * @class MappedinNode
        */
    export class MappedinNode extends MappedinNavigatable {
            #private;
            /**
                * Node ID.
                * @property id {string}
                */
            id: string;
            /**
                *  X coordinate of Node's position.
                * @property x {number}
                */
            x: number;
            /**
                * Y coordinate of Node's position.
                * @property y {number}
                */
            y: number;
            /**
                * Operation Hours of this node. A Location may have different operation hours per node, for example 2 washrooms
                */
            operationHours?: TOpeningHours[];
            externalId?: string;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Map Object that this Node is located on.
                *
                * @property map {MappedinMap}
                */
            get map(): MappedinMap;
            /**
                * Latitude of node. This is expensive, especially if doing it for many/all nodes
                */
            get lat(): number;
            /**
                * Longitude of node. This is expensive, especially if doing it for many/all nodes
                */
            get lon(): number;
            /**
                * Adjacent Nodes.
                *
                * @property paths
                * @type [MappedinNode]
                */
            get paths(): MappedinNode[];
            set paths(paths: MappedinNode[]);
            /**
                * Locations attached to this Node.
                *
                * @property locations
                * @type [MappedinLocation]
                */
            get locations(): MappedinLocation[];
            /**
                * Polygon that this node is part of
                */
            get polygon(): MappedinPolygon;
            static hydrate(nodes: any, mappedin: Mappedin): MappedinNode[];
            static fetch(mappedin: Mappedin): Promise<MappedinNode[]>;
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate distance between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinPolygon' {
    import type { MappedinNode, MappedinLocation, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import { MappedinNavigatable, MappedinDirections, MappedinDestinationSet, MappedinMap, TDirectionToOptions } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * The {@link MappedinPolygon} class represents the 3D shape of a {@link MappedinLocation} on a {{@link MappedinMap}. Polygons have access to Locations they belong to, and any entrances to the Polygon.
        *
        * A Polygon can have more properties but usually the default is sufficient. The {@link Mappedin}'things' object is where you would specify what properties you want to download for Polygons. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * @class MappedinPolygon
        */
    export class MappedinPolygon extends MappedinNavigatable {
            #private;
            geometry: any;
            perspectives?: any;
            image?: {
                    visible: boolean;
                    url: string | Blob;
                    original: string | Blob;
                    useLocalScaling: boolean;
                    viewBox: {
                            width: number;
                            height: number;
                    };
                    scale: {
                            x: number;
                            y: number;
                    };
                    fitToBounds: boolean;
                    position: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    rotation: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    _isAbsolutelyPositioned?: boolean;
            };
            holes?: unknown[];
            textures?: {
                    image: any;
                    name: 'front' | 'side';
                    useFrontFaceImage?: boolean;
            }[];
            material: {
                    color: string;
                    opacity?: number;
            };
            label?: {
                    visible: boolean;
                    text: string;
                    align: string;
                    position: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    rotation: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    fontFamily: string;
                    fontSize: number;
                    color: string;
            };
            /**
                * Node ID.
                *
                * @property id {string}
                */
            id: string;
            layer?: string;
            layerId?: string;
            name?: string;
            externalId?: string;
            vertexes?: {
                    x: number;
                    y: number;
            }[];
            /**
                * @internal
                *
                * The center coordinate of the polygon used for positioning {@link FloatingLabels} for MVF venues.
                */
            center?: {
                    x: number;
                    y: number;
            };
            canvasBounds?: {
                    align: string;
                    maxHeight: number;
                    maxWidth: number;
                    rotation: number;
                    x: number;
                    y: number;
            };
            /** Category grouped ranking determined by the {@link MappedinCategory.sortOrder} and {@link rank} for this polygon. */
            categoryRank?: number;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Map Object that this Polygon is located on.
                *
                * @property map {MappedinMap}
                */
            get map(): MappedinMap;
            /**
                * Locations attached to the Polygon.
                *
                * @property locations {[MappedinLocation]}
                */
            get locations(): MappedinLocation[];
            /**
                * Polygon's entrance Nodes.
                *
                * @property entrances {[MappedinNode]}
                */
            get entrances(): MappedinNode[];
            set entrances(entrances: MappedinNode[]);
            /**
                * Ranking for this polygon.
                */
            get rank(): {
                    score: number;
                    node: string;
            } | null;
            static hydrate(polygons: any, mappedin: Mappedin): MappedinPolygon[];
            static fetch(mappedin: Mappedin): Promise<MappedinPolygon[]>;
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate distance between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinCategory' {
    /**
        * Collection of all Categories within the Venue.
        *
        * @property categories
        * @type [MappedinCategory]
        */
    import type { MappedinLocation, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { TPicture } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    /**
        * A {@link MappedinCategory} is a collection of similar Locations.
        *
        * A Category can have more properties such as 'name', or 'parents' (for hierarchical categories) as well.
        * For example, you may have a Fashion category, which has a Men's Fashion and Women's Fashion category. A Men's clothing store would belong to the Men’s Fashion category, but not necessarily be present in the Fashion category's list of Locations.
        *
        * The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Categories. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Category properties specified:
        *
        *	things: {
        *		venue: [],
        *		locations: [],
        *		categories: ['venue', 'name', 'language', 'externalId', 'parents'],
        *		maps: []
        * 	}
        *
        * @class MappedinCategory
        */
    export class MappedinCategory {
            #private;
            name?: string | undefined;
            externalId?: string | undefined;
            parents?: string[] | undefined;
            id?: string | undefined;
            icon?: TPicture | undefined;
            iconFromDefaultList?: string | undefined;
            /** Category sort priority. */
            sortOrder?: number | undefined;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Locations in this Category.
                *
                * @property locations
                * @type [MappedinLocation]
                */
            get locations(): MappedinLocation[];
            /**
                * Children of this Category.
                *
                * @property children
                * @type [MappedinCategory]
                */
            get children(): MappedinCategory[];
            static hydrate(categories: any, mappedin: Mappedin): MappedinCategory[];
            static fetch(mappedin: Mappedin): Promise<MappedinCategory[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinDestinationSet' {
    import type { MappedinNode, MappedinPolygon, MappedinLocation } from '@mappedin/mappedin-js/get-venue/internal';
    export class MappedinDestinationSet {
        destinations: (MappedinLocation | MappedinNode | MappedinPolygon)[];
        constructor(destinations: (MappedinLocation | MappedinNode | MappedinPolygon)[]);
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinVortex' {
    import type { Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * A {@link MappedinVortex} is a special entity that represents a link between two or more {@link MappedinMap}s at a given {@link MappedinVenue}. It is typically something like an elevator or stairs. These are also known as Connections in some parts of the system.
        *
        * They can be marked (wheelchair) Accessible or not for pathfinding purposes. If you ask for Accessible directions, paths that include non-accessible Vortexes like Stairs will not be used.
        *
        * @class MappedinVortex
        */
    export class MappedinVortex {
            #private;
            /**
                * Vortex ID.
                *
                * @property id {string}
                */
            id: string;
            accessible?: boolean;
            name?: string;
            type?: string;
            weight?: number;
            multiplier?: number;
            nodes?: string[];
            constructor(data: any);
            static hydrate(vortexes: any): MappedinVortex[];
            static fetch(mappedin: Mappedin): Promise<MappedinVortex[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinVenue' {
    import type { Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { TLogo, TOpeningHours } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    /**
      * A {@link MappedinVenue} is a specific place (like a mall) with one or more Maps (typically representing different floors) and Locations (stores, washrooms, elevators, etc).
      *
      * A Venue can have more properties such as 'name' and 'slug'. The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Venues. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
      *
      * See below for an example a 'things' object with available Venue properties specified:
      *
      *	things: {
      *		venue: ['slug', 'name', 'language', 'address', 'city', 'state', 'postal', 'telephone', 'latitude', 'longitude', 'website', 'operationHours'],
      *		locations: [],
      *		categories: [],
      *		maps: []
      * 	}
      *
      *
      * @class MappedinVenue
      */
    export class MappedinVenue {
        #private;
        defaultMap: string;
        address: string;
        city: string;
        countrycode: string;
        externalId: string;
        id: string;
        latitude?: number;
        logo?: TLogo;
        longitude?: number;
        name: string;
        operationHours?: TOpeningHours[];
        postal: string;
        slug: string;
        state: string;
        telephone: string;
        tzid: string;
        tzidOverride: string;
        utcOffset: string;
        website: string;
        secureContentStorage: boolean;
        defaultLanguage: {
            code: string;
            name: string;
        };
        languages: {
            name: string;
            code: string;
        }[];
        topLocations?: string[];
        constructor(mappedin: Mappedin, data: any);
        get metadata(): any;
        set metadata(value: any);
        static hydrate(data: any, mappedin: Mappedin): MappedinVenue;
        static fetch(mappedin: Mappedin): Promise<MappedinVenue>;
        get isMultiBuilding(): any;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinTheme' {
    import type { Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    export class MappedinTheme {
        #private;
        /**
          * Theme ID.
          *
          * @property id {string}
          */
        id: string;
        constructor(data: any);
        static hydrate(themes: any): MappedinTheme[];
        static fetch(mappedin: Mappedin): Promise<MappedinTheme[]>;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinRankings' {
    import type { Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { TPolygonRanking } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    /**
      * A {@link MappedinRankings} object is something that contains all the rankings for all the {@link MappedinPolygon}s in the venue. It has a `polygons` array in which each item is linked to zero or more {@link MappedinPolygon}s.
      *
      * Rankings shows what the priority of displaying each polygon is.
      *
      * A specific polygon's ranking can have the properties `polygonId`, `entranceNodeId`, `score`.
      *
      * The {@link Mappedin} `things` object is where you would specify what type of ranking data you want to download for the venue. Only specify what you will actually use, to minimize transfer time.
      *
      * See below for an example a `things` object with the available ranking properties specified:
      *
      *	things: {
      *		venue: [],
      *		locations: [],
      *		categories: [],
      *		maps: [],
      *		rankings: ['polygons'],
      *	}
      *
      * @class MappedinRankings
      */
    export class MappedinRankings {
        #private;
        constructor(data: any);
        polygons: TPolygonRanking[];
        static hydrate(rankings: any): MappedinRankings;
        static fetch(mappedin: Mappedin): Promise<MappedinRankings | null>;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinLocationRankings' {
    import type { Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { TLocation } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    /** One of these contains all the venue's rankings. * */
    export class MappedinLocationRankings {
        #private;
        constructor(data: any);
        locations: TLocation[];
        static hydrate(locationRankings: any): MappedinLocationRankings;
        static fetch(mappedin: Mappedin): Promise<MappedinLocationRankings>;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinEvent' {
    import type { TImage } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    import type { MappedinLocation, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * An event such as a promotion attached to a location in a venue for a period of time. Events can be created in the Mappedin CMS.
        *
        * @class MappedinEvent
        */
    export class MappedinEvent {
            #private;
            /**
                * Unique id string of the event.
                */
            id: string;
            type: string;
            /**
                * Event name
                */
            name: string;
            /**
                * Optional, longer description of the event.
                */
            description?: string | undefined;
            /**
                * Optional image to be used for displaying the event.
                */
            image?: TImage | undefined;
            /**
                * Start timestamp of the event. Javascript date in milliseconds since 1 January 1970 UTC.
                */
            startDate?: number | undefined;
            /**
                * Start timestamp of the event. Javascript date in milliseconds since 1 January 1970 UTC.
                */
            endDate?: number | undefined;
            /**
                * Timestamp when the event should be displayed. Javascript date in milliseconds since 1 January 1970 UTC.
                */
            showDate?: number | undefined;
            /**
                * @internal
                */
            constructor(mappedin: Mappedin, data: any);
            /**
                * Location this event is occuring at.
                */
            location(): MappedinLocation | undefined;
            /**
                * @internal
                */
            static hydrate(events: any, mappedin: Mappedin): MappedinEvent[];
            /**
                * @internal
                */
            static fetch(mappedin: Mappedin): Promise<MappedinEvent[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinLocationState' {
    import type { Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * A location state, that can belong to any number of {@link MappedinLocation}s.
        * @class MappedinLocationState
        */
    export class MappedinLocationState {
            #private;
            /**
                * @internal
                */
            constructor(data: any);
            /**
                * @internal
                */
            static hydrate(locationStates: any): MappedinLocationState[];
            id: string;
            name: string;
            value: string;
            /**
                * @internal
                */
            static fetch(mappedin: Mappedin): Promise<MappedinLocationState[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinMap' {
    import type { MappedinMapGroup, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    import type { TGeoReference } from '@mappedin/mappedin-js/get-venue/Mappedin.API.types';
    import { MappedinPolygon, MappedinLocation, MappedinCoordinate } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * A {@link MappedinMap} belonging to a specific {@link MappedinVenue}. Typically represents a certain floor. Give this to a {@link MapView} to display to the user.
        *
        * A Map can have more properties such as 'elevation', 'name' (e.g. Level 1), and 'shortName' (e.g. L1). The elevation property can be used to determine the order of the floors (first, second, etc). Elevation is 0 based, going up and down in integers representing the number of floors above or below 0, which is ground level.
        *
        * The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Maps. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Map properties specified:
        *
        *	things: {
        *		venue: [],
        *		locations: [],
        *		categories: [],
        *		maps: ['name', 'elevation', 'shortName']
        * 	}
        *
        * @class MappedinMap
        */
    export class MappedinMap {
            #private;
            id: string;
            group: string;
            name: string;
            shortName: string;
            elevation: number;
            subtitle?: string;
            scale?: number;
            layers: {
                    visible: boolean;
                    name: string;
                    id: string;
            }[];
            x_scale?: number;
            perspectiveId?: string;
            scene: any;
            width: number;
            height: number;
            georeference: TGeoReference[];
            constructor(mappedin: Mappedin, data: any);
            _scale: number;
            /**
                * Polygons on this Map.
                *
                * @property polygons {[MappedinPolygon]}
                */
            get polygons(): MappedinPolygon[] | undefined;
            /**
                * Locations on this map
                */
            get locations(): MappedinLocation[];
            get nodes(): import("./MappedinNode").MappedinNode[];
            /**
                * Map Group this map belongs to.
                *
                * @property mapGroup {MappedinMapGroup}
                */
            get mapGroup(): MappedinMapGroup | null;
            /**
                * Create coordinate using mappedin units
                * @internal
                *
                * @param x x of coordinate
                * @param y y of coordinate
                */
            createCoordinateByXY(x: number, y: number): MappedinCoordinate;
            /**
                * Create coordinate using lat/lon
                *
                * @param lat latitude of coordinate
                * @param lon longitude of coordinate
                */
            createCoordinate(lat: number, lon: number): MappedinCoordinate;
            /**
                *
                * @returns map rotation in radians from north
                */
            getNorth(): any;
            static hydrate(maps: any, mappedin: Mappedin): MappedinMap[];
            static fetch(mappedin: Mappedin): Promise<MappedinMap[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/MappedinMapGroup' {
    import type { MappedinMap, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    /**
        * A {@link MappedinMapGroup} is a collection of maps, usually representing the different floors of a single building. All Maps will be in a MapGroup, but if your Venue is only a single building (like a mall) you can likely ignore MapGroups entirely.
        *
        * @class MappedinMapGroup
        */
    export class MappedinMapGroup {
            #private;
            id: string;
            name: string;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Maps within this MapGroup.
                *
                * @property maps {[MappedinMap]}
                */
            get maps(): MappedinMap[];
            static hydrate(mapGroups: any, mappedin: Mappedin): MappedinMapGroup[];
            static fetch(mappedin: Mappedin): Promise<MappedinMapGroup[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/get-venue/utils' {
    import type { TGetVenueOptions, TGetVenueOptionsInternal } from '@mappedin/mappedin-js/get-venue/Mappedin.types';
    import type { MappedinMap } from '@mappedin/mappedin-js/get-venue/internal';
    import { Mappedin, MappedinNavigatable, MappedinNode, MappedinPolygon, MappedinLocation, MappedinCoordinate } from '@mappedin/mappedin-js/get-venue/internal';
    export function isGatewayKey(key: string): boolean;
    export function stringifyQuery(query: any, gateway?: boolean): string;
    export function buildUrl(options: TGetVenueOptionsInternal & TGetVenueOptions, pathname: string, query: any, supplementary?: boolean): string;
    /**
        * Make a network request to the Mappedin API to fetch an array of objects.
        * @param options options from getVenue- baseUrl and supplementaryUrl are used
        * @param pathname the type of data to request (like polygons or nodes)
        * @param query extra parameters to pass in the request
        * @param supplementary whether to use the supplementaryUrl when sending the request
        * @returns the result json
        */
    export function getArray(options: TGetVenueOptionsInternal & TGetVenueOptions, pathname: string, query: any, supplementary?: boolean): Promise<any>;
    /**
        * Make a network request to the Mappedin API to fetch an object.
        * @param options options from getVenue- baseUrl and supplementaryUrl are used
        * @param pathname the type of data to request (like polygons or nodes)
        * @param query extra parameters to pass in the request
        * @param supplementary whether to use the supplementaryUrl when sending the request
        * @param isExpectingArray whether the endpoint returns an array
        * @returns the result json
        */
    export function getObject(options: TGetVenueOptionsInternal & TGetVenueOptions, pathname: string, query: any, supplementary?: boolean, isExpectingArray?: boolean): Promise<any>;
    /**
        * Prepares the request and URL fields to pass into generateAPIRequest
        * @param options options from getVenue- baseUrl and supplementaryUrl are used
        * @param url string describing the url corresponding to the client's request
        * @param supplementary whether to use the supplementaryUrl when sending the request
        */
    export function constructParamsForRequest(options: TGetVenueOptionsInternal & TGetVenueOptions, url: string, supplementary?: boolean): {
            req: {
                    method: string;
                    headers: any;
            };
            url: string;
    };
    export function generateAPIRequest(options: TGetVenueOptionsInternal & TGetVenueOptions, url: string, supplementary?: boolean): Promise<any>;
    export function addToSet(array: any, value: any): void;
    export function getDistanceBetweenLatLon([lat1, lon1]: [number, number], [lat2, lon2]: [number, number]): any;
    export function getMapScale(map: MappedinMap): any;
    export function getNodesForNavigatable(obj: MappedinNavigatable): string[];
    export function populateBundledImagesAsBlobs(data: any): Promise<any>;
    export function getNearestNode(nodes: MappedinNode[], nodeOrCoordinate: MappedinNode | MappedinCoordinate): MappedinNode;
    export function debounce(func: any, wait: any, immediate?: any): (...args: any[]) => void;
    /**
        * Normalize the sortOrder value between 1 and 2, excluding 1 and 2.
        * Smaller sortOrder numbers result in higher priority (closer to 2) while higher numbers result in lower (closer to 1).
        * Provide an additional polygonRank for more granular ranking.
        * @param sortOrder the value of the category's sortOrder
        * @param min minimum sortOrder
        * @param max maximum sortOrder
        * @param polygonRank optional polygonRank between 0 and 1
        * @returns the normalized value
        */
    export function normalizeCategoryRank(sortOrder: number, min: number, max: number, polygonRank?: number): number;
    export function getDeviceID(): string;
    export function getSessionID(): string;
    /**
        * Finds the main Location associated with a Polygon. This means a Location
        * attached to the Polygon that has no parents, or, if there are none of those,
        * a Location nearest the top of some hierarchy that does have the Polygon attached.
        *
        * This means if there are multiple hierarchies of Locations attached to the Polygon,
        * the one that gets returned is not guaranteed to be what you want.
        *
        * @method getPrimaryLocationForPolygon
        * @param polygon {MappedinPolygon} The Polygon you want the primary Location of.
        * @return {MappedinLocation}
        */
    export const getPrimaryLocationForPolygon: (polygon: MappedinPolygon | string | undefined, venue: Mappedin) => MappedinLocation | null;
}

declare module '@mappedin/mappedin-js/get-venue/Mappedin.cache' {
    import { MappedinNode, MappedinPolygon, MappedinLocation, MappedinCategory, MappedinVortex, MappedinRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, Mappedin } from '@mappedin/mappedin-js/get-venue/internal';
    class MappedinCache {
        #private;
        constructor(mappedin: Mappedin);
        /**
          * Caches for getCollectionById function in `Mappedin.ts`
          * `!` is fine here, we're telling typescript that these
          * fields will be initialized at a later time (aka lazy)
          */
        categories: {
            [id: string]: MappedinCategory;
        };
        locations: {
            [id: string]: MappedinLocation;
        };
        vortexes: {
            [id: string]: MappedinVortex;
        };
        maps: {
            [id: string]: MappedinMap;
        };
        nodes: {
            [id: string]: MappedinNode;
        };
        polygons: {
            [id: string]: MappedinPolygon;
        };
        events: {
            [id: string]: MappedinEvent;
        };
        mapGroups: {
            [id: string]: MappedinMapGroup;
        };
        locationStates: {
            [id: string]: MappedinLocationState;
        };
        rankings: {
            [id: string]: MappedinRankings;
        };
        languages: {
            [id: string]: string;
        };
        get polygonsByMapId(): Map<string, MappedinPolygon[]>;
        get nodesByMapId(): Map<string, MappedinNode[]>;
        findNearestNodeOnMap(mapId: string, coordinate: MappedinCoordinate): MappedinNode;
        get locationsByMapId(): Map<string, MappedinLocation[]>;
        static instances: Map<Mappedin, MappedinCache>;
        static create(mappedin: Mappedin): MappedinCache;
        static clear(): void;
        static clearInstance(mappedin: Mappedin): void;
    }
    export default MappedinCache;
}

declare module '@mappedin/mappedin-js/renderer/internal/shave-text' {
    export type TDrawFn = (ctx: CanvasRenderingContext2D, x: number, y: number) => void;
    type TShave = (str: string, size: number, maxWidth: number, maxLines?: number, lineHeight?: number, options?: {
        strokeText: boolean;
    }) => {
        maxWidth: number;
        maxHeight: number;
        lines: number;
        draw: TDrawFn;
    };
    export const getMeasureCanvas: () => {
        measureCanvas: HTMLCanvasElement | undefined;
        measureCanvasContext: CanvasRenderingContext2D;
    };
    export const shaveText: TShave;
    export {};
}

declare module '@mappedin/mappedin-js/navigator/Edge' {
    import INode from '@mappedin/mappedin-js/navigator/interfaces/INode';
    import IVortex from '@mappedin/mappedin-js/navigator/interfaces/IVortex';
    class Edge {
        origin: INode;
        destination: INode;
        vortex?: IVortex;
        distance: number;
        angle: number;
        weight: number;
        constructor({ origin, destination, vortex, elevationDelta, distance, angle, pathWeight, }: {
            origin: INode;
            destination: INode;
            vortex?: IVortex;
            elevationDelta?: number;
            distance?: number;
            angle?: number;
            pathWeight?: number;
        });
    }
    export default Edge;
}

declare module '@mappedin/mappedin-js/navigator/interfaces/IMap' {
    interface IGeoReference {
        target: {
            x: number;
            y: number;
        };
        control: {
            x: number;
            y: number;
        };
    }
    interface IMap {
        id: string;
        name: string;
        shortName: string;
        elevation?: number;
        scale?: number;
        x_scale?: number;
        georeference?: IGeoReference[];
        [propName: string]: any;
    }
    export default IMap;
}

declare module '@mappedin/mappedin-js/navigator/interfaces/INode' {
    interface INode {
        id: string;
        x: number;
        y: number;
        map: string;
        externalId?: string;
        [propName: string]: any;
    }
    export default INode;
}

declare module '@mappedin/mappedin-js/navigator/interfaces/IVortex' {
    interface IVortex {
        id: string;
        name: string;
        type: string;
        weight: number;
        multiplier: number;
        [propName: string]: any;
    }
    export default IVortex;
}

declare module '@mappedin/mappedin-js/navigator/Navigator.utils' {
    export type TCoordinate = {
            x: number;
            y: number;
    };
    /**
        * Modified line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
        * Determines the intersection point of two line segments.
        * Return null if the lines don't intersect.
        */
    export function getLineIntersection(line1Point1: TCoordinate, line1Point2: TCoordinate, line2Point1: TCoordinate, line2Point2: TCoordinate): {
            x: number;
            y: number;
    } | null;
    /**
        * Offsets a line between two nodes by a certain distance.
        */
    export function getOffsetLine(point1: TCoordinate, point2: TCoordinate, offset: number): {
            x: number;
            y: number;
    }[];
    /**
        * Determines if there is a line of sight between two nodes.
        */
    export function hasLineOfSight(origin: TCoordinate, destination: TCoordinate, edges?: TCoordinate[][], bufferRadius?: number): boolean;
}

declare module '@mappedin/mappedin-js/navigator/interfaces/ILocation' {
    interface ILocation {
        id: string;
        name: string;
        [propName: string]: any;
    }
    export default ILocation;
}

declare module '@mappedin/mappedin-js/navigator/interfaces/IPolygon' {
    interface IPolygon {
        id: string;
        map: string;
        layer?: string;
        layerId?: string;
        externalId?: string;
        name?: string;
        vertexes: {
            x: number;
            y: number;
        }[];
    }
    export default IPolygon;
}

declare module '@mappedin/mappedin-js/renderer/internal/quad-tree' {
    export function contains(rect1: Rectangle, rect2: Rectangle): boolean;
    export function intersects(rect1: Rectangle, rect2: Rectangle): boolean;
    export function intersectPoint(rect1: Rectangle, point: Point2D): boolean;
    export type Point2D = [number, number];
    class Rectangle<T = unknown> {
        x: number;
        y: number;
        w: number;
        h: number;
        userData: T;
        constructor(x: number, y: number, w: number, h: number, userData?: T);
        contains(rectangle: Rectangle): boolean;
        intersects(rectangle: Rectangle): boolean;
        intersectsPoint(point: Point2D): boolean;
        draw(context: CanvasRenderingContext2D): void;
    }
    class QuadTree<T = unknown> {
        boundary: Rectangle<T>;
        capacity: number;
        objects: Rectangle<T>[];
        topLeft: QuadTree<T>;
        topRight: QuadTree<T>;
        bottomLeft: QuadTree<T>;
        bottomRight: QuadTree<T>;
        divided: boolean;
        parent?: QuadTree<T>;
        getSize(): any;
        constructor(boundary: Rectangle<T>, parent?: QuadTree<T>);
        subdivide(): void;
        queryRect(rectangle: Rectangle): Rectangle<T>[];
        queryPoint(point: Point2D): Rectangle<T>[];
        insert(rectangle: Rectangle<T>): boolean;
        drawObjects(context: CanvasRenderingContext2D): void;
        draw(context: CanvasRenderingContext2D): void;
    }
    export { QuadTree, Rectangle };
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.EffectComposer' {
    import { N8AOPostPass } from 'n8ao';
    import { EffectComposer as PPEffectComposer, EffectPass, Pass, ShaderPass, RenderPass, ClearPass, Effect, SMAAPreset } from 'postprocessing';
    import type { PerspectiveCamera, Scene, Texture, Mesh } from 'three';
    import { Uniform } from 'three';
    import type { TAntialiasConfiguration, TAOConfiguration, TMapViewOptions } from '@mappedin/mappedin-js/renderer/MapView.types';
    export type TCompositeUniforms = {
        animatedColorOpacity: Uniform;
        inputBuffer: Uniform;
        staticSceneColorTexture: Uniform;
        staticSceneDepthTexture: Uniform;
        animatedSceneColorTexture: Uniform;
        animatedSceneDepthTexture: Uniform;
        alwaysOnTopSceneColorTexture: Uniform;
        alwaysOnBottomSceneColorTexture: Uniform;
    };
    type TAmbientOcclusionOptions = Pick<TMapViewOptions, 'aoQuality' | 'aoResolution' | 'aoEnabled'>;
    type TAntialiasOptions = Pick<TMapViewOptions, 'antialias' | 'antialiasQuality'>;
    export type TPostProcessingOptions = TAmbientOcclusionOptions & TAntialiasOptions & {
        compositeUniforms?: TCompositeUniforms;
    };
    export type TPass = (RenderPass | ShaderPass | EffectPass | AmbientOcclusionPass) & {
        name: string;
    };
    export enum EAOQualities {
        performance = "Performance",
        low = "Low",
        medium = "Medium",
        high = "High",
        ultra = "Ultra"
    }
    export enum EPass {
        RenderPass = "RenderPass",
        CompositeRenderPass = "CompositeRenderPass",
        AmbientOcclusionPass = "AmbientOcclusionPass",
        EffectsPassAntialiasEnabled = "EffectsPassAntialiasEnabled",
        EffectsPassAntialiasDisabled = "EffectsPassAntialiasDisabled",
        FinalPass = "FinalPass"
    }
    export enum EEffect {
        SMAA = "SMAAEffect",
        Outline = "OutlineEffect"
    }
    export class CustomRenderPass extends Pass {
        effectComposer: EffectComposer;
        clearPass: ClearPass;
        constructor(effectComposer: any);
        render(renderer: any, inputBuffer: any, outputBuffer: any, deltaTime: any, stencilTest: any): void;
        initialize(_: any, __: any, frameBufferType: any): void;
    }
    export class AmbientOcclusionPass extends N8AOPostPass {
        effectComposer: EffectComposer;
        cachePass: ShaderPass;
        enabled: boolean;
        constructor(effectComposer: EffectComposer, configuration: TAOConfiguration);
        setAOConfiguration(configuration: TAOConfiguration): void;
        setQualityMode(aoQuality: any): void;
        get distanceFalloff(): number;
        initialize(renderer: any, alpha: any, frameBufferType: any): void;
        render(renderer: any, inputBuffer: any, outputBuffer: any, deltaTime: any, stencilTest: any): void;
    }
    export class CustomEffectPass extends EffectPass {
        constructor(camera?: PerspectiveCamera, ...effects: Effect[]);
        getEffects(): Effect[];
        getEffectByName(name: EEffect): Effect | null;
    }
    export class EffectComposer {
        options: TPostProcessingOptions & Required<Pick<TPostProcessingOptions, 'antialias' | 'antialiasQuality' | 'aoEnabled' | 'aoQuality' | 'aoResolution'>>;
        isWebGL2: boolean;
        effectComposer: PPEffectComposer;
        scene: Scene;
        camera: PerspectiveCamera;
        depthTexture?: Texture;
        renderer: any;
        constructor(renderer: any, options: TPostProcessingOptions);
        get initialized(): boolean;
        init(scene: Scene, camera: PerspectiveCamera): void;
        render(): void;
        setSize(width: number, height: number): void;
        getPassByName(passName: EPass): TPass | null;
        getEffectsByName(name: EEffect): Effect[];
        setAmbientOcclusionConfiguration(configuration: TAOConfiguration): void;
        setAntialiasConfiguration(configuration: TAntialiasConfiguration): void;
        setPolygonOutlineColor(color: string): void;
        addSelectionForOutline(polygonMesh: Mesh): void;
        removeSelectionForOutline(polygonMesh: Mesh): void;
        getOutlineEffect(): Effect;
        getAntialiasingPreset(): SMAAPreset;
        getAntialiasingEffect(): Effect;
    }
    export {};
}

declare module '@mappedin/mappedin-js/renderer/internal/Mappedin.MultiFloorView' {
    export namespace VIEW_STATE {
        let SINGLE_FLOOR: string;
        let MULTI_FLOOR: string;
    }
    export namespace START {
        let TOP: string;
        let BOTTOM: string;
    }
    export namespace DIR {
        let DOWN: string;
        let UP: string;
    }
    export default MultiFloorView;
    class MultiFloorView {
        constructor(mapView: any, object: any, maps: any, options: any);
        _focusMapsStart: string;
        _focusMapsDir: string;
        _focusMapsLen: number;
        _focusAnimCurve: any;
        _focusAnimDuration: number;
        rotationAxis: any;
        mapBoundingBoxes: any[];
        _helperBoundingBoxes: any[];
        mapAxesHelpers: any[];
        mapView: any;
        object: any;
        options: any;
        padding: any;
        rotation: any;
        maps: any;
        debug: any;
        mapSpacing: number;
        mapTilt: number;
        resize(): void;
        focusOnMaps({ start, len, dir, mapIndices, duration, curve, }?: {
            start?: string | undefined;
            len?: number | undefined;
            dir?: string | undefined;
            mapIndices: any;
            duration?: number | undefined;
            curve?: any;
        }): Promise<any>;
        get viewPortHeight(): number;
        get viewPortWidth(): number;
        positionMaps(): void;
        addMaps(maps: any): void;
        removeMaps(): void;
        addMapBoundingBoxes(): void;
        removeMapBoundingBoxes(): void;
        removeHelperBoundingBoxes(): void;
        addAxesHelpers(): void;
        removeAxesHelpers(): void;
        set mapTiltDegrees(arg: number);
        get mapTiltDegrees(): number;
        /**
         * Display 2D screen projections of each 3D map object in the journey. Useful for drawing 2D elements on screen.
       *
         * @attribute projections
         * @readOnly
       *
         * @returns {Array} Array for Objects with min/max x/y values
         * @example
    
        projections = [{
            max: {
                x: 1062.4393974378236,
                y: 745.7583492891705
            },
            min: {
                x: 17.560602562176346,
                y: 225.0806956450056
            }
        ...
        ]
         */
        get projections(): any[];
        tiltMaps(tiltRad: any): void;
        _focusBox: any;
        _scrollWindow: number | undefined;
        tween: any;
        getFocusMaps(start: any, dir: any, len: any): any;
        getFocusBox(): any;
        getVisibleMaps(): any;
        getVisibleMapIds(): any;
        getVisibleMapIndices(): number[];
        getMapsByIndices(indices: any): any;
        get bottomMapVisible(): any;
        get topMapVisible(): any;
        scrollMapsUp(): Promise<any>;
        scrollMapsDown(): Promise<any>;
        destroy(): void;
    }
}

