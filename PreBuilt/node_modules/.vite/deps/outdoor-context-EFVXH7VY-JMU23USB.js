import {
  fe,
  ue
} from "./chunk-FBLCN4N2.js";
import {
  c
} from "./chunk-HTJBKITB.js";
import {
  q,
  s,
  t,
  u
} from "./chunk-JTA7SHR4.js";
import "./chunk-LQ2VYIYD.js";

// node_modules/@mappedin/mappedin-js/lib/esm/renderer/outdoor-context-EFVXH7VY.js
var Pe = s((e53, t3) => {
  "use strict";
  function r(e54, t4) {
    this.x = e54, this.y = t4;
  }
  c(), t3.exports = r, q(r, "Point"), r.prototype = { clone: function() {
    return new r(this.x, this.y);
  }, add: function(e54) {
    return this.clone()._add(e54);
  }, sub: function(e54) {
    return this.clone()._sub(e54);
  }, multByPoint: function(e54) {
    return this.clone()._multByPoint(e54);
  }, divByPoint: function(e54) {
    return this.clone()._divByPoint(e54);
  }, mult: function(e54) {
    return this.clone()._mult(e54);
  }, div: function(e54) {
    return this.clone()._div(e54);
  }, rotate: function(e54) {
    return this.clone()._rotate(e54);
  }, rotateAround: function(e54, t4) {
    return this.clone()._rotateAround(e54, t4);
  }, matMult: function(e54) {
    return this.clone()._matMult(e54);
  }, unit: function() {
    return this.clone()._unit();
  }, perp: function() {
    return this.clone()._perp();
  }, round: function() {
    return this.clone()._round();
  }, mag: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, equals: function(e54) {
    return this.x === e54.x && this.y === e54.y;
  }, dist: function(e54) {
    return Math.sqrt(this.distSqr(e54));
  }, distSqr: function(e54) {
    var t4 = e54.x - this.x, r3 = e54.y - this.y;
    return t4 * t4 + r3 * r3;
  }, angle: function() {
    return Math.atan2(this.y, this.x);
  }, angleTo: function(e54) {
    return Math.atan2(this.y - e54.y, this.x - e54.x);
  }, angleWith: function(e54) {
    return this.angleWithSep(e54.x, e54.y);
  }, angleWithSep: function(e54, t4) {
    return Math.atan2(this.x * t4 - this.y * e54, this.x * e54 + this.y * t4);
  }, _matMult: function(e54) {
    var t4 = e54[0] * this.x + e54[1] * this.y, r3 = e54[2] * this.x + e54[3] * this.y;
    return this.x = t4, this.y = r3, this;
  }, _add: function(e54) {
    return this.x += e54.x, this.y += e54.y, this;
  }, _sub: function(e54) {
    return this.x -= e54.x, this.y -= e54.y, this;
  }, _mult: function(e54) {
    return this.x *= e54, this.y *= e54, this;
  }, _div: function(e54) {
    return this.x /= e54, this.y /= e54, this;
  }, _multByPoint: function(e54) {
    return this.x *= e54.x, this.y *= e54.y, this;
  }, _divByPoint: function(e54) {
    return this.x /= e54.x, this.y /= e54.y, this;
  }, _unit: function() {
    return this._div(this.mag()), this;
  }, _perp: function() {
    var e54 = this.y;
    return this.y = this.x, this.x = -e54, this;
  }, _rotate: function(e54) {
    var t4 = Math.cos(e54), r3 = Math.sin(e54), i = t4 * this.x - r3 * this.y, a = r3 * this.x + t4 * this.y;
    return this.x = i, this.y = a, this;
  }, _rotateAround: function(e54, t4) {
    var r3 = Math.cos(e54), i = Math.sin(e54), a = t4.x + r3 * (this.x - t4.x) - i * (this.y - t4.y), n = t4.y + i * (this.x - t4.x) + r3 * (this.y - t4.y);
    return this.x = a, this.y = n, this;
  }, _round: function() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  } }, r.convert = function(e54) {
    return e54 instanceof r ? e54 : Array.isArray(e54) ? new r(e54[0], e54[1]) : e54;
  };
});
var gc = s((e53, t3) => {
  "use strict";
  function r(e54, t4, r3, i) {
    this.cx = 3 * e54, this.bx = 3 * (r3 - e54) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t4, this.by = 3 * (i - t4) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e54, this.p1y = t4, this.p2x = r3, this.p2y = i;
  }
  c(), t3.exports = r, q(r, "UnitBezier"), r.prototype = { sampleCurveX: function(e54) {
    return ((this.ax * e54 + this.bx) * e54 + this.cx) * e54;
  }, sampleCurveY: function(e54) {
    return ((this.ay * e54 + this.by) * e54 + this.cy) * e54;
  }, sampleCurveDerivativeX: function(e54) {
    return (3 * this.ax * e54 + 2 * this.bx) * e54 + this.cx;
  }, solveCurveX: function(e54, t4) {
    if (void 0 === t4 && (t4 = 1e-6), e54 < 0)
      return 0;
    if (e54 > 1)
      return 1;
    for (var r3 = e54, i = 0; i < 8; i++) {
      var a = this.sampleCurveX(r3) - e54;
      if (Math.abs(a) < t4)
        return r3;
      var n = this.sampleCurveDerivativeX(r3);
      if (Math.abs(n) < 1e-6)
        break;
      r3 -= a / n;
    }
    var s3 = 0, o = 1;
    for (r3 = e54, i = 0; i < 20 && (a = this.sampleCurveX(r3), !(Math.abs(a - e54) < t4)); i++)
      e54 > a ? s3 = r3 : o = r3, r3 = 0.5 * (o - s3) + s3;
    return r3;
  }, solve: function(e54, t4) {
    return this.sampleCurveY(this.solveCurveX(e54, t4));
  } };
});
var vx = s((e53, t3) => {
  function r(e54, t4) {
    var r3, i, a, n, s3, o, l, u3;
    for (r3 = 3 & e54.length, i = e54.length - r3, a = t4, s3 = 3432918353, o = 461845907, u3 = 0; u3 < i; )
      l = 255 & e54.charCodeAt(u3) | (255 & e54.charCodeAt(++u3)) << 8 | (255 & e54.charCodeAt(++u3)) << 16 | (255 & e54.charCodeAt(++u3)) << 24, ++u3, a = 27492 + (65535 & (n = 5 * (65535 & (a = (a ^= l = (65535 & (l = (l = (65535 & l) * s3 + (((l >>> 16) * s3 & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | a >>> 19)) + ((5 * (a >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (n >>> 16) & 65535) << 16);
    switch (l = 0, r3) {
      case 3:
        l ^= (255 & e54.charCodeAt(u3 + 2)) << 16;
      case 2:
        l ^= (255 & e54.charCodeAt(u3 + 1)) << 8;
      case 1:
        a ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & e54.charCodeAt(u3))) * s3 + (((l >>> 16) * s3 & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
    }
    return a ^= e54.length, a = 2246822507 * (65535 & (a ^= a >>> 16)) + ((2246822507 * (a >>> 16) & 65535) << 16) & 4294967295, a = 3266489909 * (65535 & (a ^= a >>> 13)) + ((3266489909 * (a >>> 16) & 65535) << 16) & 4294967295, (a ^= a >>> 16) >>> 0;
  }
  c(), q(r, "murmurhash3_32_gc"), typeof t3 < "u" && (t3.exports = r);
});
var wx = s((e53, t3) => {
  function r(e54, t4) {
    for (var r3, i = e54.length, a = t4 ^ i, n = 0; i >= 4; )
      r3 = 1540483477 * (65535 & (r3 = 255 & e54.charCodeAt(n) | (255 & e54.charCodeAt(++n)) << 8 | (255 & e54.charCodeAt(++n)) << 16 | (255 & e54.charCodeAt(++n)) << 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ (r3 = 1540483477 * (65535 & (r3 ^= r3 >>> 24)) + ((1540483477 * (r3 >>> 16) & 65535) << 16)), i -= 4, ++n;
    switch (i) {
      case 3:
        a ^= (255 & e54.charCodeAt(n + 2)) << 16;
      case 2:
        a ^= (255 & e54.charCodeAt(n + 1)) << 8;
      case 1:
        a = 1540483477 * (65535 & (a ^= 255 & e54.charCodeAt(n))) + ((1540483477 * (a >>> 16) & 65535) << 16);
    }
    return a = 1540483477 * (65535 & (a ^= a >>> 13)) + ((1540483477 * (a >>> 16) & 65535) << 16), (a ^= a >>> 15) >>> 0;
  }
  c(), q(r, "murmurhash2_32_gc"), void 0 !== typeof t3 && (t3.exports = r);
});
var Vh = s((e53, t3) => {
  c();
  var r = vx(), i = wx();
  t3.exports = r, t3.exports.murmur3 = r, t3.exports.murmur2 = i;
});
var gf = s((e53, t3) => {
  "use strict";
  c();
  var r = Pe();
  function i(e54, t4, r3, i3, n3) {
    this.properties = {}, this.extent = r3, this.type = 0, this._pbf = e54, this._geometry = -1, this._keys = i3, this._values = n3, e54.readFields(a, this, t4);
  }
  function a(e54, t4, r3) {
    1 == e54 ? t4.id = r3.readVarint() : 2 == e54 ? n(r3, t4) : 3 == e54 ? t4.type = r3.readVarint() : 4 == e54 && (t4._geometry = r3.pos);
  }
  function n(e54, t4) {
    for (var r3 = e54.readVarint() + e54.pos; e54.pos < r3; ) {
      var i3 = t4._keys[e54.readVarint()], a3 = t4._values[e54.readVarint()];
      t4.properties[i3] = a3;
    }
  }
  function s3(e54) {
    var t4 = e54.length;
    if (t4 <= 1)
      return [e54];
    for (var r3, i3, a3 = [], n3 = 0; n3 < t4; n3++) {
      var s4 = o(e54[n3]);
      0 !== s4 && (void 0 === i3 && (i3 = s4 < 0), i3 === s4 < 0 ? (r3 && a3.push(r3), r3 = [e54[n3]]) : r3.push(e54[n3]));
    }
    return r3 && a3.push(r3), a3;
  }
  function o(e54) {
    for (var t4, r3, i3 = 0, a3 = 0, n3 = e54.length, s4 = n3 - 1; a3 < n3; s4 = a3++)
      t4 = e54[a3], i3 += ((r3 = e54[s4]).x - t4.x) * (t4.y + r3.y);
    return i3;
  }
  t3.exports = i, q(i, "VectorTileFeature"), q(a, "readFeature"), q(n, "readTag"), i.types = ["Unknown", "Point", "LineString", "Polygon"], i.prototype.loadGeometry = function() {
    var e54 = this._pbf;
    e54.pos = this._geometry;
    for (var t4, i3 = e54.readVarint() + e54.pos, a3 = 1, n3 = 0, s4 = 0, o3 = 0, l = []; e54.pos < i3; ) {
      if (n3 <= 0) {
        var u3 = e54.readVarint();
        a3 = 7 & u3, n3 = u3 >> 3;
      }
      if (n3--, 1 === a3 || 2 === a3)
        s4 += e54.readSVarint(), o3 += e54.readSVarint(), 1 === a3 && (t4 && l.push(t4), t4 = []), t4.push(new r(s4, o3));
      else {
        if (7 !== a3)
          throw new Error("unknown command " + a3);
        t4 && t4.push(t4[0].clone());
      }
    }
    return t4 && l.push(t4), l;
  }, i.prototype.bbox = function() {
    var e54 = this._pbf;
    e54.pos = this._geometry;
    for (var t4 = e54.readVarint() + e54.pos, r3 = 1, i3 = 0, a3 = 0, n3 = 0, s4 = 1 / 0, o3 = -1 / 0, l = 1 / 0, u3 = -1 / 0; e54.pos < t4; ) {
      if (i3 <= 0) {
        var c3 = e54.readVarint();
        r3 = 7 & c3, i3 = c3 >> 3;
      }
      if (i3--, 1 === r3 || 2 === r3)
        (a3 += e54.readSVarint()) < s4 && (s4 = a3), a3 > o3 && (o3 = a3), (n3 += e54.readSVarint()) < l && (l = n3), n3 > u3 && (u3 = n3);
      else if (7 !== r3)
        throw new Error("unknown command " + r3);
    }
    return [s4, l, o3, u3];
  }, i.prototype.toGeoJSON = function(e54, t4, r3) {
    var a3, n3, o3 = this.extent * Math.pow(2, r3), l = this.extent * e54, c3 = this.extent * t4, h = this.loadGeometry(), p = i.types[this.type];
    function d(e55) {
      for (var t5 = 0; t5 < e55.length; t5++) {
        var r4 = e55[t5], i3 = 180 - 360 * (r4.y + c3) / o3;
        e55[t5] = [360 * (r4.x + l) / o3 - 180, 360 / Math.PI * Math.atan(Math.exp(i3 * Math.PI / 180)) - 90];
      }
    }
    switch (q(d, "project"), this.type) {
      case 1:
        var f = [];
        for (a3 = 0; a3 < h.length; a3++)
          f[a3] = h[a3][0];
        d(h = f);
        break;
      case 2:
        for (a3 = 0; a3 < h.length; a3++)
          d(h[a3]);
        break;
      case 3:
        for (h = s3(h), a3 = 0; a3 < h.length; a3++)
          for (n3 = 0; n3 < h[a3].length; n3++)
            d(h[a3][n3]);
    }
    1 === h.length ? h = h[0] : p = "Multi" + p;
    var m = { type: "Feature", geometry: { type: p, coordinates: h }, properties: this.properties };
    return "id" in this && (m.id = this.id), m;
  }, q(s3, "classifyRings"), q(o, "signedArea");
});
var xf = s((e53, t3) => {
  "use strict";
  c();
  var r = gf();
  function i(e54, t4) {
    this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = e54, this._keys = [], this._values = [], this._features = [], e54.readFields(a, this, t4), this.length = this._features.length;
  }
  function a(e54, t4, r3) {
    15 === e54 ? t4.version = r3.readVarint() : 1 === e54 ? t4.name = r3.readString() : 5 === e54 ? t4.extent = r3.readVarint() : 2 === e54 ? t4._features.push(r3.pos) : 3 === e54 ? t4._keys.push(r3.readString()) : 4 === e54 && t4._values.push(n(r3));
  }
  function n(e54) {
    for (var t4 = null, r3 = e54.readVarint() + e54.pos; e54.pos < r3; ) {
      var i3 = e54.readVarint() >> 3;
      t4 = 1 === i3 ? e54.readString() : 2 === i3 ? e54.readFloat() : 3 === i3 ? e54.readDouble() : 4 === i3 ? e54.readVarint64() : 5 === i3 ? e54.readVarint() : 6 === i3 ? e54.readSVarint() : 7 === i3 ? e54.readBoolean() : null;
    }
    return t4;
  }
  t3.exports = i, q(i, "VectorTileLayer"), q(a, "readLayer"), q(n, "readValueMessage"), i.prototype.feature = function(e54) {
    if (e54 < 0 || e54 >= this._features.length)
      throw new Error("feature index out of bounds");
    this._pbf.pos = this._features[e54];
    var t4 = this._pbf.readVarint() + this._pbf.pos;
    return new r(this._pbf, t4, this.extent, this._keys, this._values);
  };
});
var Ob = s((e53, t3) => {
  "use strict";
  c();
  var r = xf();
  function i(e54, t4) {
    this.layers = e54.readFields(a, {}, t4);
  }
  function a(e54, t4, i3) {
    if (3 === e54) {
      var a3 = new r(i3, i3.readVarint() + i3.pos);
      a3.length && (t4[a3.name] = a3);
    }
  }
  t3.exports = i, q(i, "VectorTile"), q(a, "readTile");
});
var ka = s((e53, t3) => {
  c(), t3.exports.VectorTile = Ob(), t3.exports.VectorTileFeature = gf(), t3.exports.VectorTileLayer = xf();
});
var o_ = s((e53) => {
  c(), e53.read = function(e54, t3, r, i, a) {
    var n, s3, o = 8 * a - i - 1, l = (1 << o) - 1, u3 = l >> 1, c3 = -7, h = r ? a - 1 : 0, p = r ? -1 : 1, d = e54[t3 + h];
    for (h += p, n = d & (1 << -c3) - 1, d >>= -c3, c3 += o; c3 > 0; n = 256 * n + e54[t3 + h], h += p, c3 -= 8)
      ;
    for (s3 = n & (1 << -c3) - 1, n >>= -c3, c3 += i; c3 > 0; s3 = 256 * s3 + e54[t3 + h], h += p, c3 -= 8)
      ;
    if (0 === n)
      n = 1 - u3;
    else {
      if (n === l)
        return s3 ? NaN : 1 / 0 * (d ? -1 : 1);
      s3 += Math.pow(2, i), n -= u3;
    }
    return (d ? -1 : 1) * s3 * Math.pow(2, n - i);
  }, e53.write = function(e54, t3, r, i, a, n) {
    var s3, o, l, u3 = 8 * n - a - 1, c3 = (1 << u3) - 1, h = c3 >> 1, p = 23 === a ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = i ? 0 : n - 1, f = i ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
    for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (o = isNaN(t3) ? 1 : 0, s3 = c3) : (s3 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -s3)) < 1 && (s3--, l *= 2), (t3 += s3 + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (s3++, l /= 2), s3 + h >= c3 ? (o = 0, s3 = c3) : s3 + h >= 1 ? (o = (t3 * l - 1) * Math.pow(2, a), s3 += h) : (o = t3 * Math.pow(2, h - 1) * Math.pow(2, a), s3 = 0)); a >= 8; e54[r + d] = 255 & o, d += f, o /= 256, a -= 8)
      ;
    for (s3 = s3 << a | o, u3 += a; u3 > 0; e54[r + d] = 255 & s3, d += f, s3 /= 256, u3 -= 8)
      ;
    e54[r + d - f] |= 128 * m;
  };
});
var Ef = s((e53, t3) => {
  "use strict";
  c(), t3.exports = i;
  var r = o_();
  function i(e54) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e54) ? e54 : new Uint8Array(e54 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  q(i, "Pbf"), i.Varint = 0, i.Fixed64 = 1, i.Bytes = 2, i.Fixed32 = 5;
  var a = 4294967296, n = 1 / a, s3 = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
  function o(e54, t4, r3) {
    var i3, a3, n3 = r3.buf;
    if (i3 = (112 & (a3 = n3[r3.pos++])) >> 4, a3 < 128 || (i3 |= (127 & (a3 = n3[r3.pos++])) << 3, a3 < 128) || (i3 |= (127 & (a3 = n3[r3.pos++])) << 10, a3 < 128) || (i3 |= (127 & (a3 = n3[r3.pos++])) << 17, a3 < 128) || (i3 |= (127 & (a3 = n3[r3.pos++])) << 24, a3 < 128) || (i3 |= (1 & (a3 = n3[r3.pos++])) << 31, a3 < 128))
      return c3(e54, i3, t4);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function l(e54) {
    return e54.type === i.Bytes ? e54.readVarint() + e54.pos : e54.pos + 1;
  }
  function c3(e54, t4, r3) {
    return r3 ? 4294967296 * t4 + (e54 >>> 0) : 4294967296 * (t4 >>> 0) + (e54 >>> 0);
  }
  function h(e54, t4) {
    var r3, i3;
    if (e54 >= 0 ? (r3 = e54 % 4294967296 | 0, i3 = e54 / 4294967296 | 0) : (i3 = ~(-e54 / 4294967296), 4294967295 ^ (r3 = ~(-e54 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, i3 = i3 + 1 | 0)), e54 >= 18446744073709552e3 || e54 < -18446744073709552e3)
      throw new Error("Given varint doesn't fit into 10 bytes");
    t4.realloc(10), p(r3, i3, t4), f(i3, t4);
  }
  function p(e54, t4, r3) {
    r3.buf[r3.pos++] = 127 & e54 | 128, e54 >>>= 7, r3.buf[r3.pos++] = 127 & e54 | 128, e54 >>>= 7, r3.buf[r3.pos++] = 127 & e54 | 128, e54 >>>= 7, r3.buf[r3.pos++] = 127 & e54 | 128, e54 >>>= 7, r3.buf[r3.pos] = 127 & e54;
  }
  function f(e54, t4) {
    var r3 = (7 & e54) << 4;
    t4.buf[t4.pos++] |= r3 | ((e54 >>>= 3) ? 128 : 0), e54 && (t4.buf[t4.pos++] = 127 & e54 | ((e54 >>>= 7) ? 128 : 0), e54 && (t4.buf[t4.pos++] = 127 & e54 | ((e54 >>>= 7) ? 128 : 0), e54 && (t4.buf[t4.pos++] = 127 & e54 | ((e54 >>>= 7) ? 128 : 0), e54 && (t4.buf[t4.pos++] = 127 & e54 | ((e54 >>>= 7) ? 128 : 0), e54 && (t4.buf[t4.pos++] = 127 & e54)))));
  }
  function m(e54, t4, r3) {
    var i3 = t4 <= 16383 ? 1 : t4 <= 2097151 ? 2 : t4 <= 268435455 ? 3 : Math.floor(Math.log(t4) / (7 * Math.LN2));
    r3.realloc(i3);
    for (var a3 = r3.pos - 1; a3 >= e54; a3--)
      r3.buf[a3 + i3] = r3.buf[a3];
  }
  function y(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeVarint(e54[r3]);
  }
  function g(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeSVarint(e54[r3]);
  }
  function _(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeFloat(e54[r3]);
  }
  function x(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeDouble(e54[r3]);
  }
  function v(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeBoolean(e54[r3]);
  }
  function b(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeFixed32(e54[r3]);
  }
  function w(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeSFixed32(e54[r3]);
  }
  function S(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeFixed64(e54[r3]);
  }
  function A(e54, t4) {
    for (var r3 = 0; r3 < e54.length; r3++)
      t4.writeSFixed64(e54[r3]);
  }
  function M3(e54, t4) {
    return (e54[t4] | e54[t4 + 1] << 8 | e54[t4 + 2] << 16) + 16777216 * e54[t4 + 3];
  }
  function I(e54, t4, r3) {
    e54[r3] = t4, e54[r3 + 1] = t4 >>> 8, e54[r3 + 2] = t4 >>> 16, e54[r3 + 3] = t4 >>> 24;
  }
  function T(e54, t4) {
    return (e54[t4] | e54[t4 + 1] << 8 | e54[t4 + 2] << 16) + (e54[t4 + 3] << 24);
  }
  function C(e54, t4, r3) {
    for (var i3 = "", a3 = t4; a3 < r3; ) {
      var n3, s4, o3, l3 = e54[a3], u3 = null, c4 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
      if (a3 + c4 > r3)
        break;
      1 === c4 ? l3 < 128 && (u3 = l3) : 2 === c4 ? 128 == (192 & (n3 = e54[a3 + 1])) && ((u3 = (31 & l3) << 6 | 63 & n3) <= 127 && (u3 = null)) : 3 === c4 ? (n3 = e54[a3 + 1], s4 = e54[a3 + 2], 128 == (192 & n3) && 128 == (192 & s4) && (((u3 = (15 & l3) << 12 | (63 & n3) << 6 | 63 & s4) <= 2047 || u3 >= 55296 && u3 <= 57343) && (u3 = null))) : 4 === c4 && (n3 = e54[a3 + 1], s4 = e54[a3 + 2], o3 = e54[a3 + 3], 128 == (192 & n3) && 128 == (192 & s4) && 128 == (192 & o3) && (((u3 = (15 & l3) << 18 | (63 & n3) << 12 | (63 & s4) << 6 | 63 & o3) <= 65535 || u3 >= 1114112) && (u3 = null))), null === u3 ? (u3 = 65533, c4 = 1) : u3 > 65535 && (u3 -= 65536, i3 += String.fromCharCode(u3 >>> 10 & 1023 | 55296), u3 = 56320 | 1023 & u3), i3 += String.fromCharCode(u3), a3 += c4;
    }
    return i3;
  }
  function P(e54, t4, r3) {
    return s3.decode(e54.subarray(t4, r3));
  }
  function k(e54, t4, r3) {
    for (var i3, a3, n3 = 0; n3 < t4.length; n3++) {
      if ((i3 = t4.charCodeAt(n3)) > 55295 && i3 < 57344) {
        if (!a3) {
          i3 > 56319 || n3 + 1 === t4.length ? (e54[r3++] = 239, e54[r3++] = 191, e54[r3++] = 189) : a3 = i3;
          continue;
        }
        if (i3 < 56320) {
          e54[r3++] = 239, e54[r3++] = 191, e54[r3++] = 189, a3 = i3;
          continue;
        }
        i3 = a3 - 55296 << 10 | i3 - 56320 | 65536, a3 = null;
      } else
        a3 && (e54[r3++] = 239, e54[r3++] = 191, e54[r3++] = 189, a3 = null);
      i3 < 128 ? e54[r3++] = i3 : (i3 < 2048 ? e54[r3++] = i3 >> 6 | 192 : (i3 < 65536 ? e54[r3++] = i3 >> 12 | 224 : (e54[r3++] = i3 >> 18 | 240, e54[r3++] = i3 >> 12 & 63 | 128), e54[r3++] = i3 >> 6 & 63 | 128), e54[r3++] = 63 & i3 | 128);
    }
    return r3;
  }
  i.prototype = { destroy: function() {
    this.buf = null;
  }, readFields: function(e54, t4, r3) {
    for (r3 = r3 || this.length; this.pos < r3; ) {
      var i3 = this.readVarint(), a3 = i3 >> 3, n3 = this.pos;
      this.type = 7 & i3, e54(a3, t4, this), this.pos === n3 && this.skip(i3);
    }
    return t4;
  }, readMessage: function(e54, t4) {
    return this.readFields(e54, t4, this.readVarint() + this.pos);
  }, readFixed32: function() {
    var e54 = M3(this.buf, this.pos);
    return this.pos += 4, e54;
  }, readSFixed32: function() {
    var e54 = T(this.buf, this.pos);
    return this.pos += 4, e54;
  }, readFixed64: function() {
    var e54 = M3(this.buf, this.pos) + M3(this.buf, this.pos + 4) * a;
    return this.pos += 8, e54;
  }, readSFixed64: function() {
    var e54 = M3(this.buf, this.pos) + T(this.buf, this.pos + 4) * a;
    return this.pos += 8, e54;
  }, readFloat: function() {
    var e54 = r.read(this.buf, this.pos, true, 23, 4);
    return this.pos += 4, e54;
  }, readDouble: function() {
    var e54 = r.read(this.buf, this.pos, true, 52, 8);
    return this.pos += 8, e54;
  }, readVarint: function(e54) {
    var t4, r3, i3 = this.buf;
    return t4 = 127 & (r3 = i3[this.pos++]), r3 < 128 || (t4 |= (127 & (r3 = i3[this.pos++])) << 7, r3 < 128) || (t4 |= (127 & (r3 = i3[this.pos++])) << 14, r3 < 128) || (t4 |= (127 & (r3 = i3[this.pos++])) << 21, r3 < 128) ? t4 : o(t4 |= (15 & (r3 = i3[this.pos])) << 28, e54, this);
  }, readVarint64: function() {
    return this.readVarint(true);
  }, readSVarint: function() {
    var e54 = this.readVarint();
    return e54 % 2 == 1 ? (e54 + 1) / -2 : e54 / 2;
  }, readBoolean: function() {
    return !!this.readVarint();
  }, readString: function() {
    var e54 = this.readVarint() + this.pos, t4 = this.pos;
    return this.pos = e54, e54 - t4 >= 12 && s3 ? P(this.buf, t4, e54) : C(this.buf, t4, e54);
  }, readBytes: function() {
    var e54 = this.readVarint() + this.pos, t4 = this.buf.subarray(this.pos, e54);
    return this.pos = e54, t4;
  }, readPackedVarint: function(e54, t4) {
    if (this.type !== i.Bytes)
      return e54.push(this.readVarint(t4));
    var r3 = l(this);
    for (e54 = e54 || []; this.pos < r3; )
      e54.push(this.readVarint(t4));
    return e54;
  }, readPackedSVarint: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readSVarint());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readSVarint());
    return e54;
  }, readPackedBoolean: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readBoolean());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readBoolean());
    return e54;
  }, readPackedFloat: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readFloat());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readFloat());
    return e54;
  }, readPackedDouble: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readDouble());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readDouble());
    return e54;
  }, readPackedFixed32: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readFixed32());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readFixed32());
    return e54;
  }, readPackedSFixed32: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readSFixed32());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readSFixed32());
    return e54;
  }, readPackedFixed64: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readFixed64());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readFixed64());
    return e54;
  }, readPackedSFixed64: function(e54) {
    if (this.type !== i.Bytes)
      return e54.push(this.readSFixed64());
    var t4 = l(this);
    for (e54 = e54 || []; this.pos < t4; )
      e54.push(this.readSFixed64());
    return e54;
  }, skip: function(e54) {
    var t4 = 7 & e54;
    if (t4 === i.Varint)
      for (; this.buf[this.pos++] > 127; )
        ;
    else if (t4 === i.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (t4 === i.Fixed32)
      this.pos += 4;
    else {
      if (t4 !== i.Fixed64)
        throw new Error("Unimplemented type: " + t4);
      this.pos += 8;
    }
  }, writeTag: function(e54, t4) {
    this.writeVarint(e54 << 3 | t4);
  }, realloc: function(e54) {
    for (var t4 = this.length || 16; t4 < this.pos + e54; )
      t4 *= 2;
    if (t4 !== this.length) {
      var r3 = new Uint8Array(t4);
      r3.set(this.buf), this.buf = r3, this.length = t4;
    }
  }, finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  }, writeFixed32: function(e54) {
    this.realloc(4), I(this.buf, e54, this.pos), this.pos += 4;
  }, writeSFixed32: function(e54) {
    this.realloc(4), I(this.buf, e54, this.pos), this.pos += 4;
  }, writeFixed64: function(e54) {
    this.realloc(8), I(this.buf, -1 & e54, this.pos), I(this.buf, Math.floor(e54 * n), this.pos + 4), this.pos += 8;
  }, writeSFixed64: function(e54) {
    this.realloc(8), I(this.buf, -1 & e54, this.pos), I(this.buf, Math.floor(e54 * n), this.pos + 4), this.pos += 8;
  }, writeVarint: function(e54) {
    (e54 = +e54 || 0) > 268435455 || e54 < 0 ? h(e54, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e54 | (e54 > 127 ? 128 : 0), !(e54 <= 127) && (this.buf[this.pos++] = 127 & (e54 >>>= 7) | (e54 > 127 ? 128 : 0), !(e54 <= 127) && (this.buf[this.pos++] = 127 & (e54 >>>= 7) | (e54 > 127 ? 128 : 0), !(e54 <= 127) && (this.buf[this.pos++] = e54 >>> 7 & 127))));
  }, writeSVarint: function(e54) {
    this.writeVarint(e54 < 0 ? 2 * -e54 - 1 : 2 * e54);
  }, writeBoolean: function(e54) {
    this.writeVarint(!!e54);
  }, writeString: function(e54) {
    e54 = String(e54), this.realloc(4 * e54.length), this.pos++;
    var t4 = this.pos;
    this.pos = k(this.buf, e54, this.pos);
    var r3 = this.pos - t4;
    r3 >= 128 && m(t4, r3, this), this.pos = t4 - 1, this.writeVarint(r3), this.pos += r3;
  }, writeFloat: function(e54) {
    this.realloc(4), r.write(this.buf, e54, this.pos, true, 23, 4), this.pos += 4;
  }, writeDouble: function(e54) {
    this.realloc(8), r.write(this.buf, e54, this.pos, true, 52, 8), this.pos += 8;
  }, writeBytes: function(e54) {
    var t4 = e54.length;
    this.writeVarint(t4), this.realloc(t4);
    for (var r3 = 0; r3 < t4; r3++)
      this.buf[this.pos++] = e54[r3];
  }, writeRawMessage: function(e54, t4) {
    this.pos++;
    var r3 = this.pos;
    e54(t4, this);
    var i3 = this.pos - r3;
    i3 >= 128 && m(r3, i3, this), this.pos = r3 - 1, this.writeVarint(i3), this.pos += i3;
  }, writeMessage: function(e54, t4, r3) {
    this.writeTag(e54, i.Bytes), this.writeRawMessage(t4, r3);
  }, writePackedVarint: function(e54, t4) {
    t4.length && this.writeMessage(e54, y, t4);
  }, writePackedSVarint: function(e54, t4) {
    t4.length && this.writeMessage(e54, g, t4);
  }, writePackedBoolean: function(e54, t4) {
    t4.length && this.writeMessage(e54, v, t4);
  }, writePackedFloat: function(e54, t4) {
    t4.length && this.writeMessage(e54, _, t4);
  }, writePackedDouble: function(e54, t4) {
    t4.length && this.writeMessage(e54, x, t4);
  }, writePackedFixed32: function(e54, t4) {
    t4.length && this.writeMessage(e54, b, t4);
  }, writePackedSFixed32: function(e54, t4) {
    t4.length && this.writeMessage(e54, w, t4);
  }, writePackedFixed64: function(e54, t4) {
    t4.length && this.writeMessage(e54, S, t4);
  }, writePackedSFixed64: function(e54, t4) {
    t4.length && this.writeMessage(e54, A, t4);
  }, writeBytesField: function(e54, t4) {
    this.writeTag(e54, i.Bytes), this.writeBytes(t4);
  }, writeFixed32Field: function(e54, t4) {
    this.writeTag(e54, i.Fixed32), this.writeFixed32(t4);
  }, writeSFixed32Field: function(e54, t4) {
    this.writeTag(e54, i.Fixed32), this.writeSFixed32(t4);
  }, writeFixed64Field: function(e54, t4) {
    this.writeTag(e54, i.Fixed64), this.writeFixed64(t4);
  }, writeSFixed64Field: function(e54, t4) {
    this.writeTag(e54, i.Fixed64), this.writeSFixed64(t4);
  }, writeVarintField: function(e54, t4) {
    this.writeTag(e54, i.Varint), this.writeVarint(t4);
  }, writeSVarintField: function(e54, t4) {
    this.writeTag(e54, i.Varint), this.writeSVarint(t4);
  }, writeStringField: function(e54, t4) {
    this.writeTag(e54, i.Bytes), this.writeString(t4);
  }, writeFloatField: function(e54, t4) {
    this.writeTag(e54, i.Fixed32), this.writeFloat(t4);
  }, writeDoubleField: function(e54, t4) {
    this.writeTag(e54, i.Fixed64), this.writeDouble(t4);
  }, writeBooleanField: function(e54, t4) {
    this.writeVarintField(e54, !!t4);
  } }, q(o, "readVarintRemainder"), q(l, "readPackedEnd"), q(c3, "toNum"), q(h, "writeBigVarint"), q(p, "writeBigVarintLow"), q(f, "writeBigVarintHigh"), q(m, "makeRoomForExtraLength"), q(y, "writePackedVarint"), q(g, "writePackedSVarint"), q(_, "writePackedFloat"), q(x, "writePackedDouble"), q(v, "writePackedBoolean"), q(b, "writePackedFixed32"), q(w, "writePackedSFixed32"), q(S, "writePackedFixed64"), q(A, "writePackedSFixed64"), q(M3, "readUInt32"), q(I, "writeInt32"), q(T, "readInt32"), q(C, "readUtf8"), q(P, "readUtf8TextDecoder"), q(k, "writeUtf8");
});
c();
var po = { name: "maplibre-gl", description: "BSD licensed community fork of mapbox-gl, a WebGL interactive maps library", version: "3.2.0", main: "dist/maplibre-gl.js", style: "dist/maplibre-gl.css", license: "BSD-3-Clause", funding: "https://github.com/maplibre/maplibre-gl-js?sponsor=1", repository: { type: "git", url: "git://github.com/maplibre/maplibre-gl-js.git" }, types: "dist/maplibre-gl.d.ts", type: "module", dependencies: { "@mapbox/geojson-rewind": "^0.5.2", "@mapbox/jsonlint-lines-primitives": "^2.0.2", "@mapbox/point-geometry": "^0.1.0", "@mapbox/tiny-sdf": "^2.0.6", "@mapbox/unitbezier": "^0.0.1", "@mapbox/vector-tile": "^1.3.1", "@mapbox/whoots-js": "^3.1.0", "@maplibre/maplibre-gl-style-spec": "^19.2.2", "@types/geojson": "^7946.0.10", "@types/mapbox__point-geometry": "^0.1.2", "@types/mapbox__vector-tile": "^1.3.0", "@types/pbf": "^3.0.2", earcut: "^2.2.4", "geojson-vt": "^3.2.1", "gl-matrix": "^3.4.3", "global-prefix": "^3.0.0", kdbush: "^4.0.2", "murmurhash-js": "^1.0.0", pbf: "^3.2.1", potpack: "^2.0.0", quickselect: "^2.0.0", supercluster: "^8.0.1", tinyqueue: "^2.0.3", "vt-pbf": "^3.1.3" }, devDependencies: { "@mapbox/mapbox-gl-rtl-text": "^0.2.3", "@mapbox/mvt-fixtures": "^3.10.0", "@rollup/plugin-commonjs": "^25.0.3", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.1.0", "@rollup/plugin-replace": "^5.0.2", "@rollup/plugin-strip": "^3.0.2", "@rollup/plugin-terser": "^0.4.3", "@rollup/plugin-typescript": "^11.1.2", "@types/benchmark": "^2.1.2", "@types/cssnano": "^5.0.0", "@types/d3": "^7.4.0", "@types/diff": "^5.0.3", "@types/earcut": "^2.1.1", "@types/eslint": "^8.44.0", "@types/gl": "^6.0.2", "@types/glob": "^8.1.0", "@types/jest": "^29.5.3", "@types/jsdom": "^21.1.1", "@types/minimist": "^1.2.2", "@types/murmurhash-js": "^1.0.4", "@types/nise": "^1.4.1", "@types/node": "^20.4.2", "@types/offscreencanvas": "^2019.7.0", "@types/pixelmatch": "^5.2.4", "@types/pngjs": "^6.0.1", "@types/react": "^18.2.15", "@types/react-dom": "^18.2.6", "@types/request": "^2.48.8", "@types/shuffle-seed": "^1.1.0", "@types/supercluster": "^7.1.0", "@types/window-or-global": "^1.0.4", "@typescript-eslint/eslint-plugin": "^5.61.0", "@typescript-eslint/parser": "^5.62.0", address: "^1.2.2", benchmark: "^2.1.4", canvas: "^2.11.2", cssnano: "^6.0.1", d3: "^7.8.5", "d3-queue": "^3.0.7", "devtools-protocol": "^0.0.1170846", diff: "^5.1.0", "dts-bundle-generator": "^8.0.1", eslint: "^8.45.0", "eslint-config-mourner": "^3.0.0", "eslint-plugin-html": "^7.1.0", "eslint-plugin-import": "^2.27.5", "eslint-plugin-jest": "^27.2.3", "eslint-plugin-tsdoc": "0.2.17", "eslint-plugin-react": "^7.32.2", expect: "^29.5.0", gl: "^6.0.2", glob: "^10.3.3", "is-builtin-module": "^3.2.1", jest: "^29.6.1", "jest-canvas-mock": "^2.5.2", "jest-environment-jsdom": "^29.6.1", jsdom: "^22.1.0", "json-stringify-pretty-compact": "^4.0.0", minimist: "^1.2.8", "mock-geolocation": "^1.0.11", nise: "^5.1.4", "node-plantuml": "^0.9.0", "npm-font-open-sans": "^1.1.0", "npm-run-all": "^4.1.5", "pdf-merger-js": "^4.3.0", pixelmatch: "^5.3.0", pngjs: "^7.0.0", postcss: "^8.4.26", "postcss-cli": "^10.1.0", "postcss-inline-svg": "^6.0.0", "pretty-bytes": "^6.1.1", puppeteer: "^20.8.2", react: "^18.2.0", "react-dom": "^18.2.0", rollup: "^3.26.2", "rollup-plugin-sourcemaps": "^0.6.3", rw: "^1.3.3", semver: "^7.5.4", "shuffle-seed": "^1.1.6", "source-map-explorer": "^2.5.3", st: "^3.0.0", stylelint: "^15.10.1", "stylelint-config-standard": "^34.0.0", "ts-jest": "^29.1.1", "ts-node": "^10.9.1", tslib: "^2.6.0", typedoc: "^0.24.8", "typedoc-plugin-markdown": "^3.15.3", "typedoc-plugin-missing-exports": "^2.0.0", typescript: "^5.1.6" }, overrides: { "postcss-inline-svg": { "css-select": "^5.1.0", "dom-serializer": "^2.0.0", htmlparser2: "^8.0.1", "postcss-value-parser": "^4.2.0" } }, scripts: { "generate-dist-package": "npm run tsnode build/generate-dist-package.js", "generate-shaders": "npm run tsnode build/generate-shaders.ts", "generate-struct-arrays": "npm run tsnode build/generate-struct-arrays.ts", "generate-style-code": "npm run tsnode build/generate-style-code.ts", "generate-typings": "npm run tsnode build/generate-typings.ts", "generate-docs": "typedoc && npm run tsnode build/generate-docs.ts", "generate-images": "npm run tsnode build/generate-doc-images.ts", "build-dist": "run-p --print-label generate-typings build-dev build-prod build-csp build-csp-dev build-css", "build-dev": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:dev", "watch-dev": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:dev --watch", "build-prod": "rollup --configPlugin @rollup/plugin-typescript -c --environment BUILD:production", "build-csp": "rollup --configPlugin @rollup/plugin-typescript -c rollup.config.csp.ts", "build-csp-dev": "rollup --configPlugin @rollup/plugin-typescript -c rollup.config.csp.ts --environment BUILD:dev", "build-css": "postcss -o dist/maplibre-gl.css src/css/maplibre-gl.css", "build-diagrams": "cd docs/diagrams; ls *.plantuml | xargs -I {} puml generate --svg {} -o {}.svg", "watch-css": "postcss --watch -o dist/maplibre-gl.css src/css/maplibre-gl.css", "build-benchmarks": "npm run build-dev && rollup --configPlugin @rollup/plugin-typescript -c test/bench/rollup_config_benchmarks.ts", "watch-benchmarks": "rollup --configPlugin @rollup/plugin-typescript -c test/bench/rollup_config_benchmarks.ts --watch", "start-server": "st --no-cache -H 0.0.0.0 --port 9966 .", start: "run-p watch-css watch-dev start-server", "start-bench": "run-p watch-css watch-benchmarks start-server", lint: "eslint --cache --ext .ts,.tsx,.js,.html --ignore-path .gitignore .", "lint-css": "stylelint src/css/maplibre-gl.css", test: "run-p lint lint-css test-render jest", jest: "jest", "jest-ci": "jest --reporters=github-actions --reporters=summary", "test-build": "jest --selectProjects=build", "test-integration": "jest --selectProjects=integration", "test-render": "npm run tsnode test/integration/render/run_render_tests.ts", "test-unit": "jest --selectProjects=unit", "test-watch-roots": "jest --watch", codegen: "run-p generate-dist-package generate-style-code generate-struct-arrays generate-shaders", benchmark: "npm run tsnode test/bench/run-benchmarks.ts", "gl-stats": "npm run tsnode test/bench/gl-stats.ts", prepare: "npm run codegen", typecheck: "tsc --noEmit && tsc --project tsconfig.dist.json", tsnode: "node --experimental-loader=ts-node/esm --no-warnings" }, files: ["build/", "dist/*", "src/"], engines: { npm: ">=8.1.0", node: ">=16.14.0" } };
c(), c();
var jy = u(Pe(), 1);
var $y = u(gc(), 1);
function Hy(e53) {
  if (e53 <= 0)
    return 0;
  if (e53 >= 1)
    return 1;
  let t3 = e53 * e53, r = t3 * e53;
  return 4 * (e53 < 0.5 ? r : 3 * (e53 - t3) + r - 0.75);
}
function bc(e53, t3, r, i) {
  let a = new $y.default(e53, t3, r, i);
  return function(e54) {
    return a.solve(e54);
  };
}
q(Hy, "easeCubicInOut"), q(bc, "bezier");
var _c = bc(0.25, 0.1, 0.25, 1);
function Te(e53, t3, r) {
  return Math.min(r, Math.max(t3, e53));
}
function Yt(e53, t3, r) {
  let i = r - t3, a = ((e53 - t3) % i + i) % i + t3;
  return a === t3 ? r : a;
}
function ho(e53, t3, r) {
  if (!e53.length)
    return r(null, []);
  let i = e53.length, a = new Array(e53.length), n = null;
  e53.forEach((e54, s3) => {
    t3(e54, (e55, t4) => {
      e55 && (n = e55), a[s3] = t4, 0 == --i && r(n, a);
    });
  });
}
function Zy(e53, t3) {
  let r = [];
  for (let i in e53)
    i in t3 || r.push(i);
  return r;
}
function R(e53, ...t3) {
  for (let r of t3)
    for (let t4 in r)
      e53[t4] = r[t4];
  return e53;
}
function Bt(e53, t3) {
  let r = {};
  for (let i = 0; i < t3.length; i++) {
    let a = t3[i];
    a in e53 && (r[a] = e53[a]);
  }
  return r;
}
q(Te, "clamp"), q(Yt, "wrap"), q(ho, "asyncAll"), q(Zy, "keysDifference"), q(R, "extend"), q(Bt, "pick");
var pw = 1;
function fo() {
  return pw++;
}
function Wy(e53) {
  return Math.log(e53) / Math.LN2 % 1 == 0;
}
function Xy(e53) {
  return e53 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e53) / Math.LN2));
}
function Tn(e53, t3, r) {
  let i = {};
  for (let a in e53)
    i[a] = t3.call(r || this, e53[a], a, e53);
  return i;
}
function mo(e53, t3, r) {
  let i = {};
  for (let a in e53)
    t3.call(r || this, e53[a], a, e53) && (i[a] = e53[a]);
  return i;
}
function Kt(e53, t3) {
  if (Array.isArray(e53)) {
    if (!Array.isArray(t3) || e53.length !== t3.length)
      return false;
    for (let r = 0; r < e53.length; r++)
      if (!Kt(e53[r], t3[r]))
        return false;
    return true;
  }
  if ("object" == typeof e53 && null !== e53 && null !== t3) {
    if ("object" != typeof t3 || Object.keys(e53).length !== Object.keys(t3).length)
      return false;
    for (let r in e53)
      if (!Kt(e53[r], t3[r]))
        return false;
    return true;
  }
  return e53 === t3;
}
function ut(e53) {
  return Array.isArray(e53) ? e53.map(ut) : "object" == typeof e53 && e53 ? Tn(e53, ut) : e53;
}
function Ky(e53, t3) {
  for (let r = 0; r < e53.length; r++)
    if (t3.indexOf(e53[r]) >= 0)
      return true;
  return false;
}
q(fo, "uniqueId"), q(Wy, "isPowerOfTwo"), q(Xy, "nextPowerOfTwo"), q(Tn, "mapObject"), q(mo, "filterObject"), q(Kt, "deepEqual"), q(ut, "clone"), q(Ky, "arraysIntersect");
var Gy = {};
function Ce(e53) {
  Gy[e53] || (typeof console < "u" && console.warn(e53), Gy[e53] = true);
}
function Jt(e53, t3, r) {
  return (r.y - e53.y) * (t3.x - e53.x) > (t3.y - e53.y) * (r.x - e53.x);
}
function Yy(e53, t3, r, i) {
  let a = t3.y - e53.y, n = t3.x - e53.x, s3 = i.y - r.y, o = i.x - r.x, l = s3 * n - o * a;
  if (0 === l)
    return null;
  let u3 = (o * (e53.y - r.y) - s3 * (e53.x - r.x)) / l;
  return new jy.default(e53.x + u3 * n, e53.y + u3 * a);
}
function Jy(e53) {
  let t3 = 0;
  for (let r, i, a = 0, n = e53.length, s3 = n - 1; a < n; s3 = a++)
    r = e53[a], i = e53[s3], t3 += (i.x - r.x) * (r.y + i.y);
  return t3;
}
function Qy([e53, t3, r]) {
  return t3 += 90, t3 *= Math.PI / 180, r *= Math.PI / 180, { x: e53 * Math.cos(t3) * Math.sin(r), y: e53 * Math.sin(t3) * Math.sin(r), z: e53 * Math.cos(r) };
}
function ct() {
  return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
}
function eg(e53) {
  let t3 = {};
  if (e53.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (e54, r, i, a) => {
    let n = i || a;
    return t3[r] = !n || n.toLowerCase(), "";
  }), t3["max-age"]) {
    let e54 = parseInt(t3["max-age"], 10);
    isNaN(e54) ? delete t3["max-age"] : t3["max-age"] = e54;
  }
  return t3;
}
q(Ce, "warnOnce"), q(Jt, "isCounterClockwise"), q(Yy, "findLineIntersection"), q(Jy, "calculateSignedArea"), q(Qy, "sphericalToCartesian"), q(ct, "isWorker"), q(eg, "parseCacheControl");
var xc = null;
function qr(e53) {
  if (null == xc) {
    let t3 = e53.navigator ? e53.navigator.userAgent : null;
    xc = !!e53.safari || !(!t3 || !(/\b(iPad|iPhone|iPod)\b/.test(t3) || t3.match("Safari") && !t3.match("Chrome")));
  }
  return xc;
}
function Ct(e53) {
  return typeof ImageBitmap < "u" && e53 instanceof ImageBitmap;
}
function tg(e53, t3) {
  let r = new Blob([new Uint8Array(e53)], { type: "image/png" });
  createImageBitmap(r).then((e54) => {
    t3(null, e54);
  }).catch((e54) => {
    t3(new Error("Could not load image because of ".concat(e54.message, ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")));
  });
}
q(qr, "isSafari"), q(Ct, "isImageBitmap"), q(tg, "arrayBufferToImageBitmap");
var qy = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
function rg(e53, t3) {
  let r = new Image();
  r.onload = () => {
    t3(null, r), URL.revokeObjectURL(r.src), r.onload = null, window.requestAnimationFrame(() => {
      r.src = qy;
    });
  }, r.onerror = () => t3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
  let i = new Blob([new Uint8Array(e53)], { type: "image/png" });
  r.src = e53.byteLength ? URL.createObjectURL(i) : qy;
}
q(rg, "arrayBufferToImage"), c();
var yo;
var vc;
var hw = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date);
var ne = { now: hw, frame(e53) {
  let t3 = requestAnimationFrame(e53);
  return { cancel: () => cancelAnimationFrame(t3) };
}, getImageData(e53, t3 = 0) {
  return this.getImageCanvasContext(e53).getImageData(-t3, -t3, e53.width + 2 * t3, e53.height + 2 * t3);
}, getImageCanvasContext(e53) {
  let t3 = window.document.createElement("canvas"), r = t3.getContext("2d", { willReadFrequently: true });
  if (!r)
    throw new Error("failed to create canvas 2d context");
  return t3.width = e53.width, t3.height = e53.height, r.drawImage(e53, 0, 0, e53.width, e53.height), r;
}, resolveURL: (e53) => (yo || (yo = document.createElement("a")), yo.href = e53, yo.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
  return !!matchMedia && (null == vc && (vc = matchMedia("(prefers-reduced-motion: reduce)")), vc.matches);
} };
c();
var wc = u(Pe(), 1);
var Be = class e {
  static testProp(t3) {
    if (!e.docStyle)
      return t3[0];
    for (let r = 0; r < t3.length; r++)
      if (t3[r] in e.docStyle)
        return t3[r];
    return t3[0];
  }
  static create(e53, t3, r) {
    let i = window.document.createElement(e53);
    return void 0 !== t3 && (i.className = t3), r && r.appendChild(i), i;
  }
  static createNS(e53, t3) {
    return window.document.createElementNS(e53, t3);
  }
  static disableDrag() {
    e.docStyle && e.selectProp && (e.userSelect = e.docStyle[e.selectProp], e.docStyle[e.selectProp] = "none");
  }
  static enableDrag() {
    e.docStyle && e.selectProp && (e.docStyle[e.selectProp] = e.userSelect);
  }
  static setTransform(t3, r) {
    t3.style[e.transformProp] = r;
  }
  static addEventListener(e53, t3, r, i = {}) {
    "passive" in i ? e53.addEventListener(t3, r, i) : e53.addEventListener(t3, r, i.capture);
  }
  static removeEventListener(e53, t3, r, i = {}) {
    "passive" in i ? e53.removeEventListener(t3, r, i) : e53.removeEventListener(t3, r, i.capture);
  }
  static suppressClickInternal(t3) {
    t3.preventDefault(), t3.stopPropagation(), window.removeEventListener("click", e.suppressClickInternal, true);
  }
  static suppressClick() {
    window.addEventListener("click", e.suppressClickInternal, true), window.setTimeout(() => {
      window.removeEventListener("click", e.suppressClickInternal, true);
    }, 0);
  }
  static mousePos(e53, t3) {
    let r = e53.getBoundingClientRect();
    return new wc.default(t3.clientX - r.left - e53.clientLeft, t3.clientY - r.top - e53.clientTop);
  }
  static touchPos(e53, t3) {
    let r = e53.getBoundingClientRect(), i = [];
    for (let a = 0; a < t3.length; a++)
      i.push(new wc.default(t3[a].clientX - r.left - e53.clientLeft, t3[a].clientY - r.top - e53.clientTop));
    return i;
  }
  static mouseButton(e53) {
    return e53.button;
  }
  static remove(e53) {
    e53.parentNode && e53.parentNode.removeChild(e53);
  }
};
q(Be, "DOM"), Be.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, Be.selectProp = Be.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), Be.transformProp = Be.testProp(["transform", "WebkitTransform"]);
var B = Be;
c(), c();
var it = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
var Tc = class extends Error {
  constructor(e53, t3, r, i) {
    super("AJAXError: ".concat(t3, " (").concat(e53, "): ").concat(r)), this.status = e53, this.statusText = t3, this.url = r, this.body = i;
  }
};
q(Tc, "AJAXError");
var hr = Tc;
var go = ct() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href;
var Sc = q((e53) => it.REGISTERED_PROTOCOLS[e53.substring(0, e53.indexOf("://"))], "getProtocolAction");
var fw = q((e53) => /^file:/.test(e53) || /^file:/.test(go()) && !/^\w+:/.test(e53), "isFileURL");
function ig(e53, t3) {
  let r = new AbortController(), i = new Request(e53.url, { method: e53.method || "GET", body: e53.body, credentials: e53.credentials, headers: e53.headers, referrer: go(), signal: r.signal }), a = false, n = false;
  "json" === e53.type && i.headers.set("Accept", "application/json");
  let s3 = q((r3, a3, s4) => {
    if (!n) {
      if (r3 && "SecurityError" !== r3.message && Ce(r3), a3 && s4)
        return o(a3);
      fetch(i).then((r4) => r4.ok ? o(r4) : r4.blob().then((i3) => t3(new hr(r4.status, r4.statusText, e53.url, i3)))).catch((e54) => {
        20 !== e54.code && t3(new Error(e54.message));
      });
    }
  }, "validateOrFetch"), o = q((r3) => {
    ("arrayBuffer" === e53.type || "image" === e53.type ? r3.arrayBuffer() : "json" === e53.type ? r3.json() : r3.text()).then((e54) => {
      n || (a = true, t3(null, e54, r3.headers.get("Cache-Control"), r3.headers.get("Expires")));
    }).catch((e54) => {
      n || t3(new Error(e54.message));
    });
  }, "finishRequest");
  return s3(null, null), { cancel: () => {
    n = true, a || r.abort();
  } };
}
function mw(e53, t3) {
  let r = new XMLHttpRequest();
  r.open(e53.method || "GET", e53.url, true), ("arrayBuffer" === e53.type || "image" === e53.type) && (r.responseType = "arraybuffer");
  for (let t4 in e53.headers)
    r.setRequestHeader(t4, e53.headers[t4]);
  return "json" === e53.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === e53.credentials, r.onerror = () => {
    t3(new Error(r.statusText));
  }, r.onload = () => {
    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
      let i = r.response;
      if ("json" === e53.type)
        try {
          i = JSON.parse(r.response);
        } catch (e54) {
          return t3(e54);
        }
      t3(null, i, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));
    } else {
      let i = new Blob([r.response], { type: r.getResponseHeader("Content-Type") });
      t3(new hr(r.status, r.statusText, e53.url, i));
    }
  }, r.send(e53.body), { cancel: () => r.abort() };
}
q(ig, "makeFetchRequest"), q(mw, "makeXMLHttpRequest");
var wi = q(function(e53, t3) {
  if (/:\/\//.test(e53.url) && !/^https?:|^file:/.test(e53.url)) {
    if (ct() && self.worker && self.worker.actor)
      return self.worker.actor.send("getResource", e53, t3);
    if (!ct())
      return (Sc(e53.url) || ig)(e53, t3);
  }
  if (!fw(e53.url)) {
    if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
      return ig(e53, t3);
    if (ct() && self.worker && self.worker.actor)
      return self.worker.actor.send("getResource", e53, t3, void 0, true);
  }
  return mw(e53, t3);
}, "makeRequest");
var fr = q(function(e53, t3) {
  return wi(R(e53, { type: "json" }), t3);
}, "getJSON");
var xo = q(function(e53, t3) {
  return wi(R(e53, { type: "arrayBuffer" }), t3);
}, "getArrayBuffer");
function Pc(e53) {
  if (!e53 || e53.indexOf("://") <= 0 || 0 === e53.indexOf("data:image/") || 0 === e53.indexOf("blob:"))
    return true;
  let t3 = new URL(e53), r = window.location;
  return t3.protocol === r.protocol && t3.host === r.host;
}
q(Pc, "sameOrigin");
var ng = q(function(e53, t3) {
  let r = window.document.createElement("video");
  r.muted = true, r.onloadstart = function() {
    t3(null, r);
  };
  for (let t4 = 0; t4 < e53.length; t4++) {
    let i = window.document.createElement("source");
    Pc(e53[t4]) || (r.crossOrigin = "Anonymous"), i.src = e53[t4], r.appendChild(i);
  }
  return { cancel: () => {
  } };
}, "getVideo");
c(), c();
var An;
var Si;
var ot;
var In = { supported: false, testSupport: dw };
var Ac = false;
var ag = false;
function dw(e53) {
  Ac || !Si || (ag ? og(e53) : An = e53);
}
function og(e53) {
  let t3 = e53.createTexture();
  e53.bindTexture(e53.TEXTURE_2D, t3);
  try {
    if (e53.texImage2D(e53.TEXTURE_2D, 0, e53.RGBA, e53.RGBA, e53.UNSIGNED_BYTE, Si), e53.isContextLost())
      return;
    In.supported = true;
  } catch {
  }
  e53.deleteTexture(t3), Ac = true;
}
typeof document < "u" && ((Si = document.createElement("img")).onload = function() {
  An && og(An), An = null, ag = true;
}, Si.onerror = function() {
  Ac = true, An = null;
}, Si.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), q(dw, "testSupport"), q(og, "testWebpTextureUpload"), ((e53) => {
  let t3, r, i, a;
  e53.resetRequestQueue = q(() => {
    t3 = [], r = 0, i = 0, a = {};
  }, "resetRequestQueue"), e53.addThrottleControl = q((e54) => {
    let t4 = i++;
    return a[t4] = e54, t4;
  }, "addThrottleControl"), e53.removeThrottleControl = q((e54) => {
    delete a[e54], c3();
  }, "removeThrottleControl");
  let n = q(() => {
    let e54 = Object.keys(a), t4 = false;
    if (e54.length > 0) {
      for (let r3 of e54)
        if (t4 = a[r3](), t4)
          break;
    }
    return t4;
  }, "isThrottled");
  e53.getImage = q((e54, i3, a3 = true) => {
    In.supported && (e54.headers || (e54.headers = {}), e54.headers.accept = "image/webp,*/*");
    let n3 = { requestParameters: e54, supportImageRefresh: a3, callback: i3, cancelled: false, completed: false, cancel: () => {
      !n3.completed && !n3.cancelled && (n3.cancelled = true, n3.innerRequest && (n3.innerRequest.cancel(), r--), c3());
    } };
    return t3.push(n3), c3(), n3;
  }, "getImage");
  let s3 = q((e54, t4) => {
    "function" == typeof createImageBitmap ? tg(e54, t4) : rg(e54, t4);
  }, "arrayBufferToCanvasImageSource"), o = q((e54) => {
    let { requestParameters: t4, supportImageRefresh: r3, callback: i3 } = e54;
    return R(t4, { type: "image" }), (false !== r3 || ct() || Sc(t4.url) || t4.headers && !Object.keys(t4.headers).reduce((e55, t5) => e55 && "accept" === t5, true) ? wi : h)(t4, (t5, r4, a3, n3) => {
      l(e54, i3, t5, r4, a3, n3);
    });
  }, "doImageRequest"), l = q((e54, t4, i3, a3, n3, o3) => {
    i3 ? t4(i3) : a3 instanceof HTMLImageElement || a3 instanceof ImageBitmap ? t4(null, a3) : a3 && s3(a3, q((e55, r3) => {
      null != e55 ? t4(e55) : null != r3 && t4(null, r3, { cacheControl: n3, expires: o3 });
    }, "decoratedCallback")), e54.cancelled || (e54.completed = true, r--, c3());
  }, "onImageResponse"), c3 = q(() => {
    let e54 = n() ? it.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : it.MAX_PARALLEL_IMAGE_REQUESTS;
    for (let i3 = r; i3 < e54 && t3.length > 0; i3++) {
      let e55 = t3.shift();
      if (e55.cancelled) {
        i3--;
        continue;
      }
      let a3 = o(e55);
      r++, e55.innerRequest = a3;
    }
  }, "processQueue"), h = q((e54, t4) => {
    let r3 = new Image(), i3 = e54.url, a3 = false, n3 = e54.credentials;
    return n3 && "include" === n3 ? r3.crossOrigin = "use-credentials" : (n3 && "same-origin" === n3 || !Pc(i3)) && (r3.crossOrigin = "anonymous"), r3.fetchPriority = "high", r3.onload = () => {
      t4(null, r3), r3.onerror = r3.onload = null;
    }, r3.onerror = () => {
      a3 || t4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), r3.onerror = r3.onload = null;
    }, r3.src = i3, { cancel: () => {
      a3 = true, r3.src = "";
    } };
  }, "getImageUsingHtmlImage");
})(ot || (ot = {})), ot.resetRequestQueue(), c();
var Ic = class {
  constructor(e53) {
    this._transformRequestFn = e53;
  }
  transformRequest(e53, t3) {
    return this._transformRequestFn && this._transformRequestFn(e53, t3) || { url: e53 };
  }
  normalizeSpriteURL(e53, t3, r) {
    let i = gw(e53);
    return i.path += "".concat(t3).concat(r), xw(i);
  }
  setTransformRequest(e53) {
    this._transformRequestFn = e53;
  }
};
q(Ic, "RequestManager");
var bo = Ic;
var yw = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
function gw(e53) {
  let t3 = e53.match(yw);
  if (!t3)
    throw new Error('Unable to parse URL "'.concat(e53, '"'));
  return { protocol: t3[1], authority: t3[2], path: t3[3] || "/", params: t3[4] ? t3[4].split("&") : [] };
}
function xw(e53) {
  let t3 = e53.params.length ? "?".concat(e53.params.join("&")) : "";
  return "".concat(e53.protocol, "://").concat(e53.authority).concat(e53.path).concat(t3);
}
function sg(e53, t3, r) {
  r[e53] && -1 !== r[e53].indexOf(t3) || (r[e53] = r[e53] || [], r[e53].push(t3));
}
function Mc(e53, t3, r) {
  if (r && r[e53]) {
    let i = r[e53].indexOf(t3);
    -1 !== i && r[e53].splice(i, 1);
  }
}
q(gw, "parseUrl"), q(xw, "formatUrl"), c(), c(), q(sg, "_addEventListener"), q(Mc, "_removeEventListener");
var Cc = class {
  constructor(e53, t3 = {}) {
    R(this, t3), this.type = e53;
  }
};
q(Cc, "Event");
var z = Cc;
var Ec = class extends z {
  constructor(e53, t3 = {}) {
    super("error", R({ error: e53 }, t3));
  }
};
q(Ec, "ErrorEvent");
var Z = Ec;
var kc = class {
  on(e53, t3) {
    return this._listeners = this._listeners || {}, sg(e53, t3, this._listeners), this;
  }
  off(e53, t3) {
    return Mc(e53, t3, this._listeners), Mc(e53, t3, this._oneTimeListeners), this;
  }
  once(e53, t3) {
    return t3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, sg(e53, t3, this._oneTimeListeners), this) : new Promise((t4) => this.once(e53, t4));
  }
  fire(e53, t3) {
    "string" == typeof e53 && (e53 = new z(e53, t3 || {}));
    let r = e53.type;
    if (this.listens(r)) {
      e53.target = this;
      let t4 = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
      for (let r3 of t4)
        r3.call(this, e53);
      let i = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
      for (let t5 of i)
        Mc(r, t5, this._oneTimeListeners), t5.call(this, e53);
      let a = this._eventedParent;
      a && (R(e53, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), a.fire(e53));
    } else
      e53 instanceof Z && console.error(e53.error);
    return this;
  }
  listens(e53) {
    return this._listeners && this._listeners[e53] && this._listeners[e53].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e53] && this._oneTimeListeners[e53].length > 0 || this._eventedParent && this._eventedParent.listens(e53);
  }
  setEventedParent(e53, t3) {
    return this._eventedParent = e53, this._eventedParentData = t3, this;
  }
};
q(kc, "Evented");
var de = kc;
c(), c(), c(), c();
var Pg = u(gc(), 1);
var bw = 8;
var _w = { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } };
var vw = { "*": { type: "source" } };
var ww = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];
var Sw = { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var Pw = { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var Tw = { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } };
var Aw = { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } };
var Iw = { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var Mw = { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } };
var Cw = { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } };
var Ew = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"];
var kw = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Lw = { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Dw = { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var zw = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Fw = { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Bw = { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Rw = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Ow = { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } };
var Vw = { type: "array", value: "*" };
var Uw = { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } };
var Nw = { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } };
var Gw = { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 };
var qw = { type: "array", value: "*", minimum: 1 };
var jw = { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } };
var $w = { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } };
var Hw = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"];
var Zw = { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } };
var Ww = { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } };
var Xw = { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } };
var Kw = { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Yw = { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Jw = { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var Qw = { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var e2 = { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } };
var t2 = { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } };
var r2 = { "*": { type: "string" } };
var M = { $version: bw, $root: _w, sources: vw, source: ww, source_vector: Sw, source_raster: Pw, source_raster_dem: Tw, source_geojson: Aw, source_video: Iw, source_image: Mw, layer: Cw, layout: Ew, layout_background: kw, layout_fill: Lw, layout_circle: Dw, layout_heatmap: zw, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: Fw, layout_symbol: Bw, layout_raster: Rw, layout_hillshade: Ow, filter: Vw, filter_operator: Uw, geometry_type: Nw, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: Gw, expression: qw, light: jw, terrain: $w, paint: Hw, paint_fill: Zw, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: Ww, paint_circle: Xw, paint_heatmap: Kw, paint_symbol: Yw, paint_raster: Jw, paint_hillshade: Qw, paint_background: e2, transition: t2, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: r2 };
var i2 = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
function n2(e53, t3) {
  let r = {};
  for (let t4 in e53)
    "ref" !== t4 && (r[t4] = e53[t4]);
  return i2.forEach((e54) => {
    e54 in t3 && (r[e54] = t3[e54]);
  }), r;
}
function Kc(e53) {
  e53 = e53.slice();
  let t3 = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < e53.length; r++)
    t3[e53[r].id] = e53[r];
  for (let r = 0; r < e53.length; r++)
    "ref" in e53[r] && (e53[r] = n2(e53[r], t3[e53[r].ref]));
  return e53;
}
function Oe(e53, t3) {
  if (Array.isArray(e53)) {
    if (!Array.isArray(t3) || e53.length !== t3.length)
      return false;
    for (let r = 0; r < e53.length; r++)
      if (!Oe(e53[r], t3[r]))
        return false;
    return true;
  }
  if ("object" == typeof e53 && null !== e53 && null !== t3) {
    if ("object" != typeof t3 || Object.keys(e53).length !== Object.keys(t3).length)
      return false;
    for (let r in e53)
      if (!Oe(e53[r], t3[r]))
        return false;
    return true;
  }
  return e53 === t3;
}
q(n2, "deref"), q(Kc, "derefLayers"), q(Oe, "deepEqual");
var Ae = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
function Tg(e53, t3, r) {
  r.push({ command: Ae.addSource, args: [e53, t3[e53]] });
}
function Ag(e53, t3, r) {
  t3.push({ command: Ae.removeSource, args: [e53] }), r[e53] = true;
}
function a2(e53, t3, r, i) {
  Ag(e53, r, i), Tg(e53, t3, r);
}
function o2(e53, t3, r) {
  let i;
  for (i in e53[r])
    if (Object.prototype.hasOwnProperty.call(e53[r], i) && "data" !== i && !Oe(e53[r][i], t3[r][i]))
      return false;
  for (i in t3[r])
    if (Object.prototype.hasOwnProperty.call(t3[r], i) && "data" !== i && !Oe(e53[r][i], t3[r][i]))
      return false;
  return true;
}
function s2(e53, t3, r, i) {
  let a;
  for (a in t3 = t3 || {}, e53 = e53 || {})
    Object.prototype.hasOwnProperty.call(e53, a) && (Object.prototype.hasOwnProperty.call(t3, a) || Ag(a, r, i));
  for (a in t3)
    Object.prototype.hasOwnProperty.call(t3, a) && (Object.prototype.hasOwnProperty.call(e53, a) ? Oe(e53[a], t3[a]) || ("geojson" === e53[a].type && "geojson" === t3[a].type && o2(e53, t3, a) ? r.push({ command: Ae.setGeoJSONSourceData, args: [a, t3[a].data] }) : a2(a, t3, r, i)) : Tg(a, t3, r));
}
function _o(e53, t3, r, i, a, n) {
  let s3;
  for (s3 in t3 = t3 || {}, e53 = e53 || {})
    Object.prototype.hasOwnProperty.call(e53, s3) && (Oe(e53[s3], t3[s3]) || r.push({ command: n, args: [i, s3, t3[s3], a] }));
  for (s3 in t3)
    !Object.prototype.hasOwnProperty.call(t3, s3) || Object.prototype.hasOwnProperty.call(e53, s3) || Oe(e53[s3], t3[s3]) || r.push({ command: n, args: [i, s3, t3[s3], a] });
}
function lg(e53) {
  return e53.id;
}
function ug(e53, t3) {
  return e53[t3.id] = t3, e53;
}
function l2(e53, t3, r) {
  t3 = t3 || [];
  let i, a, n, s3, o, l, u3, c3 = (e53 = e53 || []).map(lg), h = t3.map(lg), p = e53.reduce(ug, {}), d = t3.reduce(ug, {}), f = c3.slice(), m = /* @__PURE__ */ Object.create(null);
  for (i = 0, a = 0; i < c3.length; i++)
    n = c3[i], Object.prototype.hasOwnProperty.call(d, n) ? a++ : (r.push({ command: Ae.removeLayer, args: [n] }), f.splice(f.indexOf(n, a), 1));
  for (i = 0, a = 0; i < h.length; i++)
    n = h[h.length - 1 - i], f[f.length - 1 - i] !== n && (Object.prototype.hasOwnProperty.call(p, n) ? (r.push({ command: Ae.removeLayer, args: [n] }), f.splice(f.lastIndexOf(n, f.length - a), 1)) : a++, l = f[f.length - i], r.push({ command: Ae.addLayer, args: [d[n], l] }), f.splice(f.length - i, 0, n), m[n] = true);
  for (i = 0; i < h.length; i++)
    if (n = h[i], s3 = p[n], o = d[n], !m[n] && !Oe(s3, o)) {
      if (!Oe(s3.source, o.source) || !Oe(s3["source-layer"], o["source-layer"]) || !Oe(s3.type, o.type)) {
        r.push({ command: Ae.removeLayer, args: [n] }), l = f[f.lastIndexOf(n) + 1], r.push({ command: Ae.addLayer, args: [o, l] });
        continue;
      }
      for (u3 in _o(s3.layout, o.layout, r, n, null, Ae.setLayoutProperty), _o(s3.paint, o.paint, r, n, null, Ae.setPaintProperty), Oe(s3.filter, o.filter) || r.push({ command: Ae.setFilter, args: [n, o.filter] }), (!Oe(s3.minzoom, o.minzoom) || !Oe(s3.maxzoom, o.maxzoom)) && r.push({ command: Ae.setLayerZoomRange, args: [n, o.minzoom, o.maxzoom] }), s3)
        Object.prototype.hasOwnProperty.call(s3, u3) && ("layout" === u3 || "paint" === u3 || "filter" === u3 || "metadata" === u3 || "minzoom" === u3 || "maxzoom" === u3 || (0 === u3.indexOf("paint.") ? _o(s3[u3], o[u3], r, n, u3.slice(6), Ae.setPaintProperty) : Oe(s3[u3], o[u3]) || r.push({ command: Ae.setLayerProperty, args: [n, u3, o[u3]] })));
      for (u3 in o)
        !Object.prototype.hasOwnProperty.call(o, u3) || Object.prototype.hasOwnProperty.call(s3, u3) || "layout" === u3 || "paint" === u3 || "filter" === u3 || "metadata" === u3 || "minzoom" === u3 || "maxzoom" === u3 || (0 === u3.indexOf("paint.") ? _o(s3[u3], o[u3], r, n, u3.slice(6), Ae.setPaintProperty) : Oe(s3[u3], o[u3]) || r.push({ command: Ae.setLayerProperty, args: [n, u3, o[u3]] }));
    }
}
function Ig(e53, t3) {
  if (!e53)
    return [{ command: Ae.setStyle, args: [t3] }];
  let r = [];
  try {
    if (!Oe(e53.version, t3.version))
      return [{ command: Ae.setStyle, args: [t3] }];
    Oe(e53.center, t3.center) || r.push({ command: Ae.setCenter, args: [t3.center] }), Oe(e53.zoom, t3.zoom) || r.push({ command: Ae.setZoom, args: [t3.zoom] }), Oe(e53.bearing, t3.bearing) || r.push({ command: Ae.setBearing, args: [t3.bearing] }), Oe(e53.pitch, t3.pitch) || r.push({ command: Ae.setPitch, args: [t3.pitch] }), Oe(e53.sprite, t3.sprite) || r.push({ command: Ae.setSprite, args: [t3.sprite] }), Oe(e53.glyphs, t3.glyphs) || r.push({ command: Ae.setGlyphs, args: [t3.glyphs] }), Oe(e53.transition, t3.transition) || r.push({ command: Ae.setTransition, args: [t3.transition] }), Oe(e53.light, t3.light) || r.push({ command: Ae.setLight, args: [t3.light] });
    let i = {}, a = [];
    s2(e53.sources, t3.sources, a, i);
    let n = [];
    e53.layers && e53.layers.forEach((e54) => {
      i[e54.source] ? r.push({ command: Ae.removeLayer, args: [e54.id] }) : n.push(e54);
    }), r = r.concat(a), l2(n, t3.layers, r);
  } catch (e54) {
    console.warn("Unable to compute style diff:", e54), r = [{ command: Ae.setStyle, args: [t3] }];
  }
  return r;
}
q(Tg, "addSource"), q(Ag, "removeSource"), q(a2, "updateSource"), q(o2, "canUpdateGeoJSON"), q(s2, "diffSources"), q(_o, "diffLayerPropertyChanges"), q(lg, "pluckId"), q(ug, "indexById"), q(l2, "diffLayers"), q(Ig, "diffStyles");
var sp = class {
  constructor(e53, t3, r, i) {
    this.message = (e53 ? "".concat(e53, ": ") : "") + r, i && (this.identifier = i), null != t3 && t3.__line__ && (this.line = t3.__line__);
  }
};
q(sp, "ValidationError");
var N = sp;
function ki(e53, ...t3) {
  for (let r of t3)
    for (let t4 in r)
      e53[t4] = r[t4];
  return e53;
}
q(ki, "extendBy");
var lp = class extends Error {
  constructor(e53, t3) {
    super(t3), this.message = t3, this.key = e53;
  }
};
q(lp, "ExpressionParsingError");
var Et = lp;
var Bo = class e3 {
  constructor(e53, t3 = []) {
    this.parent = e53, this.bindings = {};
    for (let [e54, r] of t3)
      this.bindings[e54] = r;
  }
  concat(t3) {
    return new e3(this, t3);
  }
  get(e53) {
    if (this.bindings[e53])
      return this.bindings[e53];
    if (this.parent)
      return this.parent.get(e53);
    throw new Error("".concat(e53, " not found in scope."));
  }
  has(e53) {
    return !!this.bindings[e53] || !!this.parent && this.parent.has(e53);
  }
};
q(Bo, "Scope");
var Vc = Bo;
var zi = { kind: "null" };
var j = { kind: "number" };
var ce = { kind: "string" };
var oe = { kind: "boolean" };
var Lt = { kind: "color" };
var Ci = { kind: "object" };
var se = { kind: "value" };
var u2 = { kind: "error" };
var ts = { kind: "collator" };
var Fi = { kind: "formatted" };
var rs = { kind: "padding" };
var Hn = { kind: "resolvedImage" };
var is = { kind: "variableAnchorOffsetCollection" };
function vt(e53, t3) {
  return { kind: "array", itemType: e53, N: t3 };
}
function Ue(e53) {
  if ("array" === e53.kind) {
    let t3 = Ue(e53.itemType);
    return "number" == typeof e53.N ? "array<".concat(t3, ", ").concat(e53.N, ">") : "value" === e53.itemType.kind ? "array" : "array<".concat(t3, ">");
  }
  return e53.kind;
}
q(vt, "array$1"), q(Ue, "toString$1");
var c2 = [zi, j, ce, oe, Lt, Fi, Ci, vt(se), rs, Hn, is];
function Rn(e53, t3) {
  if ("error" === t3.kind)
    return null;
  if ("array" === e53.kind) {
    if ("array" === t3.kind && (0 === t3.N && "value" === t3.itemType.kind || !Rn(e53.itemType, t3.itemType)) && ("number" != typeof e53.N || e53.N === t3.N))
      return null;
  } else {
    if (e53.kind === t3.kind)
      return null;
    if ("value" === e53.kind) {
      for (let e54 of c2)
        if (!Rn(e54, t3))
          return null;
    }
  }
  return "Expected ".concat(Ue(e53), " but found ").concat(Ue(t3), " instead.");
}
function Yc(e53, t3) {
  return t3.some((t4) => t4.kind === e53.kind);
}
function On(e53, t3) {
  return t3.some((t4) => "null" === t4 ? null === e53 : "array" === t4 ? Array.isArray(e53) : "object" === t4 ? e53 && !Array.isArray(e53) && "object" == typeof e53 : t4 === typeof e53);
}
function Mn(e53, t3) {
  return "array" === e53.kind && "array" === t3.kind ? e53.itemType.kind === t3.itemType.kind && "number" == typeof e53.N : e53.kind === t3.kind;
}
q(Rn, "checkSubtype"), q(Yc, "isValidType"), q(On, "isValidNativeType"), q(Mn, "verifyType");
var Mg = 0.96422;
var Cg = 1;
var Eg = 0.82521;
var kg = 4 / 29;
var Ei = 6 / 29;
var Lg = 3 * Ei * Ei;
var p2 = Ei * Ei * Ei;
var h2 = Math.PI / 180;
var f2 = 180 / Math.PI;
function Dg(e53) {
  return (e53 %= 360) < 0 && (e53 += 360), e53;
}
function zg([e53, t3, r, i]) {
  let a, n, s3 = Dc((0.2225045 * (e53 = Lc(e53)) + 0.7168786 * (t3 = Lc(t3)) + 0.0606169 * (r = Lc(r))) / Cg);
  e53 === t3 && t3 === r ? a = n = s3 : (a = Dc((0.4360747 * e53 + 0.3850649 * t3 + 0.1430804 * r) / Mg), n = Dc((0.0139322 * e53 + 0.0971045 * t3 + 0.7141733 * r) / Eg));
  let o = 116 * s3 - 16;
  return [o < 0 ? 0 : o, 500 * (a - s3), 200 * (s3 - n), i];
}
function Lc(e53) {
  return e53 <= 0.04045 ? e53 / 12.92 : Math.pow((e53 + 0.055) / 1.055, 2.4);
}
function Dc(e53) {
  return e53 > p2 ? Math.pow(e53, 1 / 3) : e53 / Lg + kg;
}
function Fg([e53, t3, r, i]) {
  let a = (e53 + 16) / 116, n = isNaN(t3) ? a : a + t3 / 500, s3 = isNaN(r) ? a : a - r / 200;
  return a = Cg * Fc(a), n = Mg * Fc(n), s3 = Eg * Fc(s3), [zc(3.1338561 * n - 1.6168667 * a - 0.4906146 * s3), zc(-0.9787684 * n + 1.9161415 * a + 0.033454 * s3), zc(0.0719453 * n - 0.2289914 * a + 1.4052427 * s3), i];
}
function zc(e53) {
  return (e53 = e53 <= 304e-5 ? 12.92 * e53 : 1.055 * Math.pow(e53, 1 / 2.4) - 0.055) < 0 ? 0 : e53 > 1 ? 1 : e53;
}
function Fc(e53) {
  return e53 > Ei ? e53 * e53 * e53 : Lg * (e53 - kg);
}
function m2(e53) {
  let [t3, r, i, a] = zg(e53), n = Math.sqrt(r * r + i * i);
  return [Math.round(1e4 * n) ? Dg(Math.atan2(i, r) * f2) : NaN, n, t3, a];
}
function d2([e53, t3, r, i]) {
  return e53 = isNaN(e53) ? 0 : e53 * h2, Fg([r, Math.cos(e53) * t3, Math.sin(e53) * t3, i]);
}
function y2([e53, t3, r, i]) {
  function a(i3) {
    let a3 = (i3 + e53 / 30) % 12, n = t3 * Math.min(r, 1 - r);
    return r - n * Math.max(-1, Math.min(a3 - 3, 9 - a3, 1));
  }
  return e53 = Dg(e53), t3 /= 100, r /= 100, q(a, "f"), [a(0), a(8), a(4), i];
}
function g2(e53) {
  if ("transparent" === (e53 = e53.toLowerCase().trim()))
    return [0, 0, 0, 0];
  let t3 = x2[e53];
  if (t3) {
    let [e54, r3, i] = t3;
    return [e54 / 255, r3 / 255, i / 255, 1];
  }
  if (e53.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e53)) {
    let t4 = e53.length < 6 ? 1 : 2, r3 = 1;
    return [vo(e53.slice(r3, r3 += t4)), vo(e53.slice(r3, r3 += t4)), vo(e53.slice(r3, r3 += t4)), vo(e53.slice(r3, r3 + t4) || "ff")];
  }
  if (e53.startsWith("rgb")) {
    let t4 = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, r3 = e53.match(t4);
    if (r3) {
      let [e54, t5, i, a, n, s3, o, l, u3, c3, h, p] = r3, d = [a || " ", o || " ", c3].join("");
      if ("  " === d || "  /" === d || ",," === d || ",,," === d) {
        let e55 = [i, s3, u3].join(""), r4 = "%%%" === e55 ? 100 : "" === e55 ? 255 : 0;
        if (r4) {
          let e56 = [Pi(+t5 / r4, 0, 1), Pi(+n / r4, 0, 1), Pi(+l / r4, 0, 1), h ? cg(+h, p) : 1];
          if (pg(e56))
            return e56;
        }
      }
      return;
    }
  }
  let r = e53.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
  if (r) {
    let [e54, t4, i, a, n, s3, o, l, u3] = r, c3 = [i || " ", n || " ", o].join("");
    if ("  " === c3 || "  /" === c3 || ",," === c3 || ",,," === c3) {
      let e55 = [+t4, Pi(+a, 0, 100), Pi(+s3, 0, 100), l ? cg(+l, u3) : 1];
      if (pg(e55))
        return y2(e55);
    }
  }
}
function vo(e53) {
  return parseInt(e53.padEnd(2, e53), 16) / 255;
}
function cg(e53, t3) {
  return Pi(t3 ? e53 / 100 : e53, 0, 1);
}
function Pi(e53, t3, r) {
  return Math.min(Math.max(t3, e53), r);
}
function pg(e53) {
  return !e53.some(Number.isNaN);
}
q(Dg, "constrainAngle"), q(zg, "rgbToLab"), q(Lc, "rgb2xyz"), q(Dc, "xyz2lab"), q(Fg, "labToRgb"), q(zc, "xyz2rgb"), q(Fc, "lab2xyz"), q(m2, "rgbToHcl"), q(d2, "hclToRgb"), q(y2, "hslToRgb"), q(g2, "parseCssColor"), q(vo, "parseHex"), q(cg, "parseAlpha"), q(Pi, "clamp"), q(pg, "validateNumbers");
var x2 = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var kn = class e4 {
  constructor(e53, t3, r, i = 1, a = true) {
    this.r = e53, this.g = t3, this.b = r, this.a = i, a || (this.r *= i, this.g *= i, this.b *= i, i || this.overwriteGetter("rgb", [e53, t3, r, i]));
  }
  static parse(t3) {
    if (t3 instanceof e4)
      return t3;
    if ("string" != typeof t3)
      return;
    let r = g2(t3);
    return r ? new e4(...r, false) : void 0;
  }
  get rgb() {
    let { r: e53, g: t3, b: r, a: i } = this, a = i || 1 / 0;
    return this.overwriteGetter("rgb", [e53 / a, t3 / a, r / a, i]);
  }
  get hcl() {
    return this.overwriteGetter("hcl", m2(this.rgb));
  }
  get lab() {
    return this.overwriteGetter("lab", zg(this.rgb));
  }
  overwriteGetter(e53, t3) {
    return Object.defineProperty(this, e53, { value: t3 }), t3;
  }
  toString() {
    let [e53, t3, r, i] = this.rgb;
    return "rgba(".concat([e53, t3, r].map((e54) => Math.round(255 * e54)).join(","), ",").concat(i, ")");
  }
};
q(kn, "Color");
var K = kn;
K.black = new K(0, 0, 0, 1), K.white = new K(1, 1, 1, 1), K.transparent = new K(0, 0, 0, 0), K.red = new K(1, 0, 0, 1);
var up = class {
  constructor(e53, t3, r) {
    this.sensitivity = e53 ? t3 ? "variant" : "case" : t3 ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e53, t3) {
    return this.collator.compare(e53, t3);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
};
q(up, "Collator");
var Vn = up;
var cp = class {
  constructor(e53, t3, r, i, a) {
    this.text = e53, this.image = t3, this.scale = r, this.fontStack = i, this.textColor = a;
  }
};
q(cp, "FormattedSection");
var Un = cp;
var Ai = class e5 {
  constructor(e53) {
    this.sections = e53;
  }
  static fromString(t3) {
    return new e5([new Un(t3, null, null, null, null)]);
  }
  isEmpty() {
    return 0 === this.sections.length || !this.sections.some((e53) => 0 !== e53.text.length || e53.image && 0 !== e53.image.name.length);
  }
  static factory(t3) {
    return t3 instanceof e5 ? t3 : e5.fromString(t3);
  }
  toString() {
    return 0 === this.sections.length ? "" : this.sections.map((e53) => e53.text).join("");
  }
};
q(Ai, "Formatted");
var St = Ai;
var Ii = class e6 {
  constructor(e53) {
    this.values = e53.slice();
  }
  static parse(t3) {
    if (t3 instanceof e6)
      return t3;
    if ("number" == typeof t3)
      return new e6([t3, t3, t3, t3]);
    if (Array.isArray(t3) && !(t3.length < 1 || t3.length > 4)) {
      for (let e53 of t3)
        if ("number" != typeof e53)
          return;
      switch (t3.length) {
        case 1:
          t3 = [t3[0], t3[0], t3[0], t3[0]];
          break;
        case 2:
          t3 = [t3[0], t3[1], t3[0], t3[1]];
          break;
        case 3:
          t3 = [t3[0], t3[1], t3[2], t3[1]];
      }
      return new e6(t3);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
q(Ii, "Padding");
var Ot = Ii;
var b2 = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
var Ln = class e7 {
  constructor(e53) {
    this.values = e53.slice();
  }
  static parse(t3) {
    if (t3 instanceof e7)
      return t3;
    if (Array.isArray(t3) && !(t3.length < 1) && t3.length % 2 == 0) {
      for (let e53 = 0; e53 < t3.length; e53 += 2) {
        let r = t3[e53], i = t3[e53 + 1];
        if ("string" != typeof r || !b2.has(r) || !Array.isArray(i) || 2 !== i.length || "number" != typeof i[0] || "number" != typeof i[1])
          return;
      }
      return new e7(t3);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
};
q(Ln, "VariableAnchorOffsetCollection");
var Qt = Ln;
var Ro = class e8 {
  constructor(e53) {
    this.name = e53.name, this.available = e53.available;
  }
  toString() {
    return this.name;
  }
  static fromString(t3) {
    return t3 ? new e8({ name: t3, available: false }) : null;
  }
};
q(Ro, "ResolvedImage");
var pt = Ro;
function Bg(e53, t3, r, i) {
  if (!("number" == typeof e53 && e53 >= 0 && e53 <= 255 && "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof r && r >= 0 && r <= 255)) {
    return "Invalid rgba value [".concat(("number" == typeof i ? [e53, t3, r, i] : [e53, t3, r]).join(", "), "]: 'r', 'g', and 'b' must be between 0 and 255.");
  }
  return typeof i > "u" || "number" == typeof i && i >= 0 && i <= 1 ? null : "Invalid rgba value [".concat([e53, t3, r, i].join(", "), "]: 'a' must be between 0 and 1.");
}
function To(e53) {
  if (null === e53 || "string" == typeof e53 || "boolean" == typeof e53 || "number" == typeof e53 || e53 instanceof K || e53 instanceof Vn || e53 instanceof St || e53 instanceof Ot || e53 instanceof Qt || e53 instanceof pt)
    return true;
  if (Array.isArray(e53)) {
    for (let t3 of e53)
      if (!To(t3))
        return false;
    return true;
  }
  if ("object" == typeof e53) {
    for (let t3 in e53)
      if (!To(e53[t3]))
        return false;
    return true;
  }
  return false;
}
function We(e53) {
  if (null === e53)
    return zi;
  if ("string" == typeof e53)
    return ce;
  if ("boolean" == typeof e53)
    return oe;
  if ("number" == typeof e53)
    return j;
  if (e53 instanceof K)
    return Lt;
  if (e53 instanceof Vn)
    return ts;
  if (e53 instanceof St)
    return Fi;
  if (e53 instanceof Ot)
    return rs;
  if (e53 instanceof Qt)
    return is;
  if (e53 instanceof pt)
    return Hn;
  if (Array.isArray(e53)) {
    let t3, r = e53.length;
    for (let r3 of e53) {
      let e54 = We(r3);
      if (t3) {
        if (t3 === e54)
          continue;
        t3 = se;
        break;
      }
      t3 = e54;
    }
    return vt(t3 || se, r);
  }
  return Ci;
}
function Cn(e53) {
  let t3 = typeof e53;
  return null === e53 ? "" : "string" === t3 || "number" === t3 || "boolean" === t3 ? String(e53) : e53 instanceof K || e53 instanceof St || e53 instanceof Ot || e53 instanceof Qt || e53 instanceof pt ? e53.toString() : JSON.stringify(e53);
}
q(Bg, "validateRGBA"), q(To, "isValue"), q(We, "typeOf"), q(Cn, "toString");
var Oo = class e9 {
  constructor(e53, t3) {
    this.type = e53, this.value = t3;
  }
  static parse(t3, r) {
    if (2 !== t3.length)
      return r.error("'literal' expression requires exactly one argument, but found ".concat(t3.length - 1, " instead."));
    if (!To(t3[1]))
      return r.error("invalid value");
    let i = t3[1], a = We(i), n = r.expectedType;
    return "array" === a.kind && 0 === a.N && n && "array" === n.kind && ("number" != typeof n.N || 0 === n.N) && (a = n), new e9(a, i);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
q(Oo, "Literal");
var yr = Oo;
var pp = class {
  constructor(e53) {
    this.name = "ExpressionEvaluationError", this.message = e53;
  }
  toJSON() {
    return this.message;
  }
};
q(pp, "RuntimeError");
var Ne = pp;
var wo = { string: ce, number: j, boolean: oe, object: Ci };
var Vo = class e10 {
  constructor(e53, t3) {
    this.type = e53, this.args = t3;
  }
  static parse(t3, r) {
    if (t3.length < 2)
      return r.error("Expected at least one argument.");
    let i, a = 1, n = t3[0];
    if ("array" === n) {
      let e53, n3;
      if (t3.length > 2) {
        let i3 = t3[1];
        if ("string" != typeof i3 || !(i3 in wo) || "object" === i3)
          return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
        e53 = wo[i3], a++;
      } else
        e53 = se;
      if (t3.length > 3) {
        if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
          return r.error('The length argument to "array" must be a positive integer literal', 2);
        n3 = t3[2], a++;
      }
      i = vt(e53, n3);
    } else {
      if (!wo[n])
        throw new Error("Types doesn't contain name = ".concat(n));
      i = wo[n];
    }
    let s3 = [];
    for (; a < t3.length; a++) {
      let e53 = r.parse(t3[a], a, se);
      if (!e53)
        return null;
      s3.push(e53);
    }
    return new e10(i, s3);
  }
  evaluate(e53) {
    for (let t3 = 0; t3 < this.args.length; t3++) {
      let r = this.args[t3].evaluate(e53);
      if (!Rn(this.type, We(r)))
        return r;
      if (t3 === this.args.length - 1)
        throw new Ne("Expected value to be of type ".concat(Ue(this.type), ", but found ").concat(Ue(We(r)), " instead."));
    }
    throw new Error();
  }
  eachChild(e53) {
    this.args.forEach(e53);
  }
  outputDefined() {
    return this.args.every((e53) => e53.outputDefined());
  }
};
q(Vo, "Assertion");
var Rt = Vo;
var hg = { "to-boolean": oe, "to-color": Lt, "to-number": j, "to-string": ce };
var Uo = class e11 {
  constructor(e53, t3) {
    this.type = e53, this.args = t3;
  }
  static parse(t3, r) {
    if (t3.length < 2)
      return r.error("Expected at least one argument.");
    let i = t3[0];
    if (!hg[i])
      throw new Error("Can't parse ".concat(i, " as it is not part of the known types"));
    if (("to-boolean" === i || "to-string" === i) && 2 !== t3.length)
      return r.error("Expected one argument.");
    let a = hg[i], n = [];
    for (let e53 = 1; e53 < t3.length; e53++) {
      let i3 = r.parse(t3[e53], e53, se);
      if (!i3)
        return null;
      n.push(i3);
    }
    return new e11(a, n);
  }
  evaluate(e53) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e53);
      case "color": {
        let t3, r;
        for (let i of this.args) {
          if (t3 = i.evaluate(e53), r = null, t3 instanceof K)
            return t3;
          if ("string" == typeof t3) {
            let r3 = e53.parseColor(t3);
            if (r3)
              return r3;
          } else if (Array.isArray(t3) && (r = t3.length < 3 || t3.length > 4 ? "Invalid rbga value ".concat(JSON.stringify(t3), ": expected an array containing either three or four numeric values.") : Bg(t3[0], t3[1], t3[2], t3[3]), !r))
            return new K(t3[0] / 255, t3[1] / 255, t3[2] / 255, t3[3]);
        }
        throw new Ne(r || "Could not parse color from value '".concat("string" == typeof t3 ? t3 : JSON.stringify(t3), "'"));
      }
      case "padding": {
        let t3;
        for (let r of this.args) {
          t3 = r.evaluate(e53);
          let i = Ot.parse(t3);
          if (i)
            return i;
        }
        throw new Ne("Could not parse padding from value '".concat("string" == typeof t3 ? t3 : JSON.stringify(t3), "'"));
      }
      case "variableAnchorOffsetCollection": {
        let t3;
        for (let r of this.args) {
          t3 = r.evaluate(e53);
          let i = Qt.parse(t3);
          if (i)
            return i;
        }
        throw new Ne("Could not parse variableAnchorOffsetCollection from value '".concat("string" == typeof t3 ? t3 : JSON.stringify(t3), "'"));
      }
      case "number": {
        let t3 = null;
        for (let r of this.args) {
          if (t3 = r.evaluate(e53), null === t3)
            return 0;
          let i = Number(t3);
          if (!isNaN(i))
            return i;
        }
        throw new Ne("Could not convert ".concat(JSON.stringify(t3), " to number."));
      }
      case "formatted":
        return St.fromString(Cn(this.args[0].evaluate(e53)));
      case "resolvedImage":
        return pt.fromString(Cn(this.args[0].evaluate(e53)));
      default:
        return Cn(this.args[0].evaluate(e53));
    }
  }
  eachChild(e53) {
    this.args.forEach(e53);
  }
  outputDefined() {
    return this.args.every((e53) => e53.outputDefined());
  }
};
q(Uo, "Coercion");
var mr = Uo;
var _2 = ["Unknown", "Point", "LineString", "Polygon"];
var hp = class {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? "number" == typeof this.feature.type ? _2[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e53) {
    let t3 = this._parseColorCache[e53];
    return t3 || (t3 = this._parseColorCache[e53] = K.parse(e53)), t3;
  }
};
q(hp, "EvaluationContext");
var Ao = hp;
var No = class e12 {
  constructor(e53, t3, r = [], i, a = new Vc(), n = []) {
    this.registry = e53, this.path = r, this.key = r.map((e54) => "[".concat(e54, "]")).join(""), this.scope = a, this.errors = n, this.expectedType = i, this._isConstant = t3;
  }
  parse(e53, t3, r, i, a = {}) {
    return t3 ? this.concat(t3, r, i)._parse(e53, a) : this._parse(e53, a);
  }
  _parse(e53, t3) {
    function r(e54, t4, r3) {
      return "assert" === r3 ? new Rt(t4, [e54]) : "coerce" === r3 ? new mr(t4, [e54]) : e54;
    }
    if ((null === e53 || "string" == typeof e53 || "boolean" == typeof e53 || "number" == typeof e53) && (e53 = ["literal", e53]), q(r, "annotate"), Array.isArray(e53)) {
      if (0 === e53.length)
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      let i = e53[0];
      if ("string" != typeof i)
        return this.error("Expression name must be a string, but found ".concat(typeof i, ' instead. If you wanted a literal array, use ["literal", [...]].'), 0), null;
      let a = this.registry[i];
      if (a) {
        let i3 = a.parse(e53, this);
        if (!i3)
          return null;
        if (this.expectedType) {
          let e54 = this.expectedType, a3 = i3.type;
          if ("string" !== e54.kind && "number" !== e54.kind && "boolean" !== e54.kind && "object" !== e54.kind && "array" !== e54.kind || "value" !== a3.kind)
            if ("color" !== e54.kind && "formatted" !== e54.kind && "resolvedImage" !== e54.kind || "value" !== a3.kind && "string" !== a3.kind)
              if ("padding" !== e54.kind || "value" !== a3.kind && "number" !== a3.kind && "array" !== a3.kind)
                if ("variableAnchorOffsetCollection" !== e54.kind || "value" !== a3.kind && "array" !== a3.kind) {
                  if (this.checkSubtype(e54, a3))
                    return null;
                } else
                  i3 = r(i3, e54, t3.typeAnnotation || "coerce");
              else
                i3 = r(i3, e54, t3.typeAnnotation || "coerce");
            else
              i3 = r(i3, e54, t3.typeAnnotation || "coerce");
          else
            i3 = r(i3, e54, t3.typeAnnotation || "assert");
        }
        if (!(i3 instanceof yr) && "resolvedImage" !== i3.type.kind && this._isConstant(i3)) {
          let e54 = new Ao();
          try {
            i3 = new yr(i3.type, i3.evaluate(e54));
          } catch (e55) {
            return this.error(e55.message), null;
          }
        }
        return i3;
      }
      return this.error('Unknown expression "'.concat(i, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    }
    return typeof e53 > "u" ? this.error("'undefined' value invalid. Use null instead.") : "object" == typeof e53 ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error("Expected an array, but found ".concat(typeof e53, " instead."));
  }
  concat(t3, r, i) {
    let a = "number" == typeof t3 ? this.path.concat(t3) : this.path, n = i ? this.scope.concat(i) : this.scope;
    return new e12(this.registry, this._isConstant, a, r || null, n, this.errors);
  }
  error(e53, ...t3) {
    let r = "".concat(this.key).concat(t3.map((e54) => "[".concat(e54, "]")).join(""));
    this.errors.push(new Et(r, e53));
  }
  checkSubtype(e53, t3) {
    let r = Rn(e53, t3);
    return r && this.error(r), r;
  }
};
q(No, "ParsingContext");
var Io = No;
var Go = class e13 {
  constructor(e53, t3, r) {
    this.type = ts, this.locale = r, this.caseSensitive = e53, this.diacriticSensitive = t3;
  }
  static parse(t3, r) {
    if (2 !== t3.length)
      return r.error("Expected one argument.");
    let i = t3[1];
    if ("object" != typeof i || Array.isArray(i))
      return r.error("Collator options argument must be an object.");
    let a = r.parse(void 0 !== i["case-sensitive"] && i["case-sensitive"], 1, oe);
    if (!a)
      return null;
    let n = r.parse(void 0 !== i["diacritic-sensitive"] && i["diacritic-sensitive"], 1, oe);
    if (!n)
      return null;
    let s3 = null;
    return i.locale && (s3 = r.parse(i.locale, 1, ce), !s3) ? null : new e13(a, n, s3);
  }
  evaluate(e53) {
    return new Vn(this.caseSensitive.evaluate(e53), this.diacriticSensitive.evaluate(e53), this.locale ? this.locale.evaluate(e53) : null);
  }
  eachChild(e53) {
    e53(this.caseSensitive), e53(this.diacriticSensitive), this.locale && e53(this.locale);
  }
  outputDefined() {
    return false;
  }
};
q(Go, "CollatorExpression");
var Mo = Go;
var dr = 8192;
function Jc(e53, t3) {
  e53[0] = Math.min(e53[0], t3[0]), e53[1] = Math.min(e53[1], t3[1]), e53[2] = Math.max(e53[2], t3[0]), e53[3] = Math.max(e53[3], t3[1]);
}
function v2(e53) {
  return (180 + e53) / 360;
}
function w2(e53) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e53 * Math.PI / 360))) / 360;
}
function Co(e53, t3) {
  return !(e53[0] <= t3[0] || e53[2] >= t3[2] || e53[1] <= t3[1] || e53[3] >= t3[3]);
}
function S2(e53, t3) {
  let r = v2(e53[0]), i = w2(e53[1]), a = Math.pow(2, t3.z);
  return [Math.round(r * a * dr), Math.round(i * a * dr)];
}
function P2(e53, t3, r) {
  let i = e53[0] - t3[0], a = e53[1] - t3[1], n = e53[0] - r[0], s3 = e53[1] - r[1];
  return i * s3 - n * a == 0 && i * n <= 0 && a * s3 <= 0;
}
function T2(e53, t3, r) {
  return t3[1] > e53[1] != r[1] > e53[1] && e53[0] < (r[0] - t3[0]) * (e53[1] - t3[1]) / (r[1] - t3[1]) + t3[0];
}
function Qc(e53, t3) {
  let r = false;
  for (let i = 0, a = t3.length; i < a; i++) {
    let a3 = t3[i];
    for (let t4 = 0, i3 = a3.length; t4 < i3 - 1; t4++) {
      if (P2(e53, a3[t4], a3[t4 + 1]))
        return false;
      T2(e53, a3[t4], a3[t4 + 1]) && (r = !r);
    }
  }
  return r;
}
function A2(e53, t3) {
  for (let r = 0; r < t3.length; r++)
    if (Qc(e53, t3[r]))
      return true;
  return false;
}
function I2(e53, t3) {
  return e53[0] * t3[1] - e53[1] * t3[0];
}
function fg(e53, t3, r, i) {
  let a = e53[0] - r[0], n = e53[1] - r[1], s3 = t3[0] - r[0], o = t3[1] - r[1], l = i[0] - r[0], u3 = i[1] - r[1], c3 = a * u3 - l * n, h = s3 * u3 - l * o;
  return c3 > 0 && h < 0 || c3 < 0 && h > 0;
}
function M2(e53, t3, r, i) {
  let a = [t3[0] - e53[0], t3[1] - e53[1]];
  return 0 !== I2([i[0] - r[0], i[1] - r[1]], a) && !(!fg(e53, t3, r, i) || !fg(r, i, e53, t3));
}
function C2(e53, t3, r) {
  for (let i of r)
    for (let r3 = 0; r3 < i.length - 1; ++r3)
      if (M2(e53, t3, i[r3], i[r3 + 1]))
        return true;
  return false;
}
function Rg(e53, t3) {
  for (let r = 0; r < e53.length; ++r)
    if (!Qc(e53[r], t3))
      return false;
  for (let r = 0; r < e53.length - 1; ++r)
    if (C2(e53[r], e53[r + 1], t3))
      return false;
  return true;
}
function E2(e53, t3) {
  for (let r = 0; r < t3.length; r++)
    if (Rg(e53, t3[r]))
      return true;
  return false;
}
function ep(e53, t3, r) {
  let i = [];
  for (let a = 0; a < e53.length; a++) {
    let n = [];
    for (let i3 = 0; i3 < e53[a].length; i3++) {
      let s3 = S2(e53[a][i3], r);
      Jc(t3, s3), n.push(s3);
    }
    i.push(n);
  }
  return i;
}
function Og(e53, t3, r) {
  let i = [];
  for (let a = 0; a < e53.length; a++) {
    let n = ep(e53[a], t3, r);
    i.push(n);
  }
  return i;
}
function Vg(e53, t3, r, i) {
  if (e53[0] < r[0] || e53[0] > r[2]) {
    let t4 = 0.5 * i, a = e53[0] - r[0] > t4 ? -i : r[0] - e53[0] > t4 ? i : 0;
    0 === a && (a = e53[0] - r[2] > t4 ? -i : r[2] - e53[0] > t4 ? i : 0), e53[0] += a;
  }
  Jc(t3, e53);
}
function k2(e53) {
  e53[0] = e53[1] = 1 / 0, e53[2] = e53[3] = -1 / 0;
}
function mg(e53, t3, r, i) {
  let a = Math.pow(2, i.z) * dr, n = [i.x * dr, i.y * dr], s3 = [];
  for (let i3 of e53)
    for (let e54 of i3) {
      let i4 = [e54.x + n[0], e54.y + n[1]];
      Vg(i4, t3, r, a), s3.push(i4);
    }
  return s3;
}
function dg(e53, t3, r, i) {
  let a = Math.pow(2, i.z) * dr, n = [i.x * dr, i.y * dr], s3 = [];
  for (let r3 of e53) {
    let e54 = [];
    for (let i3 of r3) {
      let r4 = [i3.x + n[0], i3.y + n[1]];
      Jc(t3, r4), e54.push(r4);
    }
    s3.push(e54);
  }
  if (t3[2] - t3[0] <= a / 2) {
    k2(t3);
    for (let e54 of s3)
      for (let i3 of e54)
        Vg(i3, t3, r, a);
  }
  return s3;
}
function L2(e53, t3) {
  let r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = e53.canonicalID();
  if ("Polygon" === t3.type) {
    let n = ep(t3.coordinates, i, a), s3 = mg(e53.geometry(), r, i, a);
    if (!Co(r, i))
      return false;
    for (let e54 of s3)
      if (!Qc(e54, n))
        return false;
  }
  if ("MultiPolygon" === t3.type) {
    let n = Og(t3.coordinates, i, a), s3 = mg(e53.geometry(), r, i, a);
    if (!Co(r, i))
      return false;
    for (let e54 of s3)
      if (!A2(e54, n))
        return false;
  }
  return true;
}
function D2(e53, t3) {
  let r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = e53.canonicalID();
  if ("Polygon" === t3.type) {
    let n = ep(t3.coordinates, i, a), s3 = dg(e53.geometry(), r, i, a);
    if (!Co(r, i))
      return false;
    for (let e54 of s3)
      if (!Rg(e54, n))
        return false;
  }
  if ("MultiPolygon" === t3.type) {
    let n = Og(t3.coordinates, i, a), s3 = dg(e53.geometry(), r, i, a);
    if (!Co(r, i))
      return false;
    for (let e54 of s3)
      if (!E2(e54, n))
        return false;
  }
  return true;
}
q(Jc, "updateBBox"), q(v2, "mercatorXfromLng"), q(w2, "mercatorYfromLat"), q(Co, "boxWithinBox"), q(S2, "getTileCoordinates"), q(P2, "onBoundary"), q(T2, "rayIntersect"), q(Qc, "pointWithinPolygon"), q(A2, "pointWithinPolygons"), q(I2, "perp"), q(fg, "twoSided"), q(M2, "lineIntersectLine"), q(C2, "lineIntersectPolygon"), q(Rg, "lineStringWithinPolygon"), q(E2, "lineStringWithinPolygons"), q(ep, "getTilePolygon"), q(Og, "getTilePolygons"), q(Vg, "updatePoint"), q(k2, "resetBBox"), q(mg, "getTilePoints"), q(dg, "getTileLines"), q(L2, "pointsWithinPolygons"), q(D2, "linesWithinPolygons");
var Mi = class e14 {
  constructor(e53, t3) {
    this.type = oe, this.geojson = e53, this.geometries = t3;
  }
  static parse(t3, r) {
    if (2 !== t3.length)
      return r.error("'within' expression requires exactly one argument, but found ".concat(t3.length - 1, " instead."));
    if (To(t3[1])) {
      let r3 = t3[1];
      if ("FeatureCollection" === r3.type)
        for (let t4 = 0; t4 < r3.features.length; ++t4) {
          let i = r3.features[t4].geometry.type;
          if ("Polygon" === i || "MultiPolygon" === i)
            return new e14(r3, r3.features[t4].geometry);
        }
      else if ("Feature" === r3.type) {
        let t4 = r3.geometry.type;
        if ("Polygon" === t4 || "MultiPolygon" === t4)
          return new e14(r3, r3.geometry);
      } else if ("Polygon" === r3.type || "MultiPolygon" === r3.type)
        return new e14(r3, r3);
    }
    return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e53) {
    if (null != e53.geometry() && null != e53.canonicalID()) {
      if ("Point" === e53.geometryType())
        return L2(e53, this.geometries);
      if ("LineString" === e53.geometryType())
        return D2(e53, this.geometries);
    }
    return false;
  }
  eachChild() {
  }
  outputDefined() {
    return true;
  }
};
q(Mi, "Within");
var Nn = Mi;
var qo = class e15 {
  constructor(e53, t3) {
    this.type = t3.type, this.name = e53, this.boundExpression = t3;
  }
  static parse(t3, r) {
    if (2 !== t3.length || "string" != typeof t3[1])
      return r.error("'var' expression requires exactly one string literal argument.");
    let i = t3[1];
    return r.scope.has(i) ? new e15(i, r.scope.get(i)) : r.error('Unknown variable "'.concat(i, '". Make sure "').concat(i, '" has been bound in an enclosing "let" expression before using it.'), 1);
  }
  evaluate(e53) {
    return this.boundExpression.evaluate(e53);
  }
  eachChild() {
  }
  outputDefined() {
    return false;
  }
};
q(qo, "Var");
var Eo = qo;
var $r = class e16 {
  constructor(e53, t3, r, i) {
    this.name = e53, this.type = t3, this._evaluate = r, this.args = i;
  }
  evaluate(e53) {
    return this._evaluate(e53, this.args);
  }
  eachChild(e53) {
    this.args.forEach(e53);
  }
  outputDefined() {
    return false;
  }
  static parse(t3, r) {
    let i = t3[0], a = e16.definitions[i];
    if (!a)
      return r.error('Unknown expression "'.concat(i, '". If you wanted a literal array, use ["literal", [...]].'), 0);
    let n = Array.isArray(a) ? a[0] : a.type, s3 = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, o = s3.filter(([e53]) => !Array.isArray(e53) || e53.length === t3.length - 1), l = null;
    for (let [a3, s4] of o) {
      l = new Io(r.registry, ko, r.path, null, r.scope);
      let o3 = [], u3 = false;
      for (let e53 = 1; e53 < t3.length; e53++) {
        let r3 = t3[e53], i3 = Array.isArray(a3) ? a3[e53 - 1] : a3.type, n3 = l.parse(r3, 1 + o3.length, i3);
        if (!n3) {
          u3 = true;
          break;
        }
        o3.push(n3);
      }
      if (!u3) {
        if (Array.isArray(a3) && a3.length !== o3.length) {
          l.error("Expected ".concat(a3.length, " arguments, but found ").concat(o3.length, " instead."));
          continue;
        }
        for (let e53 = 0; e53 < o3.length; e53++) {
          let t4 = Array.isArray(a3) ? a3[e53] : a3.type, r3 = o3[e53];
          l.concat(e53 + 1).checkSubtype(t4, r3.type);
        }
        if (0 === l.errors.length)
          return new e16(i, n, s4, o3);
      }
    }
    if (1 === o.length)
      r.errors.push(...l.errors);
    else {
      let e53 = (o.length ? o : s3).map(([e54]) => z2(e54)).join(" | "), i3 = [];
      for (let e54 = 1; e54 < t3.length; e54++) {
        let a3 = r.parse(t3[e54], 1 + i3.length);
        if (!a3)
          return null;
        i3.push(Ue(a3.type));
      }
      r.error("Expected arguments of type ".concat(e53, ", but found (").concat(i3.join(", "), ") instead."));
    }
    return null;
  }
  static register(t3, r) {
    e16.definitions = r;
    for (let i in r)
      t3[i] = e16;
  }
};
q($r, "CompoundExpression");
var qt = $r;
function z2(e53) {
  return Array.isArray(e53) ? "(".concat(e53.map(Ue).join(", "), ")") : "(".concat(Ue(e53.type), "...)");
}
function ko(e53) {
  if (e53 instanceof Eo)
    return ko(e53.boundExpression);
  if (e53 instanceof qt && "error" === e53.name)
    return false;
  if (e53 instanceof Mo)
    return false;
  if (e53 instanceof Nn)
    return false;
  let t3 = e53 instanceof mr || e53 instanceof Rt, r = true;
  return e53.eachChild((e54) => {
    r = t3 ? r && ko(e54) : r && e54 instanceof yr;
  }), !!r && (ns(e53) && as(e53, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]));
}
function ns(e53) {
  if (e53 instanceof qt) {
    if ("get" === e53.name && 1 === e53.args.length)
      return false;
    if ("feature-state" === e53.name)
      return false;
    if ("has" === e53.name && 1 === e53.args.length)
      return false;
    if ("properties" === e53.name || "geometry-type" === e53.name || "id" === e53.name)
      return false;
    if (/^filter-/.test(e53.name))
      return false;
  }
  if (e53 instanceof Nn)
    return false;
  let t3 = true;
  return e53.eachChild((e54) => {
    t3 && !ns(e54) && (t3 = false);
  }), t3;
}
function Gn(e53) {
  if (e53 instanceof qt && "feature-state" === e53.name)
    return false;
  let t3 = true;
  return e53.eachChild((e54) => {
    t3 && !Gn(e54) && (t3 = false);
  }), t3;
}
function as(e53, t3) {
  if (e53 instanceof qt && t3.indexOf(e53.name) >= 0)
    return false;
  let r = true;
  return e53.eachChild((e54) => {
    r && !as(e54, t3) && (r = false);
  }), r;
}
function os(e53, t3) {
  let r, i, a = e53.length - 1, n = 0, s3 = a, o = 0;
  for (; n <= s3; )
    if (o = Math.floor((n + s3) / 2), r = e53[o], i = e53[o + 1], r <= t3) {
      if (o === a || t3 < i)
        return o;
      n = o + 1;
    } else {
      if (!(r > t3))
        throw new Ne("Input is not a number.");
      s3 = o - 1;
    }
  return 0;
}
q(z2, "stringifySignature"), q(ko, "isExpressionConstant"), q(ns, "isFeatureConstant"), q(Gn, "isStateConstant"), q(as, "isGlobalPropertyConstant"), q(os, "findStopLessThanOrEqualTo");
var jo = class e17 {
  constructor(e53, t3, r) {
    this.type = e53, this.input = t3, this.labels = [], this.outputs = [];
    for (let [e54, t4] of r)
      this.labels.push(e54), this.outputs.push(t4);
  }
  static parse(t3, r) {
    if (t3.length - 1 < 4)
      return r.error("Expected at least 4 arguments, but found only ".concat(t3.length - 1, "."));
    if ((t3.length - 1) % 2 != 0)
      return r.error("Expected an even number of arguments.");
    let i = r.parse(t3[1], 1, j);
    if (!i)
      return null;
    let a = [], n = null;
    r.expectedType && "value" !== r.expectedType.kind && (n = r.expectedType);
    for (let e53 = 1; e53 < t3.length; e53 += 2) {
      let i3 = 1 === e53 ? -1 / 0 : t3[e53], s3 = t3[e53 + 1], o = e53, l = e53 + 1;
      if ("number" != typeof i3)
        return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
      if (a.length && a[a.length - 1][0] >= i3)
        return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
      let u3 = r.parse(s3, l, n);
      if (!u3)
        return null;
      n = n || u3.type, a.push([i3, u3]);
    }
    return new e17(n, i, a);
  }
  evaluate(e53) {
    let t3 = this.labels, r = this.outputs;
    if (1 === t3.length)
      return r[0].evaluate(e53);
    let i = this.input.evaluate(e53);
    if (i <= t3[0])
      return r[0].evaluate(e53);
    let a = t3.length;
    return i >= t3[a - 1] ? r[a - 1].evaluate(e53) : r[os(t3, i)].evaluate(e53);
  }
  eachChild(e53) {
    e53(this.input);
    for (let t3 of this.outputs)
      e53(t3);
  }
  outputDefined() {
    return this.outputs.every((e53) => e53.outputDefined());
  }
};
q(jo, "Step");
var Li = jo;
function F2(e53) {
  return "rgb" === e53 || "hcl" === e53 || "lab" === e53;
}
function Hr(e53, t3, r) {
  return e53 + r * (t3 - e53);
}
function B2(e53, t3, r, i = "rgb") {
  switch (i) {
    case "rgb": {
      let [i3, a, n, s3] = Lo(e53.rgb, t3.rgb, r);
      return new K(i3, a, n, s3, false);
    }
    case "hcl": {
      let i3, a, [n, s3, o, l] = e53.hcl, [u3, c3, h, p] = t3.hcl;
      if (isNaN(n) || isNaN(u3))
        isNaN(n) ? isNaN(u3) ? i3 = NaN : (i3 = u3, (1 === o || 0 === o) && (a = c3)) : (i3 = n, (1 === h || 0 === h) && (a = s3));
      else {
        let e54 = u3 - n;
        u3 > n && e54 > 180 ? e54 -= 360 : u3 < n && n - u3 > 180 && (e54 += 360), i3 = n + r * e54;
      }
      let [d, f, m, y] = d2([i3, null != a ? a : Hr(s3, c3, r), Hr(o, h, r), Hr(l, p, r)]);
      return new K(d, f, m, y, false);
    }
    case "lab": {
      let [i3, a, n, s3] = Fg(Lo(e53.lab, t3.lab, r));
      return new K(i3, a, n, s3, false);
    }
  }
}
function Lo(e53, t3, r) {
  return e53.map((e54, i) => Hr(e54, t3[i], r));
}
function R2(e53, t3, r) {
  return new Ot(Lo(e53.values, t3.values, r));
}
function O2(e53, t3, r) {
  let i = e53.values, a = t3.values;
  if (i.length !== a.length)
    throw new Ne("Cannot interpolate values of different length. from: ".concat(e53.toString(), ", to: ").concat(t3.toString()));
  let n = [];
  for (let e54 = 0; e54 < i.length; e54 += 2) {
    if (i[e54] !== a[e54])
      throw new Ne("Cannot interpolate values containing mismatched anchors. from[".concat(e54, "]: ").concat(i[e54], ", to[").concat(e54, "]: ").concat(a[e54]));
    n.push(i[e54]);
    let [t4, s3] = i[e54 + 1], [o, l] = a[e54 + 1];
    n.push([Hr(t4, o, r), Hr(s3, l, r)]);
  }
  return new Qt(n);
}
q(F2, "isSupportedInterpolationColorSpace"), q(Hr, "number"), q(B2, "color"), q(Lo, "array"), q(R2, "padding"), q(O2, "variableAnchorOffsetCollection");
var ke = { number: Hr, color: B2, array: Lo, padding: R2, variableAnchorOffsetCollection: O2 };
var Dn = class e18 {
  constructor(e53, t3, r, i, a) {
    this.type = e53, this.operator = t3, this.interpolation = r, this.input = i, this.labels = [], this.outputs = [];
    for (let [e54, t4] of a)
      this.labels.push(e54), this.outputs.push(t4);
  }
  static interpolationFactor(e53, t3, r, i) {
    let a = 0;
    if ("exponential" === e53.name)
      a = Bc(t3, e53.base, r, i);
    else if ("linear" === e53.name)
      a = Bc(t3, 1, r, i);
    else if ("cubic-bezier" === e53.name) {
      let n = e53.controlPoints;
      a = new Pg.default(n[0], n[1], n[2], n[3]).solve(Bc(t3, 1, r, i));
    }
    return a;
  }
  static parse(t3, r) {
    let [i, a, n, ...s3] = t3;
    if (!Array.isArray(a) || 0 === a.length)
      return r.error("Expected an interpolation type expression.", 1);
    if ("linear" === a[0])
      a = { name: "linear" };
    else if ("exponential" === a[0]) {
      let e53 = a[1];
      if ("number" != typeof e53)
        return r.error("Exponential interpolation requires a numeric base.", 1, 1);
      a = { name: "exponential", base: e53 };
    } else {
      if ("cubic-bezier" !== a[0])
        return r.error("Unknown interpolation type ".concat(String(a[0])), 1, 0);
      {
        let e53 = a.slice(1);
        if (4 !== e53.length || e53.some((e54) => "number" != typeof e54 || e54 < 0 || e54 > 1))
          return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
        a = { name: "cubic-bezier", controlPoints: e53 };
      }
    }
    if (t3.length - 1 < 4)
      return r.error("Expected at least 4 arguments, but found only ".concat(t3.length - 1, "."));
    if ((t3.length - 1) % 2 != 0)
      return r.error("Expected an even number of arguments.");
    if (n = r.parse(n, 2, j), !n)
      return null;
    let o = [], l = null;
    "interpolate-hcl" === i || "interpolate-lab" === i ? l = Lt : r.expectedType && "value" !== r.expectedType.kind && (l = r.expectedType);
    for (let e53 = 0; e53 < s3.length; e53 += 2) {
      let t4 = s3[e53], i3 = s3[e53 + 1], a3 = e53 + 3, n3 = e53 + 4;
      if ("number" != typeof t4)
        return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a3);
      if (o.length && o[o.length - 1][0] >= t4)
        return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', a3);
      let u3 = r.parse(i3, n3, l);
      if (!u3)
        return null;
      l = l || u3.type, o.push([t4, u3]);
    }
    return Mn(l, j) || Mn(l, Lt) || Mn(l, rs) || Mn(l, is) || Mn(l, vt(j)) ? new e18(l, i, a, n, o) : r.error("Type ".concat(Ue(l), " is not interpolatable."));
  }
  evaluate(t3) {
    let r = this.labels, i = this.outputs;
    if (1 === r.length)
      return i[0].evaluate(t3);
    let a = this.input.evaluate(t3);
    if (a <= r[0])
      return i[0].evaluate(t3);
    let n = r.length;
    if (a >= r[n - 1])
      return i[n - 1].evaluate(t3);
    let s3 = os(r, a), o = r[s3], l = r[s3 + 1], u3 = e18.interpolationFactor(this.interpolation, a, o, l), c3 = i[s3].evaluate(t3), h = i[s3 + 1].evaluate(t3);
    switch (this.operator) {
      case "interpolate":
        return ke[this.type.kind](c3, h, u3);
      case "interpolate-hcl":
        return ke.color(c3, h, u3, "hcl");
      case "interpolate-lab":
        return ke.color(c3, h, u3, "lab");
    }
  }
  eachChild(e53) {
    e53(this.input);
    for (let t3 of this.outputs)
      e53(t3);
  }
  outputDefined() {
    return this.outputs.every((e53) => e53.outputDefined());
  }
};
q(Dn, "Interpolate");
var wt = Dn;
function Bc(e53, t3, r, i) {
  let a = i - r, n = e53 - r;
  return 0 === a ? 0 : 1 === t3 ? n / a : (Math.pow(t3, n) - 1) / (Math.pow(t3, a) - 1);
}
q(Bc, "exponentialInterpolation");
var zn = class e19 {
  constructor(e53, t3) {
    this.type = e53, this.args = t3;
  }
  static parse(t3, r) {
    if (t3.length < 2)
      return r.error("Expectected at least one argument.");
    let i = null, a = r.expectedType;
    a && "value" !== a.kind && (i = a);
    let n = [];
    for (let e53 of t3.slice(1)) {
      let t4 = r.parse(e53, 1 + n.length, i, void 0, { typeAnnotation: "omit" });
      if (!t4)
        return null;
      i = i || t4.type, n.push(t4);
    }
    if (!i)
      throw new Error("No output type");
    return a && n.some((e53) => Rn(a, e53.type)) ? new e19(se, n) : new e19(i, n);
  }
  evaluate(e53) {
    let t3, r = null, i = 0;
    for (let a of this.args)
      if (i++, r = a.evaluate(e53), r && r instanceof pt && !r.available && (t3 || (t3 = r.name), r = null, i === this.args.length && (r = t3)), null !== r)
        break;
    return r;
  }
  eachChild(e53) {
    this.args.forEach(e53);
  }
  outputDefined() {
    return this.args.every((e53) => e53.outputDefined());
  }
};
q(zn, "Coalesce");
var Do = zn;
var $o = class e20 {
  constructor(e53, t3) {
    this.type = t3.type, this.bindings = [].concat(e53), this.result = t3;
  }
  evaluate(e53) {
    return this.result.evaluate(e53);
  }
  eachChild(e53) {
    for (let t3 of this.bindings)
      e53(t3[1]);
    e53(this.result);
  }
  static parse(t3, r) {
    if (t3.length < 4)
      return r.error("Expected at least 3 arguments, but found ".concat(t3.length - 1, " instead."));
    let i = [];
    for (let e53 = 1; e53 < t3.length - 1; e53 += 2) {
      let a3 = t3[e53];
      if ("string" != typeof a3)
        return r.error("Expected string, but found ".concat(typeof a3, " instead."), e53);
      if (/[^a-zA-Z0-9_]/.test(a3))
        return r.error("Variable names must contain only alphanumeric characters or '_'.", e53);
      let n = r.parse(t3[e53 + 1], e53 + 1);
      if (!n)
        return null;
      i.push([a3, n]);
    }
    let a = r.parse(t3[t3.length - 1], t3.length - 1, r.expectedType, i);
    return a ? new e20(i, a) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
};
q($o, "Let");
var zo = $o;
var Ho = class e21 {
  constructor(e53, t3, r) {
    this.type = e53, this.index = t3, this.input = r;
  }
  static parse(t3, r) {
    if (3 !== t3.length)
      return r.error("Expected 2 arguments, but found ".concat(t3.length - 1, " instead."));
    let i = r.parse(t3[1], 1, j), a = r.parse(t3[2], 2, vt(r.expectedType || se));
    if (!i || !a)
      return null;
    let n = a.type;
    return new e21(n.itemType, i, a);
  }
  evaluate(e53) {
    let t3 = this.index.evaluate(e53), r = this.input.evaluate(e53);
    if (t3 < 0)
      throw new Ne("Array index out of bounds: ".concat(t3, " < 0."));
    if (t3 >= r.length)
      throw new Ne("Array index out of bounds: ".concat(t3, " > ").concat(r.length - 1, "."));
    if (t3 !== Math.floor(t3))
      throw new Ne("Array index must be an integer, but found ".concat(t3, " instead."));
    return r[t3];
  }
  eachChild(e53) {
    e53(this.index), e53(this.input);
  }
  outputDefined() {
    return false;
  }
};
q(Ho, "At");
var Uc = Ho;
var Zo = class e22 {
  constructor(e53, t3) {
    this.type = oe, this.needle = e53, this.haystack = t3;
  }
  static parse(t3, r) {
    if (3 !== t3.length)
      return r.error("Expected 2 arguments, but found ".concat(t3.length - 1, " instead."));
    let i = r.parse(t3[1], 1, se), a = r.parse(t3[2], 2, se);
    return i && a ? Yc(i.type, [oe, ce, j, zi, se]) ? new e22(i, a) : r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Ue(i.type), " instead")) : null;
  }
  evaluate(e53) {
    let t3 = this.needle.evaluate(e53), r = this.haystack.evaluate(e53);
    if (!r)
      return false;
    if (!On(t3, ["boolean", "string", "number", "null"]))
      throw new Ne("Expected first argument to be of type boolean, string, number or null, but found ".concat(Ue(We(t3)), " instead."));
    if (!On(r, ["string", "array"]))
      throw new Ne("Expected second argument to be of type array or string, but found ".concat(Ue(We(r)), " instead."));
    return r.indexOf(t3) >= 0;
  }
  eachChild(e53) {
    e53(this.needle), e53(this.haystack);
  }
  outputDefined() {
    return true;
  }
};
q(Zo, "In");
var Nc = Zo;
var Fn = class e23 {
  constructor(e53, t3, r) {
    this.type = j, this.needle = e53, this.haystack = t3, this.fromIndex = r;
  }
  static parse(t3, r) {
    if (t3.length <= 2 || t3.length >= 5)
      return r.error("Expected 3 or 4 arguments, but found ".concat(t3.length - 1, " instead."));
    let i = r.parse(t3[1], 1, se), a = r.parse(t3[2], 2, se);
    if (!i || !a)
      return null;
    if (!Yc(i.type, [oe, ce, j, zi, se]))
      return r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(Ue(i.type), " instead"));
    if (4 === t3.length) {
      let n = r.parse(t3[3], 3, j);
      return n ? new e23(i, a, n) : null;
    }
    return new e23(i, a);
  }
  evaluate(e53) {
    let t3 = this.needle.evaluate(e53), r = this.haystack.evaluate(e53);
    if (!On(t3, ["boolean", "string", "number", "null"]))
      throw new Ne("Expected first argument to be of type boolean, string, number or null, but found ".concat(Ue(We(t3)), " instead."));
    if (!On(r, ["string", "array"]))
      throw new Ne("Expected second argument to be of type array or string, but found ".concat(Ue(We(r)), " instead."));
    if (this.fromIndex) {
      let i = this.fromIndex.evaluate(e53);
      return r.indexOf(t3, i);
    }
    return r.indexOf(t3);
  }
  eachChild(e53) {
    e53(this.needle), e53(this.haystack), this.fromIndex && e53(this.fromIndex);
  }
  outputDefined() {
    return false;
  }
};
q(Fn, "IndexOf");
var Gc = Fn;
var Wo = class e24 {
  constructor(e53, t3, r, i, a, n) {
    this.inputType = e53, this.type = t3, this.input = r, this.cases = i, this.outputs = a, this.otherwise = n;
  }
  static parse(t3, r) {
    if (t3.length < 5)
      return r.error("Expected at least 4 arguments, but found only ".concat(t3.length - 1, "."));
    if (t3.length % 2 != 1)
      return r.error("Expected an even number of arguments.");
    let i, a;
    r.expectedType && "value" !== r.expectedType.kind && (a = r.expectedType);
    let n = {}, s3 = [];
    for (let e53 = 2; e53 < t3.length - 1; e53 += 2) {
      let o3 = t3[e53], l3 = t3[e53 + 1];
      Array.isArray(o3) || (o3 = [o3]);
      let u3 = r.concat(e53);
      if (0 === o3.length)
        return u3.error("Expected at least one branch label.");
      for (let e54 of o3) {
        if ("number" != typeof e54 && "string" != typeof e54)
          return u3.error("Branch labels must be numbers or strings.");
        if ("number" == typeof e54 && Math.abs(e54) > Number.MAX_SAFE_INTEGER)
          return u3.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));
        if ("number" == typeof e54 && Math.floor(e54) !== e54)
          return u3.error("Numeric branch labels must be integer values.");
        if (i) {
          if (u3.checkSubtype(i, We(e54)))
            return null;
        } else
          i = We(e54);
        if (typeof n[String(e54)] < "u")
          return u3.error("Branch labels must be unique.");
        n[String(e54)] = s3.length;
      }
      let c3 = r.parse(l3, e53, a);
      if (!c3)
        return null;
      a = a || c3.type, s3.push(c3);
    }
    let o = r.parse(t3[1], 1, se);
    if (!o)
      return null;
    let l = r.parse(t3[t3.length - 1], t3.length - 1, a);
    return !l || "value" !== o.type.kind && r.concat(1).checkSubtype(i, o.type) ? null : new e24(i, a, o, n, s3, l);
  }
  evaluate(e53) {
    let t3 = this.input.evaluate(e53);
    return (We(t3) === this.inputType && this.outputs[this.cases[t3]] || this.otherwise).evaluate(e53);
  }
  eachChild(e53) {
    e53(this.input), this.outputs.forEach(e53), e53(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e53) => e53.outputDefined()) && this.otherwise.outputDefined();
  }
};
q(Wo, "Match");
var qc = Wo;
var Xo = class e25 {
  constructor(e53, t3, r) {
    this.type = e53, this.branches = t3, this.otherwise = r;
  }
  static parse(t3, r) {
    if (t3.length < 4)
      return r.error("Expected at least 3 arguments, but found only ".concat(t3.length - 1, "."));
    if (t3.length % 2 != 0)
      return r.error("Expected an odd number of arguments.");
    let i;
    r.expectedType && "value" !== r.expectedType.kind && (i = r.expectedType);
    let a = [];
    for (let e53 = 1; e53 < t3.length - 1; e53 += 2) {
      let n3 = r.parse(t3[e53], e53, oe);
      if (!n3)
        return null;
      let s3 = r.parse(t3[e53 + 1], e53 + 1, i);
      if (!s3)
        return null;
      a.push([n3, s3]), i = i || s3.type;
    }
    let n = r.parse(t3[t3.length - 1], t3.length - 1, i);
    if (!n)
      return null;
    if (!i)
      throw new Error("Can't infer output type");
    return new e25(i, a, n);
  }
  evaluate(e53) {
    for (let [t3, r] of this.branches)
      if (t3.evaluate(e53))
        return r.evaluate(e53);
    return this.otherwise.evaluate(e53);
  }
  eachChild(e53) {
    for (let [t3, r] of this.branches)
      e53(t3), e53(r);
    e53(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e53, t3]) => t3.outputDefined()) && this.otherwise.outputDefined();
  }
};
q(Xo, "Case");
var jc = Xo;
var Bn = class e26 {
  constructor(e53, t3, r, i) {
    this.type = e53, this.input = t3, this.beginIndex = r, this.endIndex = i;
  }
  static parse(t3, r) {
    if (t3.length <= 2 || t3.length >= 5)
      return r.error("Expected 3 or 4 arguments, but found ".concat(t3.length - 1, " instead."));
    let i = r.parse(t3[1], 1, se), a = r.parse(t3[2], 2, j);
    if (!i || !a)
      return null;
    if (!Yc(i.type, [vt(se), ce, se]))
      return r.error("Expected first argument to be of type array or string, but found ".concat(Ue(i.type), " instead"));
    if (4 === t3.length) {
      let n = r.parse(t3[3], 3, j);
      return n ? new e26(i.type, i, a, n) : null;
    }
    return new e26(i.type, i, a);
  }
  evaluate(e53) {
    let t3 = this.input.evaluate(e53), r = this.beginIndex.evaluate(e53);
    if (!On(t3, ["string", "array"]))
      throw new Ne("Expected first argument to be of type array or string, but found ".concat(Ue(We(t3)), " instead."));
    if (this.endIndex) {
      let i = this.endIndex.evaluate(e53);
      return t3.slice(r, i);
    }
    return t3.slice(r);
  }
  eachChild(e53) {
    e53(this.input), e53(this.beginIndex), this.endIndex && e53(this.endIndex);
  }
  outputDefined() {
    return false;
  }
};
q(Bn, "Slice");
var $c = Bn;
function yg(e53, t3) {
  return "==" === e53 || "!=" === e53 ? "boolean" === t3.kind || "string" === t3.kind || "number" === t3.kind || "null" === t3.kind || "value" === t3.kind : "string" === t3.kind || "number" === t3.kind || "value" === t3.kind;
}
function V2(e53, t3, r) {
  return t3 === r;
}
function U2(e53, t3, r) {
  return t3 !== r;
}
function N2(e53, t3, r) {
  return t3 < r;
}
function G2(e53, t3, r) {
  return t3 > r;
}
function q2(e53, t3, r) {
  return t3 <= r;
}
function j2(e53, t3, r) {
  return t3 >= r;
}
function Ug(e53, t3, r, i) {
  return 0 === i.compare(t3, r);
}
function $2(e53, t3, r, i) {
  return !Ug(e53, t3, r, i);
}
function H2(e53, t3, r, i) {
  return i.compare(t3, r) < 0;
}
function Z2(e53, t3, r, i) {
  return i.compare(t3, r) > 0;
}
function W2(e53, t3, r, i) {
  return i.compare(t3, r) <= 0;
}
function X2(e53, t3, r, i) {
  return i.compare(t3, r) >= 0;
}
function Bi(e53, t3, r) {
  var i;
  let a = "==" !== e53 && "!=" !== e53;
  return q(i = class {
    constructor(e54, t4, r3) {
      this.type = oe, this.lhs = e54, this.rhs = t4, this.collator = r3, this.hasUntypedArgument = "value" === e54.type.kind || "value" === t4.type.kind;
    }
    static parse(e54, t4) {
      if (3 !== e54.length && 4 !== e54.length)
        return t4.error("Expected two or three arguments.");
      let r3 = e54[0], n = t4.parse(e54[1], 1, se);
      if (!n)
        return null;
      if (!yg(r3, n.type))
        return t4.concat(1).error('"'.concat(r3, `" comparisons are not supported for type '`).concat(Ue(n.type), "'."));
      let s3 = t4.parse(e54[2], 2, se);
      if (!s3)
        return null;
      if (!yg(r3, s3.type))
        return t4.concat(2).error('"'.concat(r3, `" comparisons are not supported for type '`).concat(Ue(s3.type), "'."));
      if (n.type.kind !== s3.type.kind && "value" !== n.type.kind && "value" !== s3.type.kind)
        return t4.error("Cannot compare types '".concat(Ue(n.type), "' and '").concat(Ue(s3.type), "'."));
      a && ("value" === n.type.kind && "value" !== s3.type.kind ? n = new Rt(s3.type, [n]) : "value" !== n.type.kind && "value" === s3.type.kind && (s3 = new Rt(n.type, [s3])));
      let o = null;
      if (4 === e54.length) {
        if ("string" !== n.type.kind && "string" !== s3.type.kind && "value" !== n.type.kind && "value" !== s3.type.kind)
          return t4.error("Cannot use collator to compare non-string types.");
        if (o = t4.parse(e54[3], 3, ts), !o)
          return null;
      }
      return new i(n, s3, o);
    }
    evaluate(i3) {
      let n = this.lhs.evaluate(i3), s3 = this.rhs.evaluate(i3);
      if (a && this.hasUntypedArgument) {
        let t4 = We(n), r3 = We(s3);
        if (t4.kind !== r3.kind || "string" !== t4.kind && "number" !== t4.kind)
          throw new Ne('Expected arguments for "'.concat(e53, '" to be (string, string) or (number, number), but found (').concat(t4.kind, ", ").concat(r3.kind, ") instead."));
      }
      if (this.collator && !a && this.hasUntypedArgument) {
        let e54 = We(n), r3 = We(s3);
        if ("string" !== e54.kind || "string" !== r3.kind)
          return t3(i3, n, s3);
      }
      return this.collator ? r(i3, n, s3, this.collator.evaluate(i3)) : t3(i3, n, s3);
    }
    eachChild(e54) {
      e54(this.lhs), e54(this.rhs), this.collator && e54(this.collator);
    }
    outputDefined() {
      return true;
    }
  }, "Comparison"), i;
}
q(yg, "isComparableType"), q(V2, "eq"), q(U2, "neq"), q(N2, "lt"), q(G2, "gt"), q(q2, "lteq"), q(j2, "gteq"), q(Ug, "eqCollate"), q($2, "neqCollate"), q(H2, "ltCollate"), q(Z2, "gtCollate"), q(W2, "lteqCollate"), q(X2, "gteqCollate"), q(Bi, "makeComparison");
var K2 = Bi("==", V2, Ug);
var Y2 = Bi("!=", U2, $2);
var J2 = Bi("<", N2, H2);
var Q2 = Bi(">", G2, Z2);
var eS = Bi("<=", q2, W2);
var tS = Bi(">=", j2, X2);
var Ko = class e27 {
  constructor(e53, t3, r, i, a) {
    this.type = ce, this.number = e53, this.locale = t3, this.currency = r, this.minFractionDigits = i, this.maxFractionDigits = a;
  }
  static parse(t3, r) {
    if (3 !== t3.length)
      return r.error("Expected two arguments.");
    let i = r.parse(t3[1], 1, j);
    if (!i)
      return null;
    let a = t3[2];
    if ("object" != typeof a || Array.isArray(a))
      return r.error("NumberFormat options argument must be an object.");
    let n = null;
    if (a.locale && (n = r.parse(a.locale, 1, ce), !n))
      return null;
    let s3 = null;
    if (a.currency && (s3 = r.parse(a.currency, 1, ce), !s3))
      return null;
    let o = null;
    if (a["min-fraction-digits"] && (o = r.parse(a["min-fraction-digits"], 1, j), !o))
      return null;
    let l = null;
    return a["max-fraction-digits"] && (l = r.parse(a["max-fraction-digits"], 1, j), !l) ? null : new e27(i, n, s3, o, l);
  }
  evaluate(e53) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e53) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(e53) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e53) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e53) : void 0 }).format(this.number.evaluate(e53));
  }
  eachChild(e53) {
    e53(this.number), this.locale && e53(this.locale), this.currency && e53(this.currency), this.minFractionDigits && e53(this.minFractionDigits), this.maxFractionDigits && e53(this.maxFractionDigits);
  }
  outputDefined() {
    return false;
  }
};
q(Ko, "NumberFormat");
var Hc = Ko;
var Yo = class e28 {
  constructor(e53) {
    this.type = Fi, this.sections = e53;
  }
  static parse(t3, r) {
    if (t3.length < 2)
      return r.error("Expected at least one argument.");
    let i = t3[1];
    if (!Array.isArray(i) && "object" == typeof i)
      return r.error("First argument must be an image or text section.");
    let a = [], n = false;
    for (let e53 = 1; e53 <= t3.length - 1; ++e53) {
      let i3 = t3[e53];
      if (n && "object" == typeof i3 && !Array.isArray(i3)) {
        n = false;
        let e54 = null;
        if (i3["font-scale"] && (e54 = r.parse(i3["font-scale"], 1, j), !e54))
          return null;
        let t4 = null;
        if (i3["text-font"] && (t4 = r.parse(i3["text-font"], 1, vt(ce)), !t4))
          return null;
        let s3 = null;
        if (i3["text-color"] && (s3 = r.parse(i3["text-color"], 1, Lt), !s3))
          return null;
        let o = a[a.length - 1];
        o.scale = e54, o.font = t4, o.textColor = s3;
      } else {
        let i4 = r.parse(t3[e53], 1, se);
        if (!i4)
          return null;
        let s3 = i4.type.kind;
        if ("string" !== s3 && "value" !== s3 && "null" !== s3 && "resolvedImage" !== s3)
          return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        n = true, a.push({ content: i4, scale: null, font: null, textColor: null });
      }
    }
    return new e28(a);
  }
  evaluate(e53) {
    let t3 = q((t4) => {
      let r = t4.content.evaluate(e53);
      return We(r) === Hn ? new Un("", r, null, null, null) : new Un(Cn(r), null, t4.scale ? t4.scale.evaluate(e53) : null, t4.font ? t4.font.evaluate(e53).join(",") : null, t4.textColor ? t4.textColor.evaluate(e53) : null);
    }, "evaluateSection");
    return new St(this.sections.map(t3));
  }
  eachChild(e53) {
    for (let t3 of this.sections)
      e53(t3.content), t3.scale && e53(t3.scale), t3.font && e53(t3.font), t3.textColor && e53(t3.textColor);
  }
  outputDefined() {
    return false;
  }
};
q(Yo, "FormatExpression");
var qn = Yo;
var Jo = class e29 {
  constructor(e53) {
    this.type = Hn, this.input = e53;
  }
  static parse(t3, r) {
    if (2 !== t3.length)
      return r.error("Expected two arguments.");
    let i = r.parse(t3[1], 1, ce);
    return i ? new e29(i) : r.error("No image name provided.");
  }
  evaluate(e53) {
    let t3 = this.input.evaluate(e53), r = pt.fromString(t3);
    return r && e53.availableImages && (r.available = e53.availableImages.indexOf(t3) > -1), r;
  }
  eachChild(e53) {
    e53(this.input);
  }
  outputDefined() {
    return false;
  }
};
q(Jo, "ImageExpression");
var Zc = Jo;
var Qo = class e30 {
  constructor(e53) {
    this.type = j, this.input = e53;
  }
  static parse(t3, r) {
    if (2 !== t3.length)
      return r.error("Expected 1 argument, but found ".concat(t3.length - 1, " instead."));
    let i = r.parse(t3[1], 1);
    return i ? "array" !== i.type.kind && "string" !== i.type.kind && "value" !== i.type.kind ? r.error("Expected argument of type string or array, but found ".concat(Ue(i.type), " instead.")) : new e30(i) : null;
  }
  evaluate(e53) {
    let t3 = this.input.evaluate(e53);
    if ("string" == typeof t3)
      return t3.length;
    if (Array.isArray(t3))
      return t3.length;
    throw new Ne("Expected value to be of type string or array, but found ".concat(Ue(We(t3)), " instead."));
  }
  eachChild(e53) {
    e53(this.input);
  }
  outputDefined() {
    return false;
  }
};
q(Qo, "Length");
var Wc = Qo;
var Kr = { "==": K2, "!=": Y2, ">": Q2, "<": J2, ">=": tS, "<=": eS, array: Rt, at: Uc, boolean: Rt, case: jc, coalesce: Do, collator: Mo, format: qn, image: Zc, in: Nc, "index-of": Gc, interpolate: wt, "interpolate-hcl": wt, "interpolate-lab": wt, length: Wc, let: zo, literal: yr, match: qc, number: Rt, "number-format": Hc, object: Rt, slice: $c, step: Li, string: Rt, "to-boolean": mr, "to-color": mr, "to-number": mr, "to-string": mr, var: Eo, within: Nn };
function gg(e53, [t3, r, i, a]) {
  t3 = t3.evaluate(e53), r = r.evaluate(e53), i = i.evaluate(e53);
  let n = a ? a.evaluate(e53) : 1, s3 = Bg(t3, r, i, n);
  if (s3)
    throw new Ne(s3);
  return new K(t3 / 255, r / 255, i / 255, n, false);
}
function xg(e53, t3) {
  return e53 in t3;
}
function Rc(e53, t3) {
  let r = t3[e53];
  return typeof r > "u" ? null : r;
}
function rS(e53, t3, r, i) {
  for (; r <= i; ) {
    let a = r + i >> 1;
    if (t3[a] === e53)
      return true;
    t3[a] > e53 ? i = a - 1 : r = a + 1;
  }
  return false;
}
function jr(e53) {
  return { type: e53 };
}
function Xc(e53) {
  return { result: "success", value: e53 };
}
function Ti(e53) {
  return { result: "error", value: e53 };
}
function gr(e53) {
  return "data-driven" === e53["property-type"] || "cross-faded-data-driven" === e53["property-type"];
}
function Ng(e53) {
  return !!e53.expression && e53.expression.parameters.indexOf("zoom") > -1;
}
function tp(e53) {
  return !!e53.expression && e53.expression.interpolated;
}
function _e(e53) {
  return e53 instanceof Number ? "number" : e53 instanceof String ? "string" : e53 instanceof Boolean ? "boolean" : Array.isArray(e53) ? "array" : null === e53 ? "null" : typeof e53;
}
function ss(e53) {
  return "object" == typeof e53 && null !== e53 && !Array.isArray(e53);
}
function iS(e53) {
  return e53;
}
function Gg(e53, t3) {
  let r, i, a, n = "color" === t3.type, s3 = e53.stops && "object" == typeof e53.stops[0][0], o = s3 || void 0 !== e53.property, l = s3 || !o, u3 = e53.type || (tp(t3) ? "exponential" : "interval");
  if (n || "padding" === t3.type) {
    let r3 = n ? K.parse : Ot.parse;
    (e53 = ki({}, e53)).stops && (e53.stops = e53.stops.map((e54) => [e54[0], r3(e54[1])])), e53.default ? e53.default = r3(e53.default) : e53.default = r3(t3.default);
  }
  if (e53.colorSpace && !F2(e53.colorSpace))
    throw new Error('Unknown color space: "'.concat(e53.colorSpace, '"'));
  if ("exponential" === u3)
    r = bg;
  else if ("interval" === u3)
    r = aS;
  else if ("categorical" === u3) {
    r = nS, i = /* @__PURE__ */ Object.create(null);
    for (let t4 of e53.stops)
      i[t4[0]] = t4[1];
    a = typeof e53.stops[0][0];
  } else {
    if ("identity" !== u3)
      throw new Error('Unknown function type "'.concat(u3, '"'));
    r = oS;
  }
  if (s3) {
    let r3 = {}, i3 = [];
    for (let t4 = 0; t4 < e53.stops.length; t4++) {
      let a4 = e53.stops[t4], n4 = a4[0].zoom;
      void 0 === r3[n4] && (r3[n4] = { zoom: n4, type: e53.type, property: e53.property, default: e53.default, stops: [] }, i3.push(n4)), r3[n4].stops.push([a4[0].value, a4[1]]);
    }
    let a3 = [];
    for (let e54 of i3)
      a3.push([r3[e54].zoom, Gg(r3[e54], t3)]);
    let n3 = { name: "linear" };
    return { kind: "composite", interpolationType: n3, interpolationFactor: wt.interpolationFactor.bind(void 0, n3), zoomStops: a3.map((e54) => e54[0]), evaluate: ({ zoom: r4 }, i4) => bg({ stops: a3, base: e53.base }, t3, r4).evaluate(r4, i4) };
  }
  if (l) {
    let n3 = "exponential" === u3 ? { name: "exponential", base: void 0 !== e53.base ? e53.base : 1 } : null;
    return { kind: "camera", interpolationType: n3, interpolationFactor: wt.interpolationFactor.bind(void 0, n3), zoomStops: e53.stops.map((e54) => e54[0]), evaluate: ({ zoom: n4 }) => r(e53, t3, n4, i, a) };
  }
  return { kind: "source", evaluate(n3, s4) {
    let o3 = s4 && s4.properties ? s4.properties[e53.property] : void 0;
    return void 0 === o3 ? Zn(e53.default, t3.default) : r(e53, t3, o3, i, a);
  } };
}
function Zn(e53, t3, r) {
  return void 0 !== e53 ? e53 : void 0 !== t3 ? t3 : void 0 !== r ? r : void 0;
}
function nS(e53, t3, r, i, a) {
  return Zn(typeof r === a ? i[r] : void 0, e53.default, t3.default);
}
function aS(e53, t3, r) {
  if ("number" !== _e(r))
    return Zn(e53.default, t3.default);
  let i = e53.stops.length;
  if (1 === i || r <= e53.stops[0][0])
    return e53.stops[0][1];
  if (r >= e53.stops[i - 1][0])
    return e53.stops[i - 1][1];
  let a = os(e53.stops.map((e54) => e54[0]), r);
  return e53.stops[a][1];
}
function bg(e53, t3, r) {
  let i = void 0 !== e53.base ? e53.base : 1;
  if ("number" !== _e(r))
    return Zn(e53.default, t3.default);
  let a = e53.stops.length;
  if (1 === a || r <= e53.stops[0][0])
    return e53.stops[0][1];
  if (r >= e53.stops[a - 1][0])
    return e53.stops[a - 1][1];
  let n = os(e53.stops.map((e54) => e54[0]), r), s3 = sS(r, i, e53.stops[n][0], e53.stops[n + 1][0]), o = e53.stops[n][1], l = e53.stops[n + 1][1], u3 = ke[t3.type] || iS;
  return "function" == typeof o.evaluate ? { evaluate(...t4) {
    let r3 = o.evaluate.apply(void 0, t4), i3 = l.evaluate.apply(void 0, t4);
    if (void 0 !== r3 && void 0 !== i3)
      return u3(r3, i3, s3, e53.colorSpace);
  } } : u3(o, l, s3, e53.colorSpace);
}
function oS(e53, t3, r) {
  switch (t3.type) {
    case "color":
      r = K.parse(r);
      break;
    case "formatted":
      r = St.fromString(r.toString());
      break;
    case "resolvedImage":
      r = pt.fromString(r.toString());
      break;
    case "padding":
      r = Ot.parse(r);
      break;
    default:
      _e(r) !== t3.type && ("enum" !== t3.type || !t3.values[r]) && (r = void 0);
  }
  return Zn(r, e53.default, t3.default);
}
function sS(e53, t3, r, i) {
  let a = i - r, n = e53 - r;
  return 0 === a ? 0 : 1 === t3 ? n / a : (Math.pow(t3, n) - 1) / (Math.pow(t3, a) - 1);
}
q(gg, "rgba"), q(xg, "has"), q(Rc, "get"), q(rS, "binarySearch"), q(jr, "varargs"), qt.register(Kr, { error: [u2, [ce], (e53, [t3]) => {
  throw new Ne(t3.evaluate(e53));
}], typeof: [ce, [se], (e53, [t3]) => Ue(We(t3.evaluate(e53)))], "to-rgba": [vt(j, 4), [Lt], (e53, [t3]) => {
  let [r, i, a, n] = t3.evaluate(e53).rgb;
  return [255 * r, 255 * i, 255 * a, n];
}], rgb: [Lt, [j, j, j], gg], rgba: [Lt, [j, j, j, j], gg], has: { type: oe, overloads: [[[ce], (e53, [t3]) => xg(t3.evaluate(e53), e53.properties())], [[ce, Ci], (e53, [t3, r]) => xg(t3.evaluate(e53), r.evaluate(e53))]] }, get: { type: se, overloads: [[[ce], (e53, [t3]) => Rc(t3.evaluate(e53), e53.properties())], [[ce, Ci], (e53, [t3, r]) => Rc(t3.evaluate(e53), r.evaluate(e53))]] }, "feature-state": [se, [ce], (e53, [t3]) => Rc(t3.evaluate(e53), e53.featureState || {})], properties: [Ci, [], (e53) => e53.properties()], "geometry-type": [ce, [], (e53) => e53.geometryType()], id: [se, [], (e53) => e53.id()], zoom: [j, [], (e53) => e53.globals.zoom], "heatmap-density": [j, [], (e53) => e53.globals.heatmapDensity || 0], "line-progress": [j, [], (e53) => e53.globals.lineProgress || 0], accumulated: [se, [], (e53) => void 0 === e53.globals.accumulated ? null : e53.globals.accumulated], "+": [j, jr(j), (e53, t3) => {
  let r = 0;
  for (let i of t3)
    r += i.evaluate(e53);
  return r;
}], "*": [j, jr(j), (e53, t3) => {
  let r = 1;
  for (let i of t3)
    r *= i.evaluate(e53);
  return r;
}], "-": { type: j, overloads: [[[j, j], (e53, [t3, r]) => t3.evaluate(e53) - r.evaluate(e53)], [[j], (e53, [t3]) => -t3.evaluate(e53)]] }, "/": [j, [j, j], (e53, [t3, r]) => t3.evaluate(e53) / r.evaluate(e53)], "%": [j, [j, j], (e53, [t3, r]) => t3.evaluate(e53) % r.evaluate(e53)], ln2: [j, [], () => Math.LN2], pi: [j, [], () => Math.PI], e: [j, [], () => Math.E], "^": [j, [j, j], (e53, [t3, r]) => Math.pow(t3.evaluate(e53), r.evaluate(e53))], sqrt: [j, [j], (e53, [t3]) => Math.sqrt(t3.evaluate(e53))], log10: [j, [j], (e53, [t3]) => Math.log(t3.evaluate(e53)) / Math.LN10], ln: [j, [j], (e53, [t3]) => Math.log(t3.evaluate(e53))], log2: [j, [j], (e53, [t3]) => Math.log(t3.evaluate(e53)) / Math.LN2], sin: [j, [j], (e53, [t3]) => Math.sin(t3.evaluate(e53))], cos: [j, [j], (e53, [t3]) => Math.cos(t3.evaluate(e53))], tan: [j, [j], (e53, [t3]) => Math.tan(t3.evaluate(e53))], asin: [j, [j], (e53, [t3]) => Math.asin(t3.evaluate(e53))], acos: [j, [j], (e53, [t3]) => Math.acos(t3.evaluate(e53))], atan: [j, [j], (e53, [t3]) => Math.atan(t3.evaluate(e53))], min: [j, jr(j), (e53, t3) => Math.min(...t3.map((t4) => t4.evaluate(e53)))], max: [j, jr(j), (e53, t3) => Math.max(...t3.map((t4) => t4.evaluate(e53)))], abs: [j, [j], (e53, [t3]) => Math.abs(t3.evaluate(e53))], round: [j, [j], (e53, [t3]) => {
  let r = t3.evaluate(e53);
  return r < 0 ? -Math.round(-r) : Math.round(r);
}], floor: [j, [j], (e53, [t3]) => Math.floor(t3.evaluate(e53))], ceil: [j, [j], (e53, [t3]) => Math.ceil(t3.evaluate(e53))], "filter-==": [oe, [ce, se], (e53, [t3, r]) => e53.properties()[t3.value] === r.value], "filter-id-==": [oe, [se], (e53, [t3]) => e53.id() === t3.value], "filter-type-==": [oe, [ce], (e53, [t3]) => e53.geometryType() === t3.value], "filter-<": [oe, [ce, se], (e53, [t3, r]) => {
  let i = e53.properties()[t3.value], a = r.value;
  return typeof i == typeof a && i < a;
}], "filter-id-<": [oe, [se], (e53, [t3]) => {
  let r = e53.id(), i = t3.value;
  return typeof r == typeof i && r < i;
}], "filter->": [oe, [ce, se], (e53, [t3, r]) => {
  let i = e53.properties()[t3.value], a = r.value;
  return typeof i == typeof a && i > a;
}], "filter-id->": [oe, [se], (e53, [t3]) => {
  let r = e53.id(), i = t3.value;
  return typeof r == typeof i && r > i;
}], "filter-<=": [oe, [ce, se], (e53, [t3, r]) => {
  let i = e53.properties()[t3.value], a = r.value;
  return typeof i == typeof a && i <= a;
}], "filter-id-<=": [oe, [se], (e53, [t3]) => {
  let r = e53.id(), i = t3.value;
  return typeof r == typeof i && r <= i;
}], "filter->=": [oe, [ce, se], (e53, [t3, r]) => {
  let i = e53.properties()[t3.value], a = r.value;
  return typeof i == typeof a && i >= a;
}], "filter-id->=": [oe, [se], (e53, [t3]) => {
  let r = e53.id(), i = t3.value;
  return typeof r == typeof i && r >= i;
}], "filter-has": [oe, [se], (e53, [t3]) => t3.value in e53.properties()], "filter-has-id": [oe, [], (e53) => null !== e53.id() && void 0 !== e53.id()], "filter-type-in": [oe, [vt(ce)], (e53, [t3]) => t3.value.indexOf(e53.geometryType()) >= 0], "filter-id-in": [oe, [vt(se)], (e53, [t3]) => t3.value.indexOf(e53.id()) >= 0], "filter-in-small": [oe, [ce, vt(se)], (e53, [t3, r]) => r.value.indexOf(e53.properties()[t3.value]) >= 0], "filter-in-large": [oe, [ce, vt(se)], (e53, [t3, r]) => rS(e53.properties()[t3.value], r.value, 0, r.value.length - 1)], all: { type: oe, overloads: [[[oe, oe], (e53, [t3, r]) => t3.evaluate(e53) && r.evaluate(e53)], [jr(oe), (e53, t3) => {
  for (let r of t3)
    if (!r.evaluate(e53))
      return false;
  return true;
}]] }, any: { type: oe, overloads: [[[oe, oe], (e53, [t3, r]) => t3.evaluate(e53) || r.evaluate(e53)], [jr(oe), (e53, t3) => {
  for (let r of t3)
    if (r.evaluate(e53))
      return true;
  return false;
}]] }, "!": [oe, [oe], (e53, [t3]) => !t3.evaluate(e53)], "is-supported-script": [oe, [ce], (e53, [t3]) => {
  let r = e53.globals && e53.globals.isSupportedScript;
  return !r || r(t3.evaluate(e53));
}], upcase: [ce, [ce], (e53, [t3]) => t3.evaluate(e53).toUpperCase()], downcase: [ce, [ce], (e53, [t3]) => t3.evaluate(e53).toLowerCase()], concat: [ce, jr(se), (e53, t3) => t3.map((t4) => Cn(t4.evaluate(e53))).join("")], "resolved-locale": [ce, [ts], (e53, [t3]) => t3.evaluate(e53).resolvedLocale()] }), q(Xc, "success"), q(Ti, "error"), q(gr, "supportsPropertyExpression"), q(Ng, "supportsZoomExpression"), q(tp, "supportsInterpolation"), q(_e, "getType"), q(ss, "isFunction"), q(iS, "identityFunction"), q(Gg, "createFunction"), q(Zn, "coalesce$1"), q(nS, "evaluateCategoricalFunction"), q(aS, "evaluateIntervalFunction"), q(bg, "evaluateExponentialFunction"), q(oS, "evaluateIdentityFunction"), q(sS, "interpolationFactor");
var fp = class {
  constructor(e53, t3) {
    this.expression = e53, this._warningHistory = {}, this._evaluator = new Ao(), this._defaultValue = t3 ? uS(t3) : null, this._enumValues = t3 && "enum" === t3.type ? t3.values : null;
  }
  evaluateWithoutErrorHandling(e53, t3, r, i, a, n) {
    return this._evaluator.globals = e53, this._evaluator.feature = t3, this._evaluator.featureState = r, this._evaluator.canonical = i, this._evaluator.availableImages = a || null, this._evaluator.formattedSection = n, this.expression.evaluate(this._evaluator);
  }
  evaluate(e53, t3, r, i, a, n) {
    this._evaluator.globals = e53, this._evaluator.feature = t3 || null, this._evaluator.featureState = r || null, this._evaluator.canonical = i, this._evaluator.availableImages = a || null, this._evaluator.formattedSection = n || null;
    try {
      let e54 = this.expression.evaluate(this._evaluator);
      if (null == e54 || "number" == typeof e54 && e54 != e54)
        return this._defaultValue;
      if (this._enumValues && !(e54 in this._enumValues))
        throw new Ne("Expected value to be one of ".concat(Object.keys(this._enumValues).map((e55) => JSON.stringify(e55)).join(", "), ", but found ").concat(JSON.stringify(e54), " instead."));
      return e54;
    } catch (e54) {
      return this._warningHistory[e54.message] || (this._warningHistory[e54.message] = true, typeof console < "u" && console.warn(e54.message)), this._defaultValue;
    }
  }
};
q(fp, "StyleExpression");
var Zr = fp;
function Wn(e53) {
  return Array.isArray(e53) && e53.length > 0 && "string" == typeof e53[0] && e53[0] in Kr;
}
function rp(e53, t3) {
  let r = new Io(Kr, ko, [], t3 ? lS(t3) : void 0), i = r.parse(e53, void 0, void 0, void 0, t3 && "string" === t3.type ? { typeAnnotation: "coerce" } : void 0);
  return i ? Xc(new Zr(i, t3)) : Ti(r.errors);
}
q(Wn, "isExpression"), q(rp, "createExpression");
var mp = class {
  constructor(e53, t3) {
    this.kind = e53, this._styleExpression = t3, this.isStateDependent = "constant" !== e53 && !Gn(t3.expression);
  }
  evaluateWithoutErrorHandling(e53, t3, r, i, a, n) {
    return this._styleExpression.evaluateWithoutErrorHandling(e53, t3, r, i, a, n);
  }
  evaluate(e53, t3, r, i, a, n) {
    return this._styleExpression.evaluate(e53, t3, r, i, a, n);
  }
};
q(mp, "ZoomConstantExpression");
var xr = mp;
var dp = class {
  constructor(e53, t3, r, i) {
    this.kind = e53, this.zoomStops = r, this._styleExpression = t3, this.isStateDependent = "camera" !== e53 && !Gn(t3.expression), this.interpolationType = i;
  }
  evaluateWithoutErrorHandling(e53, t3, r, i, a, n) {
    return this._styleExpression.evaluateWithoutErrorHandling(e53, t3, r, i, a, n);
  }
  evaluate(e53, t3, r, i, a, n) {
    return this._styleExpression.evaluate(e53, t3, r, i, a, n);
  }
  interpolationFactor(e53, t3, r) {
    return this.interpolationType ? wt.interpolationFactor(this.interpolationType, e53, t3, r) : 0;
  }
};
q(dp, "ZoomDependentExpression");
var br = dp;
function qg(e53, t3) {
  let r = rp(e53, t3);
  if ("error" === r.result)
    return r;
  let i = r.value.expression, a = ns(i);
  if (!a && !gr(t3))
    return Ti([new Et("", "data expressions not supported")]);
  let n = as(i, ["zoom"]);
  if (!n && !Ng(t3))
    return Ti([new Et("", "zoom expressions not supported")]);
  let s3 = Po(i);
  if (!s3 && !n)
    return Ti([new Et("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (s3 instanceof Et)
    return Ti([s3]);
  if (s3 instanceof wt && !tp(t3))
    return Ti([new Et("", '"interpolate" expressions cannot be used with this property')]);
  if (!s3)
    return Xc(new xr(a ? "constant" : "source", r.value));
  let o = s3 instanceof wt ? s3.interpolation : void 0;
  return Xc(new br(a ? "camera" : "composite", r.value, s3.labels, o));
}
q(qg, "createPropertyExpression");
var es = class e31 {
  constructor(e53, t3) {
    this._parameters = e53, this._specification = t3, ki(this, Gg(this._parameters, this._specification));
  }
  static deserialize(t3) {
    return new e31(t3._parameters, t3._specification);
  }
  static serialize(e53) {
    return { _parameters: e53._parameters, _specification: e53._specification };
  }
};
q(es, "StylePropertyFunction");
var jn = es;
function jg(e53, t3) {
  if (ss(e53))
    return new jn(e53, t3);
  if (Wn(e53)) {
    let r = qg(e53, t3);
    if ("error" === r.result)
      throw new Error(r.value.map((e54) => "".concat(e54.key, ": ").concat(e54.message)).join(", "));
    return r.value;
  }
  {
    let r = e53;
    return "color" === t3.type && "string" == typeof e53 ? r = K.parse(e53) : "padding" !== t3.type || "number" != typeof e53 && !Array.isArray(e53) ? "variableAnchorOffsetCollection" === t3.type && Array.isArray(e53) && (r = Qt.parse(e53)) : r = Ot.parse(e53), { kind: "constant", evaluate: () => r };
  }
}
function Po(e53) {
  let t3 = null;
  if (e53 instanceof zo)
    t3 = Po(e53.result);
  else if (e53 instanceof Do) {
    for (let r of e53.args)
      if (t3 = Po(r), t3)
        break;
  } else
    (e53 instanceof Li || e53 instanceof wt) && e53.input instanceof qt && "zoom" === e53.input.name && (t3 = e53);
  return t3 instanceof Et || e53.eachChild((e54) => {
    let r = Po(e54);
    r instanceof Et ? t3 = r : !t3 && r ? t3 = new Et("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t3 && r && t3 !== r && (t3 = new Et("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), t3;
}
function lS(e53) {
  let t3 = { color: Lt, string: ce, number: j, enum: ce, boolean: oe, formatted: Fi, padding: rs, resolvedImage: Hn, variableAnchorOffsetCollection: is };
  return "array" === e53.type ? vt(t3[e53.value] || se, e53.length) : t3[e53.type];
}
function uS(e53) {
  return "color" === e53.type && ss(e53.default) ? new K(0, 0, 0, 0) : "color" === e53.type ? K.parse(e53.default) || null : "padding" === e53.type ? Ot.parse(e53.default) || null : "variableAnchorOffsetCollection" === e53.type ? Qt.parse(e53.default) || null : void 0 === e53.default ? null : e53.default;
}
function ip(e53) {
  if (true === e53 || false === e53)
    return true;
  if (!Array.isArray(e53) || 0 === e53.length)
    return false;
  switch (e53[0]) {
    case "has":
      return e53.length >= 2 && "$id" !== e53[1] && "$type" !== e53[1];
    case "in":
      return e53.length >= 3 && ("string" != typeof e53[1] || Array.isArray(e53[2]));
    case "!in":
    case "!has":
    case "none":
      return false;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return 3 !== e53.length || Array.isArray(e53[1]) || Array.isArray(e53[2]);
    case "any":
    case "all":
      for (let t3 of e53.slice(1))
        if (!ip(t3) && "boolean" != typeof t3)
          return false;
      return true;
    default:
      return true;
  }
}
q(jg, "normalizePropertyExpression"), q(Po, "findZoomCurve"), q(lS, "getExpectedType"), q(uS, "getDefaultValue"), q(ip, "isExpressionFilter");
var cS = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
function Xn(e53) {
  if (null == e53)
    return { filter: () => true, needGeometry: false };
  ip(e53) || (e53 = Fo(e53));
  let t3 = rp(e53, cS);
  if ("error" === t3.result)
    throw new Error(t3.value.map((e54) => "".concat(e54.key, ": ").concat(e54.message)).join(", "));
  return { filter: (e54, r, i) => t3.value.evaluate(e54, r, {}, i), needGeometry: $g(e53) };
}
function pS(e53, t3) {
  return e53 < t3 ? -1 : e53 > t3 ? 1 : 0;
}
function $g(e53) {
  if (!Array.isArray(e53))
    return false;
  if ("within" === e53[0])
    return true;
  for (let t3 = 1; t3 < e53.length; t3++)
    if ($g(e53[t3]))
      return true;
  return false;
}
function Fo(e53) {
  if (!e53)
    return true;
  let t3 = e53[0];
  return e53.length <= 1 ? "any" !== t3 : "==" === t3 ? Oc(e53[1], e53[2], "==") : "!=" === t3 ? So(Oc(e53[1], e53[2], "==")) : "<" === t3 || ">" === t3 || "<=" === t3 || ">=" === t3 ? Oc(e53[1], e53[2], t3) : "any" === t3 ? hS(e53.slice(1)) : "all" === t3 ? ["all"].concat(e53.slice(1).map(Fo)) : "none" === t3 ? ["all"].concat(e53.slice(1).map(Fo).map(So)) : "in" === t3 ? _g(e53[1], e53.slice(2)) : "!in" === t3 ? So(_g(e53[1], e53.slice(2))) : "has" === t3 ? vg(e53[1]) : "!has" === t3 ? So(vg(e53[1])) : "within" !== t3 || e53;
}
function Oc(e53, t3, r) {
  switch (e53) {
    case "$type":
      return ["filter-type-".concat(r), t3];
    case "$id":
      return ["filter-id-".concat(r), t3];
    default:
      return ["filter-".concat(r), e53, t3];
  }
}
function hS(e53) {
  return ["any"].concat(e53.map(Fo));
}
function _g(e53, t3) {
  if (0 === t3.length)
    return false;
  switch (e53) {
    case "$type":
      return ["filter-type-in", ["literal", t3]];
    case "$id":
      return ["filter-id-in", ["literal", t3]];
    default:
      return t3.length > 200 && !t3.some((e54) => typeof e54 != typeof t3[0]) ? ["filter-in-large", e53, ["literal", t3.sort(pS)]] : ["filter-in-small", e53, ["literal", t3]];
  }
}
function vg(e53) {
  switch (e53) {
    case "$type":
      return true;
    case "$id":
      return ["filter-has-id"];
    default:
      return ["filter-has", e53];
  }
}
function So(e53) {
  return ["!", e53];
}
function Hg() {
  let e53 = {}, t3 = M.$version;
  for (let r in M.$root) {
    let i = M.$root[r];
    if (i.required) {
      let a = null;
      a = "version" === r ? t3 : "array" === i.type ? [] : {}, null != a && (e53[r] = a);
    }
  }
  return e53;
}
function Zg(e53) {
  let t3 = e53.key, r = e53.value;
  return r ? [new N(t3, r, "constants have been deprecated as of v8")] : [];
}
function Ze(e53) {
  return e53 instanceof Number || e53 instanceof String || e53 instanceof Boolean ? e53.valueOf() : e53;
}
function Wr(e53) {
  if (Array.isArray(e53))
    return e53.map(Wr);
  if (e53 instanceof Object && !(e53 instanceof Number || e53 instanceof String || e53 instanceof Boolean)) {
    let t3 = {};
    for (let r in e53)
      t3[r] = Wr(e53[r]);
    return t3;
  }
  return Ze(e53);
}
function kt(e53) {
  let t3 = e53.key, r = e53.value, i = e53.valueSpec || {}, a = e53.objectElementValidators || {}, n = e53.style, s3 = e53.styleSpec, o = e53.validateSpec, l = [], u3 = _e(r);
  if ("object" !== u3)
    return [new N(t3, r, "object expected, ".concat(u3, " found"))];
  for (let e54 in r) {
    let u4, c3 = e54.split(".")[0], h = i[c3] || i["*"];
    if (a[c3])
      u4 = a[c3];
    else if (i[c3])
      u4 = o;
    else if (a["*"])
      u4 = a["*"];
    else {
      if (!i["*"]) {
        l.push(new N(t3, r[e54], 'unknown property "'.concat(e54, '"')));
        continue;
      }
      u4 = o;
    }
    l = l.concat(u4({ key: (t3 && "".concat(t3, ".")) + e54, value: r[e54], valueSpec: h, style: n, styleSpec: s3, object: r, objectKey: e54, validateSpec: o }, r));
  }
  for (let e54 in i)
    a[e54] || i[e54].required && void 0 === i[e54].default && void 0 === r[e54] && l.push(new N(t3, r, 'missing required property "'.concat(e54, '"')));
  return l;
}
function np(e53) {
  let t3 = e53.value, r = e53.valueSpec, i = e53.validateSpec, a = e53.style, n = e53.styleSpec, s3 = e53.key, o = e53.arrayElementValidator || i;
  if ("array" !== _e(t3))
    return [new N(s3, t3, "array expected, ".concat(_e(t3), " found"))];
  if (r.length && t3.length !== r.length)
    return [new N(s3, t3, "array length ".concat(r.length, " expected, length ").concat(t3.length, " found"))];
  if (r["min-length"] && t3.length < r["min-length"])
    return [new N(s3, t3, "array length at least ".concat(r["min-length"], " expected, length ").concat(t3.length, " found"))];
  let l = { type: r.value, values: r.values };
  n.$version < 7 && (l.function = r.function), "object" === _e(r.value) && (l = r.value);
  let u3 = [];
  for (let r3 = 0; r3 < t3.length; r3++)
    u3 = u3.concat(o({ array: t3, arrayIndex: r3, value: t3[r3], valueSpec: l, validateSpec: e53.validateSpec, style: a, styleSpec: n, key: "".concat(s3, "[").concat(r3, "]") }));
  return u3;
}
function ap(e53) {
  let t3 = e53.key, r = e53.value, i = e53.valueSpec, a = _e(r);
  return "number" === a && r != r && (a = "NaN"), "number" !== a ? [new N(t3, r, "number expected, ".concat(a, " found"))] : "minimum" in i && r < i.minimum ? [new N(t3, r, "".concat(r, " is less than the minimum value ").concat(i.minimum))] : "maximum" in i && r > i.maximum ? [new N(t3, r, "".concat(r, " is greater than the maximum value ").concat(i.maximum))] : [];
}
function Wg(e53) {
  let t3, r, i, a = e53.valueSpec, n = Ze(e53.value.type), s3 = {}, o = "categorical" !== n && void 0 === e53.value.property, l = !o, u3 = "array" === _e(e53.value.stops) && "array" === _e(e53.value.stops[0]) && "object" === _e(e53.value.stops[0][0]), c3 = kt({ key: e53.key, value: e53.value, valueSpec: e53.styleSpec.function, validateSpec: e53.validateSpec, style: e53.style, styleSpec: e53.styleSpec, objectElementValidators: { stops: h, default: f } });
  return "identity" === n && o && c3.push(new N(e53.key, e53.value, 'missing required property "property"')), "identity" !== n && !e53.value.stops && c3.push(new N(e53.key, e53.value, 'missing required property "stops"')), "exponential" === n && e53.valueSpec.expression && !tp(e53.valueSpec) && c3.push(new N(e53.key, e53.value, "exponential functions not supported")), e53.styleSpec.$version >= 8 && (l && !gr(e53.valueSpec) ? c3.push(new N(e53.key, e53.value, "property functions not supported")) : o && !Ng(e53.valueSpec) && c3.push(new N(e53.key, e53.value, "zoom functions not supported"))), ("categorical" === n || u3) && void 0 === e53.value.property && c3.push(new N(e53.key, e53.value, '"property" property is required')), c3;
  function h(e54) {
    if ("identity" === n)
      return [new N(e54.key, e54.value, 'identity function may not have a "stops" property')];
    let t4 = [], r3 = e54.value;
    return t4 = t4.concat(np({ key: e54.key, value: r3, valueSpec: e54.valueSpec, validateSpec: e54.validateSpec, style: e54.style, styleSpec: e54.styleSpec, arrayElementValidator: p })), "array" === _e(r3) && 0 === r3.length && t4.push(new N(e54.key, r3, "array must have at least one stop")), t4;
  }
  function p(e54) {
    let t4 = [], n3 = e54.value, o3 = e54.key;
    if ("array" !== _e(n3))
      return [new N(o3, n3, "array expected, ".concat(_e(n3), " found"))];
    if (2 !== n3.length)
      return [new N(o3, n3, "array length 2 expected, length ".concat(n3.length, " found"))];
    if (u3) {
      if ("object" !== _e(n3[0]))
        return [new N(o3, n3, "object expected, ".concat(_e(n3[0]), " found"))];
      if (void 0 === n3[0].zoom)
        return [new N(o3, n3, "object stop key must have zoom")];
      if (void 0 === n3[0].value)
        return [new N(o3, n3, "object stop key must have value")];
      if (i && i > Ze(n3[0].zoom))
        return [new N(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
      Ze(n3[0].zoom) !== i && (i = Ze(n3[0].zoom), r = void 0, s3 = {}), t4 = t4.concat(kt({ key: "".concat(o3, "[0]"), value: n3[0], valueSpec: { zoom: {} }, validateSpec: e54.validateSpec, style: e54.style, styleSpec: e54.styleSpec, objectElementValidators: { zoom: ap, value: d } }));
    } else
      t4 = t4.concat(d({ key: "".concat(o3, "[0]"), value: n3[0], valueSpec: {}, validateSpec: e54.validateSpec, style: e54.style, styleSpec: e54.styleSpec }, n3));
    return Wn(Wr(n3[1])) ? t4.concat([new N("".concat(o3, "[1]"), n3[1], "expressions are not allowed in function stops.")]) : t4.concat(e54.validateSpec({ key: "".concat(o3, "[1]"), value: n3[1], valueSpec: a, validateSpec: e54.validateSpec, style: e54.style, styleSpec: e54.styleSpec }));
  }
  function d(e54, i3) {
    let o3 = _e(e54.value), l3 = Ze(e54.value), u4 = null !== e54.value ? e54.value : i3;
    if (t3) {
      if (o3 !== t3)
        return [new N(e54.key, u4, "".concat(o3, " stop domain type must match previous stop domain type ").concat(t3))];
    } else
      t3 = o3;
    if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
      return [new N(e54.key, u4, "stop domain value must be a number, string, or boolean")];
    if ("number" !== o3 && "categorical" !== n) {
      let t4 = "number expected, ".concat(o3, " found");
      return gr(a) && void 0 === n && (t4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new N(e54.key, u4, t4)];
    }
    return "categorical" !== n || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== n && "number" === o3 && void 0 !== r && l3 < r ? [new N(e54.key, u4, "stop domain values must appear in ascending order")] : (r = l3, "categorical" === n && l3 in s3 ? [new N(e54.key, u4, "stop domain values must be unique")] : (s3[l3] = true, [])) : [new N(e54.key, u4, "integer expected, found ".concat(l3))];
  }
  function f(e54) {
    return e54.validateSpec({ key: e54.key, value: e54.value, valueSpec: a, validateSpec: e54.validateSpec, style: e54.style, styleSpec: e54.styleSpec });
  }
}
function Di(e53) {
  let t3 = ("property" === e53.expressionContext ? qg : rp)(Wr(e53.value), e53.valueSpec);
  if ("error" === t3.result)
    return t3.value.map((t4) => new N("".concat(e53.key).concat(t4.key), e53.value, t4.message));
  let r = t3.value.expression || t3.value._styleExpression.expression;
  if ("property" === e53.expressionContext && "text-font" === e53.propertyKey && !r.outputDefined())
    return [new N(e53.key, e53.value, 'Invalid data expression for "'.concat(e53.propertyKey, '". Output values must be contained as literals within the expression.'))];
  if ("property" === e53.expressionContext && "layout" === e53.propertyType && !Gn(r))
    return [new N(e53.key, e53.value, '"feature-state" data expressions are not supported with layout properties.')];
  if ("filter" === e53.expressionContext && !Gn(r))
    return [new N(e53.key, e53.value, '"feature-state" data expressions are not supported with filters.')];
  if (e53.expressionContext && 0 === e53.expressionContext.indexOf("cluster")) {
    if (!as(r, ["zoom", "feature-state"]))
      return [new N(e53.key, e53.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if ("cluster-initial" === e53.expressionContext && !ns(r))
      return [new N(e53.key, e53.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
function fS(e53) {
  let t3 = e53.value, r = e53.key, i = _e(t3);
  return "boolean" !== i ? [new N(r, t3, "boolean expected, ".concat(i, " found"))] : [];
}
function mS(e53) {
  let t3 = e53.key, r = e53.value, i = _e(r);
  return "string" !== i ? [new N(t3, r, "color expected, ".concat(i, " found"))] : K.parse(String(r)) ? [] : [new N(t3, r, 'color expected, "'.concat(r, '" found'))];
}
function $n(e53) {
  let t3 = e53.key, r = e53.value, i = e53.valueSpec, a = [];
  return Array.isArray(i.values) ? -1 === i.values.indexOf(Ze(r)) && a.push(new N(t3, r, "expected one of [".concat(i.values.join(", "), "], ").concat(JSON.stringify(r), " found"))) : -1 === Object.keys(i.values).indexOf(Ze(r)) && a.push(new N(t3, r, "expected one of [".concat(Object.keys(i.values).join(", "), "], ").concat(JSON.stringify(r), " found"))), a;
}
function op(e53) {
  return ip(Wr(e53.value)) ? Di(ki({}, e53, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Xg(e53);
}
function Xg(e53) {
  let t3 = e53.value, r = e53.key;
  if ("array" !== _e(t3))
    return [new N(r, t3, "array expected, ".concat(_e(t3), " found"))];
  let i, a = e53.styleSpec, n = [];
  if (t3.length < 1)
    return [new N(r, t3, "filter array must have at least 1 element")];
  switch (n = n.concat($n({ key: "".concat(r, "[0]"), value: t3[0], valueSpec: a.filter_operator, style: e53.style, styleSpec: e53.styleSpec })), Ze(t3[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      t3.length >= 2 && "$type" === Ze(t3[1]) && n.push(new N(r, t3, '"$type" cannot be use with operator "'.concat(t3[0], '"')));
    case "==":
    case "!=":
      3 !== t3.length && n.push(new N(r, t3, 'filter array for operator "'.concat(t3[0], '" must have 3 elements')));
    case "in":
    case "!in":
      t3.length >= 2 && (i = _e(t3[1]), "string" !== i && n.push(new N("".concat(r, "[1]"), t3[1], "string expected, ".concat(i, " found"))));
      for (let s3 = 2; s3 < t3.length; s3++)
        i = _e(t3[s3]), "$type" === Ze(t3[1]) ? n = n.concat($n({ key: "".concat(r, "[").concat(s3, "]"), value: t3[s3], valueSpec: a.geometry_type, style: e53.style, styleSpec: e53.styleSpec })) : "string" !== i && "number" !== i && "boolean" !== i && n.push(new N("".concat(r, "[").concat(s3, "]"), t3[s3], "string, number, or boolean expected, ".concat(i, " found")));
      break;
    case "any":
    case "all":
    case "none":
      for (let i3 = 1; i3 < t3.length; i3++)
        n = n.concat(Xg({ key: "".concat(r, "[").concat(i3, "]"), value: t3[i3], style: e53.style, styleSpec: e53.styleSpec }));
      break;
    case "has":
    case "!has":
      i = _e(t3[1]), 2 !== t3.length ? n.push(new N(r, t3, 'filter array for "'.concat(t3[0], '" operator must have 2 elements'))) : "string" !== i && n.push(new N("".concat(r, "[1]"), t3[1], "string expected, ".concat(i, " found")));
      break;
    case "within":
      i = _e(t3[1]), 2 !== t3.length ? n.push(new N(r, t3, 'filter array for "'.concat(t3[0], '" operator must have 2 elements'))) : "object" !== i && n.push(new N("".concat(r, "[1]"), t3[1], "object expected, ".concat(i, " found")));
  }
  return n;
}
function Kg(e53, t3) {
  let r = e53.key, i = e53.validateSpec, a = e53.style, n = e53.styleSpec, s3 = e53.value, o = e53.objectKey, l = n["".concat(t3, "_").concat(e53.layerType)];
  if (!l)
    return [];
  let u3 = o.match(/^(.*)-transition$/);
  if ("paint" === t3 && u3 && l[u3[1]] && l[u3[1]].transition)
    return i({ key: r, value: s3, valueSpec: n.transition, style: a, styleSpec: n });
  let c3, h = e53.valueSpec || l[o];
  if (!h)
    return [new N(r, s3, 'unknown property "'.concat(o, '"'))];
  if ("string" === _e(s3) && gr(h) && !h.tokens && (c3 = /^{([^}]+)}$/.exec(s3)))
    return [new N(r, s3, '"'.concat(o, '" does not support interpolation syntax\n') + 'Use an identity property function instead: `{ "type": "identity", "property": '.concat(JSON.stringify(c3[1]), " }`."))];
  let p = [];
  return "symbol" === e53.layerType && ("text-field" === o && a && !a.glyphs && p.push(new N(r, s3, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o && ss(Wr(s3)) && "identity" === Ze(s3.type) && p.push(new N(r, s3, '"text-font" does not support identity functions'))), p.concat(i({ key: e53.key, value: s3, valueSpec: h, style: a, styleSpec: n, expressionContext: "property", propertyType: t3, propertyKey: o }));
}
function Yg(e53) {
  return Kg(e53, "paint");
}
function Jg(e53) {
  return Kg(e53, "layout");
}
function Qg(e53) {
  let t3 = [], r = e53.value, i = e53.key, a = e53.style, n = e53.styleSpec;
  !r.type && !r.ref && t3.push(new N(i, r, 'either "type" or "ref" is required'));
  let s3 = Ze(r.type), o = Ze(r.ref);
  if (r.id) {
    let n3 = Ze(r.id);
    for (let s4 = 0; s4 < e53.arrayIndex; s4++) {
      let e54 = a.layers[s4];
      Ze(e54.id) === n3 && t3.push(new N(i, r.id, 'duplicate layer id "'.concat(r.id, '", previously used at line ').concat(e54.id.__line__)));
    }
  }
  if ("ref" in r) {
    let e54;
    ["type", "source", "source-layer", "filter", "layout"].forEach((e55) => {
      e55 in r && t3.push(new N(i, r[e55], '"'.concat(e55, '" is prohibited for ref layers')));
    }), a.layers.forEach((t4) => {
      Ze(t4.id) === o && (e54 = t4);
    }), e54 ? e54.ref ? t3.push(new N(i, r.ref, "ref cannot reference another ref layer")) : s3 = Ze(e54.type) : t3.push(new N(i, r.ref, 'ref layer "'.concat(o, '" not found')));
  } else if ("background" !== s3)
    if (r.source) {
      let e54 = a.sources && a.sources[r.source], n3 = e54 && Ze(e54.type);
      e54 ? "vector" === n3 && "raster" === s3 ? t3.push(new N(i, r.source, 'layer "'.concat(r.id, '" requires a raster source'))) : "raster" === n3 && "raster" !== s3 ? t3.push(new N(i, r.source, 'layer "'.concat(r.id, '" requires a vector source'))) : "vector" !== n3 || r["source-layer"] ? "raster-dem" === n3 && "hillshade" !== s3 ? t3.push(new N(i, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" === s3 && r.paint && r.paint["line-gradient"] && ("geojson" !== n3 || !e54.lineMetrics) && t3.push(new N(i, r, 'layer "'.concat(r.id, '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.'))) : t3.push(new N(i, r, 'layer "'.concat(r.id, '" must specify a "source-layer"'))) : t3.push(new N(i, r.source, 'source "'.concat(r.source, '" not found')));
    } else
      t3.push(new N(i, r, 'missing required property "source"'));
  return t3 = t3.concat(kt({ key: i, value: r, valueSpec: n.layer, style: e53.style, styleSpec: e53.styleSpec, validateSpec: e53.validateSpec, objectElementValidators: { "*": () => [], type: () => e53.validateSpec({ key: "".concat(i, ".type"), value: r.type, valueSpec: n.layer.type, style: e53.style, styleSpec: e53.styleSpec, validateSpec: e53.validateSpec, object: r, objectKey: "type" }), filter: op, layout: (e54) => kt({ layer: r, key: e54.key, value: e54.value, style: e54.style, styleSpec: e54.styleSpec, validateSpec: e54.validateSpec, objectElementValidators: { "*": (e55) => Jg(ki({ layerType: s3 }, e55)) } }), paint: (e54) => kt({ layer: r, key: e54.key, value: e54.value, style: e54.style, styleSpec: e54.styleSpec, validateSpec: e54.validateSpec, objectElementValidators: { "*": (e55) => Yg(ki({ layerType: s3 }, e55)) } }) } })), t3;
}
function Xr(e53) {
  let t3 = e53.value, r = e53.key, i = _e(t3);
  return "string" !== i ? [new N(r, t3, "string expected, ".concat(i, " found"))] : [];
}
q(Xn, "createFilter"), q(pS, "compare"), q($g, "geometryNeeded"), q(Fo, "convertFilter$1"), q(Oc, "convertComparisonOp$1"), q(hS, "convertDisjunctionOp"), q(_g, "convertInOp$1"), q(vg, "convertHasOp$1"), q(So, "convertNegation"), q(Hg, "emptyStyle"), q(Zg, "validateConstants"), q(Ze, "unbundle"), q(Wr, "deepUnbundle"), q(kt, "validateObject"), q(np, "validateArray"), q(ap, "validateNumber"), q(Wg, "validateFunction"), q(Di, "validateExpression"), q(fS, "validateBoolean"), q(mS, "validateColor"), q($n, "validateEnum"), q(op, "validateFilter"), q(Xg, "validateNonExpressionFilter"), q(Kg, "validateProperty"), q(Yg, "validatePaintProperty"), q(Jg, "validateLayoutProperty"), q(Qg, "validateLayer"), q(Xr, "validateString");
var wg = { promoteId: dS };
function ex(e53) {
  let t3 = e53.value, r = e53.key, i = e53.styleSpec, a = e53.style, n = e53.validateSpec;
  if (!t3.type)
    return [new N(r, t3, '"type" is required')];
  let s3, o = Ze(t3.type);
  switch (o) {
    case "vector":
    case "raster":
    case "raster-dem":
      return s3 = kt({ key: r, value: t3, valueSpec: i["source_".concat(o.replace("-", "_"))], style: e53.style, styleSpec: i, objectElementValidators: wg, validateSpec: n }), s3;
    case "geojson":
      if (s3 = kt({ key: r, value: t3, valueSpec: i.source_geojson, style: a, styleSpec: i, validateSpec: n, objectElementValidators: wg }), t3.cluster)
        for (let e54 in t3.clusterProperties) {
          let [i3, a3] = t3.clusterProperties[e54], o3 = "string" == typeof i3 ? [i3, ["accumulated"], ["get", e54]] : i3;
          s3.push(...Di({ key: "".concat(r, ".").concat(e54, ".map"), value: a3, validateSpec: n, expressionContext: "cluster-map" })), s3.push(...Di({ key: "".concat(r, ".").concat(e54, ".reduce"), value: o3, validateSpec: n, expressionContext: "cluster-reduce" }));
        }
      return s3;
    case "video":
      return kt({ key: r, value: t3, valueSpec: i.source_video, style: a, validateSpec: n, styleSpec: i });
    case "image":
      return kt({ key: r, value: t3, valueSpec: i.source_image, style: a, validateSpec: n, styleSpec: i });
    case "canvas":
      return [new N(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return $n({ key: "".concat(r, ".type"), value: t3.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: a, validateSpec: n, styleSpec: i });
  }
}
function dS({ key: e53, value: t3 }) {
  if ("string" === _e(t3))
    return Xr({ key: e53, value: t3 });
  {
    let r = [];
    for (let i in t3)
      r.push(...Xr({ key: "".concat(e53, ".").concat(i), value: t3[i] }));
    return r;
  }
}
function tx(e53) {
  let t3 = e53.value, r = e53.styleSpec, i = r.light, a = e53.style, n = [], s3 = _e(t3);
  if (void 0 === t3)
    return n;
  if ("object" !== s3)
    return n = n.concat([new N("light", t3, "object expected, ".concat(s3, " found"))]), n;
  for (let s4 in t3) {
    let o = s4.match(/^(.*)-transition$/);
    n = o && i[o[1]] && i[o[1]].transition ? n.concat(e53.validateSpec({ key: s4, value: t3[s4], valueSpec: r.transition, validateSpec: e53.validateSpec, style: a, styleSpec: r })) : i[s4] ? n.concat(e53.validateSpec({ key: s4, value: t3[s4], valueSpec: i[s4], validateSpec: e53.validateSpec, style: a, styleSpec: r })) : n.concat([new N(s4, t3[s4], 'unknown property "'.concat(s4, '"'))]);
  }
  return n;
}
function rx(e53) {
  let t3 = e53.value, r = e53.styleSpec, i = r.terrain, a = e53.style, n = [], s3 = _e(t3);
  if (void 0 === t3)
    return n;
  if ("object" !== s3)
    return n = n.concat([new N("terrain", t3, "object expected, ".concat(s3, " found"))]), n;
  for (let s4 in t3)
    n = i[s4] ? n.concat(e53.validateSpec({ key: s4, value: t3[s4], valueSpec: i[s4], validateSpec: e53.validateSpec, style: a, styleSpec: r })) : n.concat([new N(s4, t3[s4], 'unknown property "'.concat(s4, '"'))]);
  return n;
}
function yS(e53) {
  return 0 === Xr(e53).length ? [] : Di(e53);
}
function gS(e53) {
  return 0 === Xr(e53).length ? [] : Di(e53);
}
function xS(e53) {
  let t3 = e53.key, r = e53.value;
  if ("array" === _e(r)) {
    if (r.length < 1 || r.length > 4)
      return [new N(t3, r, "padding requires 1 to 4 values; ".concat(r.length, " values found"))];
    let i = { type: "number" }, a = [];
    for (let n = 0; n < r.length; n++)
      a = a.concat(e53.validateSpec({ key: "".concat(t3, "[").concat(n, "]"), value: r[n], validateSpec: e53.validateSpec, valueSpec: i }));
    return a;
  }
  return ap({ key: t3, value: r, valueSpec: {} });
}
function bS(e53) {
  let t3 = e53.key, r = e53.value, i = _e(r), a = e53.styleSpec;
  if ("array" !== i || r.length < 1 || r.length % 2 != 0)
    return [new N(t3, r, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let n = [];
  for (let i3 = 0; i3 < r.length; i3 += 2)
    n = n.concat($n({ key: "".concat(t3, "[").concat(i3, "]"), value: r[i3], valueSpec: a.layout_symbol["text-anchor"] })), n = n.concat(np({ key: "".concat(t3, "[").concat(i3 + 1, "]"), value: r[i3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: e53.validateSpec, style: e53.style, styleSpec: a }));
  return n;
}
function ix(e53) {
  let t3 = [], r = e53.value, i = e53.key;
  if (Array.isArray(r)) {
    let a = [], n = [];
    for (let s3 in r) {
      r[s3].id && a.includes(r[s3].id) && t3.push(new N(i, r, "all the sprites' ids must be unique, but ".concat(r[s3].id, " is duplicated"))), a.push(r[s3].id), r[s3].url && n.includes(r[s3].url) && t3.push(new N(i, r, "all the sprites' URLs must be unique, but ".concat(r[s3].url, " is duplicated"))), n.push(r[s3].url);
      let o = { id: { type: "string", required: true }, url: { type: "string", required: true } };
      t3 = t3.concat(kt({ key: "".concat(i, "[").concat(s3, "]"), value: r[s3], valueSpec: o, validateSpec: e53.validateSpec }));
    }
    return t3;
  }
  return Xr({ key: i, value: r });
}
q(ex, "validateSource"), q(dS, "validatePromoteId"), q(tx, "validateLight"), q(rx, "validateTerrain"), q(yS, "validateFormatted"), q(gS, "validateImage"), q(xS, "validatePadding"), q(bS, "validateVariableAnchorOffsetCollection"), q(ix, "validateSprite");
var Sg = { "*": () => [], array: np, boolean: fS, number: ap, color: mS, constants: Zg, enum: $n, filter: op, function: Wg, layer: Qg, object: kt, source: ex, light: tx, terrain: rx, string: Xr, formatted: yS, resolvedImage: gS, padding: xS, variableAnchorOffsetCollection: bS, sprite: ix };
function En(e53) {
  let t3 = e53.value, r = e53.valueSpec, i = e53.styleSpec;
  return e53.validateSpec = En, r.expression && ss(Ze(t3)) ? Wg(e53) : r.expression && Wn(Wr(t3)) ? Di(e53) : r.type && Sg[r.type] ? Sg[r.type](e53) : kt(ki({}, e53, { valueSpec: r.type ? i[r.type] : r }));
}
function nx(e53) {
  let t3 = e53.value, r = e53.key, i = Xr(e53);
  return i.length || (-1 === t3.indexOf("{fontstack}") && i.push(new N(r, t3, '"glyphs" url must include a "{fontstack}" token')), -1 === t3.indexOf("{range}") && i.push(new N(r, t3, '"glyphs" url must include a "{range}" token'))), i;
}
function Vt(e53, t3 = M) {
  let r = [];
  return r = r.concat(En({ key: "", value: e53, valueSpec: t3.$root, styleSpec: t3, style: e53, validateSpec: En, objectElementValidators: { glyphs: nx, "*": () => [] } })), e53.constants && (r = r.concat(Zg({ key: "constants", value: e53.constants, style: e53, styleSpec: t3, validateSpec: En }))), ax(r);
}
function er(e53) {
  return function(t3) {
    return e53({ ...t3, validateSpec: En });
  };
}
function ax(e53) {
  return [].concat(e53).sort((e54, t3) => e54.line - t3.line);
}
function tr(e53) {
  return function(...t3) {
    return ax(e53.apply(this, t3));
  };
}
q(En, "validate"), q(nx, "validateGlyphsUrl"), q(Vt, "validateStyleMin"), Vt.source = tr(er(ex)), Vt.sprite = tr(er(ix)), Vt.glyphs = tr(er(nx)), Vt.light = tr(er(tx)), Vt.terrain = tr(er(rx)), Vt.layer = tr(er(Qg)), Vt.filter = tr(er(op)), Vt.paintProperty = tr(er(Yg)), Vt.layoutProperty = tr(er(Jg)), q(er, "injectValidateSpec"), q(ax, "sortErrors"), q(tr, "wrapCleanErrors"), c();
var qe = Vt;
var ok = qe.source;
var ox = qe.light;
var sk = qe.terrain;
var lk = qe.filter;
var sx = qe.paintProperty;
var lx = qe.layoutProperty;
function Ri(e53, t3) {
  let r = false;
  if (t3 && t3.length)
    for (let i of t3)
      e53.fire(new Z(new Error(i.message))), r = true;
  return r;
}
q(Ri, "emitValidationErrors"), c(), c(), c();
var ls = class e32 {
  constructor(e53, t3, r) {
    let i = this.cells = [];
    if (e53 instanceof ArrayBuffer) {
      this.arrayBuffer = e53;
      let a3 = new Int32Array(this.arrayBuffer);
      e53 = a3[0], t3 = a3[1], r = a3[2], this.d = t3 + 2 * r;
      for (let e54 = 0; e54 < this.d * this.d; e54++) {
        let t4 = a3[3 + e54], r3 = a3[3 + e54 + 1];
        i.push(t4 === r3 ? null : a3.subarray(t4, r3));
      }
      let n = a3[3 + i.length], s3 = a3[3 + i.length + 1];
      this.keys = a3.subarray(n, s3), this.bboxes = a3.subarray(s3), this.insert = this._insertReadonly;
    } else {
      this.d = t3 + 2 * r;
      for (let e54 = 0; e54 < this.d * this.d; e54++)
        i.push([]);
      this.keys = [], this.bboxes = [];
    }
    this.n = t3, this.extent = e53, this.padding = r, this.scale = t3 / e53, this.uid = 0;
    let a = r / t3 * e53;
    this.min = -a, this.max = e53 + a;
  }
  insert(e53, t3, r, i, a) {
    this._forEachCell(t3, r, i, a, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e53), this.bboxes.push(t3), this.bboxes.push(r), this.bboxes.push(i), this.bboxes.push(a);
  }
  _insertReadonly() {
    throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
  }
  _insertCell(e53, t3, r, i, a, n) {
    this.cells[a].push(n);
  }
  query(e53, t3, r, i, a) {
    let n = this.min, s3 = this.max;
    if (e53 <= n && t3 <= n && s3 <= r && s3 <= i && !a)
      return Array.prototype.slice.call(this.keys);
    {
      let n3 = [], s4 = {};
      return this._forEachCell(e53, t3, r, i, this._queryCell, n3, s4, a), n3;
    }
  }
  _queryCell(e53, t3, r, i, a, n, s3, o) {
    let l = this.cells[a];
    if (null !== l) {
      let a3 = this.keys, u3 = this.bboxes;
      for (let c3 = 0; c3 < l.length; c3++) {
        let h = l[c3];
        if (void 0 === s3[h]) {
          let l3 = 4 * h;
          (o ? o(u3[l3 + 0], u3[l3 + 1], u3[l3 + 2], u3[l3 + 3]) : e53 <= u3[l3 + 2] && t3 <= u3[l3 + 3] && r >= u3[l3 + 0] && i >= u3[l3 + 1]) ? (s3[h] = true, n.push(a3[h])) : s3[h] = false;
        }
      }
    }
  }
  _forEachCell(e53, t3, r, i, a, n, s3, o) {
    let l = this._convertToCellCoord(e53), u3 = this._convertToCellCoord(t3), c3 = this._convertToCellCoord(r), h = this._convertToCellCoord(i);
    for (let p = l; p <= c3; p++)
      for (let l3 = u3; l3 <= h; l3++) {
        let u4 = this.d * l3 + p;
        if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(l3), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(l3 + 1))) && a.call(this, e53, t3, r, i, u4, n, s3, o))
          return;
      }
  }
  _convertFromCellCoord(e53) {
    return (e53 - this.padding) / this.scale;
  }
  _convertToCellCoord(e53) {
    return Math.max(0, Math.min(this.d - 1, Math.floor(e53 * this.scale) + this.padding));
  }
  toArrayBuffer() {
    if (this.arrayBuffer)
      return this.arrayBuffer;
    let e53 = this.cells, t3 = 3 + this.cells.length + 1 + 1, r = 0;
    for (let e54 = 0; e54 < this.cells.length; e54++)
      r += this.cells[e54].length;
    let i = new Int32Array(t3 + r + this.keys.length + this.bboxes.length);
    i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
    let a = t3;
    for (let t4 = 0; t4 < e53.length; t4++) {
      let r3 = e53[t4];
      i[3 + t4] = a, i.set(r3, a), a += r3.length;
    }
    return i[3 + e53.length] = a, i.set(this.keys, a), a += this.keys.length, i[3 + e53.length + 1] = a, i.set(this.bboxes, a), a += this.bboxes.length, i.buffer;
  }
  static serialize(e53, t3) {
    let r = e53.toArrayBuffer();
    return t3 && t3.push(r), { buffer: r };
  }
  static deserialize(t3) {
    return new e32(t3.buffer);
  }
};
q(ls, "TransferableGridIndex");
var Yr = ls;
var _r = {};
function G(e53, t3, r = {}) {
  if (_r[e53])
    throw new Error("".concat(e53, " is already registered."));
  Object.defineProperty(t3, "_classRegistryKey", { value: e53, writeable: false }), _r[e53] = { klass: t3, omit: r.omit || [], shallow: r.shallow || [] };
}
q(G, "register"), G("Object", Object), G("TransferableGridIndex", Yr), G("Color", K), G("Error", Error), G("AJAXError", hr), G("ResolvedImage", pt), G("StylePropertyFunction", jn), G("StyleExpression", Zr, { omit: ["_evaluator"] }), G("ZoomDependentExpression", br), G("ZoomConstantExpression", xr), G("CompoundExpression", qt, { omit: ["_evaluate"] });
for (let e53 in Kr)
  Kr[e53]._classRegistryKey || G("Expression_".concat(e53), Kr[e53]);
function ux(e53) {
  return e53 && typeof ArrayBuffer < "u" && (e53 instanceof ArrayBuffer || e53.constructor && "ArrayBuffer" === e53.constructor.name);
}
function Oi(e53, t3) {
  if (null == e53 || "boolean" == typeof e53 || "number" == typeof e53 || "string" == typeof e53 || e53 instanceof Boolean || e53 instanceof Number || e53 instanceof String || e53 instanceof Date || e53 instanceof RegExp || e53 instanceof Blob)
    return e53;
  if (ux(e53) || Ct(e53))
    return t3 && t3.push(e53), e53;
  if (ArrayBuffer.isView(e53)) {
    let r = e53;
    return t3 && t3.push(r.buffer), r;
  }
  if (e53 instanceof ImageData)
    return t3 && t3.push(e53.data.buffer), e53;
  if (Array.isArray(e53)) {
    let r = [];
    for (let i of e53)
      r.push(Oi(i, t3));
    return r;
  }
  if ("object" == typeof e53) {
    let r = e53.constructor, i = r._classRegistryKey;
    if (!i)
      throw new Error("can't serialize object of unregistered class");
    if (!_r[i])
      throw new Error("".concat(i, " is not registered."));
    let a = r.serialize ? r.serialize(e53, t3) : {};
    if (r.serialize) {
      if (t3 && a === t3[t3.length - 1])
        throw new Error("statically serialized object won't survive transfer of $name property");
    } else {
      for (let r3 in e53) {
        if (!e53.hasOwnProperty(r3) || _r[i].omit.indexOf(r3) >= 0)
          continue;
        let n = e53[r3];
        a[r3] = _r[i].shallow.indexOf(r3) >= 0 ? n : Oi(n, t3);
      }
      e53 instanceof Error && (a.message = e53.message);
    }
    if (a.$name)
      throw new Error("$name property is reserved for worker serialization logic.");
    return "Object" !== i && (a.$name = i), a;
  }
  throw new Error("can't serialize object of type ".concat(typeof e53));
}
function Vi(e53) {
  if (null == e53 || "boolean" == typeof e53 || "number" == typeof e53 || "string" == typeof e53 || e53 instanceof Boolean || e53 instanceof Number || e53 instanceof String || e53 instanceof Date || e53 instanceof RegExp || e53 instanceof Blob || ux(e53) || Ct(e53) || ArrayBuffer.isView(e53) || e53 instanceof ImageData)
    return e53;
  if (Array.isArray(e53))
    return e53.map(Vi);
  if ("object" == typeof e53) {
    let t3 = e53.$name || "Object";
    if (!_r[t3])
      throw new Error("can't deserialize unregistered class ".concat(t3));
    let { klass: r } = _r[t3];
    if (!r)
      throw new Error("can't deserialize unregistered class ".concat(t3));
    if (r.deserialize)
      return r.deserialize(e53);
    let i = Object.create(r.prototype);
    for (let r3 of Object.keys(e53)) {
      if ("$name" === r3)
        continue;
      let a = e53[r3];
      i[r3] = _r[t3].shallow.indexOf(r3) >= 0 ? a : Vi(a);
    }
    return i;
  }
  throw new Error("can't deserialize object of type ".concat(typeof e53));
}
q(ux, "isArrayBuffer"), q(Oi, "serialize"), q(Vi, "deserialize"), c(), c();
var yp = class {
  constructor() {
    this.first = true;
  }
  update(e53, t3) {
    let r = Math.floor(e53);
    return this.first ? (this.first = false, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = e53, this.lastFloorZoom = r, true) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = t3) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = t3), e53 !== this.lastZoom && (this.lastZoom = e53, this.lastFloorZoom = r, true));
  }
};
q(yp, "ZoomHistory");
var Ui = yp;
c(), c();
var pe = { "Latin-1 Supplement": (e53) => e53 >= 128 && e53 <= 255, Arabic: (e53) => e53 >= 1536 && e53 <= 1791, "Arabic Supplement": (e53) => e53 >= 1872 && e53 <= 1919, "Arabic Extended-A": (e53) => e53 >= 2208 && e53 <= 2303, "Hangul Jamo": (e53) => e53 >= 4352 && e53 <= 4607, "Unified Canadian Aboriginal Syllabics": (e53) => e53 >= 5120 && e53 <= 5759, Khmer: (e53) => e53 >= 6016 && e53 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (e53) => e53 >= 6320 && e53 <= 6399, "General Punctuation": (e53) => e53 >= 8192 && e53 <= 8303, "Letterlike Symbols": (e53) => e53 >= 8448 && e53 <= 8527, "Number Forms": (e53) => e53 >= 8528 && e53 <= 8591, "Miscellaneous Technical": (e53) => e53 >= 8960 && e53 <= 9215, "Control Pictures": (e53) => e53 >= 9216 && e53 <= 9279, "Optical Character Recognition": (e53) => e53 >= 9280 && e53 <= 9311, "Enclosed Alphanumerics": (e53) => e53 >= 9312 && e53 <= 9471, "Geometric Shapes": (e53) => e53 >= 9632 && e53 <= 9727, "Miscellaneous Symbols": (e53) => e53 >= 9728 && e53 <= 9983, "Miscellaneous Symbols and Arrows": (e53) => e53 >= 11008 && e53 <= 11263, "CJK Radicals Supplement": (e53) => e53 >= 11904 && e53 <= 12031, "Kangxi Radicals": (e53) => e53 >= 12032 && e53 <= 12255, "Ideographic Description Characters": (e53) => e53 >= 12272 && e53 <= 12287, "CJK Symbols and Punctuation": (e53) => e53 >= 12288 && e53 <= 12351, Hiragana: (e53) => e53 >= 12352 && e53 <= 12447, Katakana: (e53) => e53 >= 12448 && e53 <= 12543, Bopomofo: (e53) => e53 >= 12544 && e53 <= 12591, "Hangul Compatibility Jamo": (e53) => e53 >= 12592 && e53 <= 12687, Kanbun: (e53) => e53 >= 12688 && e53 <= 12703, "Bopomofo Extended": (e53) => e53 >= 12704 && e53 <= 12735, "CJK Strokes": (e53) => e53 >= 12736 && e53 <= 12783, "Katakana Phonetic Extensions": (e53) => e53 >= 12784 && e53 <= 12799, "Enclosed CJK Letters and Months": (e53) => e53 >= 12800 && e53 <= 13055, "CJK Compatibility": (e53) => e53 >= 13056 && e53 <= 13311, "CJK Unified Ideographs Extension A": (e53) => e53 >= 13312 && e53 <= 19903, "Yijing Hexagram Symbols": (e53) => e53 >= 19904 && e53 <= 19967, "CJK Unified Ideographs": (e53) => e53 >= 19968 && e53 <= 40959, "Yi Syllables": (e53) => e53 >= 40960 && e53 <= 42127, "Yi Radicals": (e53) => e53 >= 42128 && e53 <= 42191, "Hangul Jamo Extended-A": (e53) => e53 >= 43360 && e53 <= 43391, "Hangul Syllables": (e53) => e53 >= 44032 && e53 <= 55215, "Hangul Jamo Extended-B": (e53) => e53 >= 55216 && e53 <= 55295, "Private Use Area": (e53) => e53 >= 57344 && e53 <= 63743, "CJK Compatibility Ideographs": (e53) => e53 >= 63744 && e53 <= 64255, "Arabic Presentation Forms-A": (e53) => e53 >= 64336 && e53 <= 65023, "Vertical Forms": (e53) => e53 >= 65040 && e53 <= 65055, "CJK Compatibility Forms": (e53) => e53 >= 65072 && e53 <= 65103, "Small Form Variants": (e53) => e53 >= 65104 && e53 <= 65135, "Arabic Presentation Forms-B": (e53) => e53 >= 65136 && e53 <= 65279, "Halfwidth and Fullwidth Forms": (e53) => e53 >= 65280 && e53 <= 65519 };
function gp(e53) {
  for (let t3 of e53)
    if (cx(t3.charCodeAt(0)))
      return true;
  return false;
}
function cx(e53) {
  return 746 === e53 || 747 === e53 || !(e53 < 4352) && !(!(pe["Bopomofo Extended"](e53) || pe.Bopomofo(e53) || pe["CJK Compatibility Forms"](e53) && !(e53 >= 65097 && e53 <= 65103) || pe["CJK Compatibility Ideographs"](e53) || pe["CJK Compatibility"](e53) || pe["CJK Radicals Supplement"](e53) || pe["CJK Strokes"](e53) || pe["CJK Symbols and Punctuation"](e53) && !(e53 >= 12296 && e53 <= 12305) && !(e53 >= 12308 && e53 <= 12319) && 12336 !== e53 || pe["CJK Unified Ideographs Extension A"](e53) || pe["CJK Unified Ideographs"](e53) || pe["Enclosed CJK Letters and Months"](e53) || pe["Hangul Compatibility Jamo"](e53) || pe["Hangul Jamo Extended-A"](e53) || pe["Hangul Jamo Extended-B"](e53) || pe["Hangul Jamo"](e53) || pe["Hangul Syllables"](e53) || pe.Hiragana(e53) || pe["Ideographic Description Characters"](e53) || pe.Kanbun(e53) || pe["Kangxi Radicals"](e53) || pe["Katakana Phonetic Extensions"](e53) || pe.Katakana(e53) && 12540 !== e53) && (!pe["Halfwidth and Fullwidth Forms"](e53) || 65288 === e53 || 65289 === e53 || 65293 === e53 || e53 >= 65306 && e53 <= 65310 || 65339 === e53 || 65341 === e53 || 65343 === e53 || e53 >= 65371 && e53 <= 65503 || 65507 === e53 || e53 >= 65512 && e53 <= 65519) && (!pe["Small Form Variants"](e53) || e53 >= 65112 && e53 <= 65118 || e53 >= 65123 && e53 <= 65126) && !pe["Unified Canadian Aboriginal Syllabics"](e53) && !pe["Unified Canadian Aboriginal Syllabics Extended"](e53) && !pe["Vertical Forms"](e53) && !pe["Yijing Hexagram Symbols"](e53) && !pe["Yi Syllables"](e53) && !pe["Yi Radicals"](e53));
}
function px(e53) {
  return e53 >= 1424 && e53 <= 2303 || pe["Arabic Presentation Forms-A"](e53) || pe["Arabic Presentation Forms-B"](e53);
}
function _S(e53, t3) {
  return !(!t3 && px(e53) || e53 >= 2304 && e53 <= 3583 || e53 >= 3840 && e53 <= 4255 || pe.Khmer(e53));
}
function hx(e53) {
  for (let t3 of e53)
    if (px(t3.charCodeAt(0)))
      return true;
  return false;
}
function fx(e53, t3) {
  for (let r of e53)
    if (!_S(r.charCodeAt(0), t3))
      return false;
  return true;
}
q(gp, "allowsVerticalWritingMode"), q(cx, "charHasUprightVerticalOrientation"), q(px, "charInRTLScript"), q(_S, "charInSupportedScript"), q(hx, "stringContainsRTLText"), q(fx, "isStringInSupportedScript"), c();
var Ut = { unavailable: "unavailable", deferred: "deferred", loading: "loading", loaded: "loaded", error: "error" };
var xp = null;
var ht = Ut.unavailable;
var vr = null;
var _p = q(function(e53) {
  e53 && "string" == typeof e53 && e53.indexOf("NetworkError") > -1 && (ht = Ut.error), xp && xp(e53);
}, "triggerPluginCompletionEvent");
function bp() {
  us.fire(new z("pluginStateChange", { pluginStatus: ht, pluginURL: vr }));
}
q(bp, "sendPluginStateToWorker");
var us = new de();
var Kn = q(function() {
  return ht;
}, "getRTLTextPluginStatus");
var mx = q(function(e53) {
  return e53({ pluginStatus: ht, pluginURL: vr }), us.on("pluginStateChange", e53), e53;
}, "registerForPluginStateChange");
var dx = q(function(e53, t3, r = false) {
  if (ht === Ut.deferred || ht === Ut.loading || ht === Ut.loaded)
    throw new Error("setRTLTextPlugin cannot be called multiple times.");
  vr = ne.resolveURL(e53), ht = Ut.deferred, xp = t3, bp(), r || yx();
}, "setRTLTextPlugin");
var yx = q(function() {
  if (ht !== Ut.deferred || !vr)
    throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
  ht = Ut.loading, bp(), vr && xo({ url: vr }, (e53) => {
    e53 ? _p(e53) : (ht = Ut.loaded, bp());
  });
}, "downloadRTLTextPlugin");
var ft = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ht === Ut.loaded || null != ft.applyArabicShaping, isLoading: () => ht === Ut.loading, setState(e53) {
  if (!ct())
    throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
  ht = e53.pluginStatus, vr = e53.pluginURL;
}, isParsed() {
  if (!ct())
    throw new Error("rtl-text-plugin is only parsed on the worker-threads");
  return null != ft.applyArabicShaping && null != ft.processBidirectionalText && null != ft.processStyledBidirectionalText;
}, getPluginURL() {
  if (!ct())
    throw new Error("rtl-text-plugin url can only be queried from the worker threads");
  return vr;
} };
var gx = q(function() {
  !ft.isLoading() && !ft.isLoaded() && "deferred" === Kn() && yx();
}, "lazyLoadRTLTextPlugin");
var vp = class {
  constructor(e53, t3) {
    this.zoom = e53, t3 ? (this.now = t3.now, this.fadeDuration = t3.fadeDuration, this.zoomHistory = t3.zoomHistory, this.transition = t3.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ui(), this.transition = {});
  }
  isSupportedScript(e53) {
    return fx(e53, ft.isLoaded());
  }
  crossFadingFactor() {
    return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
  }
  getCrossfadeParameters() {
    let e53 = this.zoom, t3 = e53 - Math.floor(e53), r = this.crossFadingFactor();
    return e53 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: t3 + (1 - t3) * r } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r) * t3 };
  }
};
q(vp, "EvaluationParameters");
var ye = vp;
var wp = class {
  constructor(e53, t3) {
    this.property = e53, this.value = t3, this.expression = jg(void 0 === t3 ? e53.specification.default : t3, e53.specification);
  }
  isDataDriven() {
    return "source" === this.expression.kind || "composite" === this.expression.kind;
  }
  possiblyEvaluate(e53, t3, r) {
    return this.property.possiblyEvaluate(this, e53, t3, r);
  }
};
q(wp, "PropertyValue");
var Ni = wp;
var Sp = class {
  constructor(e53) {
    this.property = e53, this.value = new Ni(e53, void 0);
  }
  transitioned(e53, t3) {
    return new cs(this.property, this.value, t3, R({}, e53.transition, this.transition), e53.now);
  }
  untransitioned() {
    return new cs(this.property, this.value, null, {}, 0);
  }
};
q(Sp, "TransitionablePropertyValue");
var Yn = Sp;
var Pp = class {
  constructor(e53) {
    this._properties = e53, this._values = Object.create(e53.defaultTransitionablePropertyValues);
  }
  getValue(e53) {
    return ut(this._values[e53].value.value);
  }
  setValue(e53, t3) {
    Object.prototype.hasOwnProperty.call(this._values, e53) || (this._values[e53] = new Yn(this._values[e53].property)), this._values[e53].value = new Ni(this._values[e53].property, null === t3 ? void 0 : ut(t3));
  }
  getTransition(e53) {
    return ut(this._values[e53].transition);
  }
  setTransition(e53, t3) {
    Object.prototype.hasOwnProperty.call(this._values, e53) || (this._values[e53] = new Yn(this._values[e53].property)), this._values[e53].transition = ut(t3) || void 0;
  }
  serialize() {
    let e53 = {};
    for (let t3 of Object.keys(this._values)) {
      let r = this.getValue(t3);
      void 0 !== r && (e53[t3] = r);
      let i = this.getTransition(t3);
      void 0 !== i && (e53["".concat(t3, "-transition")] = i);
    }
    return e53;
  }
  transitioned(e53, t3) {
    let r = new ps(this._properties);
    for (let i of Object.keys(this._values))
      r._values[i] = this._values[i].transitioned(e53, t3._values[i]);
    return r;
  }
  untransitioned() {
    let e53 = new ps(this._properties);
    for (let t3 of Object.keys(this._values))
      e53._values[t3] = this._values[t3].untransitioned();
    return e53;
  }
};
q(Pp, "Transitionable");
var Gi = Pp;
var Tp = class {
  constructor(e53, t3, r, i, a) {
    this.property = e53, this.value = t3, this.begin = a + i.delay || 0, this.end = this.begin + i.duration || 0, e53.specification.transition && (i.delay || i.duration) && (this.prior = r);
  }
  possiblyEvaluate(e53, t3, r) {
    let i = e53.now || 0, a = this.value.possiblyEvaluate(e53, t3, r), n = this.prior;
    if (n) {
      if (i > this.end)
        return this.prior = null, a;
      if (this.value.isDataDriven())
        return this.prior = null, a;
      if (i < this.begin)
        return n.possiblyEvaluate(e53, t3, r);
      {
        let s3 = (i - this.begin) / (this.end - this.begin);
        return this.property.interpolate(n.possiblyEvaluate(e53, t3, r), a, Hy(s3));
      }
    }
    return a;
  }
};
q(Tp, "TransitioningPropertyValue");
var cs = Tp;
var Ap = class {
  constructor(e53) {
    this._properties = e53, this._values = Object.create(e53.defaultTransitioningPropertyValues);
  }
  possiblyEvaluate(e53, t3, r) {
    let i = new wr(this._properties);
    for (let a of Object.keys(this._values))
      i._values[a] = this._values[a].possiblyEvaluate(e53, t3, r);
    return i;
  }
  hasTransition() {
    for (let e53 of Object.keys(this._values))
      if (this._values[e53].prior)
        return true;
    return false;
  }
};
q(Ap, "Transitioning");
var ps = Ap;
var Ip = class {
  constructor(e53) {
    this._properties = e53, this._values = Object.create(e53.defaultPropertyValues);
  }
  getValue(e53) {
    return ut(this._values[e53].value);
  }
  setValue(e53, t3) {
    this._values[e53] = new Ni(this._values[e53].property, null === t3 ? void 0 : ut(t3));
  }
  serialize() {
    let e53 = {};
    for (let t3 of Object.keys(this._values)) {
      let r = this.getValue(t3);
      void 0 !== r && (e53[t3] = r);
    }
    return e53;
  }
  possiblyEvaluate(e53, t3, r) {
    let i = new wr(this._properties);
    for (let a of Object.keys(this._values))
      i._values[a] = this._values[a].possiblyEvaluate(e53, t3, r);
    return i;
  }
};
q(Ip, "Layout");
var hs = Ip;
var Mp = class {
  constructor(e53, t3, r) {
    this.property = e53, this.value = t3, this.parameters = r;
  }
  isConstant() {
    return "constant" === this.value.kind;
  }
  constantOr(e53) {
    return "constant" === this.value.kind ? this.value.value : e53;
  }
  evaluate(e53, t3, r, i) {
    return this.property.evaluate(this.value, this.parameters, e53, t3, r, i);
  }
};
q(Mp, "PossiblyEvaluatedPropertyValue");
var at = Mp;
var Cp = class {
  constructor(e53) {
    this._properties = e53, this._values = Object.create(e53.defaultPossiblyEvaluatedValues);
  }
  get(e53) {
    return this._values[e53];
  }
};
q(Cp, "PossiblyEvaluated");
var wr = Cp;
var Ep = class {
  constructor(e53) {
    this.specification = e53;
  }
  possiblyEvaluate(e53, t3) {
    if (e53.isDataDriven())
      throw new Error("Value should not be data driven");
    return e53.expression.evaluate(t3);
  }
  interpolate(e53, t3, r) {
    let i = this.specification.type, a = ke[i];
    return a ? a(e53, t3, r) : e53;
  }
};
q(Ep, "DataConstantProperty");
var $ = Ep;
var kp = class {
  constructor(e53, t3) {
    this.specification = e53, this.overrides = t3;
  }
  possiblyEvaluate(e53, t3, r, i) {
    return "constant" === e53.expression.kind || "camera" === e53.expression.kind ? new at(this, { kind: "constant", value: e53.expression.evaluate(t3, null, {}, r, i) }, t3) : new at(this, e53.expression, t3);
  }
  interpolate(e53, t3, r) {
    if ("constant" !== e53.value.kind || "constant" !== t3.value.kind)
      return e53;
    if (void 0 === e53.value.value || void 0 === t3.value.value)
      return new at(this, { kind: "constant", value: void 0 }, e53.parameters);
    let i = this.specification.type, a = ke[i];
    if (a) {
      let i3 = a(e53.value.value, t3.value.value, r);
      return new at(this, { kind: "constant", value: i3 }, e53.parameters);
    }
    return e53;
  }
  evaluate(e53, t3, r, i, a, n) {
    return "constant" === e53.kind ? e53.value : e53.evaluate(t3, r, i, a, n);
  }
};
q(kp, "DataDrivenProperty");
var W = kp;
var Lp = class extends W {
  possiblyEvaluate(e53, t3, r, i) {
    if (void 0 === e53.value)
      return new at(this, { kind: "constant", value: void 0 }, t3);
    if ("constant" === e53.expression.kind) {
      let a = e53.expression.evaluate(t3, null, {}, r, i), n = "resolvedImage" === e53.property.specification.type && "string" != typeof a ? a.name : a, s3 = this._calculate(n, n, n, t3);
      return new at(this, { kind: "constant", value: s3 }, t3);
    }
    if ("camera" === e53.expression.kind) {
      let r3 = this._calculate(e53.expression.evaluate({ zoom: t3.zoom - 1 }), e53.expression.evaluate({ zoom: t3.zoom }), e53.expression.evaluate({ zoom: t3.zoom + 1 }), t3);
      return new at(this, { kind: "constant", value: r3 }, t3);
    }
    return new at(this, e53.expression, t3);
  }
  evaluate(e53, t3, r, i, a, n) {
    if ("source" === e53.kind) {
      let s3 = e53.evaluate(t3, r, i, a, n);
      return this._calculate(s3, s3, s3, t3);
    }
    return "composite" === e53.kind ? this._calculate(e53.evaluate({ zoom: Math.floor(t3.zoom) - 1 }, r, i), e53.evaluate({ zoom: Math.floor(t3.zoom) }, r, i), e53.evaluate({ zoom: Math.floor(t3.zoom) + 1 }, r, i), t3) : e53.value;
  }
  _calculate(e53, t3, r, i) {
    return i.zoom > i.zoomHistory.lastIntegerZoom ? { from: e53, to: t3 } : { from: r, to: t3 };
  }
  interpolate(e53) {
    return e53;
  }
};
q(Lp, "CrossFadedDataDrivenProperty");
var rr = Lp;
var Dp = class {
  constructor(e53) {
    this.specification = e53;
  }
  possiblyEvaluate(e53, t3, r, i) {
    if (void 0 !== e53.value) {
      if ("constant" === e53.expression.kind) {
        let a = e53.expression.evaluate(t3, null, {}, r, i);
        return this._calculate(a, a, a, t3);
      }
      return this._calculate(e53.expression.evaluate(new ye(Math.floor(t3.zoom - 1), t3)), e53.expression.evaluate(new ye(Math.floor(t3.zoom), t3)), e53.expression.evaluate(new ye(Math.floor(t3.zoom + 1), t3)), t3);
    }
  }
  _calculate(e53, t3, r, i) {
    return i.zoom > i.zoomHistory.lastIntegerZoom ? { from: e53, to: t3 } : { from: r, to: t3 };
  }
  interpolate(e53) {
    return e53;
  }
};
q(Dp, "CrossFadedProperty");
var Jr = Dp;
var zp = class {
  constructor(e53) {
    this.specification = e53;
  }
  possiblyEvaluate(e53, t3, r, i) {
    return !!e53.expression.evaluate(t3, null, {}, r, i);
  }
  interpolate() {
    return false;
  }
};
q(zp, "ColorRampProperty");
var Qr = zp;
var Fp = class {
  constructor(e53) {
    this.properties = e53, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
    for (let t3 in e53) {
      let r = e53[t3];
      r.specification.overridable && this.overridableProperties.push(t3);
      let i = this.defaultPropertyValues[t3] = new Ni(r, void 0), a = this.defaultTransitionablePropertyValues[t3] = new Yn(r);
      this.defaultTransitioningPropertyValues[t3] = a.untransitioned(), this.defaultPossiblyEvaluatedValues[t3] = i.possiblyEvaluate({});
    }
  }
};
q(Fp, "Properties");
var Re = Fp;
G("DataDrivenProperty", W), G("DataConstantProperty", $), G("CrossFadedDataDrivenProperty", rr), G("CrossFadedProperty", Jr), G("ColorRampProperty", Qr);
var fs = "-transition";
var Bp = class extends de {
  constructor(e53, t3) {
    if (super(), this.id = e53.id, this.type = e53.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== e53.type && (this.metadata = e53.metadata, this.minzoom = e53.minzoom, this.maxzoom = e53.maxzoom, "background" !== e53.type && (this.source = e53.source, this.sourceLayer = e53["source-layer"], this.filter = e53.filter), t3.layout && (this._unevaluatedLayout = new hs(t3.layout)), t3.paint)) {
      this._transitionablePaint = new Gi(t3.paint);
      for (let t4 in e53.paint)
        this.setPaintProperty(t4, e53.paint[t4], { validate: false });
      for (let t4 in e53.layout)
        this.setLayoutProperty(t4, e53.layout[t4], { validate: false });
      this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new wr(t3.paint);
    }
  }
  getCrossfadeParameters() {
    return this._crossfadeParameters;
  }
  getLayoutProperty(e53) {
    return "visibility" === e53 ? this.visibility : this._unevaluatedLayout.getValue(e53);
  }
  setLayoutProperty(e53, t3, r = {}) {
    if (null != t3) {
      let i = "layers.".concat(this.id, ".layout.").concat(e53);
      if (this._validate(lx, i, e53, t3, r))
        return;
    }
    "visibility" !== e53 ? this._unevaluatedLayout.setValue(e53, t3) : this.visibility = t3;
  }
  getPaintProperty(e53) {
    return e53.endsWith(fs) ? this._transitionablePaint.getTransition(e53.slice(0, -fs.length)) : this._transitionablePaint.getValue(e53);
  }
  setPaintProperty(e53, t3, r = {}) {
    if (null != t3) {
      let i = "layers.".concat(this.id, ".paint.").concat(e53);
      if (this._validate(sx, i, e53, t3, r))
        return false;
    }
    if (e53.endsWith(fs))
      return this._transitionablePaint.setTransition(e53.slice(0, -fs.length), t3 || void 0), false;
    {
      let r3 = this._transitionablePaint._values[e53], i = "cross-faded-data-driven" === r3.property.specification["property-type"], a = r3.value.isDataDriven(), n = r3.value;
      this._transitionablePaint.setValue(e53, t3), this._handleSpecialPaintPropertyUpdate(e53);
      let s3 = this._transitionablePaint._values[e53].value;
      return s3.isDataDriven() || a || i || this._handleOverridablePaintPropertyUpdate(e53, n, s3);
    }
  }
  _handleSpecialPaintPropertyUpdate(e53) {
  }
  _handleOverridablePaintPropertyUpdate(e53, t3, r) {
    return false;
  }
  isHidden(e53) {
    return !!(this.minzoom && e53 < this.minzoom || this.maxzoom && e53 >= this.maxzoom) || "none" === this.visibility;
  }
  updateTransitions(e53) {
    this._transitioningPaint = this._transitionablePaint.transitioned(e53, this._transitioningPaint);
  }
  hasTransition() {
    return this._transitioningPaint.hasTransition();
  }
  recalculate(e53, t3) {
    e53.getCrossfadeParameters && (this._crossfadeParameters = e53.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e53, void 0, t3)), this.paint = this._transitioningPaint.possiblyEvaluate(e53, void 0, t3);
  }
  serialize() {
    let e53 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
    return this.visibility && (e53.layout = e53.layout || {}, e53.layout.visibility = this.visibility), mo(e53, (e54, t3) => !(void 0 === e54 || "layout" === t3 && !Object.keys(e54).length || "paint" === t3 && !Object.keys(e54).length));
  }
  _validate(e53, t3, r, i, a = {}) {
    return (!a || false !== a.validate) && Ri(this, e53.call(qe, { key: t3, layerType: this.type, objectKey: r, value: i, styleSpec: M, style: { glyphs: true, sprite: true } }));
  }
  is3D() {
    return false;
  }
  isTileClipped() {
    return false;
  }
  hasOffscreenPass() {
    return false;
  }
  resize() {
  }
  isStateDependent() {
    for (let e53 in this.paint._values) {
      let t3 = this.paint.get(e53);
      if (t3 instanceof at && gr(t3.property.specification) && ("source" === t3.value.kind || "composite" === t3.value.kind) && t3.value.isStateDependent)
        return true;
    }
    return false;
  }
};
q(Bp, "StyleLayer");
var je = Bp;
c(), c(), c();
var vS = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
var Rp = class {
  constructor(e53, t3) {
    this._structArray = e53, this._pos1 = t3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
  }
};
q(Rp, "Struct");
var ei = Rp;
var wS = 128;
var SS = 5;
var Op = class {
  constructor() {
    this.isTransferred = false, this.capacity = -1, this.resize(0);
  }
  static serialize(e53, t3) {
    return e53._trim(), t3 && (e53.isTransferred = true, t3.push(e53.arrayBuffer)), { length: e53.length, arrayBuffer: e53.arrayBuffer };
  }
  static deserialize(e53) {
    let t3 = Object.create(this.prototype);
    return t3.arrayBuffer = e53.arrayBuffer, t3.length = e53.length, t3.capacity = e53.arrayBuffer.byteLength / t3.bytesPerElement, t3._refreshViews(), t3;
  }
  _trim() {
    this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
  }
  clear() {
    this.length = 0;
  }
  resize(e53) {
    this.reserve(e53), this.length = e53;
  }
  reserve(e53) {
    if (e53 > this.capacity) {
      this.capacity = Math.max(e53, Math.floor(this.capacity * SS), wS), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
      let t3 = this.uint8;
      this._refreshViews(), t3 && this.uint8.set(t3);
    }
  }
  _refreshViews() {
    throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
  }
};
q(Op, "StructArray");
var Ve = Op;
function ve(e53, t3 = 1) {
  let r = 0, i = 0;
  return { members: e53.map((e54) => {
    let a = PS(e54.type), n = r = xx(r, Math.max(t3, a)), s3 = e54.components || 1;
    return i = Math.max(i, a), r += a * s3, { name: e54.name, type: e54.type, components: s3, offset: n };
  }), size: xx(r, Math.max(i, t3)), alignment: t3 };
}
function PS(e53) {
  return vS[e53].BYTES_PER_ELEMENT;
}
function xx(e53, t3) {
  return Math.ceil(e53 / t3) * t3;
}
q(ve, "createLayout"), q(PS, "sizeOf"), q(xx, "align");
var bx = u(Pe(), 1);
var Vp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3) {
    let r = this.length;
    return this.resize(r + 1), this.emplace(r, e53, t3);
  }
  emplace(e53, t3, r) {
    let i = 2 * e53;
    return this.int16[i + 0] = t3, this.int16[i + 1] = r, e53;
  }
};
q(Vp, "StructArrayLayout2i4");
var ti = Vp;
ti.prototype.bytesPerElement = 4, G("StructArrayLayout2i4", ti);
var Up = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e53, t3, r);
  }
  emplace(e53, t3, r, i) {
    let a = 3 * e53;
    return this.int16[a + 0] = t3, this.int16[a + 1] = r, this.int16[a + 2] = i, e53;
  }
};
q(Up, "StructArrayLayout3i6");
var qi = Up;
qi.prototype.bytesPerElement = 6, G("StructArrayLayout3i6", qi);
var Np = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i) {
    let a = this.length;
    return this.resize(a + 1), this.emplace(a, e53, t3, r, i);
  }
  emplace(e53, t3, r, i, a) {
    let n = 4 * e53;
    return this.int16[n + 0] = t3, this.int16[n + 1] = r, this.int16[n + 2] = i, this.int16[n + 3] = a, e53;
  }
};
q(Np, "StructArrayLayout4i8");
var Jn = Np;
Jn.prototype.bytesPerElement = 8, G("StructArrayLayout4i8", Jn);
var Gp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e53, t3, r, i, a, n);
  }
  emplace(e53, t3, r, i, a, n, s3) {
    let o = 6 * e53;
    return this.int16[o + 0] = t3, this.int16[o + 1] = r, this.int16[o + 2] = i, this.int16[o + 3] = a, this.int16[o + 4] = n, this.int16[o + 5] = s3, e53;
  }
};
q(Gp, "StructArrayLayout2i4i12");
var Qn = Gp;
Qn.prototype.bytesPerElement = 12, G("StructArrayLayout2i4i12", Qn);
var qp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e53, t3, r, i, a, n);
  }
  emplace(e53, t3, r, i, a, n, s3) {
    let o = 4 * e53, l = 8 * e53;
    return this.int16[o + 0] = t3, this.int16[o + 1] = r, this.uint8[l + 4] = i, this.uint8[l + 5] = a, this.uint8[l + 6] = n, this.uint8[l + 7] = s3, e53;
  }
};
q(qp, "StructArrayLayout2i4ub8");
var ea = qp;
ea.prototype.bytesPerElement = 8, G("StructArrayLayout2i4ub8", ea);
var jp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3) {
    let r = this.length;
    return this.resize(r + 1), this.emplace(r, e53, t3);
  }
  emplace(e53, t3, r) {
    let i = 2 * e53;
    return this.float32[i + 0] = t3, this.float32[i + 1] = r, e53;
  }
};
q(jp, "StructArrayLayout2f8");
var Sr = jp;
Sr.prototype.bytesPerElement = 8, G("StructArrayLayout2f8", Sr);
var $p = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n, s3, o, l, u3) {
    let c3 = this.length;
    return this.resize(c3 + 1), this.emplace(c3, e53, t3, r, i, a, n, s3, o, l, u3);
  }
  emplace(e53, t3, r, i, a, n, s3, o, l, u3, c3) {
    let h = 10 * e53;
    return this.uint16[h + 0] = t3, this.uint16[h + 1] = r, this.uint16[h + 2] = i, this.uint16[h + 3] = a, this.uint16[h + 4] = n, this.uint16[h + 5] = s3, this.uint16[h + 6] = o, this.uint16[h + 7] = l, this.uint16[h + 8] = u3, this.uint16[h + 9] = c3, e53;
  }
};
q($p, "StructArrayLayout10ui20");
var ta = $p;
ta.prototype.bytesPerElement = 20, G("StructArrayLayout10ui20", ta);
var Hp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n, s3, o, l, u3, c3, h) {
    let p = this.length;
    return this.resize(p + 1), this.emplace(p, e53, t3, r, i, a, n, s3, o, l, u3, c3, h);
  }
  emplace(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p) {
    let d = 12 * e53;
    return this.int16[d + 0] = t3, this.int16[d + 1] = r, this.int16[d + 2] = i, this.int16[d + 3] = a, this.uint16[d + 4] = n, this.uint16[d + 5] = s3, this.uint16[d + 6] = o, this.uint16[d + 7] = l, this.int16[d + 8] = u3, this.int16[d + 9] = c3, this.int16[d + 10] = h, this.int16[d + 11] = p, e53;
  }
};
q(Hp, "StructArrayLayout4i4ui4i24");
var ra = Hp;
ra.prototype.bytesPerElement = 24, G("StructArrayLayout4i4ui4i24", ra);
var Zp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e53, t3, r);
  }
  emplace(e53, t3, r, i) {
    let a = 3 * e53;
    return this.float32[a + 0] = t3, this.float32[a + 1] = r, this.float32[a + 2] = i, e53;
  }
};
q(Zp, "StructArrayLayout3f12");
var ia = Zp;
ia.prototype.bytesPerElement = 12, G("StructArrayLayout3f12", ia);
var Wp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
  }
  emplaceBack(e53) {
    let t3 = this.length;
    return this.resize(t3 + 1), this.emplace(t3, e53);
  }
  emplace(e53, t3) {
    let r = 1 * e53;
    return this.uint32[r + 0] = t3, e53;
  }
};
q(Wp, "StructArrayLayout1ul4");
var na = Wp;
na.prototype.bytesPerElement = 4, G("StructArrayLayout1ul4", na);
var Xp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n, s3, o, l) {
    let u3 = this.length;
    return this.resize(u3 + 1), this.emplace(u3, e53, t3, r, i, a, n, s3, o, l);
  }
  emplace(e53, t3, r, i, a, n, s3, o, l, u3) {
    let c3 = 10 * e53, h = 5 * e53;
    return this.int16[c3 + 0] = t3, this.int16[c3 + 1] = r, this.int16[c3 + 2] = i, this.int16[c3 + 3] = a, this.int16[c3 + 4] = n, this.int16[c3 + 5] = s3, this.uint32[h + 3] = o, this.uint16[c3 + 8] = l, this.uint16[c3 + 9] = u3, e53;
  }
};
q(Xp, "StructArrayLayout6i1ul2ui20");
var aa = Xp;
aa.prototype.bytesPerElement = 20, G("StructArrayLayout6i1ul2ui20", aa);
var Kp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n) {
    let s3 = this.length;
    return this.resize(s3 + 1), this.emplace(s3, e53, t3, r, i, a, n);
  }
  emplace(e53, t3, r, i, a, n, s3) {
    let o = 6 * e53;
    return this.int16[o + 0] = t3, this.int16[o + 1] = r, this.int16[o + 2] = i, this.int16[o + 3] = a, this.int16[o + 4] = n, this.int16[o + 5] = s3, e53;
  }
};
q(Kp, "StructArrayLayout2i2i2i12");
var oa = Kp;
oa.prototype.bytesPerElement = 12, G("StructArrayLayout2i2i2i12", oa);
var Yp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a) {
    let n = this.length;
    return this.resize(n + 1), this.emplace(n, e53, t3, r, i, a);
  }
  emplace(e53, t3, r, i, a, n) {
    let s3 = 4 * e53, o = 8 * e53;
    return this.float32[s3 + 0] = t3, this.float32[s3 + 1] = r, this.float32[s3 + 2] = i, this.int16[o + 6] = a, this.int16[o + 7] = n, e53;
  }
};
q(Yp, "StructArrayLayout2f1f2i16");
var sa = Yp;
sa.prototype.bytesPerElement = 16, G("StructArrayLayout2f1f2i16", sa);
var Jp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i) {
    let a = this.length;
    return this.resize(a + 1), this.emplace(a, e53, t3, r, i);
  }
  emplace(e53, t3, r, i, a) {
    let n = 12 * e53, s3 = 3 * e53;
    return this.uint8[n + 0] = t3, this.uint8[n + 1] = r, this.float32[s3 + 1] = i, this.float32[s3 + 2] = a, e53;
  }
};
q(Jp, "StructArrayLayout2ub2f12");
var la = Jp;
la.prototype.bytesPerElement = 12, G("StructArrayLayout2ub2f12", la);
var Qp = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e53, t3, r);
  }
  emplace(e53, t3, r, i) {
    let a = 3 * e53;
    return this.uint16[a + 0] = t3, this.uint16[a + 1] = r, this.uint16[a + 2] = i, e53;
  }
};
q(Qp, "StructArrayLayout3ui6");
var ji = Qp;
ji.prototype.bytesPerElement = 6, G("StructArrayLayout3ui6", ji);
var eh = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y) {
    let g = this.length;
    return this.resize(g + 1), this.emplace(g, e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y);
  }
  emplace(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y, g) {
    let _ = 24 * e53, x = 12 * e53, v = 48 * e53;
    return this.int16[_ + 0] = t3, this.int16[_ + 1] = r, this.uint16[_ + 2] = i, this.uint16[_ + 3] = a, this.uint32[x + 2] = n, this.uint32[x + 3] = s3, this.uint32[x + 4] = o, this.uint16[_ + 10] = l, this.uint16[_ + 11] = u3, this.uint16[_ + 12] = c3, this.float32[x + 7] = h, this.float32[x + 8] = p, this.uint8[v + 36] = d, this.uint8[v + 37] = f, this.uint8[v + 38] = m, this.uint32[x + 10] = y, this.int16[_ + 22] = g, e53;
  }
};
q(eh, "StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48");
var ua = eh;
ua.prototype.bytesPerElement = 48, G("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ua);
var th = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y, g, _, x, v, b, w, S, A, M3, I, T) {
    let C = this.length;
    return this.resize(C + 1), this.emplace(C, e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y, g, _, x, v, b, w, S, A, M3, I, T);
  }
  emplace(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y, g, _, x, v, b, w, S, A, M3, I, T, C) {
    let P = 34 * e53, k = 17 * e53;
    return this.int16[P + 0] = t3, this.int16[P + 1] = r, this.int16[P + 2] = i, this.int16[P + 3] = a, this.int16[P + 4] = n, this.int16[P + 5] = s3, this.int16[P + 6] = o, this.int16[P + 7] = l, this.uint16[P + 8] = u3, this.uint16[P + 9] = c3, this.uint16[P + 10] = h, this.uint16[P + 11] = p, this.uint16[P + 12] = d, this.uint16[P + 13] = f, this.uint16[P + 14] = m, this.uint16[P + 15] = y, this.uint16[P + 16] = g, this.uint16[P + 17] = _, this.uint16[P + 18] = x, this.uint16[P + 19] = v, this.uint16[P + 20] = b, this.uint16[P + 21] = w, this.uint16[P + 22] = S, this.uint32[k + 12] = A, this.float32[k + 13] = M3, this.float32[k + 14] = I, this.float32[k + 15] = T, this.float32[k + 16] = C, e53;
  }
};
q(th, "StructArrayLayout8i15ui1ul4f68");
var ca = th;
ca.prototype.bytesPerElement = 68, G("StructArrayLayout8i15ui1ul4f68", ca);
var rh = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53) {
    let t3 = this.length;
    return this.resize(t3 + 1), this.emplace(t3, e53);
  }
  emplace(e53, t3) {
    let r = 1 * e53;
    return this.float32[r + 0] = t3, e53;
  }
};
q(rh, "StructArrayLayout1f4");
var ri = rh;
ri.prototype.bytesPerElement = 4, G("StructArrayLayout1f4", ri);
var ih = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r) {
    let i = this.length;
    return this.resize(i + 1), this.emplace(i, e53, t3, r);
  }
  emplace(e53, t3, r, i) {
    let a = 2 * e53, n = 4 * e53;
    return this.uint32[a + 0] = t3, this.uint16[n + 2] = r, this.uint16[n + 3] = i, e53;
  }
};
q(ih, "StructArrayLayout1ul2ui8");
var pa = ih;
pa.prototype.bytesPerElement = 8, G("StructArrayLayout1ul2ui8", pa);
var nh = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3) {
    let r = this.length;
    return this.resize(r + 1), this.emplace(r, e53, t3);
  }
  emplace(e53, t3, r) {
    let i = 2 * e53;
    return this.uint16[i + 0] = t3, this.uint16[i + 1] = r, e53;
  }
};
q(nh, "StructArrayLayout2ui4");
var ha = nh;
ha.prototype.bytesPerElement = 4, G("StructArrayLayout2ui4", ha);
var ah = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
  }
  emplaceBack(e53) {
    let t3 = this.length;
    return this.resize(t3 + 1), this.emplace(t3, e53);
  }
  emplace(e53, t3) {
    let r = 1 * e53;
    return this.uint16[r + 0] = t3, e53;
  }
};
q(ah, "StructArrayLayout1ui2");
var fa = ah;
fa.prototype.bytesPerElement = 2, G("StructArrayLayout1ui2", fa);
var oh = class extends Ve {
  _refreshViews() {
    this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
  }
  emplaceBack(e53, t3, r, i) {
    let a = this.length;
    return this.resize(a + 1), this.emplace(a, e53, t3, r, i);
  }
  emplace(e53, t3, r, i, a) {
    let n = 4 * e53;
    return this.float32[n + 0] = t3, this.float32[n + 1] = r, this.float32[n + 2] = i, this.float32[n + 3] = a, e53;
  }
};
q(oh, "StructArrayLayout4f16");
var $i = oh;
$i.prototype.bytesPerElement = 16, G("StructArrayLayout4f16", $i);
var sh = class extends ei {
  get anchorPointX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorPointY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get x1() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get y1() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get x2() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get y2() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get anchorPoint() {
    return new bx.default(this.anchorPointX, this.anchorPointY);
  }
};
q(sh, "CollisionBoxStruct");
var ms = sh;
ms.prototype.size = 20;
var lh = class extends aa {
  get(e53) {
    return new ms(this, e53);
  }
};
q(lh, "CollisionBoxArray");
var ma = lh;
G("CollisionBoxArray", ma);
var uh = class extends ei {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get glyphStartIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get numGlyphs() {
    return this._structArray.uint16[this._pos2 + 3];
  }
  get vertexStartIndex() {
    return this._structArray.uint32[this._pos4 + 2];
  }
  get lineStartIndex() {
    return this._structArray.uint32[this._pos4 + 3];
  }
  get lineLength() {
    return this._structArray.uint32[this._pos4 + 4];
  }
  get segment() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get lowerSize() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get upperSize() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get lineOffsetX() {
    return this._structArray.float32[this._pos4 + 7];
  }
  get lineOffsetY() {
    return this._structArray.float32[this._pos4 + 8];
  }
  get writingMode() {
    return this._structArray.uint8[this._pos1 + 36];
  }
  get placedOrientation() {
    return this._structArray.uint8[this._pos1 + 37];
  }
  set placedOrientation(e53) {
    this._structArray.uint8[this._pos1 + 37] = e53;
  }
  get hidden() {
    return this._structArray.uint8[this._pos1 + 38];
  }
  set hidden(e53) {
    this._structArray.uint8[this._pos1 + 38] = e53;
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 10];
  }
  set crossTileID(e53) {
    this._structArray.uint32[this._pos4 + 10] = e53;
  }
  get associatedIconIndex() {
    return this._structArray.int16[this._pos2 + 22];
  }
};
q(uh, "PlacedSymbolStruct");
var ds = uh;
ds.prototype.size = 48;
var ch = class extends ua {
  get(e53) {
    return new ds(this, e53);
  }
};
q(ch, "PlacedSymbolArray");
var da = ch;
G("PlacedSymbolArray", da);
var ph = class extends ei {
  get anchorX() {
    return this._structArray.int16[this._pos2 + 0];
  }
  get anchorY() {
    return this._structArray.int16[this._pos2 + 1];
  }
  get rightJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 2];
  }
  get centerJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 3];
  }
  get leftJustifiedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 4];
  }
  get verticalPlacedTextSymbolIndex() {
    return this._structArray.int16[this._pos2 + 5];
  }
  get placedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 6];
  }
  get verticalPlacedIconSymbolIndex() {
    return this._structArray.int16[this._pos2 + 7];
  }
  get key() {
    return this._structArray.uint16[this._pos2 + 8];
  }
  get textBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 9];
  }
  get textBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 10];
  }
  get verticalTextBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 11];
  }
  get verticalTextBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 12];
  }
  get iconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 13];
  }
  get iconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 14];
  }
  get verticalIconBoxStartIndex() {
    return this._structArray.uint16[this._pos2 + 15];
  }
  get verticalIconBoxEndIndex() {
    return this._structArray.uint16[this._pos2 + 16];
  }
  get featureIndex() {
    return this._structArray.uint16[this._pos2 + 17];
  }
  get numHorizontalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 18];
  }
  get numVerticalGlyphVertices() {
    return this._structArray.uint16[this._pos2 + 19];
  }
  get numIconVertices() {
    return this._structArray.uint16[this._pos2 + 20];
  }
  get numVerticalIconVertices() {
    return this._structArray.uint16[this._pos2 + 21];
  }
  get useRuntimeCollisionCircles() {
    return this._structArray.uint16[this._pos2 + 22];
  }
  get crossTileID() {
    return this._structArray.uint32[this._pos4 + 12];
  }
  set crossTileID(e53) {
    this._structArray.uint32[this._pos4 + 12] = e53;
  }
  get textBoxScale() {
    return this._structArray.float32[this._pos4 + 13];
  }
  get textOffset0() {
    return this._structArray.float32[this._pos4 + 14];
  }
  get textOffset1() {
    return this._structArray.float32[this._pos4 + 15];
  }
  get collisionCircleDiameter() {
    return this._structArray.float32[this._pos4 + 16];
  }
};
q(ph, "SymbolInstanceStruct");
var ys = ph;
ys.prototype.size = 68;
var hh = class extends ca {
  get(e53) {
    return new ys(this, e53);
  }
};
q(hh, "SymbolInstanceArray");
var ya = hh;
G("SymbolInstanceArray", ya);
var fh = class extends ri {
  getoffsetX(e53) {
    return this.float32[1 * e53 + 0];
  }
};
q(fh, "GlyphOffsetArray");
var ga = fh;
G("GlyphOffsetArray", ga);
var mh = class extends qi {
  getx(e53) {
    return this.int16[3 * e53 + 0];
  }
  gety(e53) {
    return this.int16[3 * e53 + 1];
  }
  gettileUnitDistanceFromAnchor(e53) {
    return this.int16[3 * e53 + 2];
  }
};
q(mh, "SymbolLineVertexArray");
var xa = mh;
G("SymbolLineVertexArray", xa);
var dh = class extends ei {
  get featureIndex() {
    return this._structArray.uint32[this._pos4 + 0];
  }
  get sourceLayerIndex() {
    return this._structArray.uint16[this._pos2 + 2];
  }
  get bucketIndex() {
    return this._structArray.uint16[this._pos2 + 3];
  }
};
q(dh, "FeatureIndexStruct");
var gs = dh;
gs.prototype.size = 8;
var yh = class extends pa {
  get(e53) {
    return new gs(this, e53);
  }
};
q(yh, "FeatureIndexArray");
var ba = yh;
G("FeatureIndexArray", ba);
var gh = class extends ti {
};
q(gh, "PosArray");
var Pr = gh;
var xh = class extends qi {
};
q(xh, "Pos3dArray");
var xs = xh;
var bh = class extends Jn {
};
q(bh, "RasterBoundsArray");
var Hi = bh;
var _h = class extends ti {
};
q(_h, "CircleLayoutArray");
var bs = _h;
var vh = class extends ti {
};
q(vh, "FillLayoutArray");
var _s = vh;
var wh = class extends Qn {
};
q(wh, "FillExtrusionLayoutArray");
var vs = wh;
var Sh = class extends ea {
};
q(Sh, "LineLayoutArray");
var ws = Sh;
var Ph = class extends Sr {
};
q(Ph, "LineExtLayoutArray");
var Ss = Ph;
var Th = class extends ta {
};
q(Th, "PatternLayoutArray");
var ir = Th;
var Ah = class extends ra {
};
q(Ah, "SymbolLayoutArray");
var Ps = Ah;
var Ih = class extends ia {
};
q(Ih, "SymbolDynamicLayoutArray");
var Ts = Ih;
var Mh = class extends na {
};
q(Mh, "SymbolOpacityArray");
var As = Mh;
var Ch = class extends oa {
};
q(Ch, "CollisionBoxLayoutArray");
var _a = Ch;
var Eh = class extends sa {
};
q(Eh, "CollisionCircleLayoutArray");
var Is = Eh;
var kh = class extends la {
};
q(kh, "CollisionVertexArray");
var Ms = kh;
var Lh = class extends ji {
};
q(Lh, "QuadTriangleArray");
var Cs = Lh;
var Dh = class extends ji {
};
q(Dh, "TriangleIndexArray");
var nt = Dh;
var zh = class extends ha {
};
q(zh, "LineIndexArray");
var Tr = zh;
var Fh = class extends fa {
};
q(Fh, "LineStripIndexArray");
var va = Fh;
c();
var TS = ve([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: _x, size: TL, alignment: AL } = TS;
c();
var ii = class e33 {
  constructor(e53 = []) {
    this.segments = e53;
  }
  prepareSegment(t3, r, i, a) {
    let n = this.segments[this.segments.length - 1];
    return t3 > e33.MAX_VERTEX_ARRAY_LENGTH && Ce("Max vertices per segment is ".concat(e33.MAX_VERTEX_ARRAY_LENGTH, ": bucket requested ").concat(t3)), (!n || n.vertexLength + t3 > e33.MAX_VERTEX_ARRAY_LENGTH || n.sortKey !== a) && (n = { vertexOffset: r.length, primitiveOffset: i.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== a && (n.sortKey = a), this.segments.push(n)), n;
  }
  get() {
    return this.segments;
  }
  destroy() {
    for (let e53 of this.segments)
      for (let t3 in e53.vaos)
        e53.vaos[t3].destroy();
  }
  static simpleSegment(t3, r, i, a) {
    return new e33([{ vertexOffset: t3, primitiveOffset: r, vertexLength: i, primitiveLength: a, vaos: {}, sortKey: 0 }]);
  }
};
q(ii, "SegmentVector");
var me = ii;
function Bh(e53, t3) {
  return 256 * (e53 = Te(Math.floor(e53), 0, 255)) + (t3 = Te(Math.floor(t3), 0, 255));
}
me.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, G("SegmentVector", me), c(), c(), q(Bh, "packUint8ToFloat"), c();
var wa = ve([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
c();
var Tx = u(Vh(), 1);
var Ls = class e34 {
  constructor() {
    this.ids = [], this.positions = [], this.indexed = false;
  }
  add(e53, t3, r, i) {
    this.ids.push(Px(e53)), this.positions.push(t3, r, i);
  }
  getPositions(e53) {
    if (!this.indexed)
      throw new Error("Trying to get index, but feature positions are not indexed");
    let t3 = Px(e53), r = 0, i = this.ids.length - 1;
    for (; r < i; ) {
      let e54 = r + i >> 1;
      this.ids[e54] >= t3 ? i = e54 : r = e54 + 1;
    }
    let a = [];
    for (; this.ids[r] === t3; ) {
      let e54 = this.positions[3 * r], t4 = this.positions[3 * r + 1], i3 = this.positions[3 * r + 2];
      a.push({ index: e54, start: t4, end: i3 }), r++;
    }
    return a;
  }
  static serialize(e53, t3) {
    let r = new Float64Array(e53.ids), i = new Uint32Array(e53.positions);
    return Uh(r, i, 0, r.length - 1), t3 && t3.push(r.buffer, i.buffer), { ids: r, positions: i };
  }
  static deserialize(t3) {
    let r = new e34();
    return r.ids = t3.ids, r.positions = t3.positions, r.indexed = true, r;
  }
};
q(Ls, "FeaturePositionMap");
var Sa = Ls;
function Px(e53) {
  let t3 = +e53;
  return !isNaN(t3) && t3 <= Number.MAX_SAFE_INTEGER ? t3 : (0, Tx.default)(String(e53));
}
function Uh(e53, t3, r, i) {
  for (; r < i; ) {
    let a = e53[r + i >> 1], n = r - 1, s3 = i + 1;
    for (; ; ) {
      do {
        n++;
      } while (e53[n] < a);
      do {
        s3--;
      } while (e53[s3] > a);
      if (n >= s3)
        break;
      ks(e53, n, s3), ks(t3, 3 * n, 3 * s3), ks(t3, 3 * n + 1, 3 * s3 + 1), ks(t3, 3 * n + 2, 3 * s3 + 2);
    }
    s3 - r < i - s3 ? (Uh(e53, t3, r, s3), r = s3 + 1) : (Uh(e53, t3, s3 + 1, i), i = s3);
  }
}
function ks(e53, t3, r) {
  let i = e53[t3];
  e53[t3] = e53[r], e53[r] = i;
}
q(Px, "getNumericId"), q(Uh, "sort"), q(ks, "swap"), G("FeaturePositionMap", Sa), c();
var Nh = class {
  constructor(e53, t3) {
    this.gl = e53.gl, this.location = t3;
  }
};
q(Nh, "Uniform");
var nr = Nh;
var Gh = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = 0;
  }
  set(e53) {
    this.current !== e53 && (this.current = e53, this.gl.uniform1i(this.location, e53));
  }
};
q(Gh, "Uniform1i");
var Y = Gh;
var qh = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = 0;
  }
  set(e53) {
    this.current !== e53 && (this.current = e53, this.gl.uniform1f(this.location, e53));
  }
};
q(qh, "Uniform1f");
var U = qh;
var jh = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = [0, 0];
  }
  set(e53) {
    (e53[0] !== this.current[0] || e53[1] !== this.current[1]) && (this.current = e53, this.gl.uniform2f(this.location, e53[0], e53[1]));
  }
};
q(jh, "Uniform2f");
var ee = jh;
var $h = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = [0, 0, 0];
  }
  set(e53) {
    (e53[0] !== this.current[0] || e53[1] !== this.current[1] || e53[2] !== this.current[2]) && (this.current = e53, this.gl.uniform3f(this.location, e53[0], e53[1], e53[2]));
  }
};
q($h, "Uniform3f");
var st = $h;
var Hh = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = [0, 0, 0, 0];
  }
  set(e53) {
    (e53[0] !== this.current[0] || e53[1] !== this.current[1] || e53[2] !== this.current[2] || e53[3] !== this.current[3]) && (this.current = e53, this.gl.uniform4f(this.location, e53[0], e53[1], e53[2], e53[3]));
  }
};
q(Hh, "Uniform4f");
var Ar = Hh;
var Zh = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = K.transparent;
  }
  set(e53) {
    (e53.r !== this.current.r || e53.g !== this.current.g || e53.b !== this.current.b || e53.a !== this.current.a) && (this.current = e53, this.gl.uniform4f(this.location, e53.r, e53.g, e53.b, e53.a));
  }
};
q(Zh, "UniformColor");
var Dt = Zh;
var CS = new Float32Array(16);
var Wh = class extends nr {
  constructor(e53, t3) {
    super(e53, t3), this.current = CS;
  }
  set(e53) {
    if (e53[12] !== this.current[12] || e53[0] !== this.current[0])
      return this.current = e53, void this.gl.uniformMatrix4fv(this.location, false, e53);
    for (let t3 = 1; t3 < 16; t3++)
      if (e53[t3] !== this.current[t3]) {
        this.current = e53, this.gl.uniformMatrix4fv(this.location, false, e53);
        break;
      }
  }
};
q(Wh, "UniformMatrix4f");
var te = Wh;
function Xh(e53) {
  return [Bh(255 * e53.r, 255 * e53.g), Bh(255 * e53.b, 255 * e53.a)];
}
q(Xh, "packColor");
var Kh = class {
  constructor(e53, t3, r) {
    this.value = e53, this.uniformNames = t3.map((e54) => "u_".concat(e54)), this.type = r;
  }
  setUniform(e53, t3, r) {
    e53.set(r.constantOr(this.value));
  }
  getBinding(e53, t3, r) {
    return "color" === this.type ? new Dt(e53, t3) : new U(e53, t3);
  }
};
q(Kh, "ConstantBinder");
var ni = Kh;
var Yh = class {
  constructor(e53, t3) {
    this.uniformNames = t3.map((e54) => "u_".concat(e54)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
  }
  setConstantPatternPositions(e53, t3) {
    this.pixelRatioFrom = t3.pixelRatio, this.pixelRatioTo = e53.pixelRatio, this.patternFrom = t3.tlbr, this.patternTo = e53.tlbr;
  }
  setUniform(e53, t3, r, i) {
    let a = "u_pattern_to" === i ? this.patternTo : "u_pattern_from" === i ? this.patternFrom : "u_pixel_ratio_to" === i ? this.pixelRatioTo : "u_pixel_ratio_from" === i ? this.pixelRatioFrom : null;
    a && e53.set(a);
  }
  getBinding(e53, t3, r) {
    return "u_pattern" === r.substr(0, 9) ? new Ar(e53, t3) : new U(e53, t3);
  }
};
q(Yh, "CrossFadedConstantBinder");
var Ir = Yh;
var Jh = class {
  constructor(e53, t3, r, i) {
    this.expression = e53, this.type = r, this.maxValue = 0, this.paintVertexAttributes = t3.map((e54) => ({ name: "a_".concat(e54), type: "Float32", components: "color" === r ? 2 : 1, offset: 0 })), this.paintVertexArray = new i();
  }
  populatePaintArray(e53, t3, r, i, a) {
    let n = this.paintVertexArray.length, s3 = this.expression.evaluate(new ye(0), t3, {}, i, [], a);
    this.paintVertexArray.resize(e53), this._setPaintValue(n, e53, s3);
  }
  updatePaintArray(e53, t3, r, i) {
    let a = this.expression.evaluate({ zoom: 0 }, r, i);
    this._setPaintValue(e53, t3, a);
  }
  _setPaintValue(e53, t3, r) {
    if ("color" === this.type) {
      let i = Xh(r);
      for (let r3 = e53; r3 < t3; r3++)
        this.paintVertexArray.emplace(r3, i[0], i[1]);
    } else {
      for (let i = e53; i < t3; i++)
        this.paintVertexArray.emplace(i, r);
      this.maxValue = Math.max(this.maxValue, Math.abs(r));
    }
  }
  upload(e53) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e53.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
};
q(Jh, "SourceExpressionBinder");
var Nt = Jh;
var Qh = class {
  constructor(e53, t3, r, i, a, n) {
    this.expression = e53, this.uniformNames = t3.map((e54) => "u_".concat(e54, "_t")), this.type = r, this.useIntegerZoom = i, this.zoom = a, this.maxValue = 0, this.paintVertexAttributes = t3.map((e54) => ({ name: "a_".concat(e54), type: "Float32", components: "color" === r ? 4 : 2, offset: 0 })), this.paintVertexArray = new n();
  }
  populatePaintArray(e53, t3, r, i, a) {
    let n = this.expression.evaluate(new ye(this.zoom), t3, {}, i, [], a), s3 = this.expression.evaluate(new ye(this.zoom + 1), t3, {}, i, [], a), o = this.paintVertexArray.length;
    this.paintVertexArray.resize(e53), this._setPaintValue(o, e53, n, s3);
  }
  updatePaintArray(e53, t3, r, i) {
    let a = this.expression.evaluate({ zoom: this.zoom }, r, i), n = this.expression.evaluate({ zoom: this.zoom + 1 }, r, i);
    this._setPaintValue(e53, t3, a, n);
  }
  _setPaintValue(e53, t3, r, i) {
    if ("color" === this.type) {
      let a = Xh(r), n = Xh(i);
      for (let r3 = e53; r3 < t3; r3++)
        this.paintVertexArray.emplace(r3, a[0], a[1], n[0], n[1]);
    } else {
      for (let a = e53; a < t3; a++)
        this.paintVertexArray.emplace(a, r, i);
      this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(i));
    }
  }
  upload(e53) {
    this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e53.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
  }
  destroy() {
    this.paintVertexBuffer && this.paintVertexBuffer.destroy();
  }
  setUniform(e53, t3) {
    let r = this.useIntegerZoom ? Math.floor(t3.zoom) : t3.zoom, i = Te(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1);
    e53.set(i);
  }
  getBinding(e53, t3, r) {
    return new U(e53, t3);
  }
};
q(Qh, "CompositeExpressionBinder");
var Pt = Qh;
var ef = class {
  constructor(e53, t3, r, i, a, n) {
    this.expression = e53, this.type = t3, this.useIntegerZoom = r, this.zoom = i, this.layerId = n, this.zoomInPaintVertexArray = new a(), this.zoomOutPaintVertexArray = new a();
  }
  populatePaintArray(e53, t3, r) {
    let i = this.zoomInPaintVertexArray.length;
    this.zoomInPaintVertexArray.resize(e53), this.zoomOutPaintVertexArray.resize(e53), this._setPaintValues(i, e53, t3.patterns && t3.patterns[this.layerId], r);
  }
  updatePaintArray(e53, t3, r, i, a) {
    this._setPaintValues(e53, t3, r.patterns && r.patterns[this.layerId], a);
  }
  _setPaintValues(e53, t3, r, i) {
    if (!i || !r)
      return;
    let { min: a, mid: n, max: s3 } = r, o = i[a], l = i[n], u3 = i[s3];
    if (o && l && u3)
      for (let r3 = e53; r3 < t3; r3++)
        this.zoomInPaintVertexArray.emplace(r3, l.tl[0], l.tl[1], l.br[0], l.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], l.pixelRatio, o.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l.tl[0], l.tl[1], l.br[0], l.br[1], u3.tl[0], u3.tl[1], u3.br[0], u3.br[1], l.pixelRatio, u3.pixelRatio);
  }
  upload(e53) {
    this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = e53.createVertexBuffer(this.zoomInPaintVertexArray, wa.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e53.createVertexBuffer(this.zoomOutPaintVertexArray, wa.members, this.expression.isStateDependent));
  }
  destroy() {
    this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
  }
};
q(ef, "CrossFadedCompositeBinder");
var jt = ef;
var tf = class {
  constructor(e53, t3, r) {
    this.binders = {}, this._buffers = [];
    let i = [];
    for (let a in e53.paint._values) {
      if (!r(a))
        continue;
      let n = e53.paint.get(a);
      if (!(n instanceof at && gr(n.property.specification)))
        continue;
      let s3 = ES(a, e53.type), o = n.value, l = n.property.specification.type, u3 = n.property.useIntegerZoom, c3 = n.property.specification["property-type"], h = "cross-faded" === c3 || "cross-faded-data-driven" === c3;
      if ("constant" === o.kind)
        this.binders[a] = h ? new Ir(o.value, s3) : new ni(o.value, s3, l), i.push("/u_".concat(a));
      else if ("source" === o.kind || h) {
        let r3 = Ax(a, l, "source");
        this.binders[a] = h ? new jt(o, l, u3, t3, r3, e53.id) : new Nt(o, s3, l, r3), i.push("/a_".concat(a));
      } else {
        let e54 = Ax(a, l, "composite");
        this.binders[a] = new Pt(o, s3, l, u3, t3, e54), i.push("/z_".concat(a));
      }
    }
    this.cacheKey = i.sort().join("");
  }
  getMaxValue(e53) {
    let t3 = this.binders[e53];
    return t3 instanceof Nt || t3 instanceof Pt ? t3.maxValue : 0;
  }
  populatePaintArrays(e53, t3, r, i, a) {
    for (let n in this.binders) {
      let s3 = this.binders[n];
      (s3 instanceof Nt || s3 instanceof Pt || s3 instanceof jt) && s3.populatePaintArray(e53, t3, r, i, a);
    }
  }
  setConstantPatternPositions(e53, t3) {
    for (let r in this.binders) {
      let i = this.binders[r];
      i instanceof Ir && i.setConstantPatternPositions(e53, t3);
    }
  }
  updatePaintArrays(e53, t3, r, i, a) {
    let n = false;
    for (let s3 in e53) {
      let o = t3.getPositions(s3);
      for (let t4 of o) {
        let o3 = r.feature(t4.index);
        for (let r3 in this.binders) {
          let l = this.binders[r3];
          if ((l instanceof Nt || l instanceof Pt || l instanceof jt) && true === l.expression.isStateDependent) {
            let u3 = i.paint.get(r3);
            l.expression = u3.value, l.updatePaintArray(t4.start, t4.end, o3, e53[s3], a), n = true;
          }
        }
      }
    }
    return n;
  }
  defines() {
    let e53 = [];
    for (let t3 in this.binders) {
      let r = this.binders[t3];
      (r instanceof ni || r instanceof Ir) && e53.push(...r.uniformNames.map((e54) => "#define HAS_UNIFORM_".concat(e54)));
    }
    return e53;
  }
  getBinderAttributes() {
    let e53 = [];
    for (let t3 in this.binders) {
      let r = this.binders[t3];
      if (r instanceof Nt || r instanceof Pt)
        for (let t4 = 0; t4 < r.paintVertexAttributes.length; t4++)
          e53.push(r.paintVertexAttributes[t4].name);
      else if (r instanceof jt)
        for (let t4 = 0; t4 < wa.members.length; t4++)
          e53.push(wa.members[t4].name);
    }
    return e53;
  }
  getBinderUniforms() {
    let e53 = [];
    for (let t3 in this.binders) {
      let r = this.binders[t3];
      if (r instanceof ni || r instanceof Ir || r instanceof Pt)
        for (let t4 of r.uniformNames)
          e53.push(t4);
    }
    return e53;
  }
  getPaintVertexBuffers() {
    return this._buffers;
  }
  getUniforms(e53, t3) {
    let r = [];
    for (let i in this.binders) {
      let a = this.binders[i];
      if (a instanceof ni || a instanceof Ir || a instanceof Pt) {
        for (let n of a.uniformNames)
          if (t3[n]) {
            let s3 = a.getBinding(e53, t3[n], n);
            r.push({ name: n, property: i, binding: s3 });
          }
      }
    }
    return r;
  }
  setUniforms(e53, t3, r, i) {
    for (let { name: e54, property: a, binding: n } of t3)
      this.binders[a].setUniform(n, i, r.get(a), e54);
  }
  updatePaintBuffers(e53) {
    this._buffers = [];
    for (let t3 in this.binders) {
      let r = this.binders[t3];
      if (e53 && r instanceof jt) {
        let t4 = 2 === e53.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer;
        t4 && this._buffers.push(t4);
      } else
        (r instanceof Nt || r instanceof Pt) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);
    }
  }
  upload(e53) {
    for (let t3 in this.binders) {
      let r = this.binders[t3];
      (r instanceof Nt || r instanceof Pt || r instanceof jt) && r.upload(e53);
    }
    this.updatePaintBuffers();
  }
  destroy() {
    for (let e53 in this.binders) {
      let t3 = this.binders[e53];
      (t3 instanceof Nt || t3 instanceof Pt || t3 instanceof jt) && t3.destroy();
    }
  }
};
q(tf, "ProgramConfiguration");
var Ds = tf;
var rf = class {
  constructor(e53, t3, r = () => true) {
    this.programConfigurations = {};
    for (let i of e53)
      this.programConfigurations[i.id] = new Ds(i, t3, r);
    this.needsUpload = false, this._featureMap = new Sa(), this._bufferOffset = 0;
  }
  populatePaintArrays(e53, t3, r, i, a, n) {
    for (let r3 in this.programConfigurations)
      this.programConfigurations[r3].populatePaintArrays(e53, t3, i, a, n);
    void 0 !== t3.id && this._featureMap.add(t3.id, r, this._bufferOffset, e53), this._bufferOffset = e53, this.needsUpload = true;
  }
  updatePaintArrays(e53, t3, r, i) {
    for (let a of r)
      this.needsUpload = this.programConfigurations[a.id].updatePaintArrays(e53, this._featureMap, t3, a, i) || this.needsUpload;
  }
  get(e53) {
    return this.programConfigurations[e53];
  }
  upload(e53) {
    if (this.needsUpload) {
      for (let t3 in this.programConfigurations)
        this.programConfigurations[t3].upload(e53);
      this.needsUpload = false;
    }
  }
  destroy() {
    for (let e53 in this.programConfigurations)
      this.programConfigurations[e53].destroy();
  }
};
q(rf, "ProgramConfigurationSet");
var mt = rf;
function ES(e53, t3) {
  return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[e53] || [e53.replace("".concat(t3, "-"), "").replace(/-/g, "_")];
}
function kS(e53) {
  return { "line-pattern": { source: ir, composite: ir }, "fill-pattern": { source: ir, composite: ir }, "fill-extrusion-pattern": { source: ir, composite: ir } }[e53];
}
function Ax(e53, t3, r) {
  let i = { color: { source: Sr, composite: $i }, number: { source: ri, composite: Sr } }, a = kS(e53);
  return a && a[r] || i[t3][r];
}
q(ES, "paintAttributeNames"), q(kS, "getLayoutException"), q(Ax, "layoutType"), G("ConstantBinder", ni), G("CrossFadedConstantBinder", Ir), G("SourceExpressionBinder", Nt), G("CrossFadedCompositeBinder", jt), G("CompositeExpressionBinder", Pt), G("ProgramConfiguration", Ds, { omit: ["_buffers"] }), G("ProgramConfigurationSet", mt), c(), c(), c();
var LS = 15;
var nf = Math.pow(2, LS - 1) - 1;
var Ix = -nf - 1;
function dt(e53) {
  let t3 = 8192 / e53.extent, r = e53.loadGeometry();
  for (let e54 = 0; e54 < r.length; e54++) {
    let i = r[e54];
    for (let e55 = 0; e55 < i.length; e55++) {
      let r3 = i[e55], a = Math.round(r3.x * t3), n = Math.round(r3.y * t3);
      r3.x = Te(a, Ix, nf), r3.y = Te(n, Ix, nf), (a < r3.x || a > r3.x + 1 || n < r3.y || n > r3.y + 1) && Ce("Geometry exceeds allowed extent, reduce your vector tile buffer size");
    }
  }
  return r;
}
function yt(e53, t3) {
  return { type: e53.type, id: e53.id, properties: e53.properties, geometry: t3 ? dt(e53) : [] };
}
function zs(e53, t3, r, i, a) {
  e53.emplaceBack(2 * t3 + (i + 1) / 2, 2 * r + (a + 1) / 2);
}
q(dt, "loadGeometry"), c(), q(yt, "toEvaluationFeature"), q(zs, "addCircleVertex");
var af = class {
  constructor(e53) {
    this.zoom = e53.zoom, this.overscaling = e53.overscaling, this.layers = e53.layers, this.layerIds = this.layers.map((e54) => e54.id), this.index = e53.index, this.hasPattern = false, this.layoutVertexArray = new bs(), this.indexArray = new nt(), this.segments = new me(), this.programConfigurations = new mt(e53.layers, e53.zoom), this.stateDependentLayerIds = this.layers.filter((e54) => e54.isStateDependent()).map((e54) => e54.id);
  }
  populate(e53, t3, r) {
    let i = this.layers[0], a = [], n = null, s3 = false;
    "circle" === i.type && (n = i.layout.get("circle-sort-key"), s3 = !n.isConstant());
    for (let { feature: t4, id: i3, index: o, sourceLayerIndex: l } of e53) {
      let e54 = this.layers[0]._featureFilter.needGeometry, u3 = yt(t4, e54);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), u3, r))
        continue;
      let c3 = s3 ? n.evaluate(u3, {}, r) : void 0, h = { id: i3, properties: t4.properties, type: t4.type, sourceLayerIndex: l, index: o, geometry: e54 ? u3.geometry : dt(t4), patterns: {}, sortKey: c3 };
      a.push(h);
    }
    s3 && a.sort((e54, t4) => e54.sortKey - t4.sortKey);
    for (let i3 of a) {
      let { geometry: a3, index: n3, sourceLayerIndex: s4 } = i3, o = e53[n3].feature;
      this.addFeature(i3, a3, n3, r), t3.featureIndex.insert(o, a3, n3, s4, this.index);
    }
  }
  update(e53, t3, r) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e53, t3, this.stateDependentLayers, r);
  }
  isEmpty() {
    return 0 === this.layoutVertexArray.length;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e53) {
    this.uploaded || (this.layoutVertexBuffer = e53.createVertexBuffer(this.layoutVertexArray, _x), this.indexBuffer = e53.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e53), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  addFeature(e53, t3, r, i) {
    for (let r3 of t3)
      for (let t4 of r3) {
        let r4 = t4.x, i3 = t4.y;
        if (r4 < 0 || r4 >= 8192 || i3 < 0 || i3 >= 8192)
          continue;
        let a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e53.sortKey), n = a.vertexLength;
        zs(this.layoutVertexArray, r4, i3, -1, -1), zs(this.layoutVertexArray, r4, i3, 1, -1), zs(this.layoutVertexArray, r4, i3, 1, 1), zs(this.layoutVertexArray, r4, i3, -1, 1), this.indexArray.emplaceBack(n, n + 1, n + 2), this.indexArray.emplaceBack(n, n + 3, n + 2), a.vertexLength += 4, a.primitiveLength += 2;
      }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e53, r, {}, i);
  }
};
q(af, "CircleBucket");
var ai = af;
G("CircleBucket", ai, { omit: ["layers"] }), c();
var Pa = u(Pe(), 1);
function Fs(e53, t3) {
  for (let r = 0; r < e53.length; r++)
    if (Zi(t3, e53[r]))
      return true;
  for (let r = 0; r < t3.length; r++)
    if (Zi(e53, t3[r]))
      return true;
  return !!sf(e53, t3);
}
function Cx(e53, t3, r) {
  return !(!Zi(e53, t3) && !of(t3, e53, r));
}
function Bs(e53, t3) {
  if (1 === e53.length)
    return Mx(t3, e53[0]);
  for (let r = 0; r < t3.length; r++) {
    let i = t3[r];
    for (let t4 = 0; t4 < i.length; t4++)
      if (Zi(e53, i[t4]))
        return true;
  }
  for (let r = 0; r < e53.length; r++)
    if (Mx(t3, e53[r]))
      return true;
  for (let r = 0; r < t3.length; r++)
    if (sf(e53, t3[r]))
      return true;
  return false;
}
function Ex(e53, t3, r) {
  for (let i = 0; i < t3.length; i++) {
    let a = t3[i];
    if (e53.length >= 3) {
      for (let t4 = 0; t4 < a.length; t4++)
        if (Zi(e53, a[t4]))
          return true;
    }
    if (DS(e53, a, r))
      return true;
  }
  return false;
}
function DS(e53, t3, r) {
  if (e53.length > 1) {
    if (sf(e53, t3))
      return true;
    for (let i = 0; i < t3.length; i++)
      if (of(t3[i], e53, r))
        return true;
  }
  for (let i = 0; i < e53.length; i++)
    if (of(e53[i], t3, r))
      return true;
  return false;
}
function sf(e53, t3) {
  if (0 === e53.length || 0 === t3.length)
    return false;
  for (let r = 0; r < e53.length - 1; r++) {
    let i = e53[r], a = e53[r + 1];
    for (let e54 = 0; e54 < t3.length - 1; e54++) {
      if (zS(i, a, t3[e54], t3[e54 + 1]))
        return true;
    }
  }
  return false;
}
function zS(e53, t3, r, i) {
  return Jt(e53, r, i) !== Jt(t3, r, i) && Jt(e53, t3, r) !== Jt(e53, t3, i);
}
function of(e53, t3, r) {
  let i = r * r;
  if (1 === t3.length)
    return e53.distSqr(t3[0]) < i;
  for (let r3 = 1; r3 < t3.length; r3++) {
    if (kx(e53, t3[r3 - 1], t3[r3]) < i)
      return true;
  }
  return false;
}
function kx(e53, t3, r) {
  let i = t3.distSqr(r);
  if (0 === i)
    return e53.distSqr(t3);
  let a = ((e53.x - t3.x) * (r.x - t3.x) + (e53.y - t3.y) * (r.y - t3.y)) / i;
  return a < 0 ? e53.distSqr(t3) : a > 1 ? e53.distSqr(r) : e53.distSqr(r.sub(t3)._mult(a)._add(t3));
}
function Mx(e53, t3) {
  let r, i, a, n = false;
  for (let s3 = 0; s3 < e53.length; s3++) {
    r = e53[s3];
    for (let e54 = 0, s4 = r.length - 1; e54 < r.length; s4 = e54++)
      i = r[e54], a = r[s4], i.y > t3.y != a.y > t3.y && t3.x < (a.x - i.x) * (t3.y - i.y) / (a.y - i.y) + i.x && (n = !n);
  }
  return n;
}
function Zi(e53, t3) {
  let r = false;
  for (let i = 0, a = e53.length - 1; i < e53.length; a = i++) {
    let n = e53[i], s3 = e53[a];
    n.y > t3.y != s3.y > t3.y && t3.x < (s3.x - n.x) * (t3.y - n.y) / (s3.y - n.y) + n.x && (r = !r);
  }
  return r;
}
function Lx(e53, t3, r, i, a) {
  for (let n3 of e53)
    if (t3 <= n3.x && r <= n3.y && i >= n3.x && a >= n3.y)
      return true;
  let n = [new Pa.default(t3, r), new Pa.default(t3, a), new Pa.default(i, a), new Pa.default(i, r)];
  if (e53.length > 2) {
    for (let t4 of n)
      if (Zi(e53, t4))
        return true;
  }
  for (let t4 = 0; t4 < e53.length - 1; t4++) {
    if (FS(e53[t4], e53[t4 + 1], n))
      return true;
  }
  return false;
}
function FS(e53, t3, r) {
  let i = r[0], a = r[2];
  if (e53.x < i.x && t3.x < i.x || e53.x > a.x && t3.x > a.x || e53.y < i.y && t3.y < i.y || e53.y > a.y && t3.y > a.y)
    return false;
  let n = Jt(e53, t3, r[0]);
  return n !== Jt(e53, t3, r[1]) || n !== Jt(e53, t3, r[2]) || n !== Jt(e53, t3, r[3]);
}
q(Fs, "polygonIntersectsPolygon"), q(Cx, "polygonIntersectsBufferedPoint"), q(Bs, "polygonIntersectsMultiPolygon"), q(Ex, "polygonIntersectsBufferedMultiLine"), q(DS, "lineIntersectsBufferedLine"), q(sf, "lineIntersectsLine"), q(zS, "lineSegmentIntersectsLineSegment"), q(of, "pointIntersectsBufferedLine"), q(kx, "distToSegmentSquared"), q(Mx, "multiPolygonContainsPoint"), q(Zi, "polygonContainsPoint"), q(Lx, "polygonIntersectsBox"), q(FS, "edgeIntersectsBox"), c();
var Rs = u(Pe(), 1);
function oi(e53, t3, r) {
  let i = t3.paint.get(e53).value;
  return "constant" === i.kind ? i.value : r.programConfigurations.get(t3.id).getMaxValue(e53);
}
function Mr(e53) {
  return Math.sqrt(e53[0] * e53[0] + e53[1] * e53[1]);
}
function Cr(e53, t3, r, i, a) {
  if (!t3[0] && !t3[1])
    return e53;
  let n = Rs.default.convert(t3)._mult(a);
  "viewport" === r && n._rotate(-i);
  let s3 = [];
  for (let t4 = 0; t4 < e53.length; t4++) {
    let r3 = e53[t4];
    s3.push(r3.sub(n));
  }
  return s3;
}
function Dx(e53, t3) {
  let r = [];
  for (let i = 0; i < e53.length; i++) {
    let a = e53[i], n = [];
    for (let e54 = 0; e54 < a.length; e54++) {
      let r3 = a[e54 - 1], i3 = a[e54], s3 = a[e54 + 1], o = 0 === e54 ? new Rs.default(0, 0) : i3.sub(r3)._unit()._perp(), l = e54 === a.length - 1 ? new Rs.default(0, 0) : s3.sub(i3)._unit()._perp(), u3 = o._add(l)._unit(), c3 = u3.x * l.x + u3.y * l.y;
      0 !== c3 && u3._mult(1 / c3), n.push(u3._mult(t3)._add(i3));
    }
    r.push(n);
  }
  return r;
}
q(oi, "getMaximumPaintValue"), q(Mr, "translateDistance"), q(Cr, "translate"), q(Dx, "offsetLine"), c();
var zx;
var Fx;
var RS = q(() => zx = zx || new Re({ "circle-sort-key": new W(M.layout_circle["circle-sort-key"]) }), "getLayout");
var OS = q(() => Fx = Fx || new Re({ "circle-radius": new W(M.paint_circle["circle-radius"]), "circle-color": new W(M.paint_circle["circle-color"]), "circle-blur": new W(M.paint_circle["circle-blur"]), "circle-opacity": new W(M.paint_circle["circle-opacity"]), "circle-translate": new $(M.paint_circle["circle-translate"]), "circle-translate-anchor": new $(M.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new $(M.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new $(M.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new W(M.paint_circle["circle-stroke-width"]), "circle-stroke-color": new W(M.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new W(M.paint_circle["circle-stroke-opacity"]) }), "getPaint");
var Bx = { get paint() {
  return OS();
}, get layout() {
  return RS();
} };
c(), c();
var ie = 1e-6;
var we = typeof Float32Array < "u" ? Float32Array : Array;
var $t = Math.random;
var sz = Math.PI / 180;
Math.hypot || (Math.hypot = function() {
  for (var e53 = 0, t3 = arguments.length; t3--; )
    e53 += arguments[t3] * arguments[t3];
  return Math.sqrt(e53);
});
var Ta = {};
function VS() {
  var e53 = new we(4);
  return we != Float32Array && (e53[1] = 0, e53[2] = 0), e53[0] = 1, e53[3] = 1, e53;
}
function US(e53) {
  var t3 = new we(4);
  return t3[0] = e53[0], t3[1] = e53[1], t3[2] = e53[2], t3[3] = e53[3], t3;
}
function NS(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53[3] = t3[3], e53;
}
function GS(e53) {
  return e53[0] = 1, e53[1] = 0, e53[2] = 0, e53[3] = 1, e53;
}
function qS(e53, t3, r, i) {
  var a = new we(4);
  return a[0] = e53, a[1] = t3, a[2] = r, a[3] = i, a;
}
function jS(e53, t3, r, i, a) {
  return e53[0] = t3, e53[1] = r, e53[2] = i, e53[3] = a, e53;
}
function $S(e53, t3) {
  if (e53 === t3) {
    var r = t3[1];
    e53[1] = t3[2], e53[2] = r;
  } else
    e53[0] = t3[0], e53[1] = t3[2], e53[2] = t3[1], e53[3] = t3[3];
  return e53;
}
function HS(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = r * n - a * i;
  return s3 ? (s3 = 1 / s3, e53[0] = n * s3, e53[1] = -i * s3, e53[2] = -a * s3, e53[3] = r * s3, e53) : null;
}
function ZS(e53, t3) {
  var r = t3[0];
  return e53[0] = t3[3], e53[1] = -t3[1], e53[2] = -t3[2], e53[3] = r, e53;
}
function WS(e53) {
  return e53[0] * e53[3] - e53[2] * e53[1];
}
function Rx(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = r[0], l = r[1], u3 = r[2], c3 = r[3];
  return e53[0] = i * o + n * l, e53[1] = a * o + s3 * l, e53[2] = i * u3 + n * c3, e53[3] = a * u3 + s3 * c3, e53;
}
function XS(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = Math.sin(r), l = Math.cos(r);
  return e53[0] = i * l + n * o, e53[1] = a * l + s3 * o, e53[2] = i * -o + n * l, e53[3] = a * -o + s3 * l, e53;
}
function KS(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = r[0], l = r[1];
  return e53[0] = i * o, e53[1] = a * o, e53[2] = n * l, e53[3] = s3 * l, e53;
}
function YS(e53, t3) {
  var r = Math.sin(t3), i = Math.cos(t3);
  return e53[0] = i, e53[1] = r, e53[2] = -r, e53[3] = i, e53;
}
function JS(e53, t3) {
  return e53[0] = t3[0], e53[1] = 0, e53[2] = 0, e53[3] = t3[1], e53;
}
function QS(e53) {
  return "mat2(" + e53[0] + ", " + e53[1] + ", " + e53[2] + ", " + e53[3] + ")";
}
function eP(e53) {
  return Math.hypot(e53[0], e53[1], e53[2], e53[3]);
}
function tP(e53, t3, r, i) {
  return e53[2] = i[2] / i[0], r[0] = i[0], r[1] = i[1], r[3] = i[3] - e53[2] * r[1], [e53, t3, r];
}
function rP(e53, t3, r) {
  return e53[0] = t3[0] + r[0], e53[1] = t3[1] + r[1], e53[2] = t3[2] + r[2], e53[3] = t3[3] + r[3], e53;
}
function Ox(e53, t3, r) {
  return e53[0] = t3[0] - r[0], e53[1] = t3[1] - r[1], e53[2] = t3[2] - r[2], e53[3] = t3[3] - r[3], e53;
}
function iP(e53, t3) {
  return e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && e53[3] === t3[3];
}
function nP(e53, t3) {
  var r = e53[0], i = e53[1], a = e53[2], n = e53[3], s3 = t3[0], o = t3[1], l = t3[2], u3 = t3[3];
  return Math.abs(r - s3) <= ie * Math.max(1, Math.abs(r), Math.abs(s3)) && Math.abs(i - o) <= ie * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(a - l) <= ie * Math.max(1, Math.abs(a), Math.abs(l)) && Math.abs(n - u3) <= ie * Math.max(1, Math.abs(n), Math.abs(u3));
}
function aP(e53, t3, r) {
  return e53[0] = t3[0] * r, e53[1] = t3[1] * r, e53[2] = t3[2] * r, e53[3] = t3[3] * r, e53;
}
function oP(e53, t3, r, i) {
  return e53[0] = t3[0] + r[0] * i, e53[1] = t3[1] + r[1] * i, e53[2] = t3[2] + r[2] * i, e53[3] = t3[3] + r[3] * i, e53;
}
t(Ta, { LDU: () => tP, add: () => rP, adjoint: () => ZS, clone: () => US, copy: () => NS, create: () => VS, determinant: () => WS, equals: () => nP, exactEquals: () => iP, frob: () => eP, fromRotation: () => YS, fromScaling: () => JS, fromValues: () => qS, identity: () => GS, invert: () => HS, mul: () => sP, multiply: () => Rx, multiplyScalar: () => aP, multiplyScalarAndAdd: () => oP, rotate: () => XS, scale: () => KS, set: () => jS, str: () => QS, sub: () => lP, subtract: () => Ox, transpose: () => $S }), c(), q(VS, "create"), q(US, "clone"), q(NS, "copy"), q(GS, "identity"), q(qS, "fromValues"), q(jS, "set"), q($S, "transpose"), q(HS, "invert"), q(ZS, "adjoint"), q(WS, "determinant"), q(Rx, "multiply"), q(XS, "rotate"), q(KS, "scale"), q(YS, "fromRotation"), q(JS, "fromScaling"), q(QS, "str"), q(eP, "frob"), q(tP, "LDU"), q(rP, "add"), q(Ox, "subtract"), q(iP, "exactEquals"), q(nP, "equals"), q(aP, "multiplyScalar"), q(oP, "multiplyScalarAndAdd");
var sP = Rx;
var lP = Ox;
var Aa = {};
function uP() {
  var e53 = new we(9);
  return we != Float32Array && (e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[5] = 0, e53[6] = 0, e53[7] = 0), e53[0] = 1, e53[4] = 1, e53[8] = 1, e53;
}
function cP(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53[3] = t3[4], e53[4] = t3[5], e53[5] = t3[6], e53[6] = t3[8], e53[7] = t3[9], e53[8] = t3[10], e53;
}
function pP(e53) {
  var t3 = new we(9);
  return t3[0] = e53[0], t3[1] = e53[1], t3[2] = e53[2], t3[3] = e53[3], t3[4] = e53[4], t3[5] = e53[5], t3[6] = e53[6], t3[7] = e53[7], t3[8] = e53[8], t3;
}
function hP(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53[3] = t3[3], e53[4] = t3[4], e53[5] = t3[5], e53[6] = t3[6], e53[7] = t3[7], e53[8] = t3[8], e53;
}
function fP(e53, t3, r, i, a, n, s3, o, l) {
  var u3 = new we(9);
  return u3[0] = e53, u3[1] = t3, u3[2] = r, u3[3] = i, u3[4] = a, u3[5] = n, u3[6] = s3, u3[7] = o, u3[8] = l, u3;
}
function mP(e53, t3, r, i, a, n, s3, o, l, u3) {
  return e53[0] = t3, e53[1] = r, e53[2] = i, e53[3] = a, e53[4] = n, e53[5] = s3, e53[6] = o, e53[7] = l, e53[8] = u3, e53;
}
function dP(e53) {
  return e53[0] = 1, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 1, e53[5] = 0, e53[6] = 0, e53[7] = 0, e53[8] = 1, e53;
}
function yP(e53, t3) {
  if (e53 === t3) {
    var r = t3[1], i = t3[2], a = t3[5];
    e53[1] = t3[3], e53[2] = t3[6], e53[3] = r, e53[5] = t3[7], e53[6] = i, e53[7] = a;
  } else
    e53[0] = t3[0], e53[1] = t3[3], e53[2] = t3[6], e53[3] = t3[1], e53[4] = t3[4], e53[5] = t3[7], e53[6] = t3[2], e53[7] = t3[5], e53[8] = t3[8];
  return e53;
}
function gP(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = t3[4], o = t3[5], l = t3[6], u3 = t3[7], c3 = t3[8], h = c3 * s3 - o * u3, p = -c3 * n + o * l, d = u3 * n - s3 * l, f = r * h + i * p + a * d;
  return f ? (f = 1 / f, e53[0] = h * f, e53[1] = (-c3 * i + a * u3) * f, e53[2] = (o * i - a * s3) * f, e53[3] = p * f, e53[4] = (c3 * r - a * l) * f, e53[5] = (-o * r + a * n) * f, e53[6] = d * f, e53[7] = (-u3 * r + i * l) * f, e53[8] = (s3 * r - i * n) * f, e53) : null;
}
function xP(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = t3[4], o = t3[5], l = t3[6], u3 = t3[7], c3 = t3[8];
  return e53[0] = s3 * c3 - o * u3, e53[1] = a * u3 - i * c3, e53[2] = i * o - a * s3, e53[3] = o * l - n * c3, e53[4] = r * c3 - a * l, e53[5] = a * n - r * o, e53[6] = n * u3 - s3 * l, e53[7] = i * l - r * u3, e53[8] = r * s3 - i * n, e53;
}
function bP(e53) {
  var t3 = e53[0], r = e53[1], i = e53[2], a = e53[3], n = e53[4], s3 = e53[5], o = e53[6], l = e53[7], u3 = e53[8];
  return t3 * (u3 * n - s3 * l) + r * (-u3 * a + s3 * o) + i * (l * a - n * o);
}
function Vx(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = t3[4], l = t3[5], u3 = t3[6], c3 = t3[7], h = t3[8], p = r[0], d = r[1], f = r[2], m = r[3], y = r[4], g = r[5], _ = r[6], x = r[7], v = r[8];
  return e53[0] = p * i + d * s3 + f * u3, e53[1] = p * a + d * o + f * c3, e53[2] = p * n + d * l + f * h, e53[3] = m * i + y * s3 + g * u3, e53[4] = m * a + y * o + g * c3, e53[5] = m * n + y * l + g * h, e53[6] = _ * i + x * s3 + v * u3, e53[7] = _ * a + x * o + v * c3, e53[8] = _ * n + x * l + v * h, e53;
}
function _P(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = t3[4], l = t3[5], u3 = t3[6], c3 = t3[7], h = t3[8], p = r[0], d = r[1];
  return e53[0] = i, e53[1] = a, e53[2] = n, e53[3] = s3, e53[4] = o, e53[5] = l, e53[6] = p * i + d * s3 + u3, e53[7] = p * a + d * o + c3, e53[8] = p * n + d * l + h, e53;
}
function vP(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = t3[4], l = t3[5], u3 = t3[6], c3 = t3[7], h = t3[8], p = Math.sin(r), d = Math.cos(r);
  return e53[0] = d * i + p * s3, e53[1] = d * a + p * o, e53[2] = d * n + p * l, e53[3] = d * s3 - p * i, e53[4] = d * o - p * a, e53[5] = d * l - p * n, e53[6] = u3, e53[7] = c3, e53[8] = h, e53;
}
function wP(e53, t3, r) {
  var i = r[0], a = r[1];
  return e53[0] = i * t3[0], e53[1] = i * t3[1], e53[2] = i * t3[2], e53[3] = a * t3[3], e53[4] = a * t3[4], e53[5] = a * t3[5], e53[6] = t3[6], e53[7] = t3[7], e53[8] = t3[8], e53;
}
function SP(e53, t3) {
  return e53[0] = 1, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 1, e53[5] = 0, e53[6] = t3[0], e53[7] = t3[1], e53[8] = 1, e53;
}
function PP(e53, t3) {
  var r = Math.sin(t3), i = Math.cos(t3);
  return e53[0] = i, e53[1] = r, e53[2] = 0, e53[3] = -r, e53[4] = i, e53[5] = 0, e53[6] = 0, e53[7] = 0, e53[8] = 1, e53;
}
function TP(e53, t3) {
  return e53[0] = t3[0], e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = t3[1], e53[5] = 0, e53[6] = 0, e53[7] = 0, e53[8] = 1, e53;
}
function AP(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = 0, e53[3] = t3[2], e53[4] = t3[3], e53[5] = 0, e53[6] = t3[4], e53[7] = t3[5], e53[8] = 1, e53;
}
function IP(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = r + r, o = i + i, l = a + a, u3 = r * s3, c3 = i * s3, h = i * o, p = a * s3, d = a * o, f = a * l, m = n * s3, y = n * o, g = n * l;
  return e53[0] = 1 - h - f, e53[3] = c3 - g, e53[6] = p + y, e53[1] = c3 + g, e53[4] = 1 - u3 - f, e53[7] = d - m, e53[2] = p - y, e53[5] = d + m, e53[8] = 1 - u3 - h, e53;
}
function MP(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = t3[4], o = t3[5], l = t3[6], u3 = t3[7], c3 = t3[8], h = t3[9], p = t3[10], d = t3[11], f = t3[12], m = t3[13], y = t3[14], g = t3[15], _ = r * o - i * s3, x = r * l - a * s3, v = r * u3 - n * s3, b = i * l - a * o, w = i * u3 - n * o, S = a * u3 - n * l, A = c3 * m - h * f, M3 = c3 * y - p * f, I = c3 * g - d * f, T = h * y - p * m, C = h * g - d * m, P = p * g - d * y, k = _ * P - x * C + v * T + b * I - w * M3 + S * A;
  return k ? (k = 1 / k, e53[0] = (o * P - l * C + u3 * T) * k, e53[1] = (l * I - s3 * P - u3 * M3) * k, e53[2] = (s3 * C - o * I + u3 * A) * k, e53[3] = (a * C - i * P - n * T) * k, e53[4] = (r * P - a * I + n * M3) * k, e53[5] = (i * I - r * C - n * A) * k, e53[6] = (m * S - y * w + g * b) * k, e53[7] = (y * v - f * S - g * x) * k, e53[8] = (f * w - m * v + g * _) * k, e53) : null;
}
function CP(e53, t3, r) {
  return e53[0] = 2 / t3, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = -2 / r, e53[5] = 0, e53[6] = -1, e53[7] = 1, e53[8] = 1, e53;
}
function EP(e53) {
  return "mat3(" + e53[0] + ", " + e53[1] + ", " + e53[2] + ", " + e53[3] + ", " + e53[4] + ", " + e53[5] + ", " + e53[6] + ", " + e53[7] + ", " + e53[8] + ")";
}
function kP(e53) {
  return Math.hypot(e53[0], e53[1], e53[2], e53[3], e53[4], e53[5], e53[6], e53[7], e53[8]);
}
function LP(e53, t3, r) {
  return e53[0] = t3[0] + r[0], e53[1] = t3[1] + r[1], e53[2] = t3[2] + r[2], e53[3] = t3[3] + r[3], e53[4] = t3[4] + r[4], e53[5] = t3[5] + r[5], e53[6] = t3[6] + r[6], e53[7] = t3[7] + r[7], e53[8] = t3[8] + r[8], e53;
}
function Ux(e53, t3, r) {
  return e53[0] = t3[0] - r[0], e53[1] = t3[1] - r[1], e53[2] = t3[2] - r[2], e53[3] = t3[3] - r[3], e53[4] = t3[4] - r[4], e53[5] = t3[5] - r[5], e53[6] = t3[6] - r[6], e53[7] = t3[7] - r[7], e53[8] = t3[8] - r[8], e53;
}
function DP(e53, t3, r) {
  return e53[0] = t3[0] * r, e53[1] = t3[1] * r, e53[2] = t3[2] * r, e53[3] = t3[3] * r, e53[4] = t3[4] * r, e53[5] = t3[5] * r, e53[6] = t3[6] * r, e53[7] = t3[7] * r, e53[8] = t3[8] * r, e53;
}
function zP(e53, t3, r, i) {
  return e53[0] = t3[0] + r[0] * i, e53[1] = t3[1] + r[1] * i, e53[2] = t3[2] + r[2] * i, e53[3] = t3[3] + r[3] * i, e53[4] = t3[4] + r[4] * i, e53[5] = t3[5] + r[5] * i, e53[6] = t3[6] + r[6] * i, e53[7] = t3[7] + r[7] * i, e53[8] = t3[8] + r[8] * i, e53;
}
function FP(e53, t3) {
  return e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && e53[3] === t3[3] && e53[4] === t3[4] && e53[5] === t3[5] && e53[6] === t3[6] && e53[7] === t3[7] && e53[8] === t3[8];
}
function BP(e53, t3) {
  var r = e53[0], i = e53[1], a = e53[2], n = e53[3], s3 = e53[4], o = e53[5], l = e53[6], u3 = e53[7], c3 = e53[8], h = t3[0], p = t3[1], d = t3[2], f = t3[3], m = t3[4], y = t3[5], g = t3[6], _ = t3[7], x = t3[8];
  return Math.abs(r - h) <= ie * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(i - p) <= ie * Math.max(1, Math.abs(i), Math.abs(p)) && Math.abs(a - d) <= ie * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(n - f) <= ie * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(s3 - m) <= ie * Math.max(1, Math.abs(s3), Math.abs(m)) && Math.abs(o - y) <= ie * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(l - g) <= ie * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u3 - _) <= ie * Math.max(1, Math.abs(u3), Math.abs(_)) && Math.abs(c3 - x) <= ie * Math.max(1, Math.abs(c3), Math.abs(x));
}
t(Aa, { add: () => LP, adjoint: () => xP, clone: () => pP, copy: () => hP, create: () => uP, determinant: () => bP, equals: () => BP, exactEquals: () => FP, frob: () => kP, fromMat2d: () => AP, fromMat4: () => cP, fromQuat: () => IP, fromRotation: () => PP, fromScaling: () => TP, fromTranslation: () => SP, fromValues: () => fP, identity: () => dP, invert: () => gP, mul: () => RP, multiply: () => Vx, multiplyScalar: () => DP, multiplyScalarAndAdd: () => zP, normalFromMat4: () => MP, projection: () => CP, rotate: () => vP, scale: () => wP, set: () => mP, str: () => EP, sub: () => OP, subtract: () => Ux, translate: () => _P, transpose: () => yP }), c(), q(uP, "create"), q(cP, "fromMat4"), q(pP, "clone"), q(hP, "copy"), q(fP, "fromValues"), q(mP, "set"), q(dP, "identity"), q(yP, "transpose"), q(gP, "invert"), q(xP, "adjoint"), q(bP, "determinant"), q(Vx, "multiply"), q(_P, "translate"), q(vP, "rotate"), q(wP, "scale"), q(SP, "fromTranslation"), q(PP, "fromRotation"), q(TP, "fromScaling"), q(AP, "fromMat2d"), q(IP, "fromQuat"), q(MP, "normalFromMat4"), q(CP, "projection"), q(EP, "str"), q(kP, "frob"), q(LP, "add"), q(Ux, "subtract"), q(DP, "multiplyScalar"), q(zP, "multiplyScalarAndAdd"), q(FP, "exactEquals"), q(BP, "equals");
var RP = Vx;
var OP = Ux;
var q3 = {};
function VP() {
  var e53 = new we(16);
  return we != Float32Array && (e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0), e53[0] = 1, e53[5] = 1, e53[10] = 1, e53[15] = 1, e53;
}
function UP(e53) {
  var t3 = new we(16);
  return t3[0] = e53[0], t3[1] = e53[1], t3[2] = e53[2], t3[3] = e53[3], t3[4] = e53[4], t3[5] = e53[5], t3[6] = e53[6], t3[7] = e53[7], t3[8] = e53[8], t3[9] = e53[9], t3[10] = e53[10], t3[11] = e53[11], t3[12] = e53[12], t3[13] = e53[13], t3[14] = e53[14], t3[15] = e53[15], t3;
}
function NP(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53[3] = t3[3], e53[4] = t3[4], e53[5] = t3[5], e53[6] = t3[6], e53[7] = t3[7], e53[8] = t3[8], e53[9] = t3[9], e53[10] = t3[10], e53[11] = t3[11], e53[12] = t3[12], e53[13] = t3[13], e53[14] = t3[14], e53[15] = t3[15], e53;
}
function GP(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m) {
  var y = new we(16);
  return y[0] = e53, y[1] = t3, y[2] = r, y[3] = i, y[4] = a, y[5] = n, y[6] = s3, y[7] = o, y[8] = l, y[9] = u3, y[10] = c3, y[11] = h, y[12] = p, y[13] = d, y[14] = f, y[15] = m, y;
}
function qP(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y) {
  return e53[0] = t3, e53[1] = r, e53[2] = i, e53[3] = a, e53[4] = n, e53[5] = s3, e53[6] = o, e53[7] = l, e53[8] = u3, e53[9] = c3, e53[10] = h, e53[11] = p, e53[12] = d, e53[13] = f, e53[14] = m, e53[15] = y, e53;
}
function Nx(e53) {
  return e53[0] = 1, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = 1, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[10] = 1, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53;
}
function jP(e53, t3) {
  if (e53 === t3) {
    var r = t3[1], i = t3[2], a = t3[3], n = t3[6], s3 = t3[7], o = t3[11];
    e53[1] = t3[4], e53[2] = t3[8], e53[3] = t3[12], e53[4] = r, e53[6] = t3[9], e53[7] = t3[13], e53[8] = i, e53[9] = n, e53[11] = t3[14], e53[12] = a, e53[13] = s3, e53[14] = o;
  } else
    e53[0] = t3[0], e53[1] = t3[4], e53[2] = t3[8], e53[3] = t3[12], e53[4] = t3[1], e53[5] = t3[5], e53[6] = t3[9], e53[7] = t3[13], e53[8] = t3[2], e53[9] = t3[6], e53[10] = t3[10], e53[11] = t3[14], e53[12] = t3[3], e53[13] = t3[7], e53[14] = t3[11], e53[15] = t3[15];
  return e53;
}
function $P(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = t3[4], o = t3[5], l = t3[6], u3 = t3[7], c3 = t3[8], h = t3[9], p = t3[10], d = t3[11], f = t3[12], m = t3[13], y = t3[14], g = t3[15], _ = r * o - i * s3, x = r * l - a * s3, v = r * u3 - n * s3, b = i * l - a * o, w = i * u3 - n * o, S = a * u3 - n * l, A = c3 * m - h * f, M3 = c3 * y - p * f, I = c3 * g - d * f, T = h * y - p * m, C = h * g - d * m, P = p * g - d * y, k = _ * P - x * C + v * T + b * I - w * M3 + S * A;
  return k ? (k = 1 / k, e53[0] = (o * P - l * C + u3 * T) * k, e53[1] = (a * C - i * P - n * T) * k, e53[2] = (m * S - y * w + g * b) * k, e53[3] = (p * w - h * S - d * b) * k, e53[4] = (l * I - s3 * P - u3 * M3) * k, e53[5] = (r * P - a * I + n * M3) * k, e53[6] = (y * v - f * S - g * x) * k, e53[7] = (c3 * S - p * v + d * x) * k, e53[8] = (s3 * C - o * I + u3 * A) * k, e53[9] = (i * I - r * C - n * A) * k, e53[10] = (f * w - m * v + g * _) * k, e53[11] = (h * v - c3 * w - d * _) * k, e53[12] = (o * M3 - s3 * T - l * A) * k, e53[13] = (r * T - i * M3 + a * A) * k, e53[14] = (m * x - f * b - y * _) * k, e53[15] = (c3 * b - h * x + p * _) * k, e53) : null;
}
function HP(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = t3[4], o = t3[5], l = t3[6], u3 = t3[7], c3 = t3[8], h = t3[9], p = t3[10], d = t3[11], f = t3[12], m = t3[13], y = t3[14], g = t3[15];
  return e53[0] = o * (p * g - d * y) - h * (l * g - u3 * y) + m * (l * d - u3 * p), e53[1] = -(i * (p * g - d * y) - h * (a * g - n * y) + m * (a * d - n * p)), e53[2] = i * (l * g - u3 * y) - o * (a * g - n * y) + m * (a * u3 - n * l), e53[3] = -(i * (l * d - u3 * p) - o * (a * d - n * p) + h * (a * u3 - n * l)), e53[4] = -(s3 * (p * g - d * y) - c3 * (l * g - u3 * y) + f * (l * d - u3 * p)), e53[5] = r * (p * g - d * y) - c3 * (a * g - n * y) + f * (a * d - n * p), e53[6] = -(r * (l * g - u3 * y) - s3 * (a * g - n * y) + f * (a * u3 - n * l)), e53[7] = r * (l * d - u3 * p) - s3 * (a * d - n * p) + c3 * (a * u3 - n * l), e53[8] = s3 * (h * g - d * m) - c3 * (o * g - u3 * m) + f * (o * d - u3 * h), e53[9] = -(r * (h * g - d * m) - c3 * (i * g - n * m) + f * (i * d - n * h)), e53[10] = r * (o * g - u3 * m) - s3 * (i * g - n * m) + f * (i * u3 - n * o), e53[11] = -(r * (o * d - u3 * h) - s3 * (i * d - n * h) + c3 * (i * u3 - n * o)), e53[12] = -(s3 * (h * y - p * m) - c3 * (o * y - l * m) + f * (o * p - l * h)), e53[13] = r * (h * y - p * m) - c3 * (i * y - a * m) + f * (i * p - a * h), e53[14] = -(r * (o * y - l * m) - s3 * (i * y - a * m) + f * (i * l - a * o)), e53[15] = r * (o * p - l * h) - s3 * (i * p - a * h) + c3 * (i * l - a * o), e53;
}
function ZP(e53) {
  var t3 = e53[0], r = e53[1], i = e53[2], a = e53[3], n = e53[4], s3 = e53[5], o = e53[6], l = e53[7], u3 = e53[8], c3 = e53[9], h = e53[10], p = e53[11], d = e53[12], f = e53[13], m = e53[14], y = e53[15];
  return (t3 * s3 - r * n) * (h * y - p * m) - (t3 * o - i * n) * (c3 * y - p * f) + (t3 * l - a * n) * (c3 * m - h * f) + (r * o - i * s3) * (u3 * y - p * d) - (r * l - a * s3) * (u3 * m - h * d) + (i * l - a * o) * (u3 * f - c3 * d);
}
function Gx(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = t3[4], l = t3[5], u3 = t3[6], c3 = t3[7], h = t3[8], p = t3[9], d = t3[10], f = t3[11], m = t3[12], y = t3[13], g = t3[14], _ = t3[15], x = r[0], v = r[1], b = r[2], w = r[3];
  return e53[0] = x * i + v * o + b * h + w * m, e53[1] = x * a + v * l + b * p + w * y, e53[2] = x * n + v * u3 + b * d + w * g, e53[3] = x * s3 + v * c3 + b * f + w * _, x = r[4], v = r[5], b = r[6], w = r[7], e53[4] = x * i + v * o + b * h + w * m, e53[5] = x * a + v * l + b * p + w * y, e53[6] = x * n + v * u3 + b * d + w * g, e53[7] = x * s3 + v * c3 + b * f + w * _, x = r[8], v = r[9], b = r[10], w = r[11], e53[8] = x * i + v * o + b * h + w * m, e53[9] = x * a + v * l + b * p + w * y, e53[10] = x * n + v * u3 + b * d + w * g, e53[11] = x * s3 + v * c3 + b * f + w * _, x = r[12], v = r[13], b = r[14], w = r[15], e53[12] = x * i + v * o + b * h + w * m, e53[13] = x * a + v * l + b * p + w * y, e53[14] = x * n + v * u3 + b * d + w * g, e53[15] = x * s3 + v * c3 + b * f + w * _, e53;
}
function WP(e53, t3, r) {
  var i, a, n, s3, o, l, u3, c3, h, p, d, f, m = r[0], y = r[1], g = r[2];
  return t3 === e53 ? (e53[12] = t3[0] * m + t3[4] * y + t3[8] * g + t3[12], e53[13] = t3[1] * m + t3[5] * y + t3[9] * g + t3[13], e53[14] = t3[2] * m + t3[6] * y + t3[10] * g + t3[14], e53[15] = t3[3] * m + t3[7] * y + t3[11] * g + t3[15]) : (i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = t3[4], l = t3[5], u3 = t3[6], c3 = t3[7], h = t3[8], p = t3[9], d = t3[10], f = t3[11], e53[0] = i, e53[1] = a, e53[2] = n, e53[3] = s3, e53[4] = o, e53[5] = l, e53[6] = u3, e53[7] = c3, e53[8] = h, e53[9] = p, e53[10] = d, e53[11] = f, e53[12] = i * m + o * y + h * g + t3[12], e53[13] = a * m + l * y + p * g + t3[13], e53[14] = n * m + u3 * y + d * g + t3[14], e53[15] = s3 * m + c3 * y + f * g + t3[15]), e53;
}
function XP(e53, t3, r) {
  var i = r[0], a = r[1], n = r[2];
  return e53[0] = t3[0] * i, e53[1] = t3[1] * i, e53[2] = t3[2] * i, e53[3] = t3[3] * i, e53[4] = t3[4] * a, e53[5] = t3[5] * a, e53[6] = t3[6] * a, e53[7] = t3[7] * a, e53[8] = t3[8] * n, e53[9] = t3[9] * n, e53[10] = t3[10] * n, e53[11] = t3[11] * n, e53[12] = t3[12], e53[13] = t3[13], e53[14] = t3[14], e53[15] = t3[15], e53;
}
function KP(e53, t3, r, i) {
  var a, n, s3, o, l, u3, c3, h, p, d, f, m, y, g, _, x, v, b, w, S, A, M3, I, T, C = i[0], P = i[1], k = i[2], z3 = Math.hypot(C, P, k);
  return z3 < ie ? null : (C *= z3 = 1 / z3, P *= z3, k *= z3, a = Math.sin(r), s3 = 1 - (n = Math.cos(r)), o = t3[0], l = t3[1], u3 = t3[2], c3 = t3[3], h = t3[4], p = t3[5], d = t3[6], f = t3[7], m = t3[8], y = t3[9], g = t3[10], _ = t3[11], x = C * C * s3 + n, v = P * C * s3 + k * a, b = k * C * s3 - P * a, w = C * P * s3 - k * a, S = P * P * s3 + n, A = k * P * s3 + C * a, M3 = C * k * s3 + P * a, I = P * k * s3 - C * a, T = k * k * s3 + n, e53[0] = o * x + h * v + m * b, e53[1] = l * x + p * v + y * b, e53[2] = u3 * x + d * v + g * b, e53[3] = c3 * x + f * v + _ * b, e53[4] = o * w + h * S + m * A, e53[5] = l * w + p * S + y * A, e53[6] = u3 * w + d * S + g * A, e53[7] = c3 * w + f * S + _ * A, e53[8] = o * M3 + h * I + m * T, e53[9] = l * M3 + p * I + y * T, e53[10] = u3 * M3 + d * I + g * T, e53[11] = c3 * M3 + f * I + _ * T, t3 !== e53 && (e53[12] = t3[12], e53[13] = t3[13], e53[14] = t3[14], e53[15] = t3[15]), e53);
}
function YP(e53, t3, r) {
  var i = Math.sin(r), a = Math.cos(r), n = t3[4], s3 = t3[5], o = t3[6], l = t3[7], u3 = t3[8], c3 = t3[9], h = t3[10], p = t3[11];
  return t3 !== e53 && (e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53[3] = t3[3], e53[12] = t3[12], e53[13] = t3[13], e53[14] = t3[14], e53[15] = t3[15]), e53[4] = n * a + u3 * i, e53[5] = s3 * a + c3 * i, e53[6] = o * a + h * i, e53[7] = l * a + p * i, e53[8] = u3 * a - n * i, e53[9] = c3 * a - s3 * i, e53[10] = h * a - o * i, e53[11] = p * a - l * i, e53;
}
function JP(e53, t3, r) {
  var i = Math.sin(r), a = Math.cos(r), n = t3[0], s3 = t3[1], o = t3[2], l = t3[3], u3 = t3[8], c3 = t3[9], h = t3[10], p = t3[11];
  return t3 !== e53 && (e53[4] = t3[4], e53[5] = t3[5], e53[6] = t3[6], e53[7] = t3[7], e53[12] = t3[12], e53[13] = t3[13], e53[14] = t3[14], e53[15] = t3[15]), e53[0] = n * a - u3 * i, e53[1] = s3 * a - c3 * i, e53[2] = o * a - h * i, e53[3] = l * a - p * i, e53[8] = n * i + u3 * a, e53[9] = s3 * i + c3 * a, e53[10] = o * i + h * a, e53[11] = l * i + p * a, e53;
}
function QP(e53, t3, r) {
  var i = Math.sin(r), a = Math.cos(r), n = t3[0], s3 = t3[1], o = t3[2], l = t3[3], u3 = t3[4], c3 = t3[5], h = t3[6], p = t3[7];
  return t3 !== e53 && (e53[8] = t3[8], e53[9] = t3[9], e53[10] = t3[10], e53[11] = t3[11], e53[12] = t3[12], e53[13] = t3[13], e53[14] = t3[14], e53[15] = t3[15]), e53[0] = n * a + u3 * i, e53[1] = s3 * a + c3 * i, e53[2] = o * a + h * i, e53[3] = l * a + p * i, e53[4] = u3 * a - n * i, e53[5] = c3 * a - s3 * i, e53[6] = h * a - o * i, e53[7] = p * a - l * i, e53;
}
function eT(e53, t3) {
  return e53[0] = 1, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = 1, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[10] = 1, e53[11] = 0, e53[12] = t3[0], e53[13] = t3[1], e53[14] = t3[2], e53[15] = 1, e53;
}
function tT(e53, t3) {
  return e53[0] = t3[0], e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = t3[1], e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[10] = t3[2], e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53;
}
function rT(e53, t3, r) {
  var i, a, n, s3 = r[0], o = r[1], l = r[2], u3 = Math.hypot(s3, o, l);
  return u3 < ie ? null : (s3 *= u3 = 1 / u3, o *= u3, l *= u3, i = Math.sin(t3), n = 1 - (a = Math.cos(t3)), e53[0] = s3 * s3 * n + a, e53[1] = o * s3 * n + l * i, e53[2] = l * s3 * n - o * i, e53[3] = 0, e53[4] = s3 * o * n - l * i, e53[5] = o * o * n + a, e53[6] = l * o * n + s3 * i, e53[7] = 0, e53[8] = s3 * l * n + o * i, e53[9] = o * l * n - s3 * i, e53[10] = l * l * n + a, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53);
}
function iT(e53, t3) {
  var r = Math.sin(t3), i = Math.cos(t3);
  return e53[0] = 1, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = i, e53[6] = r, e53[7] = 0, e53[8] = 0, e53[9] = -r, e53[10] = i, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53;
}
function nT(e53, t3) {
  var r = Math.sin(t3), i = Math.cos(t3);
  return e53[0] = i, e53[1] = 0, e53[2] = -r, e53[3] = 0, e53[4] = 0, e53[5] = 1, e53[6] = 0, e53[7] = 0, e53[8] = r, e53[9] = 0, e53[10] = i, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53;
}
function aT(e53, t3) {
  var r = Math.sin(t3), i = Math.cos(t3);
  return e53[0] = i, e53[1] = r, e53[2] = 0, e53[3] = 0, e53[4] = -r, e53[5] = i, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[10] = 1, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53;
}
function qx(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3], o = i + i, l = a + a, u3 = n + n, c3 = i * o, h = i * l, p = i * u3, d = a * l, f = a * u3, m = n * u3, y = s3 * o, g = s3 * l, _ = s3 * u3;
  return e53[0] = 1 - (d + m), e53[1] = h + _, e53[2] = p - g, e53[3] = 0, e53[4] = h - _, e53[5] = 1 - (c3 + m), e53[6] = f + y, e53[7] = 0, e53[8] = p + g, e53[9] = f - y, e53[10] = 1 - (c3 + d), e53[11] = 0, e53[12] = r[0], e53[13] = r[1], e53[14] = r[2], e53[15] = 1, e53;
}
function oT(e53, t3) {
  var r = new we(3), i = -t3[0], a = -t3[1], n = -t3[2], s3 = t3[3], o = t3[4], l = t3[5], u3 = t3[6], c3 = t3[7], h = i * i + a * a + n * n + s3 * s3;
  return h > 0 ? (r[0] = 2 * (o * s3 + c3 * i + l * n - u3 * a) / h, r[1] = 2 * (l * s3 + c3 * a + u3 * i - o * n) / h, r[2] = 2 * (u3 * s3 + c3 * n + o * a - l * i) / h) : (r[0] = 2 * (o * s3 + c3 * i + l * n - u3 * a), r[1] = 2 * (l * s3 + c3 * a + u3 * i - o * n), r[2] = 2 * (u3 * s3 + c3 * n + o * a - l * i)), qx(e53, t3, r), e53;
}
function sT(e53, t3) {
  return e53[0] = t3[12], e53[1] = t3[13], e53[2] = t3[14], e53;
}
function jx(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[4], s3 = t3[5], o = t3[6], l = t3[8], u3 = t3[9], c3 = t3[10];
  return e53[0] = Math.hypot(r, i, a), e53[1] = Math.hypot(n, s3, o), e53[2] = Math.hypot(l, u3, c3), e53;
}
function lT(e53, t3) {
  var r = new we(3);
  jx(r, t3);
  var i = 1 / r[0], a = 1 / r[1], n = 1 / r[2], s3 = t3[0] * i, o = t3[1] * a, l = t3[2] * n, u3 = t3[4] * i, c3 = t3[5] * a, h = t3[6] * n, p = t3[8] * i, d = t3[9] * a, f = t3[10] * n, m = s3 + c3 + f, y = 0;
  return m > 0 ? (y = 2 * Math.sqrt(m + 1), e53[3] = 0.25 * y, e53[0] = (h - d) / y, e53[1] = (p - l) / y, e53[2] = (o - u3) / y) : s3 > c3 && s3 > f ? (y = 2 * Math.sqrt(1 + s3 - c3 - f), e53[3] = (h - d) / y, e53[0] = 0.25 * y, e53[1] = (o + u3) / y, e53[2] = (p + l) / y) : c3 > f ? (y = 2 * Math.sqrt(1 + c3 - s3 - f), e53[3] = (p - l) / y, e53[0] = (o + u3) / y, e53[1] = 0.25 * y, e53[2] = (h + d) / y) : (y = 2 * Math.sqrt(1 + f - s3 - c3), e53[3] = (o - u3) / y, e53[0] = (p + l) / y, e53[1] = (h + d) / y, e53[2] = 0.25 * y), e53;
}
function uT(e53, t3, r, i) {
  var a = t3[0], n = t3[1], s3 = t3[2], o = t3[3], l = a + a, u3 = n + n, c3 = s3 + s3, h = a * l, p = a * u3, d = a * c3, f = n * u3, m = n * c3, y = s3 * c3, g = o * l, _ = o * u3, x = o * c3, v = i[0], b = i[1], w = i[2];
  return e53[0] = (1 - (f + y)) * v, e53[1] = (p + x) * v, e53[2] = (d - _) * v, e53[3] = 0, e53[4] = (p - x) * b, e53[5] = (1 - (h + y)) * b, e53[6] = (m + g) * b, e53[7] = 0, e53[8] = (d + _) * w, e53[9] = (m - g) * w, e53[10] = (1 - (h + f)) * w, e53[11] = 0, e53[12] = r[0], e53[13] = r[1], e53[14] = r[2], e53[15] = 1, e53;
}
function cT(e53, t3, r, i, a) {
  var n = t3[0], s3 = t3[1], o = t3[2], l = t3[3], u3 = n + n, c3 = s3 + s3, h = o + o, p = n * u3, d = n * c3, f = n * h, m = s3 * c3, y = s3 * h, g = o * h, _ = l * u3, x = l * c3, v = l * h, b = i[0], w = i[1], S = i[2], A = a[0], M3 = a[1], I = a[2], T = (1 - (m + g)) * b, C = (d + v) * b, P = (f - x) * b, k = (d - v) * w, z3 = (1 - (p + g)) * w, E = (y + _) * w, D = (f + x) * S, B3 = (y - _) * S, L = (1 - (p + m)) * S;
  return e53[0] = T, e53[1] = C, e53[2] = P, e53[3] = 0, e53[4] = k, e53[5] = z3, e53[6] = E, e53[7] = 0, e53[8] = D, e53[9] = B3, e53[10] = L, e53[11] = 0, e53[12] = r[0] + A - (T * A + k * M3 + D * I), e53[13] = r[1] + M3 - (C * A + z3 * M3 + B3 * I), e53[14] = r[2] + I - (P * A + E * M3 + L * I), e53[15] = 1, e53;
}
function pT(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = r + r, o = i + i, l = a + a, u3 = r * s3, c3 = i * s3, h = i * o, p = a * s3, d = a * o, f = a * l, m = n * s3, y = n * o, g = n * l;
  return e53[0] = 1 - h - f, e53[1] = c3 + g, e53[2] = p - y, e53[3] = 0, e53[4] = c3 - g, e53[5] = 1 - u3 - f, e53[6] = d + m, e53[7] = 0, e53[8] = p + y, e53[9] = d - m, e53[10] = 1 - u3 - h, e53[11] = 0, e53[12] = 0, e53[13] = 0, e53[14] = 0, e53[15] = 1, e53;
}
function hT(e53, t3, r, i, a, n, s3) {
  var o = 1 / (r - t3), l = 1 / (a - i), u3 = 1 / (n - s3);
  return e53[0] = 2 * n * o, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = 2 * n * l, e53[6] = 0, e53[7] = 0, e53[8] = (r + t3) * o, e53[9] = (a + i) * l, e53[10] = (s3 + n) * u3, e53[11] = -1, e53[12] = 0, e53[13] = 0, e53[14] = s3 * n * 2 * u3, e53[15] = 0, e53;
}
function $x(e53, t3, r, i, a) {
  var n, s3 = 1 / Math.tan(t3 / 2);
  return e53[0] = s3 / r, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = s3, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[11] = -1, e53[12] = 0, e53[13] = 0, e53[15] = 0, null != a && a !== 1 / 0 ? (n = 1 / (i - a), e53[10] = (a + i) * n, e53[14] = 2 * a * i * n) : (e53[10] = -1, e53[14] = -2 * i), e53;
}
t(q3, { add: () => wT, adjoint: () => HP, clone: () => UP, copy: () => NP, create: () => VP, determinant: () => ZP, equals: () => AT, exactEquals: () => TT, frob: () => vT, fromQuat: () => pT, fromQuat2: () => oT, fromRotation: () => rT, fromRotationTranslation: () => qx, fromRotationTranslationScale: () => uT, fromRotationTranslationScaleOrigin: () => cT, fromScaling: () => tT, fromTranslation: () => eT, fromValues: () => GP, fromXRotation: () => iT, fromYRotation: () => nT, fromZRotation: () => aT, frustum: () => hT, getRotation: () => lT, getScaling: () => jx, getTranslation: () => sT, identity: () => Nx, invert: () => $P, lookAt: () => xT, mul: () => IT, multiply: () => Gx, multiplyScalar: () => ST, multiplyScalarAndAdd: () => PT, ortho: () => yT, orthoNO: () => Hx, orthoZO: () => gT, perspective: () => fT, perspectiveFromFieldOfView: () => dT, perspectiveNO: () => $x, perspectiveZO: () => mT, rotate: () => KP, rotateX: () => YP, rotateY: () => JP, rotateZ: () => QP, scale: () => XP, set: () => qP, str: () => _T, sub: () => MT, subtract: () => Zx, targetTo: () => bT, translate: () => WP, transpose: () => jP }), c(), q(VP, "create"), q(UP, "clone"), q(NP, "copy"), q(GP, "fromValues"), q(qP, "set"), q(Nx, "identity"), q(jP, "transpose"), q($P, "invert"), q(HP, "adjoint"), q(ZP, "determinant"), q(Gx, "multiply"), q(WP, "translate"), q(XP, "scale"), q(KP, "rotate"), q(YP, "rotateX"), q(JP, "rotateY"), q(QP, "rotateZ"), q(eT, "fromTranslation"), q(tT, "fromScaling"), q(rT, "fromRotation"), q(iT, "fromXRotation"), q(nT, "fromYRotation"), q(aT, "fromZRotation"), q(qx, "fromRotationTranslation"), q(oT, "fromQuat2"), q(sT, "getTranslation"), q(jx, "getScaling"), q(lT, "getRotation"), q(uT, "fromRotationTranslationScale"), q(cT, "fromRotationTranslationScaleOrigin"), q(pT, "fromQuat"), q(hT, "frustum"), q($x, "perspectiveNO");
var fT = $x;
function mT(e53, t3, r, i, a) {
  var n, s3 = 1 / Math.tan(t3 / 2);
  return e53[0] = s3 / r, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = s3, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[11] = -1, e53[12] = 0, e53[13] = 0, e53[15] = 0, null != a && a !== 1 / 0 ? (n = 1 / (i - a), e53[10] = a * n, e53[14] = a * i * n) : (e53[10] = -1, e53[14] = -i), e53;
}
function dT(e53, t3, r, i) {
  var a = Math.tan(t3.upDegrees * Math.PI / 180), n = Math.tan(t3.downDegrees * Math.PI / 180), s3 = Math.tan(t3.leftDegrees * Math.PI / 180), o = Math.tan(t3.rightDegrees * Math.PI / 180), l = 2 / (s3 + o), u3 = 2 / (a + n);
  return e53[0] = l, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = u3, e53[6] = 0, e53[7] = 0, e53[8] = -(s3 - o) * l * 0.5, e53[9] = (a - n) * u3 * 0.5, e53[10] = i / (r - i), e53[11] = -1, e53[12] = 0, e53[13] = 0, e53[14] = i * r / (r - i), e53[15] = 0, e53;
}
function Hx(e53, t3, r, i, a, n, s3) {
  var o = 1 / (t3 - r), l = 1 / (i - a), u3 = 1 / (n - s3);
  return e53[0] = -2 * o, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = -2 * l, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[10] = 2 * u3, e53[11] = 0, e53[12] = (t3 + r) * o, e53[13] = (a + i) * l, e53[14] = (s3 + n) * u3, e53[15] = 1, e53;
}
q(mT, "perspectiveZO"), q(dT, "perspectiveFromFieldOfView"), q(Hx, "orthoNO");
var yT = Hx;
function gT(e53, t3, r, i, a, n, s3) {
  var o = 1 / (t3 - r), l = 1 / (i - a), u3 = 1 / (n - s3);
  return e53[0] = -2 * o, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53[4] = 0, e53[5] = -2 * l, e53[6] = 0, e53[7] = 0, e53[8] = 0, e53[9] = 0, e53[10] = u3, e53[11] = 0, e53[12] = (t3 + r) * o, e53[13] = (a + i) * l, e53[14] = n * u3, e53[15] = 1, e53;
}
function xT(e53, t3, r, i) {
  var a, n, s3, o, l, u3, c3, h, p, d, f = t3[0], m = t3[1], y = t3[2], g = i[0], _ = i[1], x = i[2], v = r[0], b = r[1], w = r[2];
  return Math.abs(f - v) < ie && Math.abs(m - b) < ie && Math.abs(y - w) < ie ? Nx(e53) : (c3 = f - v, h = m - b, p = y - w, a = _ * (p *= d = 1 / Math.hypot(c3, h, p)) - x * (h *= d), n = x * (c3 *= d) - g * p, s3 = g * h - _ * c3, (d = Math.hypot(a, n, s3)) ? (a *= d = 1 / d, n *= d, s3 *= d) : (a = 0, n = 0, s3 = 0), o = h * s3 - p * n, l = p * a - c3 * s3, u3 = c3 * n - h * a, (d = Math.hypot(o, l, u3)) ? (o *= d = 1 / d, l *= d, u3 *= d) : (o = 0, l = 0, u3 = 0), e53[0] = a, e53[1] = o, e53[2] = c3, e53[3] = 0, e53[4] = n, e53[5] = l, e53[6] = h, e53[7] = 0, e53[8] = s3, e53[9] = u3, e53[10] = p, e53[11] = 0, e53[12] = -(a * f + n * m + s3 * y), e53[13] = -(o * f + l * m + u3 * y), e53[14] = -(c3 * f + h * m + p * y), e53[15] = 1, e53);
}
function bT(e53, t3, r, i) {
  var a = t3[0], n = t3[1], s3 = t3[2], o = i[0], l = i[1], u3 = i[2], c3 = a - r[0], h = n - r[1], p = s3 - r[2], d = c3 * c3 + h * h + p * p;
  d > 0 && (c3 *= d = 1 / Math.sqrt(d), h *= d, p *= d);
  var f = l * p - u3 * h, m = u3 * c3 - o * p, y = o * h - l * c3;
  return (d = f * f + m * m + y * y) > 0 && (f *= d = 1 / Math.sqrt(d), m *= d, y *= d), e53[0] = f, e53[1] = m, e53[2] = y, e53[3] = 0, e53[4] = h * y - p * m, e53[5] = p * f - c3 * y, e53[6] = c3 * m - h * f, e53[7] = 0, e53[8] = c3, e53[9] = h, e53[10] = p, e53[11] = 0, e53[12] = a, e53[13] = n, e53[14] = s3, e53[15] = 1, e53;
}
function _T(e53) {
  return "mat4(" + e53[0] + ", " + e53[1] + ", " + e53[2] + ", " + e53[3] + ", " + e53[4] + ", " + e53[5] + ", " + e53[6] + ", " + e53[7] + ", " + e53[8] + ", " + e53[9] + ", " + e53[10] + ", " + e53[11] + ", " + e53[12] + ", " + e53[13] + ", " + e53[14] + ", " + e53[15] + ")";
}
function vT(e53) {
  return Math.hypot(e53[0], e53[1], e53[2], e53[3], e53[4], e53[5], e53[6], e53[7], e53[8], e53[9], e53[10], e53[11], e53[12], e53[13], e53[14], e53[15]);
}
function wT(e53, t3, r) {
  return e53[0] = t3[0] + r[0], e53[1] = t3[1] + r[1], e53[2] = t3[2] + r[2], e53[3] = t3[3] + r[3], e53[4] = t3[4] + r[4], e53[5] = t3[5] + r[5], e53[6] = t3[6] + r[6], e53[7] = t3[7] + r[7], e53[8] = t3[8] + r[8], e53[9] = t3[9] + r[9], e53[10] = t3[10] + r[10], e53[11] = t3[11] + r[11], e53[12] = t3[12] + r[12], e53[13] = t3[13] + r[13], e53[14] = t3[14] + r[14], e53[15] = t3[15] + r[15], e53;
}
function Zx(e53, t3, r) {
  return e53[0] = t3[0] - r[0], e53[1] = t3[1] - r[1], e53[2] = t3[2] - r[2], e53[3] = t3[3] - r[3], e53[4] = t3[4] - r[4], e53[5] = t3[5] - r[5], e53[6] = t3[6] - r[6], e53[7] = t3[7] - r[7], e53[8] = t3[8] - r[8], e53[9] = t3[9] - r[9], e53[10] = t3[10] - r[10], e53[11] = t3[11] - r[11], e53[12] = t3[12] - r[12], e53[13] = t3[13] - r[13], e53[14] = t3[14] - r[14], e53[15] = t3[15] - r[15], e53;
}
function ST(e53, t3, r) {
  return e53[0] = t3[0] * r, e53[1] = t3[1] * r, e53[2] = t3[2] * r, e53[3] = t3[3] * r, e53[4] = t3[4] * r, e53[5] = t3[5] * r, e53[6] = t3[6] * r, e53[7] = t3[7] * r, e53[8] = t3[8] * r, e53[9] = t3[9] * r, e53[10] = t3[10] * r, e53[11] = t3[11] * r, e53[12] = t3[12] * r, e53[13] = t3[13] * r, e53[14] = t3[14] * r, e53[15] = t3[15] * r, e53;
}
function PT(e53, t3, r, i) {
  return e53[0] = t3[0] + r[0] * i, e53[1] = t3[1] + r[1] * i, e53[2] = t3[2] + r[2] * i, e53[3] = t3[3] + r[3] * i, e53[4] = t3[4] + r[4] * i, e53[5] = t3[5] + r[5] * i, e53[6] = t3[6] + r[6] * i, e53[7] = t3[7] + r[7] * i, e53[8] = t3[8] + r[8] * i, e53[9] = t3[9] + r[9] * i, e53[10] = t3[10] + r[10] * i, e53[11] = t3[11] + r[11] * i, e53[12] = t3[12] + r[12] * i, e53[13] = t3[13] + r[13] * i, e53[14] = t3[14] + r[14] * i, e53[15] = t3[15] + r[15] * i, e53;
}
function TT(e53, t3) {
  return e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && e53[3] === t3[3] && e53[4] === t3[4] && e53[5] === t3[5] && e53[6] === t3[6] && e53[7] === t3[7] && e53[8] === t3[8] && e53[9] === t3[9] && e53[10] === t3[10] && e53[11] === t3[11] && e53[12] === t3[12] && e53[13] === t3[13] && e53[14] === t3[14] && e53[15] === t3[15];
}
function AT(e53, t3) {
  var r = e53[0], i = e53[1], a = e53[2], n = e53[3], s3 = e53[4], o = e53[5], l = e53[6], u3 = e53[7], c3 = e53[8], h = e53[9], p = e53[10], d = e53[11], f = e53[12], m = e53[13], y = e53[14], g = e53[15], _ = t3[0], x = t3[1], v = t3[2], b = t3[3], w = t3[4], S = t3[5], A = t3[6], M3 = t3[7], I = t3[8], T = t3[9], C = t3[10], P = t3[11], k = t3[12], z3 = t3[13], E = t3[14], D = t3[15];
  return Math.abs(r - _) <= ie * Math.max(1, Math.abs(r), Math.abs(_)) && Math.abs(i - x) <= ie * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(a - v) <= ie * Math.max(1, Math.abs(a), Math.abs(v)) && Math.abs(n - b) <= ie * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(s3 - w) <= ie * Math.max(1, Math.abs(s3), Math.abs(w)) && Math.abs(o - S) <= ie * Math.max(1, Math.abs(o), Math.abs(S)) && Math.abs(l - A) <= ie * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(u3 - M3) <= ie * Math.max(1, Math.abs(u3), Math.abs(M3)) && Math.abs(c3 - I) <= ie * Math.max(1, Math.abs(c3), Math.abs(I)) && Math.abs(h - T) <= ie * Math.max(1, Math.abs(h), Math.abs(T)) && Math.abs(p - C) <= ie * Math.max(1, Math.abs(p), Math.abs(C)) && Math.abs(d - P) <= ie * Math.max(1, Math.abs(d), Math.abs(P)) && Math.abs(f - k) <= ie * Math.max(1, Math.abs(f), Math.abs(k)) && Math.abs(m - z3) <= ie * Math.max(1, Math.abs(m), Math.abs(z3)) && Math.abs(y - E) <= ie * Math.max(1, Math.abs(y), Math.abs(E)) && Math.abs(g - D) <= ie * Math.max(1, Math.abs(g), Math.abs(D));
}
q(gT, "orthoZO"), q(xT, "lookAt"), q(bT, "targetTo"), q(_T, "str"), q(vT, "frob"), q(wT, "add"), q(Zx, "subtract"), q(ST, "multiplyScalar"), q(PT, "multiplyScalarAndAdd"), q(TT, "exactEquals"), q(AT, "equals");
var IT = Gx;
var MT = Zx;
var gt = {};
function Wx() {
  var e53 = new we(3);
  return we != Float32Array && (e53[0] = 0, e53[1] = 0, e53[2] = 0), e53;
}
function CT(e53) {
  var t3 = new we(3);
  return t3[0] = e53[0], t3[1] = e53[1], t3[2] = e53[2], t3;
}
function Xx(e53) {
  var t3 = e53[0], r = e53[1], i = e53[2];
  return Math.hypot(t3, r, i);
}
function ET(e53, t3, r) {
  var i = new we(3);
  return i[0] = e53, i[1] = t3, i[2] = r, i;
}
function kT(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53;
}
function LT(e53, t3, r, i) {
  return e53[0] = t3, e53[1] = r, e53[2] = i, e53;
}
function DT(e53, t3, r) {
  return e53[0] = t3[0] + r[0], e53[1] = t3[1] + r[1], e53[2] = t3[2] + r[2], e53;
}
function Kx(e53, t3, r) {
  return e53[0] = t3[0] - r[0], e53[1] = t3[1] - r[1], e53[2] = t3[2] - r[2], e53;
}
function Yx(e53, t3, r) {
  return e53[0] = t3[0] * r[0], e53[1] = t3[1] * r[1], e53[2] = t3[2] * r[2], e53;
}
function Jx(e53, t3, r) {
  return e53[0] = t3[0] / r[0], e53[1] = t3[1] / r[1], e53[2] = t3[2] / r[2], e53;
}
function zT(e53, t3) {
  return e53[0] = Math.ceil(t3[0]), e53[1] = Math.ceil(t3[1]), e53[2] = Math.ceil(t3[2]), e53;
}
function FT(e53, t3) {
  return e53[0] = Math.floor(t3[0]), e53[1] = Math.floor(t3[1]), e53[2] = Math.floor(t3[2]), e53;
}
function BT(e53, t3, r) {
  return e53[0] = Math.min(t3[0], r[0]), e53[1] = Math.min(t3[1], r[1]), e53[2] = Math.min(t3[2], r[2]), e53;
}
function RT(e53, t3, r) {
  return e53[0] = Math.max(t3[0], r[0]), e53[1] = Math.max(t3[1], r[1]), e53[2] = Math.max(t3[2], r[2]), e53;
}
function OT(e53, t3) {
  return e53[0] = Math.round(t3[0]), e53[1] = Math.round(t3[1]), e53[2] = Math.round(t3[2]), e53;
}
function VT(e53, t3, r) {
  return e53[0] = t3[0] * r, e53[1] = t3[1] * r, e53[2] = t3[2] * r, e53;
}
function UT(e53, t3, r, i) {
  return e53[0] = t3[0] + r[0] * i, e53[1] = t3[1] + r[1] * i, e53[2] = t3[2] + r[2] * i, e53;
}
function Qx(e53, t3) {
  var r = t3[0] - e53[0], i = t3[1] - e53[1], a = t3[2] - e53[2];
  return Math.hypot(r, i, a);
}
function eb(e53, t3) {
  var r = t3[0] - e53[0], i = t3[1] - e53[1], a = t3[2] - e53[2];
  return r * r + i * i + a * a;
}
function tb(e53) {
  var t3 = e53[0], r = e53[1], i = e53[2];
  return t3 * t3 + r * r + i * i;
}
function NT(e53, t3) {
  return e53[0] = -t3[0], e53[1] = -t3[1], e53[2] = -t3[2], e53;
}
function GT(e53, t3) {
  return e53[0] = 1 / t3[0], e53[1] = 1 / t3[1], e53[2] = 1 / t3[2], e53;
}
function qT(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = r * r + i * i + a * a;
  return n > 0 && (n = 1 / Math.sqrt(n)), e53[0] = t3[0] * n, e53[1] = t3[1] * n, e53[2] = t3[2] * n, e53;
}
function rb(e53, t3) {
  return e53[0] * t3[0] + e53[1] * t3[1] + e53[2] * t3[2];
}
function jT(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = r[0], o = r[1], l = r[2];
  return e53[0] = a * l - n * o, e53[1] = n * s3 - i * l, e53[2] = i * o - a * s3, e53;
}
function $T(e53, t3, r, i) {
  var a = t3[0], n = t3[1], s3 = t3[2];
  return e53[0] = a + i * (r[0] - a), e53[1] = n + i * (r[1] - n), e53[2] = s3 + i * (r[2] - s3), e53;
}
function HT(e53, t3, r, i, a, n) {
  var s3 = n * n, o = s3 * (2 * n - 3) + 1, l = s3 * (n - 2) + n, u3 = s3 * (n - 1), c3 = s3 * (3 - 2 * n);
  return e53[0] = t3[0] * o + r[0] * l + i[0] * u3 + a[0] * c3, e53[1] = t3[1] * o + r[1] * l + i[1] * u3 + a[1] * c3, e53[2] = t3[2] * o + r[2] * l + i[2] * u3 + a[2] * c3, e53;
}
function ZT(e53, t3, r, i, a, n) {
  var s3 = 1 - n, o = s3 * s3, l = n * n, u3 = o * s3, c3 = 3 * n * o, h = 3 * l * s3, p = l * n;
  return e53[0] = t3[0] * u3 + r[0] * c3 + i[0] * h + a[0] * p, e53[1] = t3[1] * u3 + r[1] * c3 + i[1] * h + a[1] * p, e53[2] = t3[2] * u3 + r[2] * c3 + i[2] * h + a[2] * p, e53;
}
function WT(e53, t3) {
  t3 = t3 || 1;
  var r = 2 * $t() * Math.PI, i = 2 * $t() - 1, a = Math.sqrt(1 - i * i) * t3;
  return e53[0] = Math.cos(r) * a, e53[1] = Math.sin(r) * a, e53[2] = i * t3, e53;
}
function XT(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = r[3] * i + r[7] * a + r[11] * n + r[15];
  return s3 = s3 || 1, e53[0] = (r[0] * i + r[4] * a + r[8] * n + r[12]) / s3, e53[1] = (r[1] * i + r[5] * a + r[9] * n + r[13]) / s3, e53[2] = (r[2] * i + r[6] * a + r[10] * n + r[14]) / s3, e53;
}
function KT(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2];
  return e53[0] = i * r[0] + a * r[3] + n * r[6], e53[1] = i * r[1] + a * r[4] + n * r[7], e53[2] = i * r[2] + a * r[5] + n * r[8], e53;
}
function YT(e53, t3, r) {
  var i = r[0], a = r[1], n = r[2], s3 = r[3], o = t3[0], l = t3[1], u3 = t3[2], c3 = a * u3 - n * l, h = n * o - i * u3, p = i * l - a * o, d = a * p - n * h, f = n * c3 - i * p, m = i * h - a * c3, y = 2 * s3;
  return c3 *= y, h *= y, p *= y, d *= 2, f *= 2, m *= 2, e53[0] = o + c3 + d, e53[1] = l + h + f, e53[2] = u3 + p + m, e53;
}
function JT(e53, t3, r, i) {
  var a = [], n = [];
  return a[0] = t3[0] - r[0], a[1] = t3[1] - r[1], a[2] = t3[2] - r[2], n[0] = a[0], n[1] = a[1] * Math.cos(i) - a[2] * Math.sin(i), n[2] = a[1] * Math.sin(i) + a[2] * Math.cos(i), e53[0] = n[0] + r[0], e53[1] = n[1] + r[1], e53[2] = n[2] + r[2], e53;
}
function QT(e53, t3, r, i) {
  var a = [], n = [];
  return a[0] = t3[0] - r[0], a[1] = t3[1] - r[1], a[2] = t3[2] - r[2], n[0] = a[2] * Math.sin(i) + a[0] * Math.cos(i), n[1] = a[1], n[2] = a[2] * Math.cos(i) - a[0] * Math.sin(i), e53[0] = n[0] + r[0], e53[1] = n[1] + r[1], e53[2] = n[2] + r[2], e53;
}
function eA(e53, t3, r, i) {
  var a = [], n = [];
  return a[0] = t3[0] - r[0], a[1] = t3[1] - r[1], a[2] = t3[2] - r[2], n[0] = a[0] * Math.cos(i) - a[1] * Math.sin(i), n[1] = a[0] * Math.sin(i) + a[1] * Math.cos(i), n[2] = a[2], e53[0] = n[0] + r[0], e53[1] = n[1] + r[1], e53[2] = n[2] + r[2], e53;
}
function tA(e53, t3) {
  var r = e53[0], i = e53[1], a = e53[2], n = t3[0], s3 = t3[1], o = t3[2], l = Math.sqrt(r * r + i * i + a * a) * Math.sqrt(n * n + s3 * s3 + o * o), u3 = l && rb(e53, t3) / l;
  return Math.acos(Math.min(Math.max(u3, -1), 1));
}
function rA(e53) {
  return e53[0] = 0, e53[1] = 0, e53[2] = 0, e53;
}
function iA(e53) {
  return "vec3(" + e53[0] + ", " + e53[1] + ", " + e53[2] + ")";
}
function nA(e53, t3) {
  return e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2];
}
function aA(e53, t3) {
  var r = e53[0], i = e53[1], a = e53[2], n = t3[0], s3 = t3[1], o = t3[2];
  return Math.abs(r - n) <= ie * Math.max(1, Math.abs(r), Math.abs(n)) && Math.abs(i - s3) <= ie * Math.max(1, Math.abs(i), Math.abs(s3)) && Math.abs(a - o) <= ie * Math.max(1, Math.abs(a), Math.abs(o));
}
t(gt, { add: () => DT, angle: () => tA, bezier: () => ZT, ceil: () => zT, clone: () => CT, copy: () => kT, create: () => Wx, cross: () => jT, dist: () => uA, distance: () => Qx, div: () => lA, divide: () => Jx, dot: () => rb, equals: () => aA, exactEquals: () => nA, floor: () => FT, forEach: () => fA, fromValues: () => ET, hermite: () => HT, inverse: () => GT, len: () => pA, length: () => Xx, lerp: () => $T, max: () => RT, min: () => BT, mul: () => sA, multiply: () => Yx, negate: () => NT, normalize: () => qT, random: () => WT, rotateX: () => JT, rotateY: () => QT, rotateZ: () => eA, round: () => OT, scale: () => VT, scaleAndAdd: () => UT, set: () => LT, sqrDist: () => cA, sqrLen: () => hA, squaredDistance: () => eb, squaredLength: () => tb, str: () => iA, sub: () => oA, subtract: () => Kx, transformMat3: () => KT, transformMat4: () => XT, transformQuat: () => YT, zero: () => rA }), c(), q(Wx, "create"), q(CT, "clone"), q(Xx, "length"), q(ET, "fromValues"), q(kT, "copy"), q(LT, "set"), q(DT, "add"), q(Kx, "subtract"), q(Yx, "multiply"), q(Jx, "divide"), q(zT, "ceil"), q(FT, "floor"), q(BT, "min"), q(RT, "max"), q(OT, "round"), q(VT, "scale"), q(UT, "scaleAndAdd"), q(Qx, "distance"), q(eb, "squaredDistance"), q(tb, "squaredLength"), q(NT, "negate"), q(GT, "inverse"), q(qT, "normalize"), q(rb, "dot"), q(jT, "cross"), q($T, "lerp"), q(HT, "hermite"), q(ZT, "bezier"), q(WT, "random"), q(XT, "transformMat4"), q(KT, "transformMat3"), q(YT, "transformQuat"), q(JT, "rotateX"), q(QT, "rotateY"), q(eA, "rotateZ"), q(tA, "angle"), q(rA, "zero"), q(iA, "str"), q(nA, "exactEquals"), q(aA, "equals");
var oA = Kx;
var sA = Yx;
var lA = Jx;
var uA = Qx;
var cA = eb;
var pA = Xx;
var hA = tb;
var fA = function() {
  var e53 = Wx();
  return function(t3, r, i, a, n, s3) {
    var o, l;
    for (r || (r = 3), i || (i = 0), l = a ? Math.min(a * r + i, t3.length) : t3.length, o = i; o < l; o += r)
      e53[0] = t3[o], e53[1] = t3[o + 1], e53[2] = t3[o + 2], n(e53, e53, s3), t3[o] = e53[0], t3[o + 1] = e53[1], t3[o + 2] = e53[2];
    return t3;
  };
}();
var Xe = {};
function ib() {
  var e53 = new we(4);
  return we != Float32Array && (e53[0] = 0, e53[1] = 0, e53[2] = 0, e53[3] = 0), e53;
}
function mA(e53) {
  var t3 = new we(4);
  return t3[0] = e53[0], t3[1] = e53[1], t3[2] = e53[2], t3[3] = e53[3], t3;
}
function dA(e53, t3, r, i) {
  var a = new we(4);
  return a[0] = e53, a[1] = t3, a[2] = r, a[3] = i, a;
}
function yA(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53[2] = t3[2], e53[3] = t3[3], e53;
}
function gA(e53, t3, r, i, a) {
  return e53[0] = t3, e53[1] = r, e53[2] = i, e53[3] = a, e53;
}
function xA(e53, t3, r) {
  return e53[0] = t3[0] + r[0], e53[1] = t3[1] + r[1], e53[2] = t3[2] + r[2], e53[3] = t3[3] + r[3], e53;
}
function nb(e53, t3, r) {
  return e53[0] = t3[0] - r[0], e53[1] = t3[1] - r[1], e53[2] = t3[2] - r[2], e53[3] = t3[3] - r[3], e53;
}
function ab(e53, t3, r) {
  return e53[0] = t3[0] * r[0], e53[1] = t3[1] * r[1], e53[2] = t3[2] * r[2], e53[3] = t3[3] * r[3], e53;
}
function ob(e53, t3, r) {
  return e53[0] = t3[0] / r[0], e53[1] = t3[1] / r[1], e53[2] = t3[2] / r[2], e53[3] = t3[3] / r[3], e53;
}
function bA(e53, t3) {
  return e53[0] = Math.ceil(t3[0]), e53[1] = Math.ceil(t3[1]), e53[2] = Math.ceil(t3[2]), e53[3] = Math.ceil(t3[3]), e53;
}
function _A(e53, t3) {
  return e53[0] = Math.floor(t3[0]), e53[1] = Math.floor(t3[1]), e53[2] = Math.floor(t3[2]), e53[3] = Math.floor(t3[3]), e53;
}
function vA(e53, t3, r) {
  return e53[0] = Math.min(t3[0], r[0]), e53[1] = Math.min(t3[1], r[1]), e53[2] = Math.min(t3[2], r[2]), e53[3] = Math.min(t3[3], r[3]), e53;
}
function wA(e53, t3, r) {
  return e53[0] = Math.max(t3[0], r[0]), e53[1] = Math.max(t3[1], r[1]), e53[2] = Math.max(t3[2], r[2]), e53[3] = Math.max(t3[3], r[3]), e53;
}
function SA(e53, t3) {
  return e53[0] = Math.round(t3[0]), e53[1] = Math.round(t3[1]), e53[2] = Math.round(t3[2]), e53[3] = Math.round(t3[3]), e53;
}
function PA(e53, t3, r) {
  return e53[0] = t3[0] * r, e53[1] = t3[1] * r, e53[2] = t3[2] * r, e53[3] = t3[3] * r, e53;
}
function TA(e53, t3, r, i) {
  return e53[0] = t3[0] + r[0] * i, e53[1] = t3[1] + r[1] * i, e53[2] = t3[2] + r[2] * i, e53[3] = t3[3] + r[3] * i, e53;
}
function sb(e53, t3) {
  var r = t3[0] - e53[0], i = t3[1] - e53[1], a = t3[2] - e53[2], n = t3[3] - e53[3];
  return Math.hypot(r, i, a, n);
}
function lb(e53, t3) {
  var r = t3[0] - e53[0], i = t3[1] - e53[1], a = t3[2] - e53[2], n = t3[3] - e53[3];
  return r * r + i * i + a * a + n * n;
}
function ub(e53) {
  var t3 = e53[0], r = e53[1], i = e53[2], a = e53[3];
  return Math.hypot(t3, r, i, a);
}
function cb(e53) {
  var t3 = e53[0], r = e53[1], i = e53[2], a = e53[3];
  return t3 * t3 + r * r + i * i + a * a;
}
function AA(e53, t3) {
  return e53[0] = -t3[0], e53[1] = -t3[1], e53[2] = -t3[2], e53[3] = -t3[3], e53;
}
function IA(e53, t3) {
  return e53[0] = 1 / t3[0], e53[1] = 1 / t3[1], e53[2] = 1 / t3[2], e53[3] = 1 / t3[3], e53;
}
function MA(e53, t3) {
  var r = t3[0], i = t3[1], a = t3[2], n = t3[3], s3 = r * r + i * i + a * a + n * n;
  return s3 > 0 && (s3 = 1 / Math.sqrt(s3)), e53[0] = r * s3, e53[1] = i * s3, e53[2] = a * s3, e53[3] = n * s3, e53;
}
function CA(e53, t3) {
  return e53[0] * t3[0] + e53[1] * t3[1] + e53[2] * t3[2] + e53[3] * t3[3];
}
function EA(e53, t3, r, i) {
  var a = r[0] * i[1] - r[1] * i[0], n = r[0] * i[2] - r[2] * i[0], s3 = r[0] * i[3] - r[3] * i[0], o = r[1] * i[2] - r[2] * i[1], l = r[1] * i[3] - r[3] * i[1], u3 = r[2] * i[3] - r[3] * i[2], c3 = t3[0], h = t3[1], p = t3[2], d = t3[3];
  return e53[0] = h * u3 - p * l + d * o, e53[1] = -c3 * u3 + p * s3 - d * n, e53[2] = c3 * l - h * s3 + d * a, e53[3] = -c3 * o + h * n - p * a, e53;
}
function kA(e53, t3, r, i) {
  var a = t3[0], n = t3[1], s3 = t3[2], o = t3[3];
  return e53[0] = a + i * (r[0] - a), e53[1] = n + i * (r[1] - n), e53[2] = s3 + i * (r[2] - s3), e53[3] = o + i * (r[3] - o), e53;
}
function LA(e53, t3) {
  var r, i, a, n, s3, o;
  t3 = t3 || 1;
  do {
    s3 = (r = 2 * $t() - 1) * r + (i = 2 * $t() - 1) * i;
  } while (s3 >= 1);
  do {
    o = (a = 2 * $t() - 1) * a + (n = 2 * $t() - 1) * n;
  } while (o >= 1);
  var l = Math.sqrt((1 - s3) / o);
  return e53[0] = t3 * r, e53[1] = t3 * i, e53[2] = t3 * a * l, e53[3] = t3 * n * l, e53;
}
function DA(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = t3[3];
  return e53[0] = r[0] * i + r[4] * a + r[8] * n + r[12] * s3, e53[1] = r[1] * i + r[5] * a + r[9] * n + r[13] * s3, e53[2] = r[2] * i + r[6] * a + r[10] * n + r[14] * s3, e53[3] = r[3] * i + r[7] * a + r[11] * n + r[15] * s3, e53;
}
function zA(e53, t3, r) {
  var i = t3[0], a = t3[1], n = t3[2], s3 = r[0], o = r[1], l = r[2], u3 = r[3], c3 = u3 * i + o * n - l * a, h = u3 * a + l * i - s3 * n, p = u3 * n + s3 * a - o * i, d = -s3 * i - o * a - l * n;
  return e53[0] = c3 * u3 + d * -s3 + h * -l - p * -o, e53[1] = h * u3 + d * -o + p * -s3 - c3 * -l, e53[2] = p * u3 + d * -l + c3 * -o - h * -s3, e53[3] = t3[3], e53;
}
function FA(e53) {
  return e53[0] = 0, e53[1] = 0, e53[2] = 0, e53[3] = 0, e53;
}
function BA(e53) {
  return "vec4(" + e53[0] + ", " + e53[1] + ", " + e53[2] + ", " + e53[3] + ")";
}
function RA(e53, t3) {
  return e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && e53[3] === t3[3];
}
function OA(e53, t3) {
  var r = e53[0], i = e53[1], a = e53[2], n = e53[3], s3 = t3[0], o = t3[1], l = t3[2], u3 = t3[3];
  return Math.abs(r - s3) <= ie * Math.max(1, Math.abs(r), Math.abs(s3)) && Math.abs(i - o) <= ie * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(a - l) <= ie * Math.max(1, Math.abs(a), Math.abs(l)) && Math.abs(n - u3) <= ie * Math.max(1, Math.abs(n), Math.abs(u3));
}
t(Xe, { add: () => xA, ceil: () => bA, clone: () => mA, copy: () => yA, create: () => ib, cross: () => EA, dist: () => GA, distance: () => sb, div: () => NA, divide: () => ob, dot: () => CA, equals: () => OA, exactEquals: () => RA, floor: () => _A, forEach: () => HA, fromValues: () => dA, inverse: () => IA, len: () => jA, length: () => ub, lerp: () => kA, max: () => wA, min: () => vA, mul: () => UA, multiply: () => ab, negate: () => AA, normalize: () => MA, random: () => LA, round: () => SA, scale: () => PA, scaleAndAdd: () => TA, set: () => gA, sqrDist: () => qA, sqrLen: () => $A, squaredDistance: () => lb, squaredLength: () => cb, str: () => BA, sub: () => VA, subtract: () => nb, transformMat4: () => DA, transformQuat: () => zA, zero: () => FA }), c(), q(ib, "create"), q(mA, "clone"), q(dA, "fromValues"), q(yA, "copy"), q(gA, "set"), q(xA, "add"), q(nb, "subtract"), q(ab, "multiply"), q(ob, "divide"), q(bA, "ceil"), q(_A, "floor"), q(vA, "min"), q(wA, "max"), q(SA, "round"), q(PA, "scale"), q(TA, "scaleAndAdd"), q(sb, "distance"), q(lb, "squaredDistance"), q(ub, "length"), q(cb, "squaredLength"), q(AA, "negate"), q(IA, "inverse"), q(MA, "normalize"), q(CA, "dot"), q(EA, "cross"), q(kA, "lerp"), q(LA, "random"), q(DA, "transformMat4"), q(zA, "transformQuat"), q(FA, "zero"), q(BA, "str"), q(RA, "exactEquals"), q(OA, "equals");
var VA = nb;
var UA = ab;
var NA = ob;
var GA = sb;
var qA = lb;
var jA = ub;
var $A = cb;
var HA = function() {
  var e53 = ib();
  return function(t3, r, i, a, n, s3) {
    var o, l;
    for (r || (r = 4), i || (i = 0), l = a ? Math.min(a * r + i, t3.length) : t3.length, o = i; o < l; o += r)
      e53[0] = t3[o], e53[1] = t3[o + 1], e53[2] = t3[o + 2], e53[3] = t3[o + 3], n(e53, e53, s3), t3[o] = e53[0], t3[o + 1] = e53[1], t3[o + 2] = e53[2], t3[o + 3] = e53[3];
    return t3;
  };
}();
var Xi = {};
function pb() {
  var e53 = new we(2);
  return we != Float32Array && (e53[0] = 0, e53[1] = 0), e53;
}
function ZA(e53) {
  var t3 = new we(2);
  return t3[0] = e53[0], t3[1] = e53[1], t3;
}
function WA(e53, t3) {
  var r = new we(2);
  return r[0] = e53, r[1] = t3, r;
}
function XA(e53, t3) {
  return e53[0] = t3[0], e53[1] = t3[1], e53;
}
function KA(e53, t3, r) {
  return e53[0] = t3, e53[1] = r, e53;
}
function YA(e53, t3, r) {
  return e53[0] = t3[0] + r[0], e53[1] = t3[1] + r[1], e53;
}
function hb(e53, t3, r) {
  return e53[0] = t3[0] - r[0], e53[1] = t3[1] - r[1], e53;
}
function fb(e53, t3, r) {
  return e53[0] = t3[0] * r[0], e53[1] = t3[1] * r[1], e53;
}
function mb(e53, t3, r) {
  return e53[0] = t3[0] / r[0], e53[1] = t3[1] / r[1], e53;
}
function JA(e53, t3) {
  return e53[0] = Math.ceil(t3[0]), e53[1] = Math.ceil(t3[1]), e53;
}
function QA(e53, t3) {
  return e53[0] = Math.floor(t3[0]), e53[1] = Math.floor(t3[1]), e53;
}
function eI(e53, t3, r) {
  return e53[0] = Math.min(t3[0], r[0]), e53[1] = Math.min(t3[1], r[1]), e53;
}
function tI(e53, t3, r) {
  return e53[0] = Math.max(t3[0], r[0]), e53[1] = Math.max(t3[1], r[1]), e53;
}
function rI(e53, t3) {
  return e53[0] = Math.round(t3[0]), e53[1] = Math.round(t3[1]), e53;
}
function iI(e53, t3, r) {
  return e53[0] = t3[0] * r, e53[1] = t3[1] * r, e53;
}
function nI(e53, t3, r, i) {
  return e53[0] = t3[0] + r[0] * i, e53[1] = t3[1] + r[1] * i, e53;
}
function db(e53, t3) {
  var r = t3[0] - e53[0], i = t3[1] - e53[1];
  return Math.hypot(r, i);
}
function yb(e53, t3) {
  var r = t3[0] - e53[0], i = t3[1] - e53[1];
  return r * r + i * i;
}
function gb(e53) {
  var t3 = e53[0], r = e53[1];
  return Math.hypot(t3, r);
}
function xb(e53) {
  var t3 = e53[0], r = e53[1];
  return t3 * t3 + r * r;
}
function aI(e53, t3) {
  return e53[0] = -t3[0], e53[1] = -t3[1], e53;
}
function oI(e53, t3) {
  return e53[0] = 1 / t3[0], e53[1] = 1 / t3[1], e53;
}
function sI(e53, t3) {
  var r = t3[0], i = t3[1], a = r * r + i * i;
  return a > 0 && (a = 1 / Math.sqrt(a)), e53[0] = t3[0] * a, e53[1] = t3[1] * a, e53;
}
function lI(e53, t3) {
  return e53[0] * t3[0] + e53[1] * t3[1];
}
function uI(e53, t3, r) {
  var i = t3[0] * r[1] - t3[1] * r[0];
  return e53[0] = e53[1] = 0, e53[2] = i, e53;
}
function cI(e53, t3, r, i) {
  var a = t3[0], n = t3[1];
  return e53[0] = a + i * (r[0] - a), e53[1] = n + i * (r[1] - n), e53;
}
function pI(e53, t3) {
  t3 = t3 || 1;
  var r = 2 * $t() * Math.PI;
  return e53[0] = Math.cos(r) * t3, e53[1] = Math.sin(r) * t3, e53;
}
function hI(e53, t3, r) {
  var i = t3[0], a = t3[1];
  return e53[0] = r[0] * i + r[2] * a, e53[1] = r[1] * i + r[3] * a, e53;
}
function fI(e53, t3, r) {
  var i = t3[0], a = t3[1];
  return e53[0] = r[0] * i + r[2] * a + r[4], e53[1] = r[1] * i + r[3] * a + r[5], e53;
}
function mI(e53, t3, r) {
  var i = t3[0], a = t3[1];
  return e53[0] = r[0] * i + r[3] * a + r[6], e53[1] = r[1] * i + r[4] * a + r[7], e53;
}
function dI(e53, t3, r) {
  var i = t3[0], a = t3[1];
  return e53[0] = r[0] * i + r[4] * a + r[12], e53[1] = r[1] * i + r[5] * a + r[13], e53;
}
function yI(e53, t3, r, i) {
  var a = t3[0] - r[0], n = t3[1] - r[1], s3 = Math.sin(i), o = Math.cos(i);
  return e53[0] = a * o - n * s3 + r[0], e53[1] = a * s3 + n * o + r[1], e53;
}
function gI(e53, t3) {
  var r = e53[0], i = e53[1], a = t3[0], n = t3[1], s3 = Math.sqrt(r * r + i * i) * Math.sqrt(a * a + n * n), o = s3 && (r * a + i * n) / s3;
  return Math.acos(Math.min(Math.max(o, -1), 1));
}
function xI(e53) {
  return e53[0] = 0, e53[1] = 0, e53;
}
function bI(e53) {
  return "vec2(" + e53[0] + ", " + e53[1] + ")";
}
function _I(e53, t3) {
  return e53[0] === t3[0] && e53[1] === t3[1];
}
function vI(e53, t3) {
  var r = e53[0], i = e53[1], a = t3[0], n = t3[1];
  return Math.abs(r - a) <= ie * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(i - n) <= ie * Math.max(1, Math.abs(i), Math.abs(n));
}
t(Xi, { add: () => YA, angle: () => gI, ceil: () => JA, clone: () => ZA, copy: () => XA, create: () => pb, cross: () => uI, dist: () => AI, distance: () => db, div: () => TI, divide: () => mb, dot: () => lI, equals: () => vI, exactEquals: () => _I, floor: () => QA, forEach: () => CI, fromValues: () => WA, inverse: () => oI, len: () => wI, length: () => gb, lerp: () => cI, max: () => tI, min: () => eI, mul: () => PI, multiply: () => fb, negate: () => aI, normalize: () => sI, random: () => pI, rotate: () => yI, round: () => rI, scale: () => iI, scaleAndAdd: () => nI, set: () => KA, sqrDist: () => II, sqrLen: () => MI, squaredDistance: () => yb, squaredLength: () => xb, str: () => bI, sub: () => SI, subtract: () => hb, transformMat2: () => hI, transformMat2d: () => fI, transformMat3: () => mI, transformMat4: () => dI, zero: () => xI }), c(), q(pb, "create"), q(ZA, "clone"), q(WA, "fromValues"), q(XA, "copy"), q(KA, "set"), q(YA, "add"), q(hb, "subtract"), q(fb, "multiply"), q(mb, "divide"), q(JA, "ceil"), q(QA, "floor"), q(eI, "min"), q(tI, "max"), q(rI, "round"), q(iI, "scale"), q(nI, "scaleAndAdd"), q(db, "distance"), q(yb, "squaredDistance"), q(gb, "length"), q(xb, "squaredLength"), q(aI, "negate"), q(oI, "inverse"), q(sI, "normalize"), q(lI, "dot"), q(uI, "cross"), q(cI, "lerp"), q(pI, "random"), q(hI, "transformMat2"), q(fI, "transformMat2d"), q(mI, "transformMat3"), q(dI, "transformMat4"), q(yI, "rotate"), q(gI, "angle"), q(xI, "zero"), q(bI, "str"), q(_I, "exactEquals"), q(vI, "equals");
var wI = gb;
var SI = hb;
var PI = fb;
var TI = mb;
var AI = db;
var II = yb;
var MI = xb;
var CI = function() {
  var e53 = pb();
  return function(t3, r, i, a, n, s3) {
    var o, l;
    for (r || (r = 2), i || (i = 0), l = a ? Math.min(a * r + i, t3.length) : t3.length, o = i; o < l; o += r)
      e53[0] = t3[o], e53[1] = t3[o + 1], n(e53, e53, s3), t3[o] = e53[0], t3[o + 1] = e53[1];
    return t3;
  };
}();
var bb = u(Pe(), 1);
var lf = class extends je {
  constructor(e53) {
    super(e53, Bx);
  }
  createBucket(e53) {
    return new ai(e53);
  }
  queryRadius(e53) {
    let t3 = e53;
    return oi("circle-radius", this, t3) + oi("circle-stroke-width", this, t3) + Mr(this.paint.get("circle-translate"));
  }
  queryIntersectsFeature(e53, t3, r, i, a, n, s3, o) {
    let l = Cr(e53, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), n.angle, s3), u3 = this.paint.get("circle-radius").evaluate(t3, r) + this.paint.get("circle-stroke-width").evaluate(t3, r), c3 = "map" === this.paint.get("circle-pitch-alignment"), h = c3 ? l : EI(l, o), p = c3 ? u3 * s3 : u3;
    for (let e54 of i)
      for (let t4 of e54) {
        let e55 = c3 ? t4 : _b(t4, o), r3 = p, i3 = Xe.transformMat4([], [t4.x, t4.y, 0, 1], o);
        if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= i3[3] / n.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= n.cameraToCenterDistance / i3[3]), Cx(h, e55, r3))
          return true;
      }
    return false;
  }
};
q(lf, "CircleStyleLayer");
var Os = lf;
function _b(e53, t3) {
  let r = Xe.transformMat4([], [e53.x, e53.y, 0, 1], t3);
  return new bb.default(r[0] / r[3], r[1] / r[3]);
}
function EI(e53, t3) {
  return e53.map((e54) => _b(e54, t3));
}
q(_b, "projectPoint"), q(EI, "projectQueryGeometry"), c(), c();
var uf = class extends ai {
};
q(uf, "HeatmapBucket");
var Ia = uf;
G("HeatmapBucket", Ia, { omit: ["layers"] }), c();
var vb;
var kI = q(() => vb = vb || new Re({ "heatmap-radius": new W(M.paint_heatmap["heatmap-radius"]), "heatmap-weight": new W(M.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new $(M.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Qr(M.paint_heatmap["heatmap-color"]), "heatmap-opacity": new $(M.paint_heatmap["heatmap-opacity"]) }), "getPaint");
var wb = { get paint() {
  return kI();
} };
function cf(e53, { width: t3, height: r }, i, a) {
  if (a) {
    if (a instanceof Uint8ClampedArray)
      a = new Uint8Array(a.buffer);
    else if (a.length !== t3 * r * i)
      throw new RangeError("mismatched image size. expected: ".concat(a.length, " but got: ").concat(t3 * r * i));
  } else
    a = new Uint8Array(t3 * r * i);
  return e53.width = t3, e53.height = r, e53.data = a, e53;
}
function Sb(e53, { width: t3, height: r }, i) {
  if (t3 === e53.width && r === e53.height)
    return;
  let a = cf({}, { width: t3, height: r }, i);
  pf(e53, a, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e53.width, t3), height: Math.min(e53.height, r) }, i), e53.width = t3, e53.height = r, e53.data = a.data;
}
function pf(e53, t3, r, i, a, n) {
  if (0 === a.width || 0 === a.height)
    return t3;
  if (a.width > e53.width || a.height > e53.height || r.x > e53.width - a.width || r.y > e53.height - a.height)
    throw new RangeError("out of range source coordinates for image copy");
  if (a.width > t3.width || a.height > t3.height || i.x > t3.width - a.width || i.y > t3.height - a.height)
    throw new RangeError("out of range destination coordinates for image copy");
  let s3 = e53.data, o = t3.data;
  if (s3 === o)
    throw new Error("srcData equals dstData, so image is already copied");
  for (let l = 0; l < a.height; l++) {
    let u3 = ((r.y + l) * e53.width + r.x) * n, c3 = ((i.y + l) * t3.width + i.x) * n;
    for (let e54 = 0; e54 < a.width * n; e54++)
      o[c3 + e54] = s3[u3 + e54];
  }
  return t3;
}
c(), c(), q(cf, "createImage"), q(Sb, "resizeImage"), q(pf, "copyImage");
var Vs = class e35 {
  constructor(e53, t3) {
    cf(this, e53, 1, t3);
  }
  resize(e53) {
    Sb(this, e53, 1);
  }
  clone() {
    return new e35({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e53, t3, r, i, a) {
    pf(e53, t3, r, i, a, 1);
  }
};
q(Vs, "AlphaImage");
var si = Vs;
var Us = class e36 {
  constructor(e53, t3) {
    cf(this, e53, 4, t3);
  }
  resize(e53) {
    Sb(this, e53, 4);
  }
  replace(e53, t3) {
    t3 ? this.data.set(e53) : e53 instanceof Uint8ClampedArray ? this.data = new Uint8Array(e53.buffer) : this.data = e53;
  }
  clone() {
    return new e36({ width: this.width, height: this.height }, new Uint8Array(this.data));
  }
  static copy(e53, t3, r, i, a) {
    pf(e53, t3, r, i, a, 4);
  }
};
q(Us, "RGBAImage");
var Ee = Us;
function Ns(e53) {
  let t3 = {}, r = e53.resolution || 256, i = e53.clips ? e53.clips.length : 1, a = e53.image || new Ee({ width: r, height: i });
  if (!Wy(r))
    throw new Error("width is not a power of 2 - ".concat(r));
  let n = q((r3, i3, n3) => {
    t3[e53.evaluationKey] = n3;
    let s3 = e53.expression.evaluate(t3);
    a.data[r3 + i3 + 0] = Math.floor(255 * s3.r / s3.a), a.data[r3 + i3 + 1] = Math.floor(255 * s3.g / s3.a), a.data[r3 + i3 + 2] = Math.floor(255 * s3.b / s3.a), a.data[r3 + i3 + 3] = Math.floor(255 * s3.a);
  }, "renderPixel");
  if (e53.clips)
    for (let t4 = 0, a3 = 0; t4 < i; ++t4, a3 += 4 * r)
      for (let i3 = 0, s3 = 0; i3 < r; i3++, s3 += 4) {
        let o = i3 / (r - 1), { start: l, end: u3 } = e53.clips[t4];
        n(a3, s3, l * (1 - o) + u3 * o);
      }
  else
    for (let e54 = 0, t4 = 0; e54 < r; e54++, t4 += 4) {
      n(0, t4, e54 / (r - 1));
    }
  return a;
}
G("AlphaImage", si), G("RGBAImage", Ee), q(Ns, "renderColorRamp");
var hf = class extends je {
  constructor(e53) {
    super(e53, wb), this._updateColorRamp();
  }
  createBucket(e53) {
    return new Ia(e53);
  }
  _handleSpecialPaintPropertyUpdate(e53) {
    "heatmap-color" === e53 && this._updateColorRamp();
  }
  _updateColorRamp() {
    let e53 = this._transitionablePaint._values["heatmap-color"].value.expression;
    this.colorRamp = Ns({ expression: e53, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
  }
  resize() {
    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    return false;
  }
  hasOffscreenPass() {
    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
  }
};
q(hf, "HeatmapStyleLayer");
var Gs = hf;
c(), c();
var Pb;
var LI = q(() => Pb = Pb || new Re({ "hillshade-illumination-direction": new $(M.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new $(M.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new $(M.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new $(M.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new $(M.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new $(M.paint_hillshade["hillshade-accent-color"]) }), "getPaint");
var Tb = { get paint() {
  return LI();
} };
var ff = class extends je {
  constructor(e53) {
    super(e53, Tb);
  }
  hasOffscreenPass() {
    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
  }
};
q(ff, "HillshadeStyleLayer");
var qs = ff;
c(), c(), c();
var DI = ve([{ name: "a_pos", components: 2, type: "Int16" }], 4);
var { members: Ab, size: kF, alignment: LF } = DI;
var Mb = u(ue(), 1);
function mf(e53, t3, r, i, a) {
  Ib(e53, t3, r || 0, i || e53.length - 1, a || zI);
}
function Ib(e53, t3, r, i, a) {
  for (; i > r; ) {
    if (i - r > 600) {
      var n = i - r + 1, s3 = t3 - r + 1, o = Math.log(n), l = 0.5 * Math.exp(2 * o / 3), u3 = 0.5 * Math.sqrt(o * l * (n - l) / n) * (s3 - n / 2 < 0 ? -1 : 1);
      Ib(e53, t3, Math.max(r, Math.floor(t3 - s3 * l / n + u3)), Math.min(i, Math.floor(t3 + (n - s3) * l / n + u3)), a);
    }
    var c3 = e53[t3], h = r, p = i;
    for (Ma(e53, r, t3), a(e53[i], c3) > 0 && Ma(e53, r, i); h < p; ) {
      for (Ma(e53, h, p), h++, p--; a(e53[h], c3) < 0; )
        h++;
      for (; a(e53[p], c3) > 0; )
        p--;
    }
    0 === a(e53[r], c3) ? Ma(e53, r, p) : Ma(e53, ++p, i), p <= t3 && (r = p + 1), t3 <= p && (i = p - 1);
  }
}
function Ma(e53, t3, r) {
  var i = e53[t3];
  e53[t3] = e53[r], e53[r] = i;
}
function zI(e53, t3) {
  return e53 < t3 ? -1 : e53 > t3 ? 1 : 0;
}
function Ca(e53, t3) {
  let r = e53.length;
  if (r <= 1)
    return [e53];
  let i, a, n = [];
  for (let t4 = 0; t4 < r; t4++) {
    let r3 = Jy(e53[t4]);
    0 !== r3 && (e53[t4].area = Math.abs(r3), void 0 === a && (a = r3 < 0), a === r3 < 0 ? (i && n.push(i), i = [e53[t4]]) : i.push(e53[t4]));
  }
  if (i && n.push(i), t3 > 1)
    for (let e54 = 0; e54 < n.length; e54++)
      n[e54].length <= t3 || (mf(n[e54], t3, 1, n[e54].length - 1, FI), n[e54] = n[e54].slice(0, t3));
  return n;
}
function FI(e53, t3) {
  return t3.area - e53.area;
}
function Ki(e53, t3, r) {
  let i = r.patternDependencies, a = false;
  for (let r3 of t3) {
    let t4 = r3.paint.get("".concat(e53, "-pattern"));
    t4.isConstant() || (a = true);
    let n = t4.constantOr(null);
    n && (a = true, i[n.to] = true, i[n.from] = true);
  }
  return a;
}
function Yi(e53, t3, r, i, a) {
  let n = a.patternDependencies;
  for (let s3 of t3) {
    let t4 = s3.paint.get("".concat(e53, "-pattern")).value;
    if ("constant" !== t4.kind) {
      let e54 = t4.evaluate({ zoom: i - 1 }, r, {}, a.availableImages), o = t4.evaluate({ zoom: i }, r, {}, a.availableImages), l = t4.evaluate({ zoom: i + 1 }, r, {}, a.availableImages);
      e54 = e54 && e54.name ? e54.name : e54, o = o && o.name ? o.name : o, l = l && l.name ? l.name : l, n[e54] = true, n[o] = true, n[l] = true, r.patterns[s3.id] = { min: e54, mid: o, max: l };
    }
  }
  return r;
}
c(), c(), q(mf, "quickselect"), q(Ib, "quickselectStep"), q(Ma, "swap"), q(zI, "defaultCompare"), q(Ca, "classifyRings"), q(FI, "compareAreas"), c(), q(Ki, "hasPattern"), q(Yi, "addPatternDependencies");
var BI = 500;
var df = class {
  constructor(e53) {
    this.zoom = e53.zoom, this.overscaling = e53.overscaling, this.layers = e53.layers, this.layerIds = this.layers.map((e54) => e54.id), this.index = e53.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new _s(), this.indexArray = new nt(), this.indexArray2 = new Tr(), this.programConfigurations = new mt(e53.layers, e53.zoom), this.segments = new me(), this.segments2 = new me(), this.stateDependentLayerIds = this.layers.filter((e54) => e54.isStateDependent()).map((e54) => e54.id);
  }
  populate(e53, t3, r) {
    this.hasPattern = Ki("fill", this.layers, t3);
    let i = this.layers[0].layout.get("fill-sort-key"), a = !i.isConstant(), n = [];
    for (let { feature: s3, id: o, index: l, sourceLayerIndex: u3 } of e53) {
      let e54 = this.layers[0]._featureFilter.needGeometry, c3 = yt(s3, e54);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), c3, r))
        continue;
      let h = a ? i.evaluate(c3, {}, r, t3.availableImages) : void 0, p = { id: o, properties: s3.properties, type: s3.type, sourceLayerIndex: u3, index: l, geometry: e54 ? c3.geometry : dt(s3), patterns: {}, sortKey: h };
      n.push(p);
    }
    a && n.sort((e54, t4) => e54.sortKey - t4.sortKey);
    for (let i3 of n) {
      let { geometry: a3, index: n3, sourceLayerIndex: s3 } = i3;
      if (this.hasPattern) {
        let e54 = Yi("fill", this.layers, i3, this.zoom, t3);
        this.patternFeatures.push(e54);
      } else
        this.addFeature(i3, a3, n3, r, {});
      let o = e53[n3].feature;
      t3.featureIndex.insert(o, a3, n3, s3, this.index);
    }
  }
  update(e53, t3, r) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e53, t3, this.stateDependentLayers, r);
  }
  addFeatures(e53, t3, r) {
    for (let e54 of this.patternFeatures)
      this.addFeature(e54, e54.geometry, e54.index, t3, r);
  }
  isEmpty() {
    return 0 === this.layoutVertexArray.length;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e53) {
    this.uploaded || (this.layoutVertexBuffer = e53.createVertexBuffer(this.layoutVertexArray, Ab), this.indexBuffer = e53.createIndexBuffer(this.indexArray), this.indexBuffer2 = e53.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e53), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
  }
  addFeature(e53, t3, r, i, a) {
    for (let e54 of Ca(t3, BI)) {
      let t4 = 0;
      for (let r4 of e54)
        t4 += r4.length;
      let r3 = this.segments.prepareSegment(t4, this.layoutVertexArray, this.indexArray), i3 = r3.vertexLength, a3 = [], n = [];
      for (let t5 of e54) {
        if (0 === t5.length)
          continue;
        t5 !== e54[0] && n.push(a3.length / 2);
        let r4 = this.segments2.prepareSegment(t5.length, this.layoutVertexArray, this.indexArray2), i4 = r4.vertexLength;
        this.layoutVertexArray.emplaceBack(t5[0].x, t5[0].y), this.indexArray2.emplaceBack(i4 + t5.length - 1, i4), a3.push(t5[0].x), a3.push(t5[0].y);
        for (let e55 = 1; e55 < t5.length; e55++)
          this.layoutVertexArray.emplaceBack(t5[e55].x, t5[e55].y), this.indexArray2.emplaceBack(i4 + e55 - 1, i4 + e55), a3.push(t5[e55].x), a3.push(t5[e55].y);
        r4.vertexLength += t5.length, r4.primitiveLength += t5.length;
      }
      let s3 = (0, Mb.default)(a3, n);
      for (let e55 = 0; e55 < s3.length; e55 += 3)
        this.indexArray.emplaceBack(i3 + s3[e55], i3 + s3[e55 + 1], i3 + s3[e55 + 2]);
      r3.vertexLength += t4, r3.primitiveLength += s3.length / 3;
    }
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e53, r, a, i);
  }
};
q(df, "FillBucket");
var Ea = df;
G("FillBucket", Ea, { omit: ["layers", "patternFeatures"] }), c();
var Cb;
var Eb;
var RI = q(() => Cb = Cb || new Re({ "fill-sort-key": new W(M.layout_fill["fill-sort-key"]) }), "getLayout");
var OI = q(() => Eb = Eb || new Re({ "fill-antialias": new $(M.paint_fill["fill-antialias"]), "fill-opacity": new W(M.paint_fill["fill-opacity"]), "fill-color": new W(M.paint_fill["fill-color"]), "fill-outline-color": new W(M.paint_fill["fill-outline-color"]), "fill-translate": new $(M.paint_fill["fill-translate"]), "fill-translate-anchor": new $(M.paint_fill["fill-translate-anchor"]), "fill-pattern": new rr(M.paint_fill["fill-pattern"]) }), "getPaint");
var kb = { get paint() {
  return OI();
}, get layout() {
  return RI();
} };
var yf = class extends je {
  constructor(e53) {
    super(e53, kb);
  }
  recalculate(e53, t3) {
    super.recalculate(e53, t3);
    let r = this.paint._values["fill-outline-color"];
    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
  }
  createBucket(e53) {
    return new Ea(e53);
  }
  queryRadius() {
    return Mr(this.paint.get("fill-translate"));
  }
  queryIntersectsFeature(e53, t3, r, i, a, n, s3) {
    return Bs(Cr(e53, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), n.angle, s3), i);
  }
  isTileClipped() {
    return true;
  }
};
q(yf, "FillStyleLayer");
var js = yf;
c(), c(), c();
var VI = ve([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4);
var Lb = ve([{ name: "a_centroid", components: 2, type: "Int16" }], 4);
var { members: Db, size: A3, alignment: I3 } = VI;
var Vb = u(ue(), 1);
var Ub = u(ka(), 1);
var YI = Ub.default.VectorTileFeature.types;
var JI = 500;
var bf = Math.pow(2, 13);
function La(e53, t3, r, i, a, n, s3, o) {
  e53.emplaceBack(t3, r, 2 * Math.floor(i * bf) + s3, a * bf * 2, n * bf * 2, Math.round(o));
}
q(La, "addVertex");
var _f = class {
  constructor(e53) {
    this.zoom = e53.zoom, this.overscaling = e53.overscaling, this.layers = e53.layers, this.layerIds = this.layers.map((e54) => e54.id), this.index = e53.index, this.hasPattern = false, this.layoutVertexArray = new vs(), this.centroidVertexArray = new Pr(), this.indexArray = new nt(), this.programConfigurations = new mt(e53.layers, e53.zoom), this.segments = new me(), this.stateDependentLayerIds = this.layers.filter((e54) => e54.isStateDependent()).map((e54) => e54.id);
  }
  populate(e53, t3, r) {
    this.features = [], this.hasPattern = Ki("fill-extrusion", this.layers, t3);
    for (let { feature: i, id: a, index: n, sourceLayerIndex: s3 } of e53) {
      let e54 = this.layers[0]._featureFilter.needGeometry, o = yt(i, e54);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), o, r))
        continue;
      let l = { id: a, sourceLayerIndex: s3, index: n, geometry: e54 ? o.geometry : dt(i), properties: i.properties, type: i.type, patterns: {} };
      this.hasPattern ? this.features.push(Yi("fill-extrusion", this.layers, l, this.zoom, t3)) : this.addFeature(l, l.geometry, n, r, {}), t3.featureIndex.insert(i, l.geometry, n, s3, this.index, true);
    }
  }
  addFeatures(e53, t3, r) {
    for (let e54 of this.features) {
      let { geometry: i } = e54;
      this.addFeature(e54, i, e54.index, t3, r);
    }
  }
  update(e53, t3, r) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e53, t3, this.stateDependentLayers, r);
  }
  isEmpty() {
    return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e53) {
    this.uploaded || (this.layoutVertexBuffer = e53.createVertexBuffer(this.layoutVertexArray, Db), this.centroidVertexBuffer = e53.createVertexBuffer(this.centroidVertexArray, Lb.members, true), this.indexBuffer = e53.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e53), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
  }
  addFeature(e53, t3, r, i, a) {
    let n = { x: 0, y: 0, vertexCount: 0 };
    for (let r3 of Ca(t3, JI)) {
      let t4 = 0;
      for (let e54 of r3)
        t4 += e54.length;
      let i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
      for (let e54 of r3) {
        if (0 === e54.length || eM(e54))
          continue;
        let t5 = 0;
        for (let r4 = 0; r4 < e54.length; r4++) {
          let a4 = e54[r4];
          if (r4 >= 1) {
            let s4 = e54[r4 - 1];
            if (!QI(a4, s4)) {
              i3.vertexLength + 4 > me.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              let e55 = a4.sub(s4)._perp()._unit(), r5 = s4.dist(a4);
              t5 + r5 > 32768 && (t5 = 0), La(this.layoutVertexArray, a4.x, a4.y, e55.x, e55.y, 0, 0, t5), La(this.layoutVertexArray, a4.x, a4.y, e55.x, e55.y, 0, 1, t5), n.x += 2 * a4.x, n.y += 2 * a4.y, n.vertexCount += 2, t5 += r5, La(this.layoutVertexArray, s4.x, s4.y, e55.x, e55.y, 0, 0, t5), La(this.layoutVertexArray, s4.x, s4.y, e55.x, e55.y, 0, 1, t5), n.x += 2 * s4.x, n.y += 2 * s4.y, n.vertexCount += 2;
              let o3 = i3.vertexLength;
              this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), i3.vertexLength += 4, i3.primitiveLength += 2;
            }
          }
        }
      }
      if (i3.vertexLength + t4 > me.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(t4, this.layoutVertexArray, this.indexArray)), "Polygon" !== YI[e53.type])
        continue;
      let a3 = [], s3 = [], o = i3.vertexLength;
      for (let e54 of r3)
        if (0 !== e54.length) {
          e54 !== r3[0] && s3.push(a3.length / 2);
          for (let t5 = 0; t5 < e54.length; t5++) {
            let r4 = e54[t5];
            La(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), n.x += r4.x, n.y += r4.y, n.vertexCount += 1, a3.push(r4.x), a3.push(r4.y);
          }
        }
      let l = (0, Vb.default)(a3, s3);
      for (let e54 = 0; e54 < l.length; e54 += 3)
        this.indexArray.emplaceBack(o + l[e54], o + l[e54 + 2], o + l[e54 + 1]);
      i3.primitiveLength += l.length / 3, i3.vertexLength += t4;
    }
    for (let e54 = 0; e54 < n.vertexCount; e54++)
      this.centroidVertexArray.emplaceBack(Math.floor(n.x / n.vertexCount), Math.floor(n.y / n.vertexCount));
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e53, r, a, i);
  }
};
q(_f, "FillExtrusionBucket");
var Da = _f;
function QI(e53, t3) {
  return e53.x === t3.x && (e53.x < 0 || e53.x > 8192) || e53.y === t3.y && (e53.y < 0 || e53.y > 8192);
}
function eM(e53) {
  return e53.every((e54) => e54.x < 0) || e53.every((e54) => e54.x > 8192) || e53.every((e54) => e54.y < 0) || e53.every((e54) => e54.y > 8192);
}
G("FillExtrusionBucket", Da, { omit: ["layers", "features"] }), q(QI, "isBoundaryEdge"), q(eM, "isEntirelyOutside"), c();
var Nb;
var tM = q(() => Nb = Nb || new Re({ "fill-extrusion-opacity": new $(M["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new W(M["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new $(M["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new $(M["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new rr(M["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new W(M["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new W(M["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new $(M["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }), "getPaint");
var Gb = { get paint() {
  return tM();
} };
var Hs = u(Pe(), 1);
var vf = class extends je {
  constructor(e53) {
    super(e53, Gb);
  }
  createBucket(e53) {
    return new Da(e53);
  }
  queryRadius() {
    return Mr(this.paint.get("fill-extrusion-translate"));
  }
  is3D() {
    return true;
  }
  queryIntersectsFeature(e53, t3, r, i, a, n, s3, o) {
    let l = Cr(e53, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), n.angle, s3), u3 = this.paint.get("fill-extrusion-height").evaluate(t3, r), c3 = this.paint.get("fill-extrusion-base").evaluate(t3, r), h = nM(l, o, n, 0), p = iM(i, c3, u3, o);
    return rM(p[0], p[1], h);
  }
};
q(vf, "FillExtrusionStyleLayer");
var Zs = vf;
function za(e53, t3) {
  return e53.x * t3.x + e53.y * t3.y;
}
function qb(e53, t3) {
  if (1 === e53.length) {
    let r, i = 0, a = t3[i++];
    for (; !r || a.equals(r); )
      if (r = t3[i++], !r)
        return 1 / 0;
    for (; i < t3.length; i++) {
      let n = t3[i], s3 = e53[0], o = r.sub(a), l = n.sub(a), u3 = s3.sub(a), c3 = za(o, o), h = za(o, l), p = za(l, l), d = za(u3, o), f = za(u3, l), m = c3 * p - h * h, y = (p * d - h * f) / m, g = (c3 * f - h * d) / m, _ = 1 - y - g, x = a.z * _ + r.z * y + n.z * g;
      if (isFinite(x))
        return x;
    }
    return 1 / 0;
  }
  {
    let e54 = 1 / 0;
    for (let r of t3)
      e54 = Math.min(e54, r.z);
    return e54;
  }
}
function rM(e53, t3, r) {
  let i = 1 / 0;
  Bs(r, t3) && (i = qb(r, t3[0]));
  for (let a = 0; a < t3.length; a++) {
    let n = t3[a], s3 = e53[a];
    for (let e54 = 0; e54 < n.length - 1; e54++) {
      let t4 = n[e54], a3 = n[e54 + 1], o = s3[e54], l = [t4, a3, s3[e54 + 1], o, t4];
      Fs(r, l) && (i = Math.min(i, qb(r, l)));
    }
  }
  return i !== 1 / 0 && i;
}
function iM(e53, t3, r, i) {
  let a = [], n = [], s3 = i[8] * t3, o = i[9] * t3, l = i[10] * t3, u3 = i[11] * t3, c3 = i[8] * r, h = i[9] * r, p = i[10] * r, d = i[11] * r;
  for (let t4 of e53) {
    let e54 = [], r3 = [];
    for (let a3 of t4) {
      let t5 = a3.x, n3 = a3.y, f = i[0] * t5 + i[4] * n3 + i[12], m = i[1] * t5 + i[5] * n3 + i[13], y = i[2] * t5 + i[6] * n3 + i[14], g = i[3] * t5 + i[7] * n3 + i[15], _ = f + s3, x = m + o, v = y + l, b = g + u3, w = f + c3, S = m + h, A = y + p, M3 = g + d, I = new Hs.default(_ / b, x / b);
      I.z = v / b, e54.push(I);
      let T = new Hs.default(w / M3, S / M3);
      T.z = A / M3, r3.push(T);
    }
    a.push(e54), n.push(r3);
  }
  return [a, n];
}
function nM(e53, t3, r, i) {
  let a = [];
  for (let r3 of e53) {
    let e54 = [r3.x, r3.y, i, 1];
    Xe.transformMat4(e54, e54, t3), a.push(new Hs.default(e54[0] / e54[3], e54[1] / e54[3]));
  }
  return a;
}
q(za, "dot"), q(qb, "getIntersectionDistance"), q(rM, "checkIntersection"), q(iM, "projectExtrusion"), q(nM, "projectQueryGeometry"), c(), c(), c();
var aM = ve([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4);
var { members: jb, size: SB, alignment: PB } = aM;
c();
var oM = ve([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]);
var { members: $b, size: MB, alignment: CB } = oM;
var Wb = u(ka(), 1);
var sM = Wb.default.VectorTileFeature.types;
var Hb = 63;
var lM = Math.cos(Math.PI / 180 * 37.5);
var uM = 15;
var cM = 20;
var pM = 15;
var Xb = 0.5;
var Zb = Math.pow(2, pM - 1) / Xb;
var wf = class {
  constructor(e53) {
    this.zoom = e53.zoom, this.overscaling = e53.overscaling, this.layers = e53.layers, this.layerIds = this.layers.map((e54) => e54.id), this.index = e53.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((e54) => {
      this.gradients[e54.id] = {};
    }), this.layoutVertexArray = new ws(), this.layoutVertexArray2 = new Ss(), this.indexArray = new nt(), this.programConfigurations = new mt(e53.layers, e53.zoom), this.segments = new me(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((e54) => e54.isStateDependent()).map((e54) => e54.id);
  }
  populate(e53, t3, r) {
    this.hasPattern = Ki("line", this.layers, t3);
    let i = this.layers[0].layout.get("line-sort-key"), a = !i.isConstant(), n = [];
    for (let { feature: t4, id: s3, index: o, sourceLayerIndex: l } of e53) {
      let e54 = this.layers[0]._featureFilter.needGeometry, u3 = yt(t4, e54);
      if (!this.layers[0]._featureFilter.filter(new ye(this.zoom), u3, r))
        continue;
      let c3 = a ? i.evaluate(u3, {}, r) : void 0, h = { id: s3, properties: t4.properties, type: t4.type, sourceLayerIndex: l, index: o, geometry: e54 ? u3.geometry : dt(t4), patterns: {}, sortKey: c3 };
      n.push(h);
    }
    a && n.sort((e54, t4) => e54.sortKey - t4.sortKey);
    for (let i3 of n) {
      let { geometry: a3, index: n3, sourceLayerIndex: s3 } = i3;
      if (this.hasPattern) {
        let e54 = Yi("line", this.layers, i3, this.zoom, t3);
        this.patternFeatures.push(e54);
      } else
        this.addFeature(i3, a3, n3, r, {});
      let o = e53[n3].feature;
      t3.featureIndex.insert(o, a3, n3, s3, this.index);
    }
  }
  update(e53, t3, r) {
    this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e53, t3, this.stateDependentLayers, r);
  }
  addFeatures(e53, t3, r) {
    for (let e54 of this.patternFeatures)
      this.addFeature(e54, e54.geometry, e54.index, t3, r);
  }
  isEmpty() {
    return 0 === this.layoutVertexArray.length;
  }
  uploadPending() {
    return !this.uploaded || this.programConfigurations.needsUpload;
  }
  upload(e53) {
    this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = e53.createVertexBuffer(this.layoutVertexArray2, $b)), this.layoutVertexBuffer = e53.createVertexBuffer(this.layoutVertexArray, jb), this.indexBuffer = e53.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e53), this.uploaded = true;
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
  }
  lineFeatureClips(e53) {
    if (e53.properties && Object.prototype.hasOwnProperty.call(e53.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e53.properties, "mapbox_clip_end")) {
      return { start: +e53.properties.mapbox_clip_start, end: +e53.properties.mapbox_clip_end };
    }
  }
  addFeature(e53, t3, r, i, a) {
    let n = this.layers[0].layout, s3 = n.get("line-join").evaluate(e53, {}), o = n.get("line-cap"), l = n.get("line-miter-limit"), u3 = n.get("line-round-limit");
    this.lineClips = this.lineFeatureClips(e53);
    for (let r3 of t3)
      this.addLine(r3, e53, s3, o, l, u3);
    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e53, r, a, i);
  }
  addLine(e53, t3, r, i, a, n) {
    if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
      this.lineClipsArray.push(this.lineClips);
      for (let t4 = 0; t4 < e53.length - 1; t4++)
        this.totalDistance += e53[t4].dist(e53[t4 + 1]);
      this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
    }
    let s3 = "Polygon" === sM[t3.type], o = e53.length;
    for (; o >= 2 && e53[o - 1].equals(e53[o - 2]); )
      o--;
    let l = 0;
    for (; l < o - 1 && e53[l].equals(e53[l + 1]); )
      l++;
    if (o < (s3 ? 3 : 2))
      return;
    "bevel" === r && (a = 1.05);
    let u3, c3, h, p, d, f = this.overscaling <= 16 ? 8192 * uM / (512 * this.overscaling) : 0, m = this.segments.prepareSegment(10 * o, this.layoutVertexArray, this.indexArray);
    this.e1 = this.e2 = -1, s3 && (u3 = e53[o - 2], d = e53[l].sub(u3)._unit()._perp());
    for (let t4 = l; t4 < o; t4++) {
      if (h = t4 === o - 1 ? s3 ? e53[l + 1] : void 0 : e53[t4 + 1], h && e53[t4].equals(h))
        continue;
      d && (p = d), u3 && (c3 = u3), u3 = e53[t4], d = h ? h.sub(u3)._unit()._perp() : p, p = p || d;
      let y = p.add(d);
      (0 !== y.x || 0 !== y.y) && y._unit();
      let g = p.x * d.x + p.y * d.y, _ = y.x * d.x + y.y * d.y, x = 0 !== _ ? 1 / _ : 1 / 0, v = 2 * Math.sqrt(2 - 2 * _), b = _ < lM && c3 && h, w = p.x * d.y - p.y * d.x > 0;
      if (b && t4 > l) {
        let e54 = u3.dist(c3);
        if (e54 > 2 * f) {
          let t5 = u3.sub(u3.sub(c3)._mult(f / e54)._round());
          this.updateDistance(c3, t5), this.addCurrentVertex(t5, p, 0, 0, m), c3 = t5;
        }
      }
      let S = c3 && h, A = S ? r : s3 ? "butt" : i;
      if (S && "round" === A && (x < n ? A = "miter" : x <= 2 && (A = "fakeround")), "miter" === A && x > a && (A = "bevel"), "bevel" === A && (x > 2 && (A = "flipbevel"), x < a && (A = "miter")), c3 && this.updateDistance(c3, u3), "miter" === A)
        y._mult(x), this.addCurrentVertex(u3, y, 0, 0, m);
      else if ("flipbevel" === A) {
        if (x > 100)
          y = d.mult(-1);
        else {
          let e54 = x * p.add(d).mag() / p.sub(d).mag();
          y._perp()._mult(e54 * (w ? -1 : 1));
        }
        this.addCurrentVertex(u3, y, 0, 0, m), this.addCurrentVertex(u3, y.mult(-1), 0, 0, m);
      } else if ("bevel" === A || "fakeround" === A) {
        let e54 = -Math.sqrt(x * x - 1), t5 = w ? e54 : 0, r3 = w ? 0 : e54;
        if (c3 && this.addCurrentVertex(u3, p, t5, r3, m), "fakeround" === A) {
          let e55 = Math.round(180 * v / Math.PI / cM);
          for (let t6 = 1; t6 < e55; t6++) {
            let r4 = t6 / e55;
            if (0.5 !== r4) {
              let e56 = r4 - 0.5;
              r4 += r4 * e56 * (r4 - 1) * ((1.0904 + g * (g * (3.55645 - 1.43519 * g) - 3.2452)) * e56 * e56 + (0.848013 + g * (0.215638 * g - 1.06021)));
            }
            let i3 = d.sub(p)._mult(r4)._add(p)._unit()._mult(w ? -1 : 1);
            this.addHalfVertex(u3, i3.x, i3.y, false, w, 0, m);
          }
        }
        h && this.addCurrentVertex(u3, d, -t5, -r3, m);
      } else if ("butt" === A)
        this.addCurrentVertex(u3, y, 0, 0, m);
      else if ("square" === A) {
        let e54 = c3 ? 1 : -1;
        this.addCurrentVertex(u3, y, e54, e54, m);
      } else
        "round" === A && (c3 && (this.addCurrentVertex(u3, p, 0, 0, m), this.addCurrentVertex(u3, p, 1, 1, m, true)), h && (this.addCurrentVertex(u3, d, -1, -1, m, true), this.addCurrentVertex(u3, d, 0, 0, m)));
      if (b && t4 < o - 1) {
        let e54 = u3.dist(h);
        if (e54 > 2 * f) {
          let t5 = u3.add(h.sub(u3)._mult(f / e54)._round());
          this.updateDistance(u3, t5), this.addCurrentVertex(t5, d, 0, 0, m), u3 = t5;
        }
      }
    }
  }
  addCurrentVertex(e53, t3, r, i, a, n = false) {
    let s3 = t3.x + t3.y * r, o = t3.y - t3.x * r, l = -t3.x + t3.y * i, u3 = -t3.y - t3.x * i;
    this.addHalfVertex(e53, s3, o, n, false, r, a), this.addHalfVertex(e53, l, u3, n, true, -i, a), this.distance > Zb / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e53, t3, r, i, a, n));
  }
  addHalfVertex({ x: e53, y: t3 }, r, i, a, n, s3, o) {
    let l = (this.lineClips ? this.scaledDistance * (Zb - 1) : this.scaledDistance) * Xb;
    if (this.layoutVertexArray.emplaceBack((e53 << 1) + (a ? 1 : 0), (t3 << 1) + (n ? 1 : 0), Math.round(Hb * r) + 128, Math.round(Hb * i) + 128, 1 + (0 === s3 ? 0 : s3 < 0 ? -1 : 1) | (63 & l) << 2, l >> 6), this.lineClips) {
      let e54 = (this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start);
      this.layoutVertexArray2.emplaceBack(e54, this.lineClipsArray.length);
    }
    let u3 = o.vertexLength++;
    this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u3), o.primitiveLength++), n ? this.e2 = u3 : this.e1 = u3;
  }
  updateScaledDistance() {
    this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
  }
  updateDistance(e53, t3) {
    this.distance += e53.dist(t3), this.updateScaledDistance();
  }
};
q(wf, "LineBucket");
var Fa = wf;
G("LineBucket", Fa, { omit: ["layers", "patternFeatures"] }), c();
var Kb;
var Yb;
var hM = q(() => Kb = Kb || new Re({ "line-cap": new $(M.layout_line["line-cap"]), "line-join": new W(M.layout_line["line-join"]), "line-miter-limit": new $(M.layout_line["line-miter-limit"]), "line-round-limit": new $(M.layout_line["line-round-limit"]), "line-sort-key": new W(M.layout_line["line-sort-key"]) }), "getLayout");
var fM = q(() => Yb = Yb || new Re({ "line-opacity": new W(M.paint_line["line-opacity"]), "line-color": new W(M.paint_line["line-color"]), "line-translate": new $(M.paint_line["line-translate"]), "line-translate-anchor": new $(M.paint_line["line-translate-anchor"]), "line-width": new W(M.paint_line["line-width"]), "line-gap-width": new W(M.paint_line["line-gap-width"]), "line-offset": new W(M.paint_line["line-offset"]), "line-blur": new W(M.paint_line["line-blur"]), "line-dasharray": new Jr(M.paint_line["line-dasharray"]), "line-pattern": new rr(M.paint_line["line-pattern"]), "line-gradient": new Qr(M.paint_line["line-gradient"]) }), "getPaint");
var Sf = { get paint() {
  return fM();
}, get layout() {
  return hM();
} };
var Tf = class extends W {
  possiblyEvaluate(e53, t3) {
    return t3 = new ye(Math.floor(t3.zoom), { now: t3.now, fadeDuration: t3.fadeDuration, zoomHistory: t3.zoomHistory, transition: t3.transition }), super.possiblyEvaluate(e53, t3);
  }
  evaluate(e53, t3, r, i) {
    return t3 = R({}, t3, { zoom: Math.floor(t3.zoom) }), super.evaluate(e53, t3, r, i);
  }
};
q(Tf, "LineFloorwidthProperty");
var Ws;
var Pf = Tf;
var Af = class extends je {
  constructor(e53) {
    super(e53, Sf), this.gradientVersion = 0, Ws || ((Ws = new Pf(Sf.paint.properties["line-width"].specification)).useIntegerZoom = true);
  }
  _handleSpecialPaintPropertyUpdate(e53) {
    if ("line-gradient" === e53) {
      let e54 = this._transitionablePaint._values["line-gradient"].value.expression;
      this.stepInterpolant = e54._styleExpression.expression instanceof Li, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
    }
  }
  gradientExpression() {
    return this._transitionablePaint._values["line-gradient"].value.expression;
  }
  recalculate(e53, t3) {
    super.recalculate(e53, t3), this.paint._values["line-floorwidth"] = Ws.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e53);
  }
  createBucket(e53) {
    return new Fa(e53);
  }
  queryRadius(e53) {
    let t3 = e53, r = Jb(oi("line-width", this, t3), oi("line-gap-width", this, t3)), i = oi("line-offset", this, t3);
    return r / 2 + Math.abs(i) + Mr(this.paint.get("line-translate"));
  }
  queryIntersectsFeature(e53, t3, r, i, a, n, s3) {
    let o = Cr(e53, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), n.angle, s3), l = s3 / 2 * Jb(this.paint.get("line-width").evaluate(t3, r), this.paint.get("line-gap-width").evaluate(t3, r)), u3 = this.paint.get("line-offset").evaluate(t3, r);
    return u3 && (i = Dx(i, u3 * s3)), Ex(o, i, l);
  }
  isTileClipped() {
    return true;
  }
};
q(Af, "LineStyleLayer");
var Xs = Af;
function Jb(e53, t3) {
  return t3 > 0 ? t3 + 2 * e53 : e53;
}
q(Jb, "getLineWidth"), c(), c(), c();
var Qb = ve([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4);
var e_ = ve([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
var bR = ve([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
var t_ = ve([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
var _R = ve([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
var If = ve([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4);
var r_ = ve([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
var vR = ve([{ name: "triangle", components: 3, type: "Uint16" }]);
var wR = ve([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]);
var SR = ve([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]);
var PR = ve([{ type: "Float32", name: "offsetX" }]);
var TR = ve([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
var Oa = u(Pe(), 1);
function mM(e53, t3, r) {
  let i = t3.layout.get("text-transform").evaluate(r, {});
  return "uppercase" === i ? e53 = e53.toLocaleUpperCase() : "lowercase" === i && (e53 = e53.toLocaleLowerCase()), ft.applyArabicShaping && (e53 = ft.applyArabicShaping(e53)), e53;
}
function i_(e53, t3, r) {
  return e53.sections.forEach((e54) => {
    e54.text = mM(e54.text, t3, r);
  }), e53;
}
function n_(e53) {
  let t3 = {}, r = {}, i = [], a = 0;
  function n(t4) {
    i.push(e53[t4]), a++;
  }
  function s3(e54, t4, a3) {
    let n3 = r[e54];
    return delete r[e54], r[t4] = n3, i[n3].geometry[0].pop(), i[n3].geometry[0] = i[n3].geometry[0].concat(a3[0]), n3;
  }
  function o(e54, r3, a3) {
    let n3 = t3[r3];
    return delete t3[r3], t3[e54] = n3, i[n3].geometry[0].shift(), i[n3].geometry[0] = a3[0].concat(i[n3].geometry[0]), n3;
  }
  function l(e54, t4, r3) {
    let i3 = r3 ? t4[0][t4[0].length - 1] : t4[0][0];
    return "".concat(e54, ":").concat(i3.x, ":").concat(i3.y);
  }
  q(n, "add"), q(s3, "mergeFromRight"), q(o, "mergeFromLeft"), q(l, "getKey");
  for (let u3 = 0; u3 < e53.length; u3++) {
    let c3 = e53[u3], h = c3.geometry, p = c3.text ? c3.text.toString() : null;
    if (!p) {
      n(u3);
      continue;
    }
    let d = l(p, h), f = l(p, h, true);
    if (d in r && f in t3 && r[d] !== t3[f]) {
      let e54 = o(d, f, h), a3 = s3(d, f, i[e54].geometry);
      delete t3[d], delete r[f], r[l(p, i[a3].geometry, true)] = a3, i[e54].geometry = null;
    } else
      d in r ? s3(d, f, h) : f in t3 ? o(d, f, h) : (n(u3), t3[d] = a - 1, r[f] = a - 1);
  }
  return i.filter((e54) => e54.geometry);
}
c(), q(mM, "transformTextInternal"), q(i_, "transformText"), c(), q(n_, "mergeLines"), c(), c();
var a_ = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
c();
var li = 24;
c();
var f_ = u(Ef(), 1);
var h_ = 3;
function LM(e53, t3, r) {
  1 === e53 && r.readMessage(DM, t3);
}
function DM(e53, t3, r) {
  if (3 === e53) {
    let { id: e54, bitmap: i, width: a, height: n, left: s3, top: o, advance: l } = r.readMessage(zM, {});
    t3.push({ id: e54, bitmap: new si({ width: a + 2 * h_, height: n + 2 * h_ }, i), metrics: { width: a, height: n, left: s3, top: o, advance: l } });
  }
}
function zM(e53, t3, r) {
  1 === e53 ? t3.id = r.readVarint() : 2 === e53 ? t3.bitmap = r.readBytes() : 3 === e53 ? t3.width = r.readVarint() : 4 === e53 ? t3.height = r.readVarint() : 5 === e53 ? t3.left = r.readSVarint() : 6 === e53 ? t3.top = r.readSVarint() : 7 === e53 && (t3.advance = r.readVarint());
}
function m_(e53) {
  return new f_.default(e53).readFields(LM, []);
}
function Ba(e53) {
  let t3 = 0, r = 0;
  for (let i3 of e53)
    t3 += i3.w * i3.h, r = Math.max(r, i3.w);
  e53.sort((e54, t4) => t4.h - e54.h);
  let i = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t3 / 0.95)), r), h: 1 / 0 }], a = 0, n = 0;
  for (let t4 of e53)
    for (let e54 = i.length - 1; e54 >= 0; e54--) {
      let r3 = i[e54];
      if (!(t4.w > r3.w || t4.h > r3.h)) {
        if (t4.x = r3.x, t4.y = r3.y, n = Math.max(n, t4.y + t4.h), a = Math.max(a, t4.x + t4.w), t4.w === r3.w && t4.h === r3.h) {
          let t5 = i.pop();
          e54 < i.length && (i[e54] = t5);
        } else
          t4.h === r3.h ? (r3.x += t4.w, r3.w -= t4.w) : t4.w === r3.w ? (r3.y += t4.h, r3.h -= t4.h) : (i.push({ x: r3.x + t4.w, y: r3.y, w: r3.w - t4.w, h: t4.h }), r3.y += t4.h, r3.h -= t4.h);
        break;
      }
    }
  return { w: a, h: n, fill: t3 / (a * n) || 0 };
}
q(LM, "readFontstacks"), q(DM, "readFontstack"), q(zM, "readGlyph"), q(m_, "parseGlyphPbf"), c(), c(), q(Ba, "potpack");
var xt = 1;
var Lf = class {
  constructor(e53, { pixelRatio: t3, version: r, stretchX: i, stretchY: a, content: n }) {
    this.paddedRect = e53, this.pixelRatio = t3, this.stretchX = i, this.stretchY = a, this.content = n, this.version = r;
  }
  get tl() {
    return [this.paddedRect.x + xt, this.paddedRect.y + xt];
  }
  get br() {
    return [this.paddedRect.x + this.paddedRect.w - xt, this.paddedRect.y + this.paddedRect.h - xt];
  }
  get tlbr() {
    return this.tl.concat(this.br);
  }
  get displaySize() {
    return [(this.paddedRect.w - 2 * xt) / this.pixelRatio, (this.paddedRect.h - 2 * xt) / this.pixelRatio];
  }
};
q(Lf, "ImagePosition");
var tn = Lf;
var Df = class {
  constructor(e53, t3) {
    let r = {}, i = {};
    this.haveRenderCallbacks = [];
    let a = [];
    this.addImages(e53, r, a), this.addImages(t3, i, a);
    let { w: n, h: s3 } = Ba(a), o = new Ee({ width: n || 1, height: s3 || 1 });
    for (let t4 in e53) {
      let i3 = e53[t4], a3 = r[t4].paddedRect;
      Ee.copy(i3.data, o, { x: 0, y: 0 }, { x: a3.x + xt, y: a3.y + xt }, i3.data);
    }
    for (let e54 in t3) {
      let r3 = t3[e54], a3 = i[e54].paddedRect, n3 = a3.x + xt, s4 = a3.y + xt, l = r3.data.width, u3 = r3.data.height;
      Ee.copy(r3.data, o, { x: 0, y: 0 }, { x: n3, y: s4 }, r3.data), Ee.copy(r3.data, o, { x: 0, y: u3 - 1 }, { x: n3, y: s4 - 1 }, { width: l, height: 1 }), Ee.copy(r3.data, o, { x: 0, y: 0 }, { x: n3, y: s4 + u3 }, { width: l, height: 1 }), Ee.copy(r3.data, o, { x: l - 1, y: 0 }, { x: n3 - 1, y: s4 }, { width: 1, height: u3 }), Ee.copy(r3.data, o, { x: 0, y: 0 }, { x: n3 + l, y: s4 }, { width: 1, height: u3 });
    }
    this.image = o, this.iconPositions = r, this.patternPositions = i;
  }
  addImages(e53, t3, r) {
    for (let i in e53) {
      let a = e53[i], n = { x: 0, y: 0, w: a.data.width + 2 * xt, h: a.data.height + 2 * xt };
      r.push(n), t3[i] = new tn(n, a), a.hasRenderCallback && this.haveRenderCallbacks.push(i);
    }
  }
  patchUpdatedImages(e53, t3) {
    e53.dispatchRenderCallbacks(this.haveRenderCallbacks);
    for (let r in e53.updatedImages)
      this.patchUpdatedImage(this.iconPositions[r], e53.getImage(r), t3), this.patchUpdatedImage(this.patternPositions[r], e53.getImage(r), t3);
  }
  patchUpdatedImage(e53, t3, r) {
    if (!e53 || !t3 || e53.version === t3.version)
      return;
    e53.version = t3.version;
    let [i, a] = e53.tl;
    r.update(t3.data, void 0, { x: i, y: a });
  }
};
q(Df, "ImageAtlas");
var kf = Df;
G("ImagePosition", tn), G("ImageAtlas", kf);
var ui = ((e53) => (e53[e53.none = 0] = "none", e53[e53.horizontal = 1] = "horizontal", e53[e53.vertical = 2] = "vertical", e53[e53.horizontalOnly = 3] = "horizontalOnly", e53))(ui || {});
function Js(e53) {
  let t3 = 0.5, r = 0.5;
  switch (e53) {
    case "right":
    case "top-right":
    case "bottom-right":
      t3 = 1;
      break;
    case "left":
    case "top-left":
    case "bottom-left":
      t3 = 0;
  }
  switch (e53) {
    case "bottom":
    case "bottom-right":
    case "bottom-left":
      r = 1;
      break;
    case "top":
    case "top-right":
    case "top-left":
      r = 0;
  }
  return { horizontalAlign: t3, verticalAlign: r };
}
q(Js, "getAnchorAlignment");
var g_ = u(ka(), 1);
c();
var d_ = 255;
var Ra = 128;
var Qs = d_ * Ra;
function zf(e53, t3) {
  let { expression: r } = t3;
  if ("constant" === r.kind)
    return { kind: "constant", layoutSize: r.evaluate(new ye(e53 + 1)) };
  if ("source" === r.kind)
    return { kind: "source" };
  {
    let { zoomStops: t4, interpolationType: i } = r, a = 0;
    for (; a < t4.length && t4[a] <= e53; )
      a++;
    a = Math.max(0, a - 1);
    let n = a;
    for (; n < t4.length && t4[n] < e53 + 1; )
      n++;
    n = Math.min(t4.length - 1, n);
    let s3 = t4[a], o = t4[n];
    return "composite" === r.kind ? { kind: "composite", minZoom: s3, maxZoom: o, interpolationType: i } : { kind: "camera", minZoom: s3, maxZoom: o, minSize: r.evaluate(new ye(s3)), maxSize: r.evaluate(new ye(o)), interpolationType: i };
  }
}
function rn(e53, { uSize: t3, uSizeT: r }, { lowerSize: i, upperSize: a }) {
  return "source" === e53.kind ? i / Ra : "composite" === e53.kind ? ke.number(i / Ra, a / Ra, r) : t3;
}
function ci(e53, t3) {
  let r = 0, i = 0;
  if ("constant" === e53.kind)
    i = e53.layoutSize;
  else if ("source" !== e53.kind) {
    let { interpolationType: a, minZoom: n, maxZoom: s3 } = e53, o = a ? Te(wt.interpolationFactor(a, t3, n, s3), 0, 1) : 0;
    "camera" === e53.kind ? i = ke.number(e53.minSize, e53.maxSize, o) : r = o;
  }
  return { uSizeT: r, uSize: i };
}
function nn(e53, t3, r) {
  let i = "never", a = e53.get(t3);
  return a ? i = a : e53.get(r) && (i = "always"), i;
}
q(zf, "getSizeData"), q(rn, "evaluateSizeForFeature"), q(ci, "evaluateSizeForZoom"), c(), q(nn, "getOverlapMode");
var BM = g_.default.VectorTileFeature.types;
var RM = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
function el(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p) {
  let d = o ? Math.min(Qs, Math.round(o[0])) : 0, f = o ? Math.min(Qs, Math.round(o[1])) : 0;
  e53.emplaceBack(t3, r, Math.round(32 * i), Math.round(32 * a), n, s3, (d << 1) + (l ? 1 : 0), f, 16 * u3, 16 * c3, 256 * h, 256 * p);
}
function pi(e53, t3, r) {
  e53.emplaceBack(t3.x, t3.y, r), e53.emplaceBack(t3.x, t3.y, r), e53.emplaceBack(t3.x, t3.y, r), e53.emplaceBack(t3.x, t3.y, r);
}
function OM(e53) {
  for (let t3 of e53.sections)
    if (hx(t3.text))
      return true;
  return false;
}
q(el, "addVertex"), q(pi, "addDynamicAttributes"), q(OM, "containsRTLText");
var Ff = class {
  constructor(e53) {
    this.layoutVertexArray = new Ps(), this.indexArray = new nt(), this.programConfigurations = e53, this.segments = new me(), this.dynamicLayoutVertexArray = new Ts(), this.opacityVertexArray = new As(), this.hasVisibleVertices = false, this.placedSymbolArray = new da();
  }
  isEmpty() {
    return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
  }
  upload(e53, t3, r, i) {
    this.isEmpty() || (r && (this.layoutVertexBuffer = e53.createVertexBuffer(this.layoutVertexArray, Qb.members), this.indexBuffer = e53.createIndexBuffer(this.indexArray, t3), this.dynamicLayoutVertexBuffer = e53.createVertexBuffer(this.dynamicLayoutVertexArray, e_.members, true), this.opacityVertexBuffer = e53.createVertexBuffer(this.opacityVertexArray, RM, true), this.opacityVertexBuffer.itemSize = 1), (r || i) && this.programConfigurations.upload(e53));
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
  }
};
q(Ff, "SymbolBuffers");
var Va = Ff;
G("SymbolBuffers", Va);
var Bf = class {
  constructor(e53, t3, r) {
    this.layoutVertexArray = new e53(), this.layoutAttributes = t3, this.indexArray = new r(), this.segments = new me(), this.collisionVertexArray = new Ms();
  }
  upload(e53) {
    this.layoutVertexBuffer = e53.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e53.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e53.createVertexBuffer(this.collisionVertexArray, t_.members, true);
  }
  destroy() {
    this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
  }
};
q(Bf, "CollisionBuffers");
var Ua = Bf;
G("CollisionBuffers", Ua);
var Rf = class {
  constructor(e53) {
    this.collisionBoxArray = e53.collisionBoxArray, this.zoom = e53.zoom, this.overscaling = e53.overscaling, this.layers = e53.layers, this.layerIds = this.layers.map((e54) => e54.id), this.index = e53.index, this.pixelRatio = e53.pixelRatio, this.sourceLayerIndex = e53.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = q3.identity([]), this.placementViewportMatrix = q3.identity([]);
    let t3 = this.layers[0]._unevaluatedLayout._values;
    this.textSizeData = zf(this.zoom, t3["text-size"]), this.iconSizeData = zf(this.zoom, t3["icon-size"]);
    let r = this.layers[0].layout, i = r.get("symbol-sort-key"), a = r.get("symbol-z-order");
    this.canOverlap = "never" !== nn(r, "text-overlap", "text-allow-overlap") || "never" !== nn(r, "icon-overlap", "icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a && !i.isConstant();
    let n = "viewport-y" === a || "auto" === a && !this.sortFeaturesByKey;
    this.sortFeaturesByY = n && this.canOverlap, "point" === r.get("symbol-placement") && (this.writingModes = r.get("text-writing-mode").map((e54) => ui[e54])), this.stateDependentLayerIds = this.layers.filter((e54) => e54.isStateDependent()).map((e54) => e54.id), this.sourceID = e53.sourceID;
  }
  createArrays() {
    this.text = new Va(new mt(this.layers, this.zoom, (e53) => /^text/.test(e53))), this.icon = new Va(new mt(this.layers, this.zoom, (e53) => /^icon/.test(e53))), this.glyphOffsetArray = new ga(), this.lineVertexArray = new xa(), this.symbolInstances = new ya();
  }
  calculateGlyphDependencies(e53, t3, r, i, a) {
    for (let n = 0; n < e53.length; n++)
      if (t3[e53.charCodeAt(n)] = true, (r || i) && a) {
        let r3 = a_[e53.charAt(n)];
        r3 && (t3[r3.charCodeAt(0)] = true);
      }
  }
  populate(e53, t3, r) {
    let i = this.layers[0], a = i.layout, n = a.get("text-font"), s3 = a.get("text-field"), o = a.get("icon-image"), l = ("constant" !== s3.value.kind || s3.value.value instanceof St && !s3.value.value.isEmpty() || s3.value.value.toString().length > 0) && ("constant" !== n.value.kind || n.value.value.length > 0), u3 = "constant" !== o.value.kind || !!o.value.value || Object.keys(o.parameters).length > 0, c3 = a.get("symbol-sort-key");
    if (this.features = [], !l && !u3)
      return;
    let h = t3.iconDependencies, p = t3.glyphDependencies, d = t3.availableImages, f = new ye(this.zoom);
    for (let { feature: t4, id: s4, index: o3, sourceLayerIndex: m } of e53) {
      let e54, y, g = i._featureFilter.needGeometry, _ = yt(t4, g);
      if (!i._featureFilter.filter(f, _, r))
        continue;
      if (g || (_.geometry = dt(t4)), l) {
        let t5 = i.getValueAndResolveTokens("text-field", _, r, d), a3 = St.factory(t5);
        OM(a3) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Kn() || this.hasRTLText && ft.isParsed()) && (e54 = i_(a3, i, _));
      }
      if (u3) {
        let e55 = i.getValueAndResolveTokens("icon-image", _, r, d);
        y = e55 instanceof pt ? e55 : pt.fromString(e55);
      }
      if (!e54 && !y)
        continue;
      let x = this.sortFeaturesByKey ? c3.evaluate(_, {}, r) : void 0, v = { id: s4, text: e54, icon: y, index: o3, sourceLayerIndex: m, geometry: _.geometry, properties: t4.properties, type: BM[t4.type], sortKey: x };
      if (this.features.push(v), y && (h[y.name] = true), e54) {
        let t5 = n.evaluate(_, {}, r).join(","), i3 = "viewport" !== a.get("text-rotation-alignment") && "point" !== a.get("symbol-placement");
        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(2) >= 0;
        for (let r3 of e54.sections)
          if (r3.image)
            h[r3.image.name] = true;
          else {
            let a3 = gp(e54.toString()), n3 = r3.fontStack || t5, s5 = p[n3] = p[n3] || {};
            this.calculateGlyphDependencies(r3.text, s5, i3, this.allowVerticalPlacement, a3);
          }
      }
    }
    "line" === a.get("symbol-placement") && (this.features = n_(this.features)), this.sortFeaturesByKey && this.features.sort((e54, t4) => e54.sortKey - t4.sortKey);
  }
  update(e53, t3, r) {
    this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e53, t3, this.layers, r), this.icon.programConfigurations.updatePaintArrays(e53, t3, this.layers, r));
  }
  isEmpty() {
    return 0 === this.symbolInstances.length && !this.hasRTLText;
  }
  uploadPending() {
    return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
  }
  upload(e53) {
    !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e53), this.iconCollisionBox.upload(e53)), this.text.upload(e53, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e53, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
  }
  destroyDebugData() {
    this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
  }
  destroy() {
    this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
  }
  addToLineVertexArray(e53, t3) {
    let r = this.lineVertexArray.length;
    if (void 0 !== e53.segment) {
      let r3 = e53.dist(t3[e53.segment + 1]), i = e53.dist(t3[e53.segment]), a = {};
      for (let i3 = e53.segment + 1; i3 < t3.length; i3++)
        a[i3] = { x: t3[i3].x, y: t3[i3].y, tileUnitDistanceFromAnchor: r3 }, i3 < t3.length - 1 && (r3 += t3[i3 + 1].dist(t3[i3]));
      for (let r4 = e53.segment || 0; r4 >= 0; r4--)
        a[r4] = { x: t3[r4].x, y: t3[r4].y, tileUnitDistanceFromAnchor: i }, r4 > 0 && (i += t3[r4 - 1].dist(t3[r4]));
      for (let e54 = 0; e54 < t3.length; e54++) {
        let t4 = a[e54];
        this.lineVertexArray.emplaceBack(t4.x, t4.y, t4.tileUnitDistanceFromAnchor);
      }
    }
    return { lineStartIndex: r, lineLength: this.lineVertexArray.length - r };
  }
  addSymbols(e53, t3, r, i, a, n, s3, o, l, u3, c3, h) {
    let p = e53.indexArray, d = e53.layoutVertexArray, f = e53.segments.prepareSegment(4 * t3.length, d, p, this.canOverlap ? n.sortKey : void 0), m = this.glyphOffsetArray.length, y = f.vertexLength, g = this.allowVerticalPlacement && 2 === s3 ? Math.PI / 2 : 0, _ = n.text && n.text.sections;
    for (let i3 = 0; i3 < t3.length; i3++) {
      let { tl: a3, tr: s4, bl: l3, br: u4, tex: c4, pixelOffsetTL: m3, pixelOffsetBR: y3, minFontScaleX: x, minFontScaleY: v, glyphOffset: b, isSDF: w, sectionIndex: S } = t3[i3], A = f.vertexLength, M3 = b[1];
      el(d, o.x, o.y, a3.x, M3 + a3.y, c4.x, c4.y, r, w, m3.x, m3.y, x, v), el(d, o.x, o.y, s4.x, M3 + s4.y, c4.x + c4.w, c4.y, r, w, y3.x, m3.y, x, v), el(d, o.x, o.y, l3.x, M3 + l3.y, c4.x, c4.y + c4.h, r, w, m3.x, y3.y, x, v), el(d, o.x, o.y, u4.x, M3 + u4.y, c4.x + c4.w, c4.y + c4.h, r, w, y3.x, y3.y, x, v), pi(e53.dynamicLayoutVertexArray, o, g), p.emplaceBack(A, A + 1, A + 2), p.emplaceBack(A + 1, A + 2, A + 3), f.vertexLength += 4, f.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(b[0]), (i3 === t3.length - 1 || S !== t3[i3 + 1].sectionIndex) && e53.programConfigurations.populatePaintArrays(d.length, n, n.index, {}, h, _ && _[S]);
    }
    e53.placedSymbolArray.emplaceBack(o.x, o.y, m, this.glyphOffsetArray.length - m, y, l, u3, o.segment, r ? r[0] : 0, r ? r[1] : 0, i[0], i[1], s3, 0, false, 0, c3);
  }
  _addCollisionDebugVertex(e53, t3, r, i, a, n) {
    return t3.emplaceBack(0, 0), e53.emplaceBack(r.x, r.y, i, a, Math.round(n.x), Math.round(n.y));
  }
  addCollisionDebugVertices(e53, t3, r, i, a, n, s3) {
    let o = a.segments.prepareSegment(4, a.layoutVertexArray, a.indexArray), l = o.vertexLength, u3 = a.layoutVertexArray, c3 = a.collisionVertexArray, h = s3.anchorX, p = s3.anchorY;
    this._addCollisionDebugVertex(u3, c3, n, h, p, new Oa.default(e53, t3)), this._addCollisionDebugVertex(u3, c3, n, h, p, new Oa.default(r, t3)), this._addCollisionDebugVertex(u3, c3, n, h, p, new Oa.default(r, i)), this._addCollisionDebugVertex(u3, c3, n, h, p, new Oa.default(e53, i)), o.vertexLength += 4;
    let d = a.indexArray;
    d.emplaceBack(l, l + 1), d.emplaceBack(l + 1, l + 2), d.emplaceBack(l + 2, l + 3), d.emplaceBack(l + 3, l), o.primitiveLength += 4;
  }
  addDebugCollisionBoxes(e53, t3, r, i) {
    for (let a = e53; a < t3; a++) {
      let e54 = this.collisionBoxArray.get(a), t4 = e54.x1, n = e54.y1, s3 = e54.x2, o = e54.y2;
      this.addCollisionDebugVertices(t4, n, s3, o, i ? this.textCollisionBox : this.iconCollisionBox, e54.anchorPoint, r);
    }
  }
  generateCollisionDebugBuffers() {
    this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Ua(_a, If.members, Tr), this.iconCollisionBox = new Ua(_a, If.members, Tr);
    for (let e53 = 0; e53 < this.symbolInstances.length; e53++) {
      let t3 = this.symbolInstances.get(e53);
      this.addDebugCollisionBoxes(t3.textBoxStartIndex, t3.textBoxEndIndex, t3, true), this.addDebugCollisionBoxes(t3.verticalTextBoxStartIndex, t3.verticalTextBoxEndIndex, t3, true), this.addDebugCollisionBoxes(t3.iconBoxStartIndex, t3.iconBoxEndIndex, t3, false), this.addDebugCollisionBoxes(t3.verticalIconBoxStartIndex, t3.verticalIconBoxEndIndex, t3, false);
    }
  }
  _deserializeCollisionBoxesForSymbol(e53, t3, r, i, a, n, s3, o, l) {
    let u3 = {};
    for (let i3 = t3; i3 < r; i3++) {
      let t4 = e53.get(i3);
      u3.textBox = { x1: t4.x1, y1: t4.y1, x2: t4.x2, y2: t4.y2, anchorPointX: t4.anchorPointX, anchorPointY: t4.anchorPointY }, u3.textFeatureIndex = t4.featureIndex;
      break;
    }
    for (let t4 = i; t4 < a; t4++) {
      let r3 = e53.get(t4);
      u3.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u3.verticalTextFeatureIndex = r3.featureIndex;
      break;
    }
    for (let t4 = n; t4 < s3; t4++) {
      let r3 = e53.get(t4);
      u3.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u3.iconFeatureIndex = r3.featureIndex;
      break;
    }
    for (let t4 = o; t4 < l; t4++) {
      let r3 = e53.get(t4);
      u3.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u3.verticalIconFeatureIndex = r3.featureIndex;
      break;
    }
    return u3;
  }
  deserializeCollisionBoxes(e53) {
    this.collisionArrays = [];
    for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
      let r = this.symbolInstances.get(t3);
      this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e53, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
    }
  }
  hasTextData() {
    return this.text.segments.get().length > 0;
  }
  hasIconData() {
    return this.icon.segments.get().length > 0;
  }
  hasDebugData() {
    return this.textCollisionBox && this.iconCollisionBox;
  }
  hasTextCollisionBoxData() {
    return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
  }
  hasIconCollisionBoxData() {
    return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
  }
  addIndicesForPlacedSymbol(e53, t3) {
    let r = e53.placedSymbolArray.get(t3), i = r.vertexStartIndex + 4 * r.numGlyphs;
    for (let t4 = r.vertexStartIndex; t4 < i; t4 += 4)
      e53.indexArray.emplaceBack(t4, t4 + 1, t4 + 2), e53.indexArray.emplaceBack(t4 + 1, t4 + 2, t4 + 3);
  }
  getSortedSymbolIndexes(e53) {
    if (this.sortedAngle === e53 && void 0 !== this.symbolInstanceIndexes)
      return this.symbolInstanceIndexes;
    let t3 = Math.sin(e53), r = Math.cos(e53), i = [], a = [], n = [];
    for (let e54 = 0; e54 < this.symbolInstances.length; ++e54) {
      n.push(e54);
      let s3 = this.symbolInstances.get(e54);
      i.push(0 | Math.round(t3 * s3.anchorX + r * s3.anchorY)), a.push(s3.featureIndex);
    }
    return n.sort((e54, t4) => i[e54] - i[t4] || a[t4] - a[e54]), n;
  }
  addToSortKeyRanges(e53, t3) {
    let r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
    r && r.sortKey === t3 ? r.symbolInstanceEnd = e53 + 1 : this.sortKeyRanges.push({ sortKey: t3, symbolInstanceStart: e53, symbolInstanceEnd: e53 + 1 });
  }
  sortFeatures(e53) {
    if (this.sortFeaturesByY && this.sortedAngle !== e53 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
      this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e53), this.sortedAngle = e53, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
      for (let e54 of this.symbolInstanceIndexes) {
        let t3 = this.symbolInstances.get(e54);
        this.featureSortOrder.push(t3.featureIndex), [t3.rightJustifiedTextSymbolIndex, t3.centerJustifiedTextSymbolIndex, t3.leftJustifiedTextSymbolIndex].forEach((e55, t4, r) => {
          e55 >= 0 && r.indexOf(e55) === t4 && this.addIndicesForPlacedSymbol(this.text, e55);
        }), t3.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, t3.verticalPlacedTextSymbolIndex), t3.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t3.placedIconSymbolIndex), t3.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t3.verticalPlacedIconSymbolIndex);
      }
      this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
    }
  }
};
q(Rf, "SymbolBucket");
var Gt = Rf;
function x_(e53, t3) {
  return t3.replace(/{([^{}]+)}/g, (t4, r) => r in e53 ? String(e53[r]) : "");
}
G("SymbolBucket", Gt, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Gt.MAX_GLYPHS = 65535, Gt.addDynamicAttributes = pi, c(), q(x_, "resolveTokens"), c();
var b_;
var __;
var VM = q(() => b_ = b_ || new Re({ "symbol-placement": new $(M.layout_symbol["symbol-placement"]), "symbol-spacing": new $(M.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new $(M.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new W(M.layout_symbol["symbol-sort-key"]), "symbol-z-order": new $(M.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new $(M.layout_symbol["icon-allow-overlap"]), "icon-overlap": new $(M.layout_symbol["icon-overlap"]), "icon-ignore-placement": new $(M.layout_symbol["icon-ignore-placement"]), "icon-optional": new $(M.layout_symbol["icon-optional"]), "icon-rotation-alignment": new $(M.layout_symbol["icon-rotation-alignment"]), "icon-size": new W(M.layout_symbol["icon-size"]), "icon-text-fit": new $(M.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new $(M.layout_symbol["icon-text-fit-padding"]), "icon-image": new W(M.layout_symbol["icon-image"]), "icon-rotate": new W(M.layout_symbol["icon-rotate"]), "icon-padding": new W(M.layout_symbol["icon-padding"]), "icon-keep-upright": new $(M.layout_symbol["icon-keep-upright"]), "icon-offset": new W(M.layout_symbol["icon-offset"]), "icon-anchor": new W(M.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new $(M.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new $(M.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new $(M.layout_symbol["text-rotation-alignment"]), "text-field": new W(M.layout_symbol["text-field"]), "text-font": new W(M.layout_symbol["text-font"]), "text-size": new W(M.layout_symbol["text-size"]), "text-max-width": new W(M.layout_symbol["text-max-width"]), "text-line-height": new $(M.layout_symbol["text-line-height"]), "text-letter-spacing": new W(M.layout_symbol["text-letter-spacing"]), "text-justify": new W(M.layout_symbol["text-justify"]), "text-radial-offset": new W(M.layout_symbol["text-radial-offset"]), "text-variable-anchor": new $(M.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new W(M.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new W(M.layout_symbol["text-anchor"]), "text-max-angle": new $(M.layout_symbol["text-max-angle"]), "text-writing-mode": new $(M.layout_symbol["text-writing-mode"]), "text-rotate": new W(M.layout_symbol["text-rotate"]), "text-padding": new $(M.layout_symbol["text-padding"]), "text-keep-upright": new $(M.layout_symbol["text-keep-upright"]), "text-transform": new W(M.layout_symbol["text-transform"]), "text-offset": new W(M.layout_symbol["text-offset"]), "text-allow-overlap": new $(M.layout_symbol["text-allow-overlap"]), "text-overlap": new $(M.layout_symbol["text-overlap"]), "text-ignore-placement": new $(M.layout_symbol["text-ignore-placement"]), "text-optional": new $(M.layout_symbol["text-optional"]) }), "getLayout");
var UM = q(() => __ = __ || new Re({ "icon-opacity": new W(M.paint_symbol["icon-opacity"]), "icon-color": new W(M.paint_symbol["icon-color"]), "icon-halo-color": new W(M.paint_symbol["icon-halo-color"]), "icon-halo-width": new W(M.paint_symbol["icon-halo-width"]), "icon-halo-blur": new W(M.paint_symbol["icon-halo-blur"]), "icon-translate": new $(M.paint_symbol["icon-translate"]), "icon-translate-anchor": new $(M.paint_symbol["icon-translate-anchor"]), "text-opacity": new W(M.paint_symbol["text-opacity"]), "text-color": new W(M.paint_symbol["text-color"], { runtimeType: Lt, getOverride: (e53) => e53.textColor, hasOverride: (e53) => !!e53.textColor }), "text-halo-color": new W(M.paint_symbol["text-halo-color"]), "text-halo-width": new W(M.paint_symbol["text-halo-width"]), "text-halo-blur": new W(M.paint_symbol["text-halo-blur"]), "text-translate": new $(M.paint_symbol["text-translate"]), "text-translate-anchor": new $(M.paint_symbol["text-translate-anchor"]) }), "getPaint");
var tl = { get paint() {
  return UM();
}, get layout() {
  return VM();
} };
c();
var Of = class {
  constructor(e53) {
    if (void 0 === e53.property.overrides)
      throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
    this.type = e53.property.overrides ? e53.property.overrides.runtimeType : zi, this.defaultValue = e53;
  }
  evaluate(e53) {
    if (e53.formattedSection) {
      let t3 = this.defaultValue.property.overrides;
      if (t3 && t3.hasOverride(e53.formattedSection))
        return t3.getOverride(e53.formattedSection);
    }
    return e53.feature && e53.featureState ? this.defaultValue.evaluate(e53.feature, e53.featureState) : this.defaultValue.property.specification.default;
  }
  eachChild(e53) {
    if (!this.defaultValue.isConstant()) {
      e53(this.defaultValue.value._styleExpression.expression);
    }
  }
  outputDefined() {
    return false;
  }
  serialize() {
    return null;
  }
};
q(Of, "FormatSectionOverride");
var Na = Of;
G("FormatSectionOverride", Na, { omit: ["defaultValue"] });
var Ga = class e37 extends je {
  constructor(e53) {
    super(e53, tl);
  }
  recalculate(e53, t3) {
    if (super.recalculate(e53, t3), "auto" === this.layout.get("icon-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["icon-rotation-alignment"] = "map" : this.layout._values["icon-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-rotation-alignment") && ("point" !== this.layout.get("symbol-placement") ? this.layout._values["text-rotation-alignment"] = "map" : this.layout._values["text-rotation-alignment"] = "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
      let e54 = this.layout.get("text-writing-mode");
      if (e54) {
        let t4 = [];
        for (let r of e54)
          t4.indexOf(r) < 0 && t4.push(r);
        this.layout._values["text-writing-mode"] = t4;
      } else
        this.layout._values["text-writing-mode"] = ["horizontal"];
    }
    this._setPaintOverrides();
  }
  getValueAndResolveTokens(e53, t3, r, i) {
    let a = this.layout.get(e53).evaluate(t3, {}, r, i), n = this._unevaluatedLayout._values[e53];
    return n.isDataDriven() || Wn(n.value) || !a ? a : x_(t3.properties, a);
  }
  createBucket(e53) {
    return new Gt(e53);
  }
  queryRadius() {
    return 0;
  }
  queryIntersectsFeature() {
    throw new Error("Should take a different path in FeatureIndex");
  }
  _setPaintOverrides() {
    for (let t3 of tl.paint.overridableProperties) {
      if (!e37.hasPaintOverride(this.layout, t3))
        continue;
      let r = this.paint.get(t3), i = new Na(r), a = new Zr(i, r.property.specification), n = null;
      n = "constant" === r.value.kind || "source" === r.value.kind ? new xr("source", a) : new br("composite", a, r.value.zoomStops), this.paint._values[t3] = new at(r.property, n, r.parameters);
    }
  }
  _handleOverridablePaintPropertyUpdate(t3, r, i) {
    return !(!this.layout || r.isDataDriven() || i.isDataDriven()) && e37.hasPaintOverride(this.layout, t3);
  }
  static hasPaintOverride(e53, t3) {
    let r = e53.get("text-field"), i = tl.paint.properties[t3], a = false, n = q((e54) => {
      for (let t4 of e54)
        if (i.overrides && i.overrides.hasOverride(t4))
          return void (a = true);
    }, "checkSections");
    if ("constant" === r.value.kind && r.value.value instanceof St)
      n(r.value.value.sections);
    else if ("source" === r.value.kind) {
      let e54 = q((t5) => {
        if (!a)
          if (t5 instanceof yr && We(t5.value) === Fi) {
            let e55 = t5.value;
            n(e55.sections);
          } else
            t5 instanceof qn ? n(t5.sections) : t5.eachChild(e54);
      }, "checkExpression"), t4 = r.value;
      t4._styleExpression && e54(t4._styleExpression.expression);
    }
    return a;
  }
};
q(Ga, "SymbolStyleLayer");
var rl = Ga;
c(), c();
var v_;
var NM = q(() => v_ = v_ || new Re({ "background-color": new $(M.paint_background["background-color"]), "background-pattern": new Jr(M.paint_background["background-pattern"]), "background-opacity": new $(M.paint_background["background-opacity"]) }), "getPaint");
var w_ = { get paint() {
  return NM();
} };
var Vf = class extends je {
  constructor(e53) {
    super(e53, w_);
  }
};
q(Vf, "BackgroundStyleLayer");
var il = Vf;
c(), c();
var S_;
var GM = q(() => S_ = S_ || new Re({ "raster-opacity": new $(M.paint_raster["raster-opacity"]), "raster-hue-rotate": new $(M.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new $(M.paint_raster["raster-brightness-min"]), "raster-brightness-max": new $(M.paint_raster["raster-brightness-max"]), "raster-saturation": new $(M.paint_raster["raster-saturation"]), "raster-contrast": new $(M.paint_raster["raster-contrast"]), "raster-resampling": new $(M.paint_raster["raster-resampling"]), "raster-fade-duration": new $(M.paint_raster["raster-fade-duration"]) }), "getPaint");
var P_ = { get paint() {
  return GM();
} };
var Uf = class extends je {
  constructor(e53) {
    super(e53, P_);
  }
};
q(Uf, "RasterStyleLayer");
var nl = Uf;
function T_(e53) {
  let t3 = [], r = e53.id;
  return void 0 === r && t3.push({ message: "layers.".concat(r, ': missing required property "id"') }), void 0 === e53.render && t3.push({ message: "layers.".concat(r, ': missing required method "render"') }), e53.renderingMode && "2d" !== e53.renderingMode && "3d" !== e53.renderingMode && t3.push({ message: "layers.".concat(r, ': property "renderingMode" must be either "2d" or "3d"') }), t3;
}
c(), q(T_, "validateCustomStyleLayer");
var Nf = class extends je {
  constructor(e53) {
    super(e53, {}), this.onAdd = q((e54) => {
      this.implementation.onAdd && this.implementation.onAdd(e54, e54.painter.context.gl);
    }, "onAdd"), this.onRemove = q((e54) => {
      this.implementation.onRemove && this.implementation.onRemove(e54, e54.painter.context.gl);
    }, "onRemove"), this.implementation = e53;
  }
  is3D() {
    return "3d" === this.implementation.renderingMode;
  }
  hasOffscreenPass() {
    return void 0 !== this.implementation.prerender;
  }
  recalculate() {
  }
  updateTransitions() {
  }
  hasTransition() {
    return false;
  }
  serialize() {
    throw new Error("Custom layers cannot be serialized");
  }
};
q(Nf, "CustomStyleLayer");
var al = Nf;
function ol(e53) {
  if ("custom" === e53.type)
    return new al(e53);
  switch (e53.type) {
    case "background":
      return new il(e53);
    case "circle":
      return new Os(e53);
    case "fill":
      return new js(e53);
    case "fill-extrusion":
      return new Zs(e53);
    case "heatmap":
      return new Gs(e53);
    case "hillshade":
      return new qs(e53);
    case "line":
      return new Xs(e53);
    case "raster":
      return new nl(e53);
    case "symbol":
      return new rl(e53);
  }
}
function an(e53) {
  let t3 = [];
  if ("string" == typeof e53)
    t3.push({ id: "default", url: e53 });
  else if (e53 && e53.length > 0) {
    let r = [];
    for (let { id: i, url: a } of e53) {
      let e54 = "".concat(i).concat(a);
      -1 === r.indexOf(e54) && (r.push(e54), t3.push({ id: i, url: a }));
    }
  }
  return t3;
}
function I_(e53, t3, r, i) {
  let a = an(e53), n = a.length, s3 = r > 1 ? "@2x" : "", o = {}, l = {}, u3 = {};
  for (let { id: e54, url: r3 } of a) {
    let a3 = t3.transformRequest(t3.normalizeSpriteURL(r3, s3, ".json"), "SpriteJSON"), c3 = "".concat(e54, "_").concat(a3.url);
    o[c3] = fr(a3, (t4, r4) => {
      delete o[c3], l[e54] = r4, A_(i, l, u3, t4, n);
    });
    let h = t3.transformRequest(t3.normalizeSpriteURL(r3, s3, ".png"), "SpriteImage"), p = "".concat(e54, "_").concat(h.url);
    o[p] = ot.getImage(h, (t4, r4) => {
      delete o[p], u3[e54] = r4, A_(i, l, u3, t4, n);
    });
  }
  return { cancel() {
    for (let e54 of Object.values(o))
      e54.cancel();
  } };
}
function A_(e53, t3, r, i, a) {
  if (i)
    return void e53(i);
  if (a !== Object.values(t3).length || a !== Object.values(r).length)
    return;
  let n = {};
  for (let e54 in t3) {
    n[e54] = {};
    let i3 = ne.getImageCanvasContext(r[e54]), a3 = t3[e54];
    for (let t4 in a3) {
      let { width: r3, height: s3, x: o, y: l, sdf: u3, pixelRatio: c3, stretchX: h, stretchY: p, content: d } = a3[t4], f = { width: r3, height: s3, x: o, y: l, context: i3 };
      n[e54][t4] = { data: null, pixelRatio: c3, sdf: u3, stretchX: h, stretchY: p, content: d, spriteData: f };
    }
  }
  e53(null, n);
}
q(ol, "createStyleLayer"), c(), c(), q(an, "coerceSpriteToArray"), q(I_, "loadSprite"), q(A_, "doOnceCompleted"), c(), c();
var Gf = class {
  constructor(e53, t3, r, i) {
    this.context = e53, this.format = r, this.texture = e53.gl.createTexture(), this.update(t3, i);
  }
  update(e53, t3, r) {
    let { width: i, height: a } = e53, n = !(this.size && this.size[0] === i && this.size[1] === a || r), { context: s3 } = this, { gl: o } = s3;
    if (this.useMipmap = !(!t3 || !t3.useMipmap), o.bindTexture(o.TEXTURE_2D, this.texture), s3.pixelStoreUnpackFlipY.set(false), s3.pixelStoreUnpack.set(1), s3.pixelStoreUnpackPremultiplyAlpha.set(this.format === o.RGBA && (!t3 || false !== t3.premultiply)), n)
      this.size = [i, a], e53 instanceof HTMLImageElement || e53 instanceof HTMLCanvasElement || e53 instanceof HTMLVideoElement || e53 instanceof ImageData || Ct(e53) ? o.texImage2D(o.TEXTURE_2D, 0, this.format, this.format, o.UNSIGNED_BYTE, e53) : o.texImage2D(o.TEXTURE_2D, 0, this.format, i, a, 0, this.format, o.UNSIGNED_BYTE, e53.data);
    else {
      let { x: t4, y: n3 } = r || { x: 0, y: 0 };
      e53 instanceof HTMLImageElement || e53 instanceof HTMLCanvasElement || e53 instanceof HTMLVideoElement || e53 instanceof ImageData || Ct(e53) ? o.texSubImage2D(o.TEXTURE_2D, 0, t4, n3, o.RGBA, o.UNSIGNED_BYTE, e53) : o.texSubImage2D(o.TEXTURE_2D, 0, t4, n3, i, a, o.RGBA, o.UNSIGNED_BYTE, e53.data);
    }
    this.useMipmap && this.isSizePowerOfTwo() && o.generateMipmap(o.TEXTURE_2D);
  }
  bind(e53, t3, r) {
    let { context: i } = this, { gl: a } = i;
    a.bindTexture(a.TEXTURE_2D, this.texture), r === a.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo() && (r = a.LINEAR), e53 !== this.filter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e53), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, r || e53), this.filter = e53), t3 !== this.wrap && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, t3), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, t3), this.wrap = t3);
  }
  isSizePowerOfTwo() {
    return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
  }
  destroy() {
    let { gl: e53 } = this.context;
    e53.deleteTexture(this.texture), this.texture = null;
  }
};
q(Gf, "Texture");
var be = Gf;
function M_(e53) {
  let { userImage: t3 } = e53;
  return !!(t3 && t3.render && t3.render()) && (e53.data.replace(new Uint8Array(t3.data.buffer)), true);
}
c(), q(M_, "renderStyleImage");
var sl = 1;
var qf = class extends de {
  constructor() {
    super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new Ee({ width: 1, height: 1 }), this.dirty = true;
  }
  isLoaded() {
    return this.loaded;
  }
  setLoaded(e53) {
    if (this.loaded !== e53 && (this.loaded = e53, e53)) {
      for (let { ids: e54, callback: t3 } of this.requestors)
        this._notify(e54, t3);
      this.requestors = [];
    }
  }
  getImage(e53) {
    let t3 = this.images[e53];
    if (t3 && !t3.data && t3.spriteData) {
      let e54 = t3.spriteData;
      t3.data = new Ee({ width: e54.width, height: e54.height }, e54.context.getImageData(e54.x, e54.y, e54.width, e54.height).data), t3.spriteData = null;
    }
    return t3;
  }
  addImage(e53, t3) {
    if (this.images[e53])
      throw new Error("Image id ".concat(e53, " already exist, use updateImage instead"));
    this._validate(e53, t3) && (this.images[e53] = t3);
  }
  _validate(e53, t3) {
    let r = true, i = t3.data || t3.spriteData;
    return this._validateStretch(t3.stretchX, i && i.width) || (this.fire(new Z(new Error('Image "'.concat(e53, '" has invalid "stretchX" value')))), r = false), this._validateStretch(t3.stretchY, i && i.height) || (this.fire(new Z(new Error('Image "'.concat(e53, '" has invalid "stretchY" value')))), r = false), this._validateContent(t3.content, t3) || (this.fire(new Z(new Error('Image "'.concat(e53, '" has invalid "content" value')))), r = false), r;
  }
  _validateStretch(e53, t3) {
    if (!e53)
      return true;
    let r = 0;
    for (let i of e53) {
      if (i[0] < r || i[1] < i[0] || t3 < i[1])
        return false;
      r = i[1];
    }
    return true;
  }
  _validateContent(e53, t3) {
    if (!e53)
      return true;
    if (4 !== e53.length)
      return false;
    let r = t3.spriteData, i = r && r.width || t3.data.width, a = r && r.height || t3.data.height;
    return !(e53[0] < 0 || i < e53[0] || e53[1] < 0 || a < e53[1] || e53[2] < 0 || i < e53[2] || e53[3] < 0 || a < e53[3] || e53[2] < e53[0] || e53[3] < e53[1]);
  }
  updateImage(e53, t3, r = true) {
    let i = this.getImage(e53);
    if (r && (i.data.width !== t3.data.width || i.data.height !== t3.data.height))
      throw new Error("size mismatch between old image (".concat(i.data.width, "x").concat(i.data.height, ") and new image (").concat(t3.data.width, "x").concat(t3.data.height, ")."));
    t3.version = i.version + 1, this.images[e53] = t3, this.updatedImages[e53] = true;
  }
  removeImage(e53) {
    let t3 = this.images[e53];
    delete this.images[e53], delete this.patterns[e53], t3.userImage && t3.userImage.onRemove && t3.userImage.onRemove();
  }
  listImages() {
    return Object.keys(this.images);
  }
  getImages(e53, t3) {
    let r = true;
    if (!this.isLoaded())
      for (let t4 of e53)
        this.images[t4] || (r = false);
    this.isLoaded() || r ? this._notify(e53, t3) : this.requestors.push({ ids: e53, callback: t3 });
  }
  _notify(e53, t3) {
    let r = {};
    for (let t4 of e53) {
      let e54 = this.getImage(t4);
      e54 || (this.fire(new z("styleimagemissing", { id: t4 })), e54 = this.getImage(t4)), e54 ? r[t4] = { data: e54.data.clone(), pixelRatio: e54.pixelRatio, sdf: e54.sdf, version: e54.version, stretchX: e54.stretchX, stretchY: e54.stretchY, content: e54.content, hasRenderCallback: !(!e54.userImage || !e54.userImage.render) } : Ce('Image "'.concat(t4, '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.'));
    }
    t3(null, r);
  }
  getPixelSize() {
    let { width: e53, height: t3 } = this.atlasImage;
    return { width: e53, height: t3 };
  }
  getPattern(e53) {
    let t3 = this.patterns[e53], r = this.getImage(e53);
    if (!r)
      return null;
    if (t3 && t3.position.version === r.version)
      return t3.position;
    if (t3)
      t3.position.version = r.version;
    else {
      let t4 = { w: r.data.width + 2 * sl, h: r.data.height + 2 * sl, x: 0, y: 0 }, i = new tn(t4, r);
      this.patterns[e53] = { bin: t4, position: i };
    }
    return this._updatePatternAtlas(), this.patterns[e53].position;
  }
  bind(e53) {
    let t3 = e53.gl;
    this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new be(e53, this.atlasImage, t3.RGBA), this.atlasTexture.bind(t3.LINEAR, t3.CLAMP_TO_EDGE);
  }
  _updatePatternAtlas() {
    let e53 = [];
    for (let t4 in this.patterns)
      e53.push(this.patterns[t4].bin);
    let { w: t3, h: r } = Ba(e53), i = this.atlasImage;
    i.resize({ width: t3 || 1, height: r || 1 });
    for (let e54 in this.patterns) {
      let { bin: t4 } = this.patterns[e54], r3 = t4.x + sl, a = t4.y + sl, n = this.getImage(e54).data, s3 = n.width, o = n.height;
      Ee.copy(n, i, { x: 0, y: 0 }, { x: r3, y: a }, { width: s3, height: o }), Ee.copy(n, i, { x: 0, y: o - 1 }, { x: r3, y: a - 1 }, { width: s3, height: 1 }), Ee.copy(n, i, { x: 0, y: 0 }, { x: r3, y: a + o }, { width: s3, height: 1 }), Ee.copy(n, i, { x: s3 - 1, y: 0 }, { x: r3 - 1, y: a }, { width: 1, height: o }), Ee.copy(n, i, { x: 0, y: 0 }, { x: r3 + s3, y: a }, { width: 1, height: o });
    }
    this.dirty = true;
  }
  beginFrame() {
    this.callbackDispatchedThisFrame = {};
  }
  dispatchRenderCallbacks(e53) {
    for (let t3 of e53) {
      if (this.callbackDispatchedThisFrame[t3])
        continue;
      this.callbackDispatchedThisFrame[t3] = true;
      let e54 = this.getImage(t3);
      e54 || Ce('Image with ID: "'.concat(t3, '" was not found')), M_(e54) && this.updateImage(t3, e54);
    }
  }
};
q(qf, "ImageManager");
var ll = qf;
function C_(e53, t3, r, i, a) {
  let n = 256 * t3, s3 = n + 255, o = i.transformRequest(r.replace("{fontstack}", e53).replace("{range}", "".concat(n, "-").concat(s3)), "Glyphs");
  xo(o, (e54, t4) => {
    if (e54)
      a(e54);
    else if (t4) {
      let e55 = {};
      for (let r3 of m_(t4))
        e55[r3.id] = r3;
      a(null, e55);
    }
  });
}
c(), c(), q(C_, "loadGlyphRange"), c();
var jf = class {
  constructor({ fontSize: e53 = 24, buffer: t3 = 3, radius: r = 8, cutoff: i = 0.25, fontFamily: a = "sans-serif", fontWeight: n = "normal", fontStyle: s3 = "normal" } = {}) {
    this.buffer = t3, this.cutoff = i, this.radius = r;
    let o = this.size = e53 + 4 * t3, l = this._createCanvas(o), u3 = this.ctx = l.getContext("2d", { willReadFrequently: true });
    u3.font = "".concat(s3, " ").concat(n, " ").concat(e53, "px ").concat(a), u3.textBaseline = "alphabetic", u3.textAlign = "left", u3.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
  }
  _createCanvas(e53) {
    let t3 = document.createElement("canvas");
    return t3.width = t3.height = e53, t3;
  }
  draw(e53) {
    let { width: t3, actualBoundingBoxAscent: r, actualBoundingBoxDescent: i, actualBoundingBoxLeft: a, actualBoundingBoxRight: n } = this.ctx.measureText(e53), s3 = Math.ceil(r), o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(n - a))), l = Math.min(this.size - this.buffer, s3 + Math.ceil(i)), u3 = o + 2 * this.buffer, c3 = l + 2 * this.buffer, h = Math.max(u3 * c3, 0), p = new Uint8ClampedArray(h), d = { data: p, width: u3, height: c3, glyphWidth: o, glyphHeight: l, glyphTop: s3, glyphLeft: 0, glyphAdvance: t3 };
    if (0 === o || 0 === l)
      return d;
    let { ctx: f, buffer: m, gridInner: y, gridOuter: g } = this;
    f.clearRect(m, m, o, l), f.fillText(e53, m, m + s3);
    let _ = f.getImageData(m, m, o, l);
    g.fill(1e20, 0, h), y.fill(0, 0, h);
    for (let e54 = 0; e54 < l; e54++)
      for (let t4 = 0; t4 < o; t4++) {
        let r3 = _.data[4 * (e54 * o + t4) + 3] / 255;
        if (0 === r3)
          continue;
        let i3 = (e54 + m) * u3 + t4 + m;
        if (1 === r3)
          g[i3] = 0, y[i3] = 1e20;
        else {
          let e55 = 0.5 - r3;
          g[i3] = e55 > 0 ? e55 * e55 : 0, y[i3] = e55 < 0 ? e55 * e55 : 0;
        }
      }
    E_(g, 0, 0, u3, c3, u3, this.f, this.v, this.z), E_(y, m, m, o, l, u3, this.f, this.v, this.z);
    for (let e54 = 0; e54 < h; e54++) {
      let t4 = Math.sqrt(g[e54]) - Math.sqrt(y[e54]);
      p[e54] = Math.round(255 - 255 * (t4 / this.radius + this.cutoff));
    }
    return d;
  }
};
q(jf, "TinySDF");
var qa = jf;
function E_(e53, t3, r, i, a, n, s3, o, l) {
  for (let u3 = t3; u3 < t3 + i; u3++)
    k_(e53, r * n + u3, n, a, s3, o, l);
  for (let u3 = r; u3 < r + a; u3++)
    k_(e53, u3 * n + t3, 1, i, s3, o, l);
}
function k_(e53, t3, r, i, a, n, s3) {
  n[0] = 0, s3[0] = -1e20, s3[1] = 1e20, a[0] = e53[t3];
  for (let o = 1, l = 0, u3 = 0; o < i; o++) {
    a[o] = e53[t3 + o * r];
    let i3 = o * o;
    do {
      let e54 = n[l];
      u3 = (a[o] - a[e54] + i3 - e54 * e54) / (o - e54) / 2;
    } while (u3 <= s3[l] && --l > -1);
    l++, n[l] = o, s3[l] = u3, s3[l + 1] = 1e20;
  }
  for (let o = 0, l = 0; o < i; o++) {
    for (; s3[l + 1] < o; )
      l++;
    let i3 = n[l], u3 = o - i3;
    e53[t3 + o * r] = a[i3] + u3 * u3;
  }
}
q(E_, "edt"), q(k_, "edt1d");
var hi = class e38 {
  constructor(e53, t3) {
    this.requestManager = e53, this.localIdeographFontFamily = t3, this.entries = {};
  }
  setURL(e53) {
    this.url = e53;
  }
  getGlyphs(t3, r) {
    let i = [];
    for (let e53 in t3)
      for (let r3 of t3[e53])
        i.push({ stack: e53, id: r3 });
    ho(i, ({ stack: t4, id: r3 }, i3) => {
      let a = this.entries[t4];
      a || (a = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {} });
      let n = a.glyphs[r3];
      if (void 0 !== n)
        return void i3(null, { stack: t4, id: r3, glyph: n });
      if (n = this._tinySDF(a, t4, r3), n)
        return a.glyphs[r3] = n, void i3(null, { stack: t4, id: r3, glyph: n });
      let s3 = Math.floor(r3 / 256);
      if (256 * s3 > 65535)
        return void i3(new Error("glyphs > 65535 not supported"));
      if (a.ranges[s3])
        return void i3(null, { stack: t4, id: r3, glyph: n });
      if (!this.url)
        return void i3(new Error("glyphsUrl is not set"));
      let o = a.requests[s3];
      o || (o = a.requests[s3] = [], e38.loadGlyphRange(t4, s3, this.url, this.requestManager, (e53, t5) => {
        if (t5) {
          for (let e54 in t5)
            this._doesCharSupportLocalGlyph(+e54) || (a.glyphs[+e54] = t5[+e54]);
          a.ranges[s3] = true;
        }
        for (let r4 of o)
          r4(e53, t5);
        delete a.requests[s3];
      })), o.push((e53, a3) => {
        e53 ? i3(e53) : a3 && i3(null, { stack: t4, id: r3, glyph: a3[r3] || null });
      });
    }, (e53, t4) => {
      if (e53)
        r(e53);
      else if (t4) {
        let e54 = {};
        for (let { stack: r3, id: i3, glyph: a } of t4)
          (e54[r3] || (e54[r3] = {}))[i3] = a && { id: a.id, bitmap: a.bitmap.clone(), metrics: a.metrics };
        r(null, e54);
      }
    });
  }
  _doesCharSupportLocalGlyph(e53) {
    return !!this.localIdeographFontFamily && (pe["CJK Unified Ideographs"](e53) || pe["Hangul Syllables"](e53) || pe.Hiragana(e53) || pe.Katakana(e53));
  }
  _tinySDF(t3, r, i) {
    let a = this.localIdeographFontFamily;
    if (!a || !this._doesCharSupportLocalGlyph(i))
      return;
    let n = t3.tinySDF;
    if (!n) {
      let i3 = "400";
      /bold/i.test(r) ? i3 = "900" : /medium/i.test(r) ? i3 = "500" : /light/i.test(r) && (i3 = "200"), n = t3.tinySDF = new e38.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: a, fontWeight: i3 });
    }
    let s3 = n.draw(String.fromCharCode(i));
    return { id: i, bitmap: new si({ width: s3.width || 30, height: s3.height || 30 }, s3.data), metrics: { width: s3.glyphWidth || 24, height: s3.glyphHeight || 24, left: s3.glyphLeft || 0, top: s3.glyphTop - 27 || -8, advance: s3.glyphAdvance || 24 } };
  }
};
q(hi, "GlyphManager"), hi.loadGlyphRange = C_, hi.TinySDF = qa;
var ul = hi;
c();
var Zf = class {
  constructor() {
    this.specification = M.light.position;
  }
  possiblyEvaluate(e53, t3) {
    return Qy(e53.expression.evaluate(t3));
  }
  interpolate(e53, t3, r) {
    return { x: ke.number(e53.x, t3.x, r), y: ke.number(e53.y, t3.y, r), z: ke.number(e53.z, t3.z, r) };
  }
};
q(Zf, "LightPositionProperty");
var $f;
var Hf = Zf;
var L_ = "-transition";
var Wf = class extends de {
  constructor(e53) {
    super(), $f = $f || new Re({ anchor: new $(M.light.anchor), position: new Hf(), color: new $(M.light.color), intensity: new $(M.light.intensity) }), this._transitionable = new Gi($f), this.setLight(e53), this._transitioning = this._transitionable.untransitioned();
  }
  getLight() {
    return this._transitionable.serialize();
  }
  setLight(e53, t3 = {}) {
    if (!this._validate(ox, e53, t3))
      for (let t4 in e53) {
        let r = e53[t4];
        t4.endsWith(L_) ? this._transitionable.setTransition(t4.slice(0, -L_.length), r) : this._transitionable.setValue(t4, r);
      }
  }
  updateTransitions(e53) {
    this._transitioning = this._transitionable.transitioned(e53, this._transitioning);
  }
  hasTransition() {
    return this._transitioning.hasTransition();
  }
  recalculate(e53) {
    this.properties = this._transitioning.possiblyEvaluate(e53);
  }
  _validate(e53, t3, r) {
    return (!r || false !== r.validate) && Ri(this, e53.call(qe, R({ value: t3, style: { glyphs: true, sprite: true }, styleSpec: M })));
  }
};
q(Wf, "Light");
var cl = Wf;
c();
var Xf = class {
  constructor(e53, t3) {
    this.width = e53, this.height = t3, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
  }
  getDash(e53, t3) {
    let r = e53.join(",") + String(t3);
    return this.dashEntry[r] || (this.dashEntry[r] = this.addDash(e53, t3)), this.dashEntry[r];
  }
  getDashRanges(e53, t3, r) {
    let i = [], a = e53.length % 2 == 1 ? -e53[e53.length - 1] * r : 0, n = e53[0] * r, s3 = true;
    i.push({ left: a, right: n, isDash: s3, zeroLength: 0 === e53[0] });
    let o = e53[0];
    for (let t4 = 1; t4 < e53.length; t4++) {
      s3 = !s3;
      let l = e53[t4];
      a = o * r, o += l, n = o * r, i.push({ left: a, right: n, isDash: s3, zeroLength: 0 === l });
    }
    return i;
  }
  addRoundDash(e53, t3, r) {
    let i = t3 / 2;
    for (let t4 = -r; t4 <= r; t4++) {
      let a = this.nextRow + r + t4, n = this.width * a, s3 = 0, o = e53[s3];
      for (let a3 = 0; a3 < this.width; a3++) {
        a3 / o.right > 1 && (o = e53[++s3]);
        let l, u3 = Math.abs(a3 - o.left), c3 = Math.abs(a3 - o.right), h = Math.min(u3, c3), p = t4 / r * (i + 1);
        if (o.isDash) {
          let e54 = i - Math.abs(p);
          l = Math.sqrt(h * h + e54 * e54);
        } else
          l = i - Math.sqrt(h * h + p * p);
        this.data[n + a3] = Math.max(0, Math.min(255, l + 128));
      }
    }
  }
  addRegularDash(e53) {
    for (let t4 = e53.length - 1; t4 >= 0; --t4) {
      let r3 = e53[t4], i3 = e53[t4 + 1];
      r3.zeroLength ? e53.splice(t4, 1) : i3 && i3.isDash === r3.isDash && (i3.left = r3.left, e53.splice(t4, 1));
    }
    let t3 = e53[0], r = e53[e53.length - 1];
    t3.isDash === r.isDash && (t3.left = r.left - this.width, r.right = t3.right + this.width);
    let i = this.width * this.nextRow, a = 0, n = e53[a];
    for (let t4 = 0; t4 < this.width; t4++) {
      t4 / n.right > 1 && (n = e53[++a]);
      let r3 = Math.abs(t4 - n.left), s3 = Math.abs(t4 - n.right), o = Math.min(r3, s3), l = n.isDash ? o : -o;
      this.data[i + t4] = Math.max(0, Math.min(255, l + 128));
    }
  }
  addDash(e53, t3) {
    let r = t3 ? 7 : 0, i = 2 * r + 1;
    if (this.nextRow + i > this.height)
      return Ce("LineAtlas out of space"), null;
    let a = 0;
    for (let t4 = 0; t4 < e53.length; t4++)
      a += e53[t4];
    if (0 !== a) {
      let i3 = this.width / a, n3 = this.getDashRanges(e53, this.width, i3);
      t3 ? this.addRoundDash(n3, i3, r) : this.addRegularDash(n3);
    }
    let n = { y: (this.nextRow + r + 0.5) / this.height, height: 2 * r / this.height, width: a };
    return this.nextRow += i, this.dirty = true, n;
  }
  bind(e53) {
    let t3 = e53.gl;
    this.texture ? (t3.bindTexture(t3.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t3.texSubImage2D(t3.TEXTURE_2D, 0, 0, 0, this.width, this.height, t3.ALPHA, t3.UNSIGNED_BYTE, this.data))) : (this.texture = t3.createTexture(), t3.bindTexture(t3.TEXTURE_2D, this.texture), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_WRAP_S, t3.REPEAT), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_WRAP_T, t3.REPEAT), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_MIN_FILTER, t3.LINEAR), t3.texParameteri(t3.TEXTURE_2D, t3.TEXTURE_MAG_FILTER, t3.LINEAR), t3.texImage2D(t3.TEXTURE_2D, 0, t3.ALPHA, this.width, this.height, 0, t3.ALPHA, t3.UNSIGNED_BYTE, this.data));
  }
};
q(Xf, "LineAtlas");
var pl = Xf;
c(), c(), c();
var Kf = class {
  constructor(e53) {
    this._callback = e53, this._triggered = false, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
      this._triggered = false, this._callback();
    });
  }
  trigger() {
    this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
      this._triggered = false, this._callback();
    }, 0));
  }
  remove() {
    delete this._channel, this._callback = () => {
    };
  }
};
q(Kf, "ThrottledInvoker");
var hl = Kf;
var Yf = class {
  constructor(e53, t3, r) {
    this.receive = q((e54) => {
      let t4 = e54.data, r3 = t4.id;
      if (r3 && (!t4.targetMapId || this.mapId === t4.targetMapId))
        if ("<cancel>" === t4.type) {
          delete this.tasks[r3];
          let e55 = this.cancelCallbacks[r3];
          delete this.cancelCallbacks[r3], e55 && e55();
        } else
          ct() || t4.mustQueue ? (this.tasks[r3] = t4, this.taskQueue.push(r3), this.invoker.trigger()) : this.processTask(r3, t4);
    }, "receive"), this.process = q(() => {
      if (!this.taskQueue.length)
        return;
      let e54 = this.taskQueue.shift(), t4 = this.tasks[e54];
      delete this.tasks[e54], this.taskQueue.length && this.invoker.trigger(), t4 && this.processTask(e54, t4);
    }, "process"), this.target = e53, this.parent = t3, this.mapId = r, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new hl(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = ct() ? e53 : window;
  }
  send(e53, t3, r, i, a = false) {
    let n = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
    r && (this.callbacks[n] = r);
    let s3 = qr(this.globalScope) ? void 0 : [];
    return this.target.postMessage({ id: n, type: e53, hasCallback: !!r, targetMapId: i, mustQueue: a, sourceMapId: this.mapId, data: Oi(t3, s3) }, s3), { cancel: () => {
      r && delete this.callbacks[n], this.target.postMessage({ id: n, type: "<cancel>", targetMapId: i, sourceMapId: this.mapId });
    } };
  }
  processTask(e53, t3) {
    if ("<response>" === t3.type) {
      let r = this.callbacks[e53];
      delete this.callbacks[e53], r && (t3.error ? r(Vi(t3.error)) : r(null, Vi(t3.data)));
    } else {
      let r = false, i = qr(this.globalScope) ? void 0 : [], a = t3.hasCallback ? (t4, a3) => {
        r = true, delete this.cancelCallbacks[e53], this.target.postMessage({ id: e53, type: "<response>", sourceMapId: this.mapId, error: t4 ? Oi(t4) : null, data: Oi(a3, i) }, i);
      } : (e54) => {
        r = true;
      }, n = null, s3 = Vi(t3.data);
      if (this.parent[t3.type])
        n = this.parent[t3.type](t3.sourceMapId, s3, a);
      else if (this.parent.getWorkerSource) {
        let e54 = t3.type.split(".");
        n = this.parent.getWorkerSource(t3.sourceMapId, e54[0], s3.source)[e54[1]](s3, a);
      } else
        a(new Error("Could not find function ".concat(t3.type)));
      !r && n && n.cancel && (this.cancelCallbacks[e53] = n.cancel);
    }
  }
  remove() {
    this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
  }
};
q(Yf, "Actor");
var fl = Yf;
var ml = class e39 {
  constructor(t3, r, i) {
    this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = i;
    let a = this.workerPool.acquire(i);
    for (let t4 = 0; t4 < a.length; t4++) {
      let n = a[t4], s3 = new e39.Actor(n, r, i);
      s3.name = "Worker ".concat(t4), this.actors.push(s3);
    }
    if (!this.actors.length)
      throw new Error("No actors found");
  }
  broadcast(e53, t3, r) {
    r = r || function() {
    }, ho(this.actors, (r3, i) => {
      r3.send(e53, t3, i);
    }, r);
  }
  getActor() {
    return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
  }
  remove(e53 = true) {
    this.actors.forEach((e54) => {
      e54.remove();
    }), this.actors = [], e53 && this.workerPool.release(this.id);
  }
};
q(ml, "Dispatcher");
var ja = ml;
function dl(e53, t3, r) {
  let i = q(function(t4, i3) {
    if (t4)
      return r(t4);
    if (i3) {
      let t5 = Bt(R(i3, e53), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
      i3.vector_layers && (t5.vectorLayers = i3.vector_layers, t5.vectorLayerIds = t5.vectorLayers.map((e54) => e54.id)), r(null, t5);
    }
  }, "loaded");
  return e53.url ? fr(t3.transformRequest(e53.url, "Source"), i) : ne.frame(() => i(null, e53));
}
ja.Actor = fl, c(), c(), c(), q(dl, "loadTileJson"), c(), c(), c();
var mi = 63710088e-1;
var fi = class e40 {
  constructor(e53, t3) {
    if (isNaN(e53) || isNaN(t3))
      throw new Error("Invalid LngLat object: (".concat(e53, ", ").concat(t3, ")"));
    if (this.lng = +e53, this.lat = +t3, this.lat > 90 || this.lat < -90)
      throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
  }
  wrap() {
    return new e40(Yt(this.lng, -180, 180), this.lat);
  }
  toArray() {
    return [this.lng, this.lat];
  }
  toString() {
    return "LngLat(".concat(this.lng, ", ").concat(this.lat, ")");
  }
  distanceTo(e53) {
    let t3 = Math.PI / 180, r = this.lat * t3, i = e53.lat * t3, a = Math.sin(r) * Math.sin(i) + Math.cos(r) * Math.cos(i) * Math.cos((e53.lng - this.lng) * t3);
    return mi * Math.acos(Math.min(a, 1));
  }
  static convert(t3) {
    if (t3 instanceof e40)
      return t3;
    if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length))
      return new e40(Number(t3[0]), Number(t3[1]));
    if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3)
      return new e40(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
    throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
  }
};
q(fi, "LngLat");
var re = fi;
var Er = class e41 {
  constructor(e53, t3) {
    e53 && (t3 ? this.setSouthWest(e53).setNorthEast(t3) : Array.isArray(e53) && (4 === e53.length ? this.setSouthWest([e53[0], e53[1]]).setNorthEast([e53[2], e53[3]]) : this.setSouthWest(e53[0]).setNorthEast(e53[1])));
  }
  setNorthEast(e53) {
    return this._ne = e53 instanceof re ? new re(e53.lng, e53.lat) : re.convert(e53), this;
  }
  setSouthWest(e53) {
    return this._sw = e53 instanceof re ? new re(e53.lng, e53.lat) : re.convert(e53), this;
  }
  extend(t3) {
    let r, i, a = this._sw, n = this._ne;
    if (t3 instanceof re)
      r = t3, i = t3;
    else {
      if (!(t3 instanceof e41)) {
        if (Array.isArray(t3)) {
          if (4 === t3.length || t3.every(Array.isArray)) {
            let r3 = t3;
            return this.extend(e41.convert(r3));
          }
          {
            let e53 = t3;
            return this.extend(re.convert(e53));
          }
        }
        return t3 && ("lng" in t3 || "lon" in t3) && "lat" in t3 ? this.extend(re.convert(t3)) : this;
      }
      if (r = t3._sw, i = t3._ne, !r || !i)
        return this;
    }
    return a || n ? (a.lng = Math.min(r.lng, a.lng), a.lat = Math.min(r.lat, a.lat), n.lng = Math.max(i.lng, n.lng), n.lat = Math.max(i.lat, n.lat)) : (this._sw = new re(r.lng, r.lat), this._ne = new re(i.lng, i.lat)), this;
  }
  getCenter() {
    return new re((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
  }
  getSouthWest() {
    return this._sw;
  }
  getNorthEast() {
    return this._ne;
  }
  getNorthWest() {
    return new re(this.getWest(), this.getNorth());
  }
  getSouthEast() {
    return new re(this.getEast(), this.getSouth());
  }
  getWest() {
    return this._sw.lng;
  }
  getSouth() {
    return this._sw.lat;
  }
  getEast() {
    return this._ne.lng;
  }
  getNorth() {
    return this._ne.lat;
  }
  toArray() {
    return [this._sw.toArray(), this._ne.toArray()];
  }
  toString() {
    return "LngLatBounds(".concat(this._sw.toString(), ", ").concat(this._ne.toString(), ")");
  }
  isEmpty() {
    return !(this._sw && this._ne);
  }
  contains(e53) {
    let { lng: t3, lat: r } = re.convert(e53), i = this._sw.lat <= r && r <= this._ne.lat, a = this._sw.lng <= t3 && t3 <= this._ne.lng;
    return this._sw.lng > this._ne.lng && (a = this._sw.lng >= t3 && t3 >= this._ne.lng), i && a;
  }
  static convert(t3) {
    return t3 instanceof e41 || !t3 ? t3 : new e41(t3);
  }
  static fromLngLat(t3, r = 0) {
    let i = 360 * r / 40075017, a = i / Math.cos(Math.PI / 180 * t3.lat);
    return new e41(new re(t3.lng - a, t3.lat - i), new re(t3.lng + a, t3.lat + i));
  }
};
q(Er, "LngLatBounds");
var lt = Er;
c();
var D_ = 2 * Math.PI * mi;
function z_(e53) {
  return D_ * Math.cos(e53 * Math.PI / 180);
}
function kr(e53) {
  return (180 + e53) / 360;
}
function Lr(e53) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e53 * Math.PI / 360))) / 360;
}
function Qf(e53, t3) {
  return e53 / z_(t3);
}
function qM(e53) {
  return 360 * e53 - 180;
}
function Jf(e53) {
  let t3 = 180 - 360 * e53;
  return 360 / Math.PI * Math.atan(Math.exp(t3 * Math.PI / 180)) - 90;
}
function jM(e53, t3) {
  return e53 * z_(Jf(t3));
}
function $M(e53) {
  return 1 / Math.cos(e53 * Math.PI / 180);
}
q(z_, "circumferenceAtLatitude"), q(kr, "mercatorXfromLng"), q(Lr, "mercatorYfromLat"), q(Qf, "mercatorZfromAltitude"), q(qM, "lngFromMercatorX"), q(Jf, "latFromMercatorY"), q(jM, "altitudeFromMercatorZ"), q($M, "mercatorScale");
var yl = class e42 {
  constructor(e53, t3, r = 0) {
    this.x = +e53, this.y = +t3, this.z = +r;
  }
  static fromLngLat(t3, r = 0) {
    let i = re.convert(t3);
    return new e42(kr(i.lng), Lr(i.lat), Qf(r, i.lat));
  }
  toLngLat() {
    return new re(qM(this.x), Jf(this.y));
  }
  toAltitude() {
    return jM(this.z, this.y);
  }
  meterInMercatorCoordinateUnits() {
    return 1 / D_ * $M(Jf(this.y));
  }
};
q(yl, "MercatorCoordinate");
var ze = yl;
var em = class {
  constructor(e53, t3, r) {
    this.bounds = lt.convert(this.validateBounds(e53)), this.minzoom = t3 || 0, this.maxzoom = r || 24;
  }
  validateBounds(e53) {
    return Array.isArray(e53) && 4 === e53.length ? [Math.max(-180, e53[0]), Math.max(-90, e53[1]), Math.min(180, e53[2]), Math.min(90, e53[3])] : [-180, -90, 180, 90];
  }
  contains(e53) {
    let t3 = Math.pow(2, e53.z), r = Math.floor(kr(this.bounds.getWest()) * t3), i = Math.floor(Lr(this.bounds.getNorth()) * t3), a = Math.ceil(kr(this.bounds.getEast()) * t3), n = Math.ceil(Lr(this.bounds.getSouth()) * t3);
    return e53.x >= r && e53.x < a && e53.y >= i && e53.y < n;
  }
};
q(em, "TileBounds");
var on = em;
var tm = class extends de {
  constructor(e53, t3, r, i) {
    if (super(), this.load = q(() => {
      this._loaded = false, this.fire(new z("dataloading", { dataType: "source" })), this._tileJSONRequest = dl(this._options, this.map._requestManager, (e54, t4) => {
        this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e54 ? this.fire(new Z(e54)) : t4 && (R(this, t4), t4.bounds && (this.tileBounds = new on(t4.bounds, this.minzoom, this.maxzoom)), this.fire(new z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new z("data", { dataType: "source", sourceDataType: "content" })));
      });
    }, "load"), this.serialize = q(() => R({}, this._options), "serialize"), this.id = e53, this.dispatcher = r, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, R(this, Bt(t3, ["url", "scheme", "tileSize", "promoteId"])), this._options = R({ type: "vector" }, t3), this._collectResourceTiming = t3.collectResourceTiming, 512 !== this.tileSize)
      throw new Error("vector tile sources must have a tileSize of 512");
    this.setEventedParent(i);
  }
  loaded() {
    return this._loaded;
  }
  hasTile(e53) {
    return !this.tileBounds || this.tileBounds.contains(e53.canonical);
  }
  onAdd(e53) {
    this.map = e53, this.load();
  }
  setSourceProperty(e53) {
    this._tileJSONRequest && this._tileJSONRequest.cancel(), e53(), this.load();
  }
  setTiles(e53) {
    return this.setSourceProperty(() => {
      this._options.tiles = e53;
    }), this;
  }
  setUrl(e53) {
    return this.setSourceProperty(() => {
      this.url = e53, this._options.url = e53;
    }), this;
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
  }
  loadTile(e53, t3) {
    let r = e53.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = { request: this.map._requestManager.transformRequest(r, "Tile"), uid: e53.uid, tileID: e53.tileID, zoom: e53.tileID.overscaledZ, tileSize: this.tileSize * e53.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    function a(r3, i3) {
      return delete e53.request, e53.aborted ? t3(null) : r3 && 404 !== r3.status ? t3(r3) : (i3 && i3.resourceTiming && (e53.resourceTiming = i3.resourceTiming), this.map._refreshExpiredTiles && i3 && e53.setExpiryData(i3), e53.loadVectorData(i3, this.map.painter), t3(null), void (e53.reloadCallback && (this.loadTile(e53, e53.reloadCallback), e53.reloadCallback = null)));
    }
    i.request.collectResourceTiming = this._collectResourceTiming, e53.actor && "expired" !== e53.state ? "loading" === e53.state ? e53.reloadCallback = t3 : e53.request = e53.actor.send("reloadTile", i, a.bind(this)) : (e53.actor = this.dispatcher.getActor(), e53.request = e53.actor.send("loadTile", i, a.bind(this))), q(a, "done");
  }
  abortTile(e53) {
    e53.request && (e53.request.cancel(), delete e53.request), e53.actor && e53.actor.send("abortTile", { uid: e53.uid, type: this.type, source: this.id }, void 0);
  }
  unloadTile(e53) {
    e53.unloadVectorData(), e53.actor && e53.actor.send("removeTile", { uid: e53.uid, type: this.type, source: this.id }, void 0);
  }
  hasTransition() {
    return false;
  }
};
q(tm, "VectorTileSource");
var sn = tm;
c();
var rm = class extends de {
  constructor(e53, t3, r, i) {
    super(), this.id = e53, this.dispatcher = r, this.setEventedParent(i), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = R({ type: "raster" }, t3), R(this, Bt(t3, ["url", "scheme", "tileSize"]));
  }
  load() {
    this._loaded = false, this.fire(new z("dataloading", { dataType: "source" })), this._tileJSONRequest = dl(this._options, this.map._requestManager, (e53, t3) => {
      this._tileJSONRequest = null, this._loaded = true, e53 ? this.fire(new Z(e53)) : t3 && (R(this, t3), t3.bounds && (this.tileBounds = new on(t3.bounds, this.minzoom, this.maxzoom)), this.fire(new z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new z("data", { dataType: "source", sourceDataType: "content" })));
    });
  }
  loaded() {
    return this._loaded;
  }
  onAdd(e53) {
    this.map = e53, this.load();
  }
  onRemove() {
    this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
  }
  serialize() {
    return R({}, this._options);
  }
  hasTile(e53) {
    return !this.tileBounds || this.tileBounds.contains(e53.canonical);
  }
  loadTile(e53, t3) {
    let r = e53.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
    e53.request = ot.getImage(this.map._requestManager.transformRequest(r, "Tile"), (r3, i, a) => {
      if (delete e53.request, e53.aborted)
        e53.state = "unloaded", t3(null);
      else if (r3)
        e53.state = "errored", t3(r3);
      else if (i) {
        this.map._refreshExpiredTiles && a && e53.setExpiryData(a);
        let r4 = this.map.painter.context, n = r4.gl;
        e53.texture = this.map.painter.getTileTexture(i.width), e53.texture ? e53.texture.update(i, { useMipmap: true }) : (e53.texture = new be(r4, i, n.RGBA, { useMipmap: true }), e53.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE, n.LINEAR_MIPMAP_NEAREST), r4.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, r4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, r4.extTextureFilterAnisotropicMax)), e53.state = "loaded", t3(null);
      }
    }, this.map._refreshExpiredTiles);
  }
  abortTile(e53, t3) {
    e53.request && (e53.request.cancel(), delete e53.request), t3();
  }
  unloadTile(e53, t3) {
    e53.texture && this.map.painter.saveTileTexture(e53.texture), t3();
  }
  hasTransition() {
    return false;
  }
};
q(rm, "RasterTileSource");
var im;
var Dr = rm;
function F_() {
  return null == im && (im = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), im;
}
function R_(e53, t3, r) {
  var i = B_(256 * e53, 256 * (t3 = Math.pow(2, r) - t3 - 1), r), a = B_(256 * (e53 + 1), 256 * (t3 + 1), r);
  return i[0] + "," + i[1] + "," + a[0] + "," + a[1];
}
function B_(e53, t3, r) {
  var i = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
  return [e53 * i - 2 * Math.PI * 6378137 / 2, t3 * i - 2 * Math.PI * 6378137 / 2];
}
c(), c(), q(F_, "offscreenCanvasSupported"), c(), c(), q(R_, "getTileBBox"), q(B_, "getMercCoords");
var O_ = u(Pe(), 1);
var nm = class {
  constructor(e53, t3, r) {
    if (e53 < 0 || e53 > 25 || r < 0 || r >= Math.pow(2, e53) || t3 < 0 || t3 >= Math.pow(2, e53))
      throw new Error("x=".concat(t3, ", y=").concat(r, ", z=").concat(e53, " outside of bounds. 0<=x<").concat(Math.pow(2, e53), ", 0<=y<").concat(Math.pow(2, e53), " 0<=z<=25 "));
    this.z = e53, this.x = t3, this.y = r, this.key = $a(0, e53, e53, t3, r);
  }
  equals(e53) {
    return this.z === e53.z && this.x === e53.x && this.y === e53.y;
  }
  url(e53, t3, r) {
    let i = R_(this.x, this.y, this.z), a = HM(this.z, this.x, this.y);
    return e53[(this.x + this.y) % e53.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, t3 > 1 ? "@2x" : "").replace(/{quadkey}/g, a).replace(/{bbox-epsg-3857}/g, i);
  }
  isChildOf(e53) {
    let t3 = this.z - e53.z;
    return t3 > 0 && e53.x === this.x >> t3 && e53.y === this.y >> t3;
  }
  getTilePoint(e53) {
    let t3 = Math.pow(2, this.z);
    return new O_.default(8192 * (e53.x * t3 - this.x), 8192 * (e53.y * t3 - this.y));
  }
  toString() {
    return "".concat(this.z, "/").concat(this.x, "/").concat(this.y);
  }
};
q(nm, "CanonicalTileID");
var ln = nm;
var am = class {
  constructor(e53, t3) {
    this.wrap = e53, this.canonical = t3, this.key = $a(e53, t3.z, t3.z, t3.x, t3.y);
  }
};
q(am, "UnwrappedTileID");
var un = am;
var Tt = class e43 {
  constructor(e53, t3, r, i, a) {
    if (e53 < r)
      throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(e53, "; z = ").concat(r));
    this.overscaledZ = e53, this.wrap = t3, this.canonical = new ln(r, +i, +a), this.key = $a(t3, e53, r, i, a);
  }
  clone() {
    return new e43(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  equals(e53) {
    return this.overscaledZ === e53.overscaledZ && this.wrap === e53.wrap && this.canonical.equals(e53.canonical);
  }
  scaledTo(t3) {
    if (t3 > this.overscaledZ)
      throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t3, "; overscaledZ = ").concat(this.overscaledZ));
    let r = this.canonical.z - t3;
    return t3 > this.canonical.z ? new e43(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new e43(t3, this.wrap, t3, this.canonical.x >> r, this.canonical.y >> r);
  }
  calculateScaledKey(e53, t3) {
    if (e53 > this.overscaledZ)
      throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(e53, "; overscaledZ = ").concat(this.overscaledZ));
    let r = this.canonical.z - e53;
    return e53 > this.canonical.z ? $a(this.wrap * +t3, e53, this.canonical.z, this.canonical.x, this.canonical.y) : $a(this.wrap * +t3, e53, e53, this.canonical.x >> r, this.canonical.y >> r);
  }
  isChildOf(e53) {
    if (e53.wrap !== this.wrap)
      return false;
    let t3 = this.canonical.z - e53.canonical.z;
    return 0 === e53.overscaledZ || e53.overscaledZ < this.overscaledZ && e53.canonical.x === this.canonical.x >> t3 && e53.canonical.y === this.canonical.y >> t3;
  }
  children(t3) {
    if (this.overscaledZ >= t3)
      return [new e43(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
    let r = this.canonical.z + 1, i = 2 * this.canonical.x, a = 2 * this.canonical.y;
    return [new e43(r, this.wrap, r, i, a), new e43(r, this.wrap, r, i + 1, a), new e43(r, this.wrap, r, i, a + 1), new e43(r, this.wrap, r, i + 1, a + 1)];
  }
  isLessThan(e53) {
    return this.wrap < e53.wrap || !(this.wrap > e53.wrap) && (this.overscaledZ < e53.overscaledZ || !(this.overscaledZ > e53.overscaledZ) && (this.canonical.x < e53.canonical.x || !(this.canonical.x > e53.canonical.x) && this.canonical.y < e53.canonical.y));
  }
  wrapped() {
    return new e43(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  unwrapTo(t3) {
    return new e43(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
  }
  overscaleFactor() {
    return Math.pow(2, this.overscaledZ - this.canonical.z);
  }
  toUnwrapped() {
    return new un(this.wrap, this.canonical);
  }
  toString() {
    return "".concat(this.overscaledZ, "/").concat(this.canonical.x, "/").concat(this.canonical.y);
  }
  getTilePoint(e53) {
    return this.canonical.getTilePoint(new ze(e53.x - this.wrap, e53.y));
  }
};
q(Tt, "OverscaledTileID");
var rt = Tt;
function $a(e53, t3, r, i, a) {
  (e53 *= 2) < 0 && (e53 = -1 * e53 - 1);
  let n = 1 << r;
  return (n * n * e53 + n * a + i).toString(36) + r.toString(36) + t3.toString(36);
}
function HM(e53, t3, r) {
  let i, a = "";
  for (let n = e53; n > 0; n--)
    i = 1 << n - 1, a += (t3 & i ? 1 : 0) + (r & i ? 2 : 0);
  return a;
}
q($a, "calculateKey"), q(HM, "getQuadkey"), G("CanonicalTileID", ln), G("OverscaledTileID", rt, { omit: ["posMatrix"] }), c();
var sm = class {
  constructor(e53, t3, r) {
    if (this.uid = e53, t3.height !== t3.width)
      throw new RangeError("DEM tiles must be square");
    if (r && "mapbox" !== r && "terrarium" !== r)
      return void Ce('"'.concat(r, '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'));
    this.stride = t3.height;
    let i = this.dim = t3.height - 2;
    this.data = new Uint32Array(t3.data.buffer), this.encoding = r || "mapbox";
    for (let e54 = 0; e54 < i; e54++)
      this.data[this._idx(-1, e54)] = this.data[this._idx(0, e54)], this.data[this._idx(i, e54)] = this.data[this._idx(i - 1, e54)], this.data[this._idx(e54, -1)] = this.data[this._idx(e54, 0)], this.data[this._idx(e54, i)] = this.data[this._idx(e54, i - 1)];
    this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(i, -1)] = this.data[this._idx(i - 1, 0)], this.data[this._idx(-1, i)] = this.data[this._idx(0, i - 1)], this.data[this._idx(i, i)] = this.data[this._idx(i - 1, i - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
    for (let e54 = 0; e54 < i; e54++)
      for (let t4 = 0; t4 < i; t4++) {
        let r3 = this.get(e54, t4);
        r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
      }
  }
  get(e53, t3) {
    let r = new Uint8Array(this.data.buffer), i = 4 * this._idx(e53, t3);
    return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r[i], r[i + 1], r[i + 2]);
  }
  getUnpackVector() {
    return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
  }
  _idx(e53, t3) {
    if (e53 < -1 || e53 >= this.dim + 1 || t3 < -1 || t3 >= this.dim + 1)
      throw new RangeError("out of range source coordinates for DEM data");
    return (t3 + 1) * this.stride + (e53 + 1);
  }
  _unpackMapbox(e53, t3, r) {
    return (256 * e53 * 256 + 256 * t3 + r) / 10 - 1e4;
  }
  _unpackTerrarium(e53, t3, r) {
    return 256 * e53 + t3 + r / 256 - 32768;
  }
  getPixels() {
    return new Ee({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
  }
  backfillBorder(e53, t3, r) {
    if (this.dim !== e53.dim)
      throw new Error("dem dimension mismatch");
    let i = t3 * this.dim, a = t3 * this.dim + this.dim, n = r * this.dim, s3 = r * this.dim + this.dim;
    switch (t3) {
      case -1:
        i = a - 1;
        break;
      case 1:
        a = i + 1;
    }
    switch (r) {
      case -1:
        n = s3 - 1;
        break;
      case 1:
        s3 = n + 1;
    }
    let o = -t3 * this.dim, l = -r * this.dim;
    for (let t4 = n; t4 < s3; t4++)
      for (let r3 = i; r3 < a; r3++)
        this.data[this._idx(r3, t4)] = e53.data[this._idx(r3 + o, t4 + l)];
  }
};
q(sm, "DEMData");
var om = sm;
G("DEMData", om);
var lm = class extends Dr {
  constructor(e53, t3, r, i) {
    super(e53, t3, r, i), this.type = "raster-dem", this.maxzoom = 22, this._options = R({ type: "raster-dem" }, t3), this.encoding = t3.encoding || "mapbox";
  }
  serialize() {
    return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
  }
  loadTile(e53, t3) {
    let r = e53.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
    function i(r3, i3) {
      if (delete e53.request, e53.aborted)
        e53.state = "unloaded", t3(null);
      else if (r3)
        e53.state = "errored", t3(r3);
      else if (i3) {
        this.map._refreshExpiredTiles && e53.setExpiryData(i3), delete i3.cacheControl, delete i3.expires;
        let t4 = Ct(i3) && F_() ? i3 : ne.getImageData(i3, 1), r4 = { uid: e53.uid, coord: e53.tileID, source: this.id, rawImageData: t4, encoding: this.encoding };
        (!e53.actor || "expired" === e53.state) && (e53.actor = this.dispatcher.getActor(), e53.actor.send("loadDEMTile", r4, a.bind(this)));
      }
    }
    function a(r3, i3) {
      r3 && (e53.state = "errored", t3(r3)), i3 && (e53.dem = i3, e53.needsHillshadePrepare = true, e53.needsTerrainPrepare = true, e53.state = "loaded", t3(null));
    }
    e53.request = ot.getImage(this.map._requestManager.transformRequest(r, "Tile"), i.bind(this), this.map._refreshExpiredTiles), e53.neighboringTiles = this._getNeighboringTiles(e53.tileID), q(i, "imageLoaded"), q(a, "done");
  }
  _getNeighboringTiles(e53) {
    let t3 = e53.canonical, r = Math.pow(2, t3.z), i = (t3.x - 1 + r) % r, a = 0 === t3.x ? e53.wrap - 1 : e53.wrap, n = (t3.x + 1 + r) % r, s3 = t3.x + 1 === r ? e53.wrap + 1 : e53.wrap, o = {};
    return o[new rt(e53.overscaledZ, a, t3.z, i, t3.y).key] = { backfilled: false }, o[new rt(e53.overscaledZ, s3, t3.z, n, t3.y).key] = { backfilled: false }, t3.y > 0 && (o[new rt(e53.overscaledZ, a, t3.z, i, t3.y - 1).key] = { backfilled: false }, o[new rt(e53.overscaledZ, e53.wrap, t3.z, t3.x, t3.y - 1).key] = { backfilled: false }, o[new rt(e53.overscaledZ, s3, t3.z, n, t3.y - 1).key] = { backfilled: false }), t3.y + 1 < r && (o[new rt(e53.overscaledZ, a, t3.z, i, t3.y + 1).key] = { backfilled: false }, o[new rt(e53.overscaledZ, e53.wrap, t3.z, t3.x, t3.y + 1).key] = { backfilled: false }, o[new rt(e53.overscaledZ, s3, t3.z, n, t3.y + 1).key] = { backfilled: false }), o;
  }
  unloadTile(e53) {
    e53.demTexture && this.map.painter.saveTileTexture(e53.demTexture), e53.fbo && (e53.fbo.destroy(), delete e53.fbo), e53.dem && delete e53.dem, delete e53.neighboringTiles, e53.state = "unloaded", e53.actor && e53.actor.send("removeDEMTile", { uid: e53.uid, source: this.id });
  }
};
q(lm, "RasterDEMTileSource");
var cn = lm;
c();
var um = class extends de {
  constructor(e53, t3, r, i) {
    super(), this.load = q(() => {
      this._updateWorkerData();
    }, "load"), this.serialize = q(() => R({}, this._options, { type: this.type, data: this._data }), "serialize"), this.id = e53, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = r.getActor(), this.setEventedParent(i), this._data = t3.data, this._options = R({}, t3), this._collectResourceTiming = t3.collectResourceTiming, void 0 !== t3.maxzoom && (this.maxzoom = t3.maxzoom), t3.type && (this.type = t3.type), t3.attribution && (this.attribution = t3.attribution), this.promoteId = t3.promoteId;
    let a = 8192 / this.tileSize;
    this.workerOptions = R({ source: this.id, cluster: t3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== t3.buffer ? t3.buffer : 128) * a, tolerance: (void 0 !== t3.tolerance ? t3.tolerance : 0.375) * a, extent: 8192, maxZoom: this.maxzoom, lineMetrics: t3.lineMetrics || false, generateId: t3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== t3.clusterMaxZoom ? t3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t3.clusterMinPoints || 2), extent: 8192, radius: (t3.clusterRadius || 50) * a, log: false, generateId: t3.generateId || false }, clusterProperties: t3.clusterProperties, filter: t3.filter }, t3.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
  }
  onAdd(e53) {
    this.map = e53, this.load();
  }
  setData(e53) {
    return this._data = e53, this._updateWorkerData(), this;
  }
  updateData(e53) {
    return this._updateWorkerData(e53), this;
  }
  setClusterOptions(e53) {
    return this.workerOptions.cluster = e53.cluster, e53 && (void 0 !== e53.clusterRadius && (this.workerOptions.superclusterOptions.radius = e53.clusterRadius), void 0 !== e53.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = e53.clusterMaxZoom)), this._updateWorkerData(), this;
  }
  getClusterExpansionZoom(e53, t3) {
    return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e53, source: this.id }, t3), this;
  }
  getClusterChildren(e53, t3) {
    return this.actor.send("geojson.getClusterChildren", { clusterId: e53, source: this.id }, t3), this;
  }
  getClusterLeaves(e53, t3, r, i) {
    return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e53, limit: t3, offset: r }, i), this;
  }
  _updateWorkerData(e53) {
    let t3 = R({}, this.workerOptions);
    e53 ? t3.dataDiff = e53 : "string" == typeof this._data ? (t3.request = this.map._requestManager.transformRequest(ne.resolveURL(this._data), "Source"), t3.request.collectResourceTiming = this._collectResourceTiming) : t3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new z("dataloading", { dataType: "source" })), this.actor.send("".concat(this.type, ".loadData"), t3, (e54, t4) => {
      if (this._pendingLoads--, this._removed || t4 && t4.abandoned)
        return void this.fire(new z("dataabort", { dataType: "source" }));
      let r = null;
      if (t4 && t4.resourceTiming && t4.resourceTiming[this.id] && (r = t4.resourceTiming[this.id].slice(0)), e54)
        return void this.fire(new Z(e54));
      let i = { dataType: "source" };
      this._collectResourceTiming && r && r.length > 0 && R(i, { resourceTiming: r }), this.fire(new z("data", { ...i, sourceDataType: "metadata" })), this.fire(new z("data", { ...i, sourceDataType: "content" }));
    });
  }
  loaded() {
    return 0 === this._pendingLoads;
  }
  loadTile(e53, t3) {
    let r = e53.actor ? "reloadTile" : "loadTile";
    e53.actor = this.actor;
    let i = { type: this.type, uid: e53.uid, tileID: e53.tileID, zoom: e53.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
    e53.request = this.actor.send(r, i, (i3, a) => (delete e53.request, e53.unloadVectorData(), e53.aborted ? t3(null) : i3 ? t3(i3) : (e53.loadVectorData(a, this.map.painter, "reloadTile" === r), t3(null))));
  }
  abortTile(e53) {
    e53.request && (e53.request.cancel(), delete e53.request), e53.aborted = true;
  }
  unloadTile(e53) {
    e53.unloadVectorData(), this.actor.send("removeTile", { uid: e53.uid, type: this.type, source: this.id });
  }
  onRemove() {
    this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
  }
  hasTransition() {
    return false;
  }
};
q(um, "GeoJSONSource");
var pn = um;
c(), c(), c();
var zr = ve([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
var cm = class extends de {
  constructor(e53, t3, r, i) {
    super(), this.load = q((e54, t4) => {
      this._loaded = false, this.fire(new z("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = ot.getImage(this.map._requestManager.transformRequest(this.url, "Image"), (r3, i3) => {
        this._request = null, this._loaded = true, r3 ? this.fire(new Z(r3)) : i3 && (this.image = i3, e54 && (this.coordinates = e54), t4 && t4(), this._finishLoading());
      });
    }, "load"), this.prepare = q(() => {
      if (0 === Object.keys(this.tiles).length || !this.image)
        return;
      let e54 = this.map.painter.context, t4 = e54.gl;
      this.boundsBuffer || (this.boundsBuffer = e54.createVertexBuffer(this._boundsArray, zr.members)), this.boundsSegments || (this.boundsSegments = me.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new be(e54, this.image, t4.RGBA), this.texture.bind(t4.LINEAR, t4.CLAMP_TO_EDGE));
      let r3 = false;
      for (let e55 in this.tiles) {
        let t5 = this.tiles[e55];
        "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, r3 = true);
      }
      r3 && this.fire(new z("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
    }, "prepare"), this.serialize = q(() => ({ type: "image", url: this.options.url, coordinates: this.coordinates }), "serialize"), this.id = e53, this.dispatcher = r, this.coordinates = t3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(i), this.options = t3;
  }
  loaded() {
    return this._loaded;
  }
  updateImage(e53) {
    return e53.url ? (this._request && (this._request.cancel(), this._request = null), this.options.url = e53.url, this.load(e53.coordinates, () => {
      this.texture = null;
    }), this) : this;
  }
  _finishLoading() {
    this.map && (this.setCoordinates(this.coordinates), this.fire(new z("data", { dataType: "source", sourceDataType: "metadata" })));
  }
  onAdd(e53) {
    this.map = e53, this.load();
  }
  onRemove() {
    this._request && (this._request.cancel(), this._request = null);
  }
  setCoordinates(e53) {
    this.coordinates = e53;
    let t3 = e53.map(ze.fromLngLat);
    this.tileID = ZM(t3), this.minzoom = this.maxzoom = this.tileID.z;
    let r = t3.map((e54) => this.tileID.getTilePoint(e54)._round());
    return this._boundsArray = new Hi(), this._boundsArray.emplaceBack(r[0].x, r[0].y, 0, 0), this._boundsArray.emplaceBack(r[1].x, r[1].y, 8192, 0), this._boundsArray.emplaceBack(r[3].x, r[3].y, 0, 8192), this._boundsArray.emplaceBack(r[2].x, r[2].y, 8192, 8192), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new z("data", { dataType: "source", sourceDataType: "content" })), this;
  }
  loadTile(e53, t3) {
    this.tileID && this.tileID.equals(e53.tileID.canonical) ? (this.tiles[String(e53.tileID.wrap)] = e53, e53.buckets = {}, t3(null)) : (e53.state = "errored", t3(null));
  }
  hasTransition() {
    return false;
  }
};
q(cm, "ImageSource");
var At = cm;
function ZM(e53) {
  let t3 = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0;
  for (let n3 of e53)
    t3 = Math.min(t3, n3.x), r = Math.min(r, n3.y), i = Math.max(i, n3.x), a = Math.max(a, n3.y);
  let n = i - t3, s3 = a - r, o = Math.max(n, s3), l = Math.max(0, Math.floor(-Math.log(o) / Math.LN2)), u3 = Math.pow(2, l);
  return new ln(l, Math.floor((t3 + i) / 2 * u3), Math.floor((r + a) / 2 * u3));
}
q(ZM, "getCoordinatesCenterTileID");
var pm = class extends At {
  constructor(e53, t3, r, i) {
    super(e53, t3, r, i), this.load = q(() => {
      this._loaded = false;
      let e54 = this.options;
      this.urls = [];
      for (let t4 of e54.urls)
        this.urls.push(this.map._requestManager.transformRequest(t4, "Source").url);
      ng(this.urls, (e55, t4) => {
        this._loaded = true, e55 ? this.fire(new Z(e55)) : t4 && (this.video = t4, this.video.loop = true, this.video.addEventListener("playing", () => {
          this.map.triggerRepaint();
        }), this.map && this.video.play(), this._finishLoading());
      });
    }, "load"), this.prepare = q(() => {
      if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
        return;
      let e54 = this.map.painter.context, t4 = e54.gl;
      this.boundsBuffer || (this.boundsBuffer = e54.createVertexBuffer(this._boundsArray, zr.members)), this.boundsSegments || (this.boundsSegments = me.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(t4.LINEAR, t4.CLAMP_TO_EDGE), t4.texSubImage2D(t4.TEXTURE_2D, 0, 0, 0, t4.RGBA, t4.UNSIGNED_BYTE, this.video)) : (this.texture = new be(e54, this.video, t4.RGBA), this.texture.bind(t4.LINEAR, t4.CLAMP_TO_EDGE));
      let r3 = false;
      for (let e55 in this.tiles) {
        let t5 = this.tiles[e55];
        "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, r3 = true);
      }
      r3 && this.fire(new z("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
    }, "prepare"), this.serialize = q(() => ({ type: "video", urls: this.urls, coordinates: this.coordinates }), "serialize"), this.roundZoom = true, this.type = "video", this.options = t3;
  }
  pause() {
    this.video && this.video.pause();
  }
  play() {
    this.video && this.video.play();
  }
  seek(e53) {
    if (this.video) {
      let t3 = this.video.seekable;
      e53 < t3.start(0) || e53 > t3.end(0) ? this.fire(new Z(new N("sources.".concat(this.id), null, "Playback for this video can be set only between the ".concat(t3.start(0), " and ").concat(t3.end(0), "-second mark.")))) : this.video.currentTime = e53;
    }
  }
  getVideo() {
    return this.video;
  }
  onAdd(e53) {
    this.map || (this.map = e53, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
  }
  hasTransition() {
    return this.video && !this.video.paused;
  }
};
q(pm, "VideoSource");
var hn = pm;
c();
var hm = class extends At {
  constructor(e53, t3, r, i) {
    super(e53, t3, r, i), this.load = q(() => {
      this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new Z(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
        this._playing = true, this.map.triggerRepaint();
      }, this.pause = function() {
        this._playing && (this.prepare(), this._playing = false);
      }, this._finishLoading());
    }, "load"), this.prepare = q(() => {
      let e54 = false;
      if (this.canvas.width !== this.width && (this.width = this.canvas.width, e54 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e54 = true), this._hasInvalidDimensions() || 0 === Object.keys(this.tiles).length)
        return;
      let t4 = this.map.painter.context, r3 = t4.gl;
      this.boundsBuffer || (this.boundsBuffer = t4.createVertexBuffer(this._boundsArray, zr.members)), this.boundsSegments || (this.boundsSegments = me.simpleSegment(0, 0, 4, 2)), this.texture ? (e54 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new be(t4, this.canvas, r3.RGBA, { premultiply: true });
      let i3 = false;
      for (let e55 in this.tiles) {
        let t5 = this.tiles[e55];
        "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, i3 = true);
      }
      i3 && this.fire(new z("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
    }, "prepare"), this.serialize = q(() => ({ type: "canvas", coordinates: this.coordinates }), "serialize"), t3.coordinates ? (!Array.isArray(t3.coordinates) || 4 !== t3.coordinates.length || t3.coordinates.some((e54) => !Array.isArray(e54) || 2 !== e54.length || e54.some((e55) => "number" != typeof e55))) && this.fire(new Z(new N("sources.".concat(e53), null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new Z(new N("sources.".concat(e53), null, 'missing required property "coordinates"'))), t3.animate && "boolean" != typeof t3.animate && this.fire(new Z(new N("sources.".concat(e53), null, 'optional "animate" property must be a boolean value'))), t3.canvas ? "string" != typeof t3.canvas && !(t3.canvas instanceof HTMLCanvasElement) && this.fire(new Z(new N("sources.".concat(e53), null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new Z(new N("sources.".concat(e53), null, 'missing required property "canvas"'))), this.options = t3, this.animate = void 0 === t3.animate || t3.animate;
  }
  getCanvas() {
    return this.canvas;
  }
  onAdd(e53) {
    this.map = e53, this.load(), this.canvas && this.animate && this.play();
  }
  onRemove() {
    this.pause();
  }
  hasTransition() {
    return this._playing;
  }
  _hasInvalidDimensions() {
    for (let e53 of [this.canvas.width, this.canvas.height])
      if (isNaN(e53) || e53 <= 0)
        return true;
    return false;
  }
};
q(hm, "CanvasSource");
var fn = hm;
var V_ = {};
var U_ = q((e53, t3, r, i) => {
  let a = new (fm(t3.type))(e53, t3, r, i);
  if (a.id !== e53)
    throw new Error("Expected Source id to be ".concat(e53, " instead of ").concat(a.id));
  return a;
}, "create");
var fm = q((e53) => {
  switch (e53) {
    case "geojson":
      return pn;
    case "image":
      return At;
    case "raster":
      return Dr;
    case "raster-dem":
      return cn;
    case "vector":
      return sn;
    case "video":
      return hn;
    case "canvas":
      return fn;
  }
  return V_[e53];
}, "getSourceType");
var N_ = q((e53, t3) => {
  V_[e53] = t3;
}, "setSourceType");
function WM(e53, t3) {
  let r = q3.create();
  return q3.translate(r, r, [1, 1, 0]), q3.scale(r, r, [0.5 * e53.width, 0.5 * e53.height, 1]), q3.multiply(r, r, e53.calculatePosMatrix(t3.toUnwrapped()));
}
function XM(e53, t3, r) {
  if (e53)
    for (let i of e53) {
      let e54 = t3[i];
      if (e54 && e54.source === r && "fill-extrusion" === e54.type)
        return true;
    }
  else
    for (let e54 in t3) {
      let i = t3[e54];
      if (i.source === r && "fill-extrusion" === i.type)
        return true;
    }
  return false;
}
function G_(e53, t3, r, i, a, n) {
  let s3 = XM(a && a.layers, t3, e53.id), o = n.maxPitchScaleFactor(), l = e53.tilesIn(i, o, s3);
  l.sort($_);
  let u3 = [];
  for (let i3 of l)
    u3.push({ wrappedTileID: i3.tileID.wrapped().key, queryResults: i3.tile.queryRenderedFeatures(t3, r, e53._state, i3.queryGeometry, i3.cameraQueryGeometry, i3.scale, a, n, o, WM(e53.transform, i3.tileID)) });
  let c3 = KM(u3);
  for (let t4 in c3)
    c3[t4].forEach((t5) => {
      let r3 = t5.feature, i3 = e53.getFeatureState(r3.layer["source-layer"], r3.id);
      r3.source = r3.layer.source, r3.layer["source-layer"] && (r3.sourceLayer = r3.layer["source-layer"]), r3.state = i3;
    });
  return c3;
}
function q_(e53, t3, r, i, a, n, s3) {
  let o = {}, l = n.queryRenderedSymbols(i), u3 = [];
  for (let e54 of Object.keys(l).map(Number))
    u3.push(s3[e54]);
  u3.sort($_);
  for (let r3 of u3) {
    let i3 = r3.featureIndex.lookupSymbolFeatures(l[r3.bucketInstanceId], t3, r3.bucketIndex, r3.sourceLayerIndex, a.filter, a.layers, a.availableImages, e53);
    for (let e54 in i3) {
      let t4 = o[e54] = o[e54] || [], a3 = i3[e54];
      a3.sort((e55, t5) => {
        let i4 = r3.featureSortOrder;
        if (i4) {
          let r4 = i4.indexOf(e55.featureIndex);
          return i4.indexOf(t5.featureIndex) - r4;
        }
        return t5.featureIndex - e55.featureIndex;
      });
      for (let e55 of a3)
        t4.push(e55);
    }
  }
  for (let t4 in o)
    o[t4].forEach((i3) => {
      let a3 = i3.feature, n3 = e53[t4], s4 = r[n3.source].getFeatureState(a3.layer["source-layer"], a3.id);
      a3.source = a3.layer.source, a3.layer["source-layer"] && (a3.sourceLayer = a3.layer["source-layer"]), a3.state = s4;
    });
  return o;
}
function j_(e53, t3) {
  let r = e53.getRenderableIds().map((t4) => e53.getTileByID(t4)), i = [], a = {};
  for (let e54 = 0; e54 < r.length; e54++) {
    let n = r[e54], s3 = n.tileID.canonical.key;
    a[s3] || (a[s3] = true, n.querySourceFeatures(i, t3));
  }
  return i;
}
function $_(e53, t3) {
  let r = e53.tileID, i = t3.tileID;
  return r.overscaledZ - i.overscaledZ || r.canonical.y - i.canonical.y || r.wrap - i.wrap || r.canonical.x - i.canonical.x;
}
function KM(e53) {
  let t3 = {}, r = {};
  for (let i of e53) {
    let e54 = i.queryResults, a = i.wrappedTileID, n = r[a] = r[a] || {};
    for (let r3 in e54) {
      let i3 = e54[r3], a3 = n[r3] = n[r3] || {}, s3 = t3[r3] = t3[r3] || [];
      for (let e55 of i3)
        a3[e55.featureIndex] || (a3[e55.featureIndex] = true, s3.push(e55));
    }
  }
  return t3;
}
function H_(e53, t3) {
  let r = {};
  if (!t3)
    return r;
  for (let i of e53) {
    let e54 = i.layerIds.map((e55) => t3.getLayer(e55)).filter(Boolean);
    if (0 !== e54.length) {
      i.layers = e54, i.stateDependentLayerIds && (i.stateDependentLayers = i.stateDependentLayerIds.map((t4) => e54.filter((e55) => e55.id === t4)[0]));
      for (let t4 of e54)
        r[t4.id] = i;
    }
  }
  return r;
}
c(), q(WM, "getPixelPosMatrix"), q(XM, "queryIncludes3DLayer"), q(G_, "queryRenderedFeatures"), q(q_, "queryRenderedSymbols"), q(j_, "querySourceFeatures"), q($_, "sortTilesIn"), q(KM, "mergeRenderedFeatureLayers"), c(), c(), c(), q(H_, "deserialize"), c(), c();
var mm = class {
  constructor(e53) {
    this._stringToNumber = {}, this._numberToString = [];
    for (let t3 = 0; t3 < e53.length; t3++) {
      let r = e53[t3];
      this._stringToNumber[r] = t3, this._numberToString[t3] = r;
    }
  }
  encode(e53) {
    return this._stringToNumber[e53];
  }
  decode(e53) {
    if (e53 >= this._numberToString.length)
      throw new Error("Out of bounds. Index requested n=".concat(e53, " can't be >= this._numberToString.length ").concat(this._numberToString.length));
    return this._numberToString[e53];
  }
};
q(mm, "DictionaryCoder");
var gl = mm;
var X_ = u(ka(), 1);
var K_ = u(Ef(), 1);
c();
var dm = class {
  constructor(e53, t3, r, i, a) {
    this.type = "Feature", this._vectorTileFeature = e53, e53._z = t3, e53._x = r, e53._y = i, this.properties = e53.properties, this.id = a;
  }
  get geometry() {
    return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
  }
  set geometry(e53) {
    this._geometry = e53;
  }
  toJSON() {
    let e53 = { geometry: this.geometry };
    for (let t3 in this)
      "_geometry" === t3 || "_vectorTileFeature" === t3 || (e53[t3] = this[t3]);
    return e53;
  }
};
q(dm, "GeoJSONFeature");
var mn = dm;
var gm = class {
  constructor(e53, t3) {
    this.tileID = e53, this.x = e53.canonical.x, this.y = e53.canonical.y, this.z = e53.canonical.z, this.grid = new Yr(8192, 16, 0), this.grid3D = new Yr(8192, 16, 0), this.featureIndexArray = new ba(), this.promoteId = t3;
  }
  insert(e53, t3, r, i, a, n) {
    let s3 = this.featureIndexArray.length;
    this.featureIndexArray.emplaceBack(r, i, a);
    let o = n ? this.grid3D : this.grid;
    for (let e54 = 0; e54 < t3.length; e54++) {
      let r3 = t3[e54], i3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
      for (let e55 = 0; e55 < r3.length; e55++) {
        let t4 = r3[e55];
        i3[0] = Math.min(i3[0], t4.x), i3[1] = Math.min(i3[1], t4.y), i3[2] = Math.max(i3[2], t4.x), i3[3] = Math.max(i3[3], t4.y);
      }
      i3[0] < 8192 && i3[1] < 8192 && i3[2] >= 0 && i3[3] >= 0 && o.insert(s3, i3[0], i3[1], i3[2], i3[3]);
    }
  }
  loadVTLayers() {
    return this.vtLayers || (this.vtLayers = new X_.default.VectorTile(new K_.default(this.rawTileData)).layers, this.sourceLayerCoder = new gl(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
  }
  query(e53, t3, r, i) {
    this.loadVTLayers();
    let a = e53.params || {}, n = 8192 / e53.tileSize / e53.scale, s3 = Xn(a.filter), o = e53.queryGeometry, l = e53.queryPadding * n, u3 = W_(o), c3 = this.grid.query(u3.minX - l, u3.minY - l, u3.maxX + l, u3.maxY + l), h = W_(e53.cameraQueryGeometry), p = this.grid3D.query(h.minX - l, h.minY - l, h.maxX + l, h.maxY + l, (t4, r3, i3, a3) => Lx(e53.cameraQueryGeometry, t4 - l, r3 - l, i3 + l, a3 + l));
    for (let e54 of p)
      c3.push(e54);
    c3.sort(YM);
    let d, f = {};
    for (let l3 = 0; l3 < c3.length; l3++) {
      let u4 = c3[l3];
      if (u4 === d)
        continue;
      d = u4;
      let h3 = this.featureIndexArray.get(u4), p3 = null;
      this.loadMatchingFeature(f, h3.bucketIndex, h3.sourceLayerIndex, h3.featureIndex, s3, a.layers, a.availableImages, t3, r, i, (t4, r3, i3) => (p3 || (p3 = dt(t4)), r3.queryIntersectsFeature(o, t4, i3, p3, this.z, e53.transform, n, e53.pixelPosMatrix)));
    }
    return f;
  }
  loadMatchingFeature(e53, t3, r, i, a, n, s3, o, l, u3, c3) {
    let h = this.bucketLayerIDs[t3];
    if (n && !Ky(n, h))
      return;
    let p = this.sourceLayerCoder.decode(r), d = this.vtLayers[p].feature(i);
    if (a.needGeometry) {
      let e54 = yt(d, true);
      if (!a.filter(new ye(this.tileID.overscaledZ), e54, this.tileID.canonical))
        return;
    } else if (!a.filter(new ye(this.tileID.overscaledZ), d))
      return;
    let f = this.getId(d, p);
    for (let t4 = 0; t4 < h.length; t4++) {
      let r3 = h[t4];
      if (n && n.indexOf(r3) < 0)
        continue;
      let a3 = o[r3];
      if (!a3)
        continue;
      let p3 = {};
      f && u3 && (p3 = u3.getState(a3.sourceLayer || "_geojsonTileLayer", f));
      let m = R({}, l[r3]);
      m.paint = Z_(m.paint, a3.paint, d, p3, s3), m.layout = Z_(m.layout, a3.layout, d, p3, s3);
      let y = !c3 || c3(d, a3, p3);
      if (!y)
        continue;
      let g = new mn(d, this.z, this.x, this.y, f);
      g.layer = m;
      let _ = e53[r3];
      void 0 === _ && (_ = e53[r3] = []), _.push({ featureIndex: i, feature: g, intersectionZ: y });
    }
  }
  lookupSymbolFeatures(e53, t3, r, i, a, n, s3, o) {
    let l = {};
    this.loadVTLayers();
    let u3 = Xn(a);
    for (let a3 of e53)
      this.loadMatchingFeature(l, r, i, a3, u3, n, s3, o, t3);
    return l;
  }
  hasLayer(e53) {
    for (let t3 of this.bucketLayerIDs)
      for (let r of t3)
        if (e53 === r)
          return true;
    return false;
  }
  getId(e53, t3) {
    let r = e53.id;
    if (this.promoteId) {
      let i = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[t3];
      r = e53.properties[i], "boolean" == typeof r && (r = Number(r));
    }
    return r;
  }
};
q(gm, "FeatureIndex");
var ym = gm;
function Z_(e53, t3, r, i, a) {
  return Tn(e53, (e54, n) => {
    let s3 = t3 instanceof wr ? t3.get(n) : null;
    return s3 && s3.evaluate ? s3.evaluate(r, i, a) : s3;
  });
}
function W_(e53) {
  let t3 = 1 / 0, r = 1 / 0, i = -1 / 0, a = -1 / 0;
  for (let n of e53)
    t3 = Math.min(t3, n.x), r = Math.min(r, n.y), i = Math.max(i, n.x), a = Math.max(a, n.y);
  return { minX: t3, minY: r, maxX: i, maxY: a };
}
function YM(e53, t3) {
  return t3 - e53;
}
G("FeatureIndex", ym, { omit: ["rawTileData", "sourceLayerCoder"] }), q(Z_, "evaluateProperties"), q(W_, "getBounds"), q(YM, "topDownFeatureComparator");
var JM = 3e4;
var xm = class {
  constructor(e53, t3) {
    this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e53, this.uid = fo(), this.uses = 0, this.tileSize = t3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
  }
  registerFadeDuration(e53) {
    let t3 = e53 + this.timeAdded;
    t3 < this.fadeEndTime || (this.fadeEndTime = t3);
  }
  wasRequested() {
    return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
  }
  clearTextures(e53) {
    this.demTexture && e53.saveTileTexture(this.demTexture), this.demTexture = null;
  }
  loadVectorData(e53, t3, r) {
    if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e53) {
      e53.featureIndex && (this.latestFeatureIndex = e53.featureIndex, e53.rawTileData ? (this.latestRawTileData = e53.rawTileData, this.latestFeatureIndex.rawTileData = e53.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e53.collisionBoxArray, this.buckets = H_(e53.buckets, t3.style), this.hasSymbolBuckets = false;
      for (let e54 in this.buckets) {
        let t4 = this.buckets[e54];
        if (t4 instanceof Gt) {
          if (this.hasSymbolBuckets = true, !r)
            break;
          t4.justReloaded = true;
        }
      }
      if (this.hasRTLText = false, this.hasSymbolBuckets)
        for (let e54 in this.buckets) {
          let t4 = this.buckets[e54];
          if (t4 instanceof Gt && t4.hasRTLText) {
            this.hasRTLText = true, gx();
            break;
          }
        }
      this.queryPadding = 0;
      for (let e54 in this.buckets) {
        let r3 = this.buckets[e54];
        this.queryPadding = Math.max(this.queryPadding, t3.style.getLayer(e54).queryRadius(r3));
      }
      e53.imageAtlas && (this.imageAtlas = e53.imageAtlas), e53.glyphAtlasImage && (this.glyphAtlasImage = e53.glyphAtlasImage);
    } else
      this.collisionBoxArray = new ma();
  }
  unloadVectorData() {
    for (let e53 in this.buckets)
      this.buckets[e53].destroy();
    this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
  }
  getBucket(e53) {
    return this.buckets[e53.id];
  }
  upload(e53) {
    for (let t4 in this.buckets) {
      let r = this.buckets[t4];
      r.uploadPending() && r.upload(e53);
    }
    let t3 = e53.gl;
    this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new be(e53, this.imageAtlas.image, t3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new be(e53, this.glyphAtlasImage, t3.ALPHA), this.glyphAtlasImage = null);
  }
  prepare(e53) {
    this.imageAtlas && this.imageAtlas.patchUpdatedImages(e53, this.imageAtlasTexture);
  }
  queryRenderedFeatures(e53, t3, r, i, a, n, s3, o, l, u3) {
    return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: i, cameraQueryGeometry: a, scale: n, tileSize: this.tileSize, pixelPosMatrix: u3, transform: o, params: s3, queryPadding: this.queryPadding * l }, e53, t3, r) : {};
  }
  querySourceFeatures(e53, t3) {
    let r = this.latestFeatureIndex;
    if (!r || !r.rawTileData)
      return;
    let i = r.loadVTLayers(), a = t3 && t3.sourceLayer ? t3.sourceLayer : "", n = i._geojsonTileLayer || i[a];
    if (!n)
      return;
    let s3 = Xn(t3 && t3.filter), { z: o, x: l, y: u3 } = this.tileID.canonical, c3 = { z: o, x: l, y: u3 };
    for (let t4 = 0; t4 < n.length; t4++) {
      let i3 = n.feature(t4);
      if (s3.needGeometry) {
        let e54 = yt(i3, true);
        if (!s3.filter(new ye(this.tileID.overscaledZ), e54, this.tileID.canonical))
          continue;
      } else if (!s3.filter(new ye(this.tileID.overscaledZ), i3))
        continue;
      let h = r.getId(i3, a), p = new mn(i3, o, l, u3, h);
      p.tile = c3, e53.push(p);
    }
  }
  hasData() {
    return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
  }
  patternsLoaded() {
    return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
  }
  setExpiryData(e53) {
    let t3 = this.expirationTime;
    if (e53.cacheControl) {
      let t4 = eg(e53.cacheControl);
      t4["max-age"] && (this.expirationTime = Date.now() + 1e3 * t4["max-age"]);
    } else
      e53.expires && (this.expirationTime = new Date(e53.expires).getTime());
    if (this.expirationTime) {
      let e54 = Date.now(), r = false;
      if (this.expirationTime > e54)
        r = false;
      else if (t3)
        if (this.expirationTime < t3)
          r = true;
        else {
          let i = this.expirationTime - t3;
          i ? this.expirationTime = e54 + Math.max(i, JM) : r = true;
        }
      else
        r = true;
      r ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
    }
  }
  getExpiryTimeout() {
    if (this.expirationTime)
      return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
  }
  setFeatureState(e53, t3) {
    if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e53).length)
      return;
    let r = this.latestFeatureIndex.loadVTLayers();
    for (let i in this.buckets) {
      if (!t3.style.hasLayer(i))
        continue;
      let a = this.buckets[i], n = a.layers[0].sourceLayer || "_geojsonTileLayer", s3 = r[n], o = e53[n];
      if (!s3 || !o || 0 === Object.keys(o).length)
        continue;
      a.update(o, s3, this.imageAtlas && this.imageAtlas.patternPositions || {});
      let l = t3 && t3.style && t3.style.getLayer(i);
      l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(a)));
    }
  }
  holdingForFade() {
    return void 0 !== this.symbolFadeHoldUntil;
  }
  symbolFadeFinished() {
    return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < ne.now();
  }
  clearFadeHold() {
    this.symbolFadeHoldUntil = void 0;
  }
  setHoldDuration(e53) {
    this.symbolFadeHoldUntil = ne.now() + e53;
  }
  setDependencies(e53, t3) {
    let r = {};
    for (let e54 of t3)
      r[e54] = true;
    this.dependencies[e53] = r;
  }
  hasDependency(e53, t3) {
    for (let r of e53) {
      let e54 = this.dependencies[r];
      if (e54) {
        for (let r3 of t3)
          if (e54[r3])
            return true;
      }
    }
    return false;
  }
};
q(xm, "Tile");
var dn = xm;
c();
var bm = class {
  constructor(e53, t3) {
    this.max = e53, this.onRemove = t3, this.reset();
  }
  reset() {
    for (let e53 in this.data)
      for (let t3 of this.data[e53])
        t3.timeout && clearTimeout(t3.timeout), this.onRemove(t3.value);
    return this.data = {}, this.order = [], this;
  }
  add(e53, t3, r) {
    let i = e53.wrapped().key;
    void 0 === this.data[i] && (this.data[i] = []);
    let a = { value: t3, timeout: void 0 };
    if (void 0 !== r && (a.timeout = setTimeout(() => {
      this.remove(e53, a);
    }, r)), this.data[i].push(a), this.order.push(i), this.order.length > this.max) {
      let e54 = this._getAndRemoveByKey(this.order[0]);
      e54 && this.onRemove(e54);
    }
    return this;
  }
  has(e53) {
    return e53.wrapped().key in this.data;
  }
  getAndRemove(e53) {
    return this.has(e53) ? this._getAndRemoveByKey(e53.wrapped().key) : null;
  }
  _getAndRemoveByKey(e53) {
    let t3 = this.data[e53].shift();
    return t3.timeout && clearTimeout(t3.timeout), 0 === this.data[e53].length && delete this.data[e53], this.order.splice(this.order.indexOf(e53), 1), t3.value;
  }
  getByKey(e53) {
    let t3 = this.data[e53];
    return t3 ? t3[0].value : null;
  }
  get(e53) {
    return this.has(e53) ? this.data[e53.wrapped().key][0].value : null;
  }
  remove(e53, t3) {
    if (!this.has(e53))
      return this;
    let r = e53.wrapped().key, i = void 0 === t3 ? 0 : this.data[r].indexOf(t3), a = this.data[r][i];
    return this.data[r].splice(i, 1), a.timeout && clearTimeout(a.timeout), 0 === this.data[r].length && delete this.data[r], this.onRemove(a.value), this.order.splice(this.order.indexOf(r), 1), this;
  }
  setMaxSize(e53) {
    for (this.max = e53; this.order.length > this.max; ) {
      let e54 = this._getAndRemoveByKey(this.order[0]);
      e54 && this.onRemove(e54);
    }
    return this;
  }
  filter(e53) {
    let t3 = [];
    for (let r in this.data)
      for (let i of this.data[r])
        e53(i.value) || t3.push(i);
    for (let e54 of t3)
      this.remove(e54.value.tileID, e54);
  }
};
q(bm, "TileCache");
var xl = bm;
var vm = u(Pe(), 1);
c();
var _m = class {
  constructor() {
    this.state = {}, this.stateChanges = {}, this.deletedStates = {};
  }
  updateState(e53, t3, r) {
    let i = String(t3);
    if (this.stateChanges[e53] = this.stateChanges[e53] || {}, this.stateChanges[e53][i] = this.stateChanges[e53][i] || {}, R(this.stateChanges[e53][i], r), null === this.deletedStates[e53]) {
      this.deletedStates[e53] = {};
      for (let t4 in this.state[e53])
        t4 !== i && (this.deletedStates[e53][t4] = null);
    } else if (this.deletedStates[e53] && null === this.deletedStates[e53][i]) {
      this.deletedStates[e53][i] = {};
      for (let t4 in this.state[e53][i])
        r[t4] || (this.deletedStates[e53][i][t4] = null);
    } else
      for (let t4 in r)
        this.deletedStates[e53] && this.deletedStates[e53][i] && null === this.deletedStates[e53][i][t4] && delete this.deletedStates[e53][i][t4];
  }
  removeFeatureState(e53, t3, r) {
    if (null === this.deletedStates[e53])
      return;
    let i = String(t3);
    if (this.deletedStates[e53] = this.deletedStates[e53] || {}, r && void 0 !== t3)
      null !== this.deletedStates[e53][i] && (this.deletedStates[e53][i] = this.deletedStates[e53][i] || {}, this.deletedStates[e53][i][r] = null);
    else if (void 0 !== t3)
      if (this.stateChanges[e53] && this.stateChanges[e53][i])
        for (r in this.deletedStates[e53][i] = {}, this.stateChanges[e53][i])
          this.deletedStates[e53][i][r] = null;
      else
        this.deletedStates[e53][i] = null;
    else
      this.deletedStates[e53] = null;
  }
  getState(e53, t3) {
    let r = String(t3), i = this.state[e53] || {}, a = this.stateChanges[e53] || {}, n = R({}, i[r], a[r]);
    if (null === this.deletedStates[e53])
      return {};
    if (this.deletedStates[e53]) {
      let r3 = this.deletedStates[e53][t3];
      if (null === r3)
        return {};
      for (let e54 in r3)
        delete n[e54];
    }
    return n;
  }
  initializeTileState(e53, t3) {
    e53.setFeatureState(this.state, t3);
  }
  coalesceChanges(e53, t3) {
    let r = {};
    for (let e54 in this.stateChanges) {
      this.state[e54] = this.state[e54] || {};
      let t4 = {};
      for (let r3 in this.stateChanges[e54])
        this.state[e54][r3] || (this.state[e54][r3] = {}), R(this.state[e54][r3], this.stateChanges[e54][r3]), t4[r3] = this.state[e54][r3];
      r[e54] = t4;
    }
    for (let e54 in this.deletedStates) {
      this.state[e54] = this.state[e54] || {};
      let t4 = {};
      if (null === this.deletedStates[e54])
        for (let r3 in this.state[e54])
          t4[r3] = {}, this.state[e54][r3] = {};
      else
        for (let r3 in this.deletedStates[e54]) {
          if (null === this.deletedStates[e54][r3])
            this.state[e54][r3] = {};
          else
            for (let t5 of Object.keys(this.deletedStates[e54][r3]))
              delete this.state[e54][r3][t5];
          t4[r3] = this.state[e54][r3];
        }
      r[e54] = r[e54] || {}, R(r[e54], t4);
    }
    if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length)
      for (let i in e53)
        e53[i].setFeatureState(r, t3);
  }
};
q(_m, "SourceFeatureState");
var bl = _m;
var di = class e44 extends de {
  constructor(e53, t3, r) {
    super(), this.id = e53, this.dispatcher = r, this.on("data", (e54) => {
      "source" === e54.dataType && "metadata" === e54.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e54.dataType && "content" === e54.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
    }), this.on("dataloading", () => {
      this._sourceErrored = false;
    }), this.on("error", () => {
      this._sourceErrored = this._source.loaded();
    }), this._source = U_(e53, t3, r, this), this._tiles = {}, this._cache = new xl(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new bl(), this._didEmitContent = false, this._updated = false;
  }
  onAdd(e53) {
    this.map = e53, this._maxTileCacheSize = e53 ? e53._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e53 ? e53._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e53);
  }
  onRemove(e53) {
    this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e53);
  }
  loaded() {
    if (this._sourceErrored)
      return true;
    if (!this._sourceLoaded || !this._source.loaded())
      return false;
    if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain))
      return true;
    if (!this._updated)
      return false;
    for (let e53 in this._tiles) {
      let t3 = this._tiles[e53];
      if ("loaded" !== t3.state && "errored" !== t3.state)
        return false;
    }
    return true;
  }
  getSource() {
    return this._source;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    if (!this._paused)
      return;
    let e53 = this._shouldReloadOnResume;
    this._paused = false, this._shouldReloadOnResume = false, e53 && this.reload(), this.transform && this.update(this.transform, this.terrain);
  }
  _loadTile(e53, t3) {
    return this._source.loadTile(e53, t3);
  }
  _unloadTile(e53) {
    if (this._source.unloadTile)
      return this._source.unloadTile(e53, () => {
      });
  }
  _abortTile(e53) {
    this._source.abortTile && this._source.abortTile(e53, () => {
    }), this._source.fire(new z("dataabort", { tile: e53, coord: e53.tileID, dataType: "source" }));
  }
  serialize() {
    return this._source.serialize();
  }
  prepare(e53) {
    this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
    for (let t3 in this._tiles) {
      let r = this._tiles[t3];
      r.upload(e53), r.prepare(this.map.style.imageManager);
    }
  }
  getIds() {
    return Object.values(this._tiles).map((e53) => e53.tileID).sort(Y_).map((e53) => e53.key);
  }
  getRenderableIds(e53) {
    let t3 = [];
    for (let r in this._tiles)
      this._isIdRenderable(r, e53) && t3.push(this._tiles[r]);
    return e53 ? t3.sort((e54, t4) => {
      let r = e54.tileID, i = t4.tileID, a = new vm.default(r.canonical.x, r.canonical.y)._rotate(this.transform.angle), n = new vm.default(i.canonical.x, i.canonical.y)._rotate(this.transform.angle);
      return r.overscaledZ - i.overscaledZ || n.y - a.y || n.x - a.x;
    }).map((e54) => e54.tileID.key) : t3.map((e54) => e54.tileID).sort(Y_).map((e54) => e54.key);
  }
  hasRenderableParent(e53) {
    let t3 = this.findLoadedParent(e53, 0);
    return !!t3 && this._isIdRenderable(t3.tileID.key);
  }
  _isIdRenderable(e53, t3) {
    return this._tiles[e53] && this._tiles[e53].hasData() && !this._coveredTiles[e53] && (t3 || !this._tiles[e53].holdingForFade());
  }
  reload() {
    if (this._paused)
      this._shouldReloadOnResume = true;
    else {
      this._cache.reset();
      for (let e53 in this._tiles)
        "errored" !== this._tiles[e53].state && this._reloadTile(e53, "reloading");
    }
  }
  _reloadTile(e53, t3) {
    let r = this._tiles[e53];
    r && ("loading" !== r.state && (r.state = t3), this._loadTile(r, this._tileLoaded.bind(this, r, e53, t3)));
  }
  _tileLoaded(e53, t3, r, i) {
    if (i)
      return e53.state = "errored", void (404 !== i.status ? this._source.fire(new Z(i, { tile: e53 })) : this.update(this.transform, this.terrain));
    e53.timeAdded = ne.now(), "expired" === r && (e53.refreshedUponExpiration = true), this._setTileReloadTimer(t3, e53), "raster-dem" === this.getSource().type && e53.dem && this._backfillDEM(e53), this._state.initializeTileState(e53, this.map ? this.map.painter : null), e53.aborted || this._source.fire(new z("data", { dataType: "source", tile: e53, coord: e53.tileID }));
  }
  _backfillDEM(e53) {
    let t3 = this.getRenderableIds();
    for (let i = 0; i < t3.length; i++) {
      let a = t3[i];
      if (e53.neighboringTiles && e53.neighboringTiles[a]) {
        let t4 = this.getTileByID(a);
        r(e53, t4), r(t4, e53);
      }
    }
    function r(e54, t4) {
      e54.needsHillshadePrepare = true, e54.needsTerrainPrepare = true;
      let r3 = t4.tileID.canonical.x - e54.tileID.canonical.x, i = t4.tileID.canonical.y - e54.tileID.canonical.y, a = Math.pow(2, e54.tileID.canonical.z), n = t4.tileID.key;
      0 === r3 && 0 === i || Math.abs(i) > 1 || (Math.abs(r3) > 1 && (1 === Math.abs(r3 + a) ? r3 += a : 1 === Math.abs(r3 - a) && (r3 -= a)), t4.dem && e54.dem && (e54.dem.backfillBorder(t4.dem, r3, i), e54.neighboringTiles && e54.neighboringTiles[n] && (e54.neighboringTiles[n].backfilled = true)));
    }
    q(r, "fillBorder");
  }
  getTile(e53) {
    return this.getTileByID(e53.key);
  }
  getTileByID(e53) {
    return this._tiles[e53];
  }
  _retainLoadedChildren(e53, t3, r, i) {
    for (let a in this._tiles) {
      let n = this._tiles[a];
      if (i[a] || !n.hasData() || n.tileID.overscaledZ <= t3 || n.tileID.overscaledZ > r)
        continue;
      let s3 = n.tileID;
      for (; n && n.tileID.overscaledZ > t3 + 1; ) {
        let e54 = n.tileID.scaledTo(n.tileID.overscaledZ - 1);
        n = this._tiles[e54.key], n && n.hasData() && (s3 = e54);
      }
      let o = s3;
      for (; o.overscaledZ > t3; )
        if (o = o.scaledTo(o.overscaledZ - 1), e53[o.key]) {
          i[s3.key] = s3;
          break;
        }
    }
  }
  findLoadedParent(e53, t3) {
    if (e53.key in this._loadedParentTiles) {
      let r = this._loadedParentTiles[e53.key];
      return r && r.tileID.overscaledZ >= t3 ? r : null;
    }
    for (let r = e53.overscaledZ - 1; r >= t3; r--) {
      let t4 = e53.scaledTo(r), i = this._getLoadedTile(t4);
      if (i)
        return i;
    }
  }
  _getLoadedTile(e53) {
    let t3 = this._tiles[e53.key];
    return t3 && t3.hasData() ? t3 : this._cache.getByKey(e53.wrapped().key);
  }
  updateCacheSize(e53) {
    let t3 = (Math.ceil(e53.width / this._source.tileSize) + 1) * (Math.ceil(e53.height / this._source.tileSize) + 1), r = null === this._maxTileCacheZoomLevels ? it.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels, i = Math.floor(t3 * r), a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, i) : i;
    this._cache.setMaxSize(a);
  }
  handleWrapJump(e53) {
    let t3 = (e53 - (void 0 === this._prevLng ? e53 : this._prevLng)) / 360, r = Math.round(t3);
    if (this._prevLng = e53, r) {
      let e54 = {};
      for (let t4 in this._tiles) {
        let i = this._tiles[t4];
        i.tileID = i.tileID.unwrapTo(i.tileID.wrap + r), e54[i.tileID.key] = i;
      }
      this._tiles = e54;
      for (let e55 in this._timers)
        clearTimeout(this._timers[e55]), delete this._timers[e55];
      for (let e55 in this._tiles) {
        let t4 = this._tiles[e55];
        this._setTileReloadTimer(e55, t4);
      }
    }
  }
  update(t3, r) {
    if (this.transform = t3, this.terrain = r, !this._sourceLoaded || this._paused)
      return;
    let i;
    this.updateCacheSize(t3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? i = t3.getVisibleUnwrappedCoordinates(this._source.tileID).map((e53) => new rt(e53.canonical.z, e53.wrap, e53.canonical.z, e53.canonical.x, e53.canonical.y)) : (i = t3.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: r }), this._source.hasTile && (i = i.filter((e53) => this._source.hasTile(e53)))) : i = [];
    let a = t3.coveringZoomLevel(this._source), n = Math.max(a - e44.maxOverzooming, this._source.minzoom), s3 = Math.max(a + e44.maxUnderzooming, this._source.minzoom);
    if (this.usedForTerrain) {
      let e53 = {};
      for (let t4 of i)
        if (t4.canonical.z > this._source.minzoom) {
          let r3 = t4.scaledTo(t4.canonical.z - 1);
          e53[r3.key] = r3;
          let i3 = t4.scaledTo(Math.max(this._source.minzoom, Math.min(t4.canonical.z, 5)));
          e53[i3.key] = i3;
        }
      i = i.concat(Object.values(e53));
    }
    let o = 0 === i.length && !this._updated && this._didEmitContent;
    this._updated = true, o && this.fire(new z("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
    let l = this._updateRetainedTiles(i, a);
    if (J_(this._source.type)) {
      let e53 = {}, t4 = {}, o3 = Object.keys(l), u4 = ne.now();
      for (let r3 of o3) {
        let i3 = l[r3], a3 = this._tiles[r3];
        if (!a3 || 0 !== a3.fadeEndTime && a3.fadeEndTime <= u4)
          continue;
        let s4 = this.findLoadedParent(i3, n);
        s4 && (this._addTile(s4.tileID), e53[s4.tileID.key] = s4.tileID), t4[r3] = i3;
      }
      this._retainLoadedChildren(t4, a, s3, l);
      for (let t5 in e53)
        l[t5] || (this._coveredTiles[t5] = true, l[t5] = e53[t5]);
      if (r) {
        let e54 = {}, t5 = {};
        for (let r3 of i)
          this._tiles[r3.key].hasData() ? e54[r3.key] = r3 : t5[r3.key] = r3;
        for (let r3 in t5) {
          let i3 = t5[r3].children(this._source.maxzoom);
          this._tiles[i3[0].key] && this._tiles[i3[1].key] && this._tiles[i3[2].key] && this._tiles[i3[3].key] && (e54[i3[0].key] = l[i3[0].key] = i3[0], e54[i3[1].key] = l[i3[1].key] = i3[1], e54[i3[2].key] = l[i3[2].key] = i3[2], e54[i3[3].key] = l[i3[3].key] = i3[3], delete t5[r3]);
        }
        for (let r3 in t5) {
          let i3 = this.findLoadedParent(t5[r3], this._source.minzoom);
          if (i3) {
            e54[i3.tileID.key] = l[i3.tileID.key] = i3.tileID;
            for (let t6 in e54)
              e54[t6].isChildOf(i3.tileID) && delete e54[t6];
          }
        }
        for (let t6 in this._tiles)
          e54[t6] || (this._coveredTiles[t6] = true);
      }
    }
    for (let e53 in l)
      this._tiles[e53].clearFadeHold();
    let u3 = Zy(this._tiles, l);
    for (let e53 of u3) {
      let t4 = this._tiles[e53];
      t4.hasSymbolBuckets && !t4.holdingForFade() ? t4.setHoldDuration(this.map._fadeDuration) : (!t4.hasSymbolBuckets || t4.symbolFadeFinished()) && this._removeTile(e53);
    }
    this._updateLoadedParentTileCache();
  }
  releaseSymbolFadeTiles() {
    for (let e53 in this._tiles)
      this._tiles[e53].holdingForFade() && this._removeTile(e53);
  }
  _updateRetainedTiles(t3, r) {
    let i = {}, a = {}, n = Math.max(r - e44.maxOverzooming, this._source.minzoom), s3 = Math.max(r + e44.maxUnderzooming, this._source.minzoom), o = {};
    for (let e53 of t3) {
      let t4 = this._addTile(e53);
      i[e53.key] = e53, !t4.hasData() && r < this._source.maxzoom && (o[e53.key] = e53);
    }
    this._retainLoadedChildren(o, r, s3, i);
    for (let e53 of t3) {
      let t4 = this._tiles[e53.key];
      if (t4.hasData())
        continue;
      if (r + 1 > this._source.maxzoom) {
        let t5 = e53.children(this._source.maxzoom)[0], r3 = this.getTile(t5);
        if (r3 && r3.hasData()) {
          i[t5.key] = t5;
          continue;
        }
      } else {
        let t5 = e53.children(this._source.maxzoom);
        if (i[t5[0].key] && i[t5[1].key] && i[t5[2].key] && i[t5[3].key])
          continue;
      }
      let s4 = t4.wasRequested();
      for (let r3 = e53.overscaledZ - 1; r3 >= n; --r3) {
        let n3 = e53.scaledTo(r3);
        if (a[n3.key])
          break;
        if (a[n3.key] = true, t4 = this.getTile(n3), !t4 && s4 && (t4 = this._addTile(n3)), t4) {
          let e54 = t4.hasData();
          if ((s4 || e54) && (i[n3.key] = n3), s4 = t4.wasRequested(), e54)
            break;
        }
      }
    }
    return i;
  }
  _updateLoadedParentTileCache() {
    this._loadedParentTiles = {};
    for (let e53 in this._tiles) {
      let t3, r = [], i = this._tiles[e53].tileID;
      for (; i.overscaledZ > 0; ) {
        if (i.key in this._loadedParentTiles) {
          t3 = this._loadedParentTiles[i.key];
          break;
        }
        r.push(i.key);
        let e54 = i.scaledTo(i.overscaledZ - 1);
        if (t3 = this._getLoadedTile(e54), t3)
          break;
        i = e54;
      }
      for (let e54 of r)
        this._loadedParentTiles[e54] = t3;
    }
  }
  _addTile(e53) {
    let t3 = this._tiles[e53.key];
    if (t3)
      return t3;
    t3 = this._cache.getAndRemove(e53), t3 && (this._setTileReloadTimer(e53.key, t3), t3.tileID = e53, this._state.initializeTileState(t3, this.map ? this.map.painter : null), this._cacheTimers[e53.key] && (clearTimeout(this._cacheTimers[e53.key]), delete this._cacheTimers[e53.key], this._setTileReloadTimer(e53.key, t3)));
    let r = t3;
    return t3 || (t3 = new dn(e53, this._source.tileSize * e53.overscaleFactor()), this._loadTile(t3, this._tileLoaded.bind(this, t3, e53.key, t3.state))), t3.uses++, this._tiles[e53.key] = t3, r || this._source.fire(new z("dataloading", { tile: t3, coord: t3.tileID, dataType: "source" })), t3;
  }
  _setTileReloadTimer(e53, t3) {
    e53 in this._timers && (clearTimeout(this._timers[e53]), delete this._timers[e53]);
    let r = t3.getExpiryTimeout();
    r && (this._timers[e53] = setTimeout(() => {
      this._reloadTile(e53, "expired"), delete this._timers[e53];
    }, r));
  }
  _removeTile(e53) {
    let t3 = this._tiles[e53];
    t3 && (t3.uses--, delete this._tiles[e53], this._timers[e53] && (clearTimeout(this._timers[e53]), delete this._timers[e53]), !(t3.uses > 0) && (t3.hasData() && "reloading" !== t3.state ? this._cache.add(t3.tileID, t3, t3.getExpiryTimeout()) : (t3.aborted = true, this._abortTile(t3), this._unloadTile(t3))));
  }
  clearTiles() {
    this._shouldReloadOnResume = false, this._paused = false;
    for (let e53 in this._tiles)
      this._removeTile(e53);
    this._cache.reset();
  }
  tilesIn(e53, t3, r) {
    let i = [], a = this.transform;
    if (!a)
      return i;
    let n = r ? a.getCameraQueryGeometry(e53) : e53, s3 = e53.map((e54) => a.pointCoordinate(e54, this.terrain)), o = n.map((e54) => a.pointCoordinate(e54, this.terrain)), l = this.getIds(), u3 = 1 / 0, c3 = 1 / 0, h = -1 / 0, p = -1 / 0;
    for (let e54 of o)
      u3 = Math.min(u3, e54.x), c3 = Math.min(c3, e54.y), h = Math.max(h, e54.x), p = Math.max(p, e54.y);
    for (let e54 = 0; e54 < l.length; e54++) {
      let r3 = this._tiles[l[e54]];
      if (r3.holdingForFade())
        continue;
      let n3 = r3.tileID, d = Math.pow(2, a.zoom - r3.tileID.overscaledZ), f = t3 * r3.queryPadding * 8192 / r3.tileSize / d, m = [n3.getTilePoint(new ze(u3, c3)), n3.getTilePoint(new ze(h, p))];
      if (m[0].x - f < 8192 && m[0].y - f < 8192 && m[1].x + f >= 0 && m[1].y + f >= 0) {
        let e55 = s3.map((e56) => n3.getTilePoint(e56)), t4 = o.map((e56) => n3.getTilePoint(e56));
        i.push({ tile: r3, tileID: n3, queryGeometry: e55, cameraQueryGeometry: t4, scale: d });
      }
    }
    return i;
  }
  getVisibleCoordinates(e53) {
    let t3 = this.getRenderableIds(e53).map((e54) => this._tiles[e54].tileID);
    for (let e54 of t3)
      e54.posMatrix = this.transform.calculatePosMatrix(e54.toUnwrapped());
    return t3;
  }
  hasTransition() {
    if (this._source.hasTransition())
      return true;
    if (J_(this._source.type)) {
      let e53 = ne.now();
      for (let t3 in this._tiles)
        if (this._tiles[t3].fadeEndTime >= e53)
          return true;
    }
    return false;
  }
  setFeatureState(e53, t3, r) {
    e53 = e53 || "_geojsonTileLayer", this._state.updateState(e53, t3, r);
  }
  removeFeatureState(e53, t3, r) {
    e53 = e53 || "_geojsonTileLayer", this._state.removeFeatureState(e53, t3, r);
  }
  getFeatureState(e53, t3) {
    return e53 = e53 || "_geojsonTileLayer", this._state.getState(e53, t3);
  }
  setDependencies(e53, t3, r) {
    let i = this._tiles[e53];
    i && i.setDependencies(t3, r);
  }
  reloadTilesForDependencies(e53, t3) {
    for (let r in this._tiles)
      this._tiles[r].hasDependency(e53, t3) && this._reloadTile(r, "reloading");
    this._cache.filter((r) => !r.hasDependency(e53, t3));
  }
};
q(di, "SourceCache");
var or = di;
function Y_(e53, t3) {
  let r = Math.abs(2 * e53.wrap) - +(e53.wrap < 0), i = Math.abs(2 * t3.wrap) - +(t3.wrap < 0);
  return e53.overscaledZ - t3.overscaledZ || i - r || t3.canonical.y - e53.canonical.y || t3.canonical.x - e53.canonical.x;
}
function J_(e53) {
  return "raster" === e53 || "image" === e53 || "video" === e53;
}
or.maxOverzooming = 10, or.maxUnderzooming = 3, q(Y_, "compareTileId"), q(J_, "isRasterType"), c(), c(), c(), c();
var Q_ = `(()=>{var Tf=Object.create;var da=Object.defineProperty;var Ef=Object.getOwnPropertyDescriptor;var Ff=Object.getOwnPropertyNames;var Mf=Object.getPrototypeOf,Lf=Object.prototype.hasOwnProperty;var we=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),sl=(e,t)=>{for(var r in t)da(e,r,{get:t[r],enumerable:!0})},Df=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of Ff(t))!Lf.call(e,i)&&i!==r&&da(e,i,{get:()=>t[i],enumerable:!(n=Ef(t,i))||n.enumerable});return e};var Z=(e,t,r)=>(r=e!=null?Tf(Mf(e)):{},Df(t||!e||!e.__esModule?da(r,"default",{value:e,enumerable:!0}):r,e));var he=we((Kx,ll)=>{"use strict";ll.exports=rr;function rr(e,t){this.x=e,this.y=t}rr.prototype={clone:function(){return new rr(this.x,this.y)},add:function(e){return this.clone()._add(e)},sub:function(e){return this.clone()._sub(e)},multByPoint:function(e){return this.clone()._multByPoint(e)},divByPoint:function(e){return this.clone()._divByPoint(e)},mult:function(e){return this.clone()._mult(e)},div:function(e){return this.clone()._div(e)},rotate:function(e){return this.clone()._rotate(e)},rotateAround:function(e,t){return this.clone()._rotateAround(e,t)},matMult:function(e){return this.clone()._matMult(e)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(e){return this.x===e.x&&this.y===e.y},dist:function(e){return Math.sqrt(this.distSqr(e))},distSqr:function(e){var t=e.x-this.x,r=e.y-this.y;return t*t+r*r},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(e){return Math.atan2(this.y-e.y,this.x-e.x)},angleWith:function(e){return this.angleWithSep(e.x,e.y)},angleWithSep:function(e,t){return Math.atan2(this.x*t-this.y*e,this.x*e+this.y*t)},_matMult:function(e){var t=e[0]*this.x+e[1]*this.y,r=e[2]*this.x+e[3]*this.y;return this.x=t,this.y=r,this},_add:function(e){return this.x+=e.x,this.y+=e.y,this},_sub:function(e){return this.x-=e.x,this.y-=e.y,this},_mult:function(e){return this.x*=e,this.y*=e,this},_div:function(e){return this.x/=e,this.y/=e,this},_multByPoint:function(e){return this.x*=e.x,this.y*=e.y,this},_divByPoint:function(e){return this.x/=e.x,this.y/=e.y,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var e=this.y;return this.y=this.x,this.x=-e,this},_rotate:function(e){var t=Math.cos(e),r=Math.sin(e),n=t*this.x-r*this.y,i=r*this.x+t*this.y;return this.x=n,this.y=i,this},_rotateAround:function(e,t){var r=Math.cos(e),n=Math.sin(e),i=t.x+r*(this.x-t.x)-n*(this.y-t.y),o=t.y+n*(this.x-t.x)+r*(this.y-t.y);return this.x=i,this.y=o,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}};rr.convert=function(e){return e instanceof rr?e:Array.isArray(e)?new rr(e[0],e[1]):e}});var ga=we((Yx,cl)=>{"use strict";cl.exports=ul;function ul(e,t,r,n){this.cx=3*e,this.bx=3*(r-e)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*t,this.by=3*(n-t)-this.cy,this.ay=1-this.cy-this.by,this.p1x=e,this.p1y=t,this.p2x=r,this.p2y=n}ul.prototype={sampleCurveX:function(e){return((this.ax*e+this.bx)*e+this.cx)*e},sampleCurveY:function(e){return((this.ay*e+this.by)*e+this.cy)*e},sampleCurveDerivativeX:function(e){return(3*this.ax*e+2*this.bx)*e+this.cx},solveCurveX:function(e,t){if(t===void 0&&(t=1e-6),e<0)return 0;if(e>1)return 1;for(var r=e,n=0;n<8;n++){var i=this.sampleCurveX(r)-e;if(Math.abs(i)<t)return r;var o=this.sampleCurveDerivativeX(r);if(Math.abs(o)<1e-6)break;r=r-i/o}var a=0,s=1;for(r=e,n=0;n<20&&(i=this.sampleCurveX(r),!(Math.abs(i-e)<t));n++)e>i?a=r:s=r,r=(s-a)*.5+a;return r},solve:function(e,t){return this.sampleCurveY(this.solveCurveX(e,t))}}});var Du=we((w0,es)=>{function Jm(e,t){var r,n,i,o,a,s,l,u,c,p;for(r=e.length&3,n=e.length-r,i=t,a=3432918353,l=461845907,p=0;p<n;)c=e.charCodeAt(p)&255|(e.charCodeAt(++p)&255)<<8|(e.charCodeAt(++p)&255)<<16|(e.charCodeAt(++p)&255)<<24,++p,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c,i=i<<13|i>>>19,o=(i&65535)*5+(((i>>>16)*5&65535)<<16)&4294967295,i=(o&65535)+27492+(((o>>>16)+58964&65535)<<16);switch(c=0,r){case 3:c^=(e.charCodeAt(p+2)&255)<<16;case 2:c^=(e.charCodeAt(p+1)&255)<<8;case 1:c^=e.charCodeAt(p)&255,c=(c&65535)*a+(((c>>>16)*a&65535)<<16)&4294967295,c=c<<15|c>>>17,c=(c&65535)*l+(((c>>>16)*l&65535)<<16)&4294967295,i^=c}return i^=e.length,i^=i>>>16,i=(i&65535)*2246822507+(((i>>>16)*2246822507&65535)<<16)&4294967295,i^=i>>>13,i=(i&65535)*3266489909+(((i>>>16)*3266489909&65535)<<16)&4294967295,i^=i>>>16,i>>>0}typeof es<"u"&&(es.exports=Jm)});var Vu=we((A0,ts)=>{function Wm(e,t){for(var r=e.length,n=t^r,i=0,o;r>=4;)o=e.charCodeAt(i)&255|(e.charCodeAt(++i)&255)<<8|(e.charCodeAt(++i)&255)<<16|(e.charCodeAt(++i)&255)<<24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),o^=o>>>24,o=(o&65535)*1540483477+(((o>>>16)*1540483477&65535)<<16),n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)^o,r-=4,++i;switch(r){case 3:n^=(e.charCodeAt(i+2)&255)<<16;case 2:n^=(e.charCodeAt(i+1)&255)<<8;case 1:n^=e.charCodeAt(i)&255,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16)}return n^=n>>>13,n=(n&65535)*1540483477+(((n>>>16)*1540483477&65535)<<16),n^=n>>>15,n>>>0}typeof ts!==void 0&&(ts.exports=Wm)});var rs=we((_0,fo)=>{var Bu=Du(),Hm=Vu();fo.exports=Bu;fo.exports.murmur3=Bu;fo.exports.murmur2=Hm});var hs=we((g1,ms)=>{"use strict";ms.exports=Io;ms.exports.default=Io;function Io(e,t,r){r=r||2;var n=t&&t.length,i=n?t[0]*r:e.length,o=Sc(e,0,i,r,!0),a=[];if(!o||o.next===o.prev)return a;var s,l,u,c,p,f,y;if(n&&(o=Vd(e,t,o,r)),e.length>80*r){s=u=e[0],l=c=e[1];for(var m=r;m<i;m+=r)p=e[m],f=e[m+1],p<s&&(s=p),f<l&&(l=f),p>u&&(u=p),f>c&&(c=f);y=Math.max(u-s,c-l),y=y!==0?32767/y:0}return Bn(o,a,r,s,l,y,0),a}function Sc(e,t,r,n,i){var o,a;if(i===ys(e,t,r,n)>0)for(o=t;o<r;o+=n)a=Pc(o,e[o],e[o+1],a);else for(o=r-n;o>=t;o-=n)a=Pc(o,e[o],e[o+1],a);return a&&Co(a,a.next)&&(Rn(a),a=a.next),a}function Ht(e,t){if(!e)return e;t||(t=e);var r=e,n;do if(n=!1,!r.steiner&&(Co(r,r.next)||se(r.prev,r,r.next)===0)){if(Rn(r),r=t=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==t);return t}function Bn(e,t,r,n,i,o,a){if(e){!a&&o&&Nd(e,n,i,o);for(var s=e,l,u;e.prev!==e.next;){if(l=e.prev,u=e.next,o?Md(e,n,i,o):Fd(e)){t.push(l.i/r|0),t.push(e.i/r|0),t.push(u.i/r|0),Rn(e),e=u.next,s=u.next;continue}if(e=u,e===s){a?a===1?(e=Ld(Ht(e),t,r),Bn(e,t,r,n,i,o,2)):a===2&&Dd(e,t,r,n,i,o):Bn(Ht(e),t,r,n,i,o,1);break}}}}function Fd(e){var t=e.prev,r=e,n=e.next;if(se(t,r,n)>=0)return!1;for(var i=t.x,o=r.x,a=n.x,s=t.y,l=r.y,u=n.y,c=i<o?i<a?i:a:o<a?o:a,p=s<l?s<u?s:u:l<u?l:u,f=i>o?i>a?i:a:o>a?o:a,y=s>l?s>u?s:u:l>u?l:u,m=n.next;m!==t;){if(m.x>=c&&m.x<=f&&m.y>=p&&m.y<=y&&Pr(i,s,o,l,a,u,m.x,m.y)&&se(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function Md(e,t,r,n){var i=e.prev,o=e,a=e.next;if(se(i,o,a)>=0)return!1;for(var s=i.x,l=o.x,u=a.x,c=i.y,p=o.y,f=a.y,y=s<l?s<u?s:u:l<u?l:u,m=c<p?c<f?c:f:p<f?p:f,h=s>l?s>u?s:u:l>u?l:u,d=c>p?c>f?c:f:p>f?p:f,g=ps(y,m,t,r,n),v=ps(h,d,t,r,n),b=e.prevZ,x=e.nextZ;b&&b.z>=g&&x&&x.z<=v;){if(b.x>=y&&b.x<=h&&b.y>=m&&b.y<=d&&b!==i&&b!==a&&Pr(s,c,l,p,u,f,b.x,b.y)&&se(b.prev,b,b.next)>=0||(b=b.prevZ,x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Pr(s,c,l,p,u,f,x.x,x.y)&&se(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;b&&b.z>=g;){if(b.x>=y&&b.x<=h&&b.y>=m&&b.y<=d&&b!==i&&b!==a&&Pr(s,c,l,p,u,f,b.x,b.y)&&se(b.prev,b,b.next)>=0)return!1;b=b.prevZ}for(;x&&x.z<=v;){if(x.x>=y&&x.x<=h&&x.y>=m&&x.y<=d&&x!==i&&x!==a&&Pr(s,c,l,p,u,f,x.x,x.y)&&se(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function Ld(e,t,r){var n=e;do{var i=n.prev,o=n.next.next;!Co(i,o)&&wc(i,n,n.next,o)&&zn(i,o)&&zn(o,i)&&(t.push(i.i/r|0),t.push(n.i/r|0),t.push(o.i/r|0),Rn(n),Rn(n.next),n=e=o),n=n.next}while(n!==e);return Ht(n)}function Dd(e,t,r,n,i,o){var a=e;do{for(var s=a.next.next;s!==a.prev;){if(a.i!==s.i&&Gd(a,s)){var l=Ac(a,s);a=Ht(a,a.next),l=Ht(l,l.next),Bn(a,t,r,n,i,o,0),Bn(l,t,r,n,i,o,0);return}s=s.next}a=a.next}while(a!==e)}function Vd(e,t,r,n){var i=[],o,a,s,l,u;for(o=0,a=t.length;o<a;o++)s=t[o]*n,l=o<a-1?t[o+1]*n:e.length,u=Sc(e,s,l,n,!1),u===u.next&&(u.steiner=!0),i.push($d(u));for(i.sort(Bd),o=0;o<i.length;o++)r=zd(i[o],r);return r}function Bd(e,t){return e.x-t.x}function zd(e,t){var r=Rd(e,t);if(!r)return t;var n=Ac(r,e);return Ht(n,n.next),Ht(r,r.next)}function Rd(e,t){var r=t,n=e.x,i=e.y,o=-1/0,a;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var s=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=n&&s>o&&(o=s,a=r.x<r.next.x?r:r.next,s===n))return a}r=r.next}while(r!==t);if(!a)return null;var l=a,u=a.x,c=a.y,p=1/0,f;r=a;do n>=r.x&&r.x>=u&&n!==r.x&&Pr(i<c?n:o,i,u,c,i<c?o:n,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(n-r.x),zn(r,e)&&(f<p||f===p&&(r.x>a.x||r.x===a.x&&Od(a,r)))&&(a=r,p=f)),r=r.next;while(r!==l);return a}function Od(e,t){return se(e.prev,e,t.prev)<0&&se(t.next,e,e.next)<0}function Nd(e,t,r,n){var i=e;do i.z===0&&(i.z=ps(i.x,i.y,t,r,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,Ud(i)}function Ud(e){var t,r,n,i,o,a,s,l,u=1;do{for(r=e,e=null,o=null,a=0;r;){for(a++,n=r,s=0,t=0;t<u&&(s++,n=n.nextZ,!!n);t++);for(l=u;s>0||l>0&&n;)s!==0&&(l===0||!n||r.z<=n.z)?(i=r,r=r.nextZ,s--):(i=n,n=n.nextZ,l--),o?o.nextZ=i:e=i,i.prevZ=o,o=i;r=n}o.nextZ=null,u*=2}while(a>1);return e}function ps(e,t,r,n,i){return e=(e-r)*i|0,t=(t-n)*i|0,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1}function $d(e){var t=e,r=e;do(t.x<r.x||t.x===r.x&&t.y<r.y)&&(r=t),t=t.next;while(t!==e);return r}function Pr(e,t,r,n,i,o,a,s){return(i-a)*(t-s)>=(e-a)*(o-s)&&(e-a)*(n-s)>=(r-a)*(t-s)&&(r-a)*(o-s)>=(i-a)*(n-s)}function Gd(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!qd(e,t)&&(zn(e,t)&&zn(t,e)&&jd(e,t)&&(se(e.prev,e,t.prev)||se(e,t.prev,t))||Co(e,t)&&se(e.prev,e,e.next)>0&&se(t.prev,t,t.next)>0)}function se(e,t,r){return(t.y-e.y)*(r.x-t.x)-(t.x-e.x)*(r.y-t.y)}function Co(e,t){return e.x===t.x&&e.y===t.y}function wc(e,t,r,n){var i=_o(se(e,t,r)),o=_o(se(e,t,n)),a=_o(se(r,n,e)),s=_o(se(r,n,t));return!!(i!==o&&a!==s||i===0&&Ao(e,r,t)||o===0&&Ao(e,n,t)||a===0&&Ao(r,e,n)||s===0&&Ao(r,t,n))}function Ao(e,t,r){return t.x<=Math.max(e.x,r.x)&&t.x>=Math.min(e.x,r.x)&&t.y<=Math.max(e.y,r.y)&&t.y>=Math.min(e.y,r.y)}function _o(e){return e>0?1:e<0?-1:0}function qd(e,t){var r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==t.i&&r.next.i!==t.i&&wc(r,r.next,e,t))return!0;r=r.next}while(r!==e);return!1}function zn(e,t){return se(e.prev,e,e.next)<0?se(e,t,e.next)>=0&&se(e,e.prev,t)>=0:se(e,t,e.prev)<0||se(e,e.next,t)<0}function jd(e,t){var r=e,n=!1,i=(e.x+t.x)/2,o=(e.y+t.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&i<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==e);return n}function Ac(e,t){var r=new fs(e.i,e.x,e.y),n=new fs(t.i,t.x,t.y),i=e.next,o=t.prev;return e.next=t,t.prev=e,r.next=i,i.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function Pc(e,t,r,n){var i=new fs(e,t,r);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function Rn(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function fs(e,t,r){this.i=e,this.x=t,this.y=r,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}Io.deviation=function(e,t,r,n){var i=t&&t.length,o=i?t[0]*r:e.length,a=Math.abs(ys(e,0,o,r));if(i)for(var s=0,l=t.length;s<l;s++){var u=t[s]*r,c=s<l-1?t[s+1]*r:e.length;a-=Math.abs(ys(e,u,c,r))}var p=0;for(s=0;s<n.length;s+=3){var f=n[s]*r,y=n[s+1]*r,m=n[s+2]*r;p+=Math.abs((e[f]-e[m])*(e[y+1]-e[f+1])-(e[f]-e[y])*(e[m+1]-e[f+1]))}return a===0&&p===0?0:Math.abs((p-a)/a)};function ys(e,t,r,n){for(var i=0,o=t,a=r-n;o<r;o+=n)i+=(e[a]-e[o])*(e[o+1]+e[a+1]),a=o;return i}Io.flatten=function(e){for(var t=e[0][0].length,r={vertices:[],holes:[],dimensions:t},n=0,i=0;i<e.length;i++){for(var o=0;o<e[i].length;o++)for(var a=0;a<t;a++)r.vertices.push(e[i][o][a]);i>0&&(n+=e[i-1].length,r.holes.push(n))}return r}});var gs=we((eP,Mc)=>{"use strict";var Xd=he();Mc.exports=_r;function _r(e,t,r,n,i){this.properties={},this.extent=r,this.type=0,this._pbf=e,this._geometry=-1,this._keys=n,this._values=i,e.readFields(Qd,this,t)}function Qd(e,t,r){e==1?t.id=r.readVarint():e==2?eg(r,t):e==3?t.type=r.readVarint():e==4&&(t._geometry=r.pos)}function eg(e,t){for(var r=e.readVarint()+e.pos;e.pos<r;){var n=t._keys[e.readVarint()],i=t._values[e.readVarint()];t.properties[n]=i}}_r.types=["Unknown","Point","LineString","Polygon"];_r.prototype.loadGeometry=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,n=0,i=0,o=0,a=[],s;e.pos<t;){if(n<=0){var l=e.readVarint();r=l&7,n=l>>3}if(n--,r===1||r===2)i+=e.readSVarint(),o+=e.readSVarint(),r===1&&(s&&a.push(s),s=[]),s.push(new Xd(i,o));else if(r===7)s&&s.push(s[0].clone());else throw new Error("unknown command "+r)}return s&&a.push(s),a};_r.prototype.bbox=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,n=0,i=0,o=0,a=1/0,s=-1/0,l=1/0,u=-1/0;e.pos<t;){if(n<=0){var c=e.readVarint();r=c&7,n=c>>3}if(n--,r===1||r===2)i+=e.readSVarint(),o+=e.readSVarint(),i<a&&(a=i),i>s&&(s=i),o<l&&(l=o),o>u&&(u=o);else if(r!==7)throw new Error("unknown command "+r)}return[a,l,s,u]};_r.prototype.toGeoJSON=function(e,t,r){var n=this.extent*Math.pow(2,r),i=this.extent*e,o=this.extent*t,a=this.loadGeometry(),s=_r.types[this.type],l,u;function c(y){for(var m=0;m<y.length;m++){var h=y[m],d=180-(h.y+o)*360/n;y[m]=[(h.x+i)*360/n-180,360/Math.PI*Math.atan(Math.exp(d*Math.PI/180))-90]}}switch(this.type){case 1:var p=[];for(l=0;l<a.length;l++)p[l]=a[l][0];a=p,c(a);break;case 2:for(l=0;l<a.length;l++)c(a[l]);break;case 3:for(a=tg(a),l=0;l<a.length;l++)for(u=0;u<a[l].length;u++)c(a[l][u]);break}a.length===1?a=a[0]:s="Multi"+s;var f={type:"Feature",geometry:{type:s,coordinates:a},properties:this.properties};return"id"in this&&(f.id=this.id),f};function tg(e){var t=e.length;if(t<=1)return[e];for(var r=[],n,i,o=0;o<t;o++){var a=rg(e[o]);a!==0&&(i===void 0&&(i=a<0),i===a<0?(n&&r.push(n),n=[e[o]]):n.push(e[o]))}return n&&r.push(n),r}function rg(e){for(var t=0,r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}});var xs=we((tP,Dc)=>{"use strict";var ng=gs();Dc.exports=Lc;function Lc(e,t){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=e,this._keys=[],this._values=[],this._features=[],e.readFields(ig,this,t),this.length=this._features.length}function ig(e,t,r){e===15?t.version=r.readVarint():e===1?t.name=r.readString():e===5?t.extent=r.readVarint():e===2?t._features.push(r.pos):e===3?t._keys.push(r.readString()):e===4&&t._values.push(og(r))}function og(e){for(var t=null,r=e.readVarint()+e.pos;e.pos<r;){var n=e.readVarint()>>3;t=n===1?e.readString():n===2?e.readFloat():n===3?e.readDouble():n===4?e.readVarint64():n===5?e.readVarint():n===6?e.readSVarint():n===7?e.readBoolean():null}return t}Lc.prototype.feature=function(e){if(e<0||e>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[e];var t=this._pbf.readVarint()+this._pbf.pos;return new ng(this._pbf,t,this.extent,this._keys,this._values)}});var Bc=we((rP,Vc)=>{"use strict";var ag=xs();Vc.exports=sg;function sg(e,t){this.layers=e.readFields(lg,{},t)}function lg(e,t,r){if(e===3){var n=new ag(r,r.readVarint()+r.pos);n.length&&(t[n.name]=n)}}});var It=we((nP,To)=>{To.exports.VectorTile=Bc();To.exports.VectorTileFeature=gs();To.exports.VectorTileLayer=xs()});var np=we(ws=>{ws.read=function(e,t,r,n,i){var o,a,s=i*8-n-1,l=(1<<s)-1,u=l>>1,c=-7,p=r?i-1:0,f=r?-1:1,y=e[t+p];for(p+=f,o=y&(1<<-c)-1,y>>=-c,c+=s;c>0;o=o*256+e[t+p],p+=f,c-=8);for(a=o&(1<<-c)-1,o>>=-c,c+=n;c>0;a=a*256+e[t+p],p+=f,c-=8);if(o===0)o=1-u;else{if(o===l)return a?NaN:(y?-1:1)*(1/0);a=a+Math.pow(2,n),o=o-u}return(y?-1:1)*a*Math.pow(2,o-n)};ws.write=function(e,t,r,n,i,o){var a,s,l,u=o*8-i-1,c=(1<<u)-1,p=c>>1,f=i===23?Math.pow(2,-24)-Math.pow(2,-77):0,y=n?0:o-1,m=n?1:-1,h=t<0||t===0&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,a=c):(a=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-a))<1&&(a--,l*=2),a+p>=1?t+=f/l:t+=f*Math.pow(2,1-p),t*l>=2&&(a++,l/=2),a+p>=c?(s=0,a=c):a+p>=1?(s=(t*l-1)*Math.pow(2,i),a=a+p):(s=t*Math.pow(2,p-1)*Math.pow(2,i),a=0));i>=8;e[r+y]=s&255,y+=m,s/=256,i-=8);for(a=a<<i|s,u+=i;u>0;e[r+y]=a&255,y+=m,a/=256,u-=8);e[r+y-m]|=h*128}});var $n=we((RS,lp)=>{"use strict";lp.exports=J;var Do=np();function J(e){this.buf=ArrayBuffer.isView&&ArrayBuffer.isView(e)?e:new Uint8Array(e||0),this.pos=0,this.type=0,this.length=this.buf.length}J.Varint=0;J.Fixed64=1;J.Bytes=2;J.Fixed32=5;var As=65536*65536,ip=1/As,Cg=12,sp=typeof TextDecoder>"u"?null:new TextDecoder("utf8");J.prototype={destroy:function(){this.buf=null},readFields:function(e,t,r){for(r=r||this.length;this.pos<r;){var n=this.readVarint(),i=n>>3,o=this.pos;this.type=n&7,e(i,t,this),this.pos===o&&this.skip(n)}return t},readMessage:function(e,t){return this.readFields(e,t,this.readVarint()+this.pos)},readFixed32:function(){var e=Vo(this.buf,this.pos);return this.pos+=4,e},readSFixed32:function(){var e=ap(this.buf,this.pos);return this.pos+=4,e},readFixed64:function(){var e=Vo(this.buf,this.pos)+Vo(this.buf,this.pos+4)*As;return this.pos+=8,e},readSFixed64:function(){var e=Vo(this.buf,this.pos)+ap(this.buf,this.pos+4)*As;return this.pos+=8,e},readFloat:function(){var e=Do.read(this.buf,this.pos,!0,23,4);return this.pos+=4,e},readDouble:function(){var e=Do.read(this.buf,this.pos,!0,52,8);return this.pos+=8,e},readVarint:function(e){var t=this.buf,r,n;return n=t[this.pos++],r=n&127,n<128||(n=t[this.pos++],r|=(n&127)<<7,n<128)||(n=t[this.pos++],r|=(n&127)<<14,n<128)||(n=t[this.pos++],r|=(n&127)<<21,n<128)?r:(n=t[this.pos],r|=(n&15)<<28,kg(r,e,this))},readVarint64:function(){return this.readVarint(!0)},readSVarint:function(){var e=this.readVarint();return e%2===1?(e+1)/-2:e/2},readBoolean:function(){return!!this.readVarint()},readString:function(){var e=this.readVarint()+this.pos,t=this.pos;return this.pos=e,e-t>=Cg&&sp?$g(this.buf,t,e):Ug(this.buf,t,e)},readBytes:function(){var e=this.readVarint()+this.pos,t=this.buf.subarray(this.pos,e);return this.pos=e,t},readPackedVarint:function(e,t){if(this.type!==J.Bytes)return e.push(this.readVarint(t));var r=ut(this);for(e=e||[];this.pos<r;)e.push(this.readVarint(t));return e},readPackedSVarint:function(e){if(this.type!==J.Bytes)return e.push(this.readSVarint());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readSVarint());return e},readPackedBoolean:function(e){if(this.type!==J.Bytes)return e.push(this.readBoolean());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readBoolean());return e},readPackedFloat:function(e){if(this.type!==J.Bytes)return e.push(this.readFloat());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readFloat());return e},readPackedDouble:function(e){if(this.type!==J.Bytes)return e.push(this.readDouble());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readDouble());return e},readPackedFixed32:function(e){if(this.type!==J.Bytes)return e.push(this.readFixed32());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readFixed32());return e},readPackedSFixed32:function(e){if(this.type!==J.Bytes)return e.push(this.readSFixed32());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readSFixed32());return e},readPackedFixed64:function(e){if(this.type!==J.Bytes)return e.push(this.readFixed64());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readFixed64());return e},readPackedSFixed64:function(e){if(this.type!==J.Bytes)return e.push(this.readSFixed64());var t=ut(this);for(e=e||[];this.pos<t;)e.push(this.readSFixed64());return e},skip:function(e){var t=e&7;if(t===J.Varint)for(;this.buf[this.pos++]>127;);else if(t===J.Bytes)this.pos=this.readVarint()+this.pos;else if(t===J.Fixed32)this.pos+=4;else if(t===J.Fixed64)this.pos+=8;else throw new Error("Unimplemented type: "+t)},writeTag:function(e,t){this.writeVarint(e<<3|t)},realloc:function(e){for(var t=this.length||16;t<this.pos+e;)t*=2;if(t!==this.length){var r=new Uint8Array(t);r.set(this.buf),this.buf=r,this.length=t}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.subarray(0,this.length)},writeFixed32:function(e){this.realloc(4),kr(this.buf,e,this.pos),this.pos+=4},writeSFixed32:function(e){this.realloc(4),kr(this.buf,e,this.pos),this.pos+=4},writeFixed64:function(e){this.realloc(8),kr(this.buf,e&-1,this.pos),kr(this.buf,Math.floor(e*ip),this.pos+4),this.pos+=8},writeSFixed64:function(e){this.realloc(8),kr(this.buf,e&-1,this.pos),kr(this.buf,Math.floor(e*ip),this.pos+4),this.pos+=8},writeVarint:function(e){if(e=+e||0,e>268435455||e<0){Tg(e,this);return}this.realloc(4),this.buf[this.pos++]=e&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=(e>>>=7)&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=(e>>>=7)&127|(e>127?128:0),!(e<=127)&&(this.buf[this.pos++]=e>>>7&127)))},writeSVarint:function(e){this.writeVarint(e<0?-e*2-1:e*2)},writeBoolean:function(e){this.writeVarint(!!e)},writeString:function(e){e=String(e),this.realloc(e.length*4),this.pos++;var t=this.pos;this.pos=Gg(this.buf,e,this.pos);var r=this.pos-t;r>=128&&op(t,r,this),this.pos=t-1,this.writeVarint(r),this.pos+=r},writeFloat:function(e){this.realloc(4),Do.write(this.buf,e,this.pos,!0,23,4),this.pos+=4},writeDouble:function(e){this.realloc(8),Do.write(this.buf,e,this.pos,!0,52,8),this.pos+=8},writeBytes:function(e){var t=e.length;this.writeVarint(t),this.realloc(t);for(var r=0;r<t;r++)this.buf[this.pos++]=e[r]},writeRawMessage:function(e,t){this.pos++;var r=this.pos;e(t,this);var n=this.pos-r;n>=128&&op(r,n,this),this.pos=r-1,this.writeVarint(n),this.pos+=n},writeMessage:function(e,t,r){this.writeTag(e,J.Bytes),this.writeRawMessage(t,r)},writePackedVarint:function(e,t){t.length&&this.writeMessage(e,Mg,t)},writePackedSVarint:function(e,t){t.length&&this.writeMessage(e,Lg,t)},writePackedBoolean:function(e,t){t.length&&this.writeMessage(e,Bg,t)},writePackedFloat:function(e,t){t.length&&this.writeMessage(e,Dg,t)},writePackedDouble:function(e,t){t.length&&this.writeMessage(e,Vg,t)},writePackedFixed32:function(e,t){t.length&&this.writeMessage(e,zg,t)},writePackedSFixed32:function(e,t){t.length&&this.writeMessage(e,Rg,t)},writePackedFixed64:function(e,t){t.length&&this.writeMessage(e,Og,t)},writePackedSFixed64:function(e,t){t.length&&this.writeMessage(e,Ng,t)},writeBytesField:function(e,t){this.writeTag(e,J.Bytes),this.writeBytes(t)},writeFixed32Field:function(e,t){this.writeTag(e,J.Fixed32),this.writeFixed32(t)},writeSFixed32Field:function(e,t){this.writeTag(e,J.Fixed32),this.writeSFixed32(t)},writeFixed64Field:function(e,t){this.writeTag(e,J.Fixed64),this.writeFixed64(t)},writeSFixed64Field:function(e,t){this.writeTag(e,J.Fixed64),this.writeSFixed64(t)},writeVarintField:function(e,t){this.writeTag(e,J.Varint),this.writeVarint(t)},writeSVarintField:function(e,t){this.writeTag(e,J.Varint),this.writeSVarint(t)},writeStringField:function(e,t){this.writeTag(e,J.Bytes),this.writeString(t)},writeFloatField:function(e,t){this.writeTag(e,J.Fixed32),this.writeFloat(t)},writeDoubleField:function(e,t){this.writeTag(e,J.Fixed64),this.writeDouble(t)},writeBooleanField:function(e,t){this.writeVarintField(e,!!t)}};function kg(e,t,r){var n=r.buf,i,o;if(o=n[r.pos++],i=(o&112)>>4,o<128||(o=n[r.pos++],i|=(o&127)<<3,o<128)||(o=n[r.pos++],i|=(o&127)<<10,o<128)||(o=n[r.pos++],i|=(o&127)<<17,o<128)||(o=n[r.pos++],i|=(o&127)<<24,o<128)||(o=n[r.pos++],i|=(o&1)<<31,o<128))return Cr(e,i,t);throw new Error("Expected varint not more than 10 bytes")}function ut(e){return e.type===J.Bytes?e.readVarint()+e.pos:e.pos+1}function Cr(e,t,r){return r?t*4294967296+(e>>>0):(t>>>0)*4294967296+(e>>>0)}function Tg(e,t){var r,n;if(e>=0?(r=e%4294967296|0,n=e/4294967296|0):(r=~(-e%4294967296),n=~(-e/4294967296),r^4294967295?r=r+1|0:(r=0,n=n+1|0)),e>=18446744073709552e3||e<-18446744073709552e3)throw new Error("Given varint doesn't fit into 10 bytes");t.realloc(10),Eg(r,n,t),Fg(n,t)}function Eg(e,t,r){r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos++]=e&127|128,e>>>=7,r.buf[r.pos]=e&127}function Fg(e,t){var r=(e&7)<<4;t.buf[t.pos++]|=r|((e>>>=3)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127|((e>>>=7)?128:0),e&&(t.buf[t.pos++]=e&127)))))}function op(e,t,r){var n=t<=16383?1:t<=2097151?2:t<=268435455?3:Math.floor(Math.log(t)/(Math.LN2*7));r.realloc(n);for(var i=r.pos-1;i>=e;i--)r.buf[i+n]=r.buf[i]}function Mg(e,t){for(var r=0;r<e.length;r++)t.writeVarint(e[r])}function Lg(e,t){for(var r=0;r<e.length;r++)t.writeSVarint(e[r])}function Dg(e,t){for(var r=0;r<e.length;r++)t.writeFloat(e[r])}function Vg(e,t){for(var r=0;r<e.length;r++)t.writeDouble(e[r])}function Bg(e,t){for(var r=0;r<e.length;r++)t.writeBoolean(e[r])}function zg(e,t){for(var r=0;r<e.length;r++)t.writeFixed32(e[r])}function Rg(e,t){for(var r=0;r<e.length;r++)t.writeSFixed32(e[r])}function Og(e,t){for(var r=0;r<e.length;r++)t.writeFixed64(e[r])}function Ng(e,t){for(var r=0;r<e.length;r++)t.writeSFixed64(e[r])}function Vo(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16)+e[t+3]*16777216}function kr(e,t,r){e[r]=t,e[r+1]=t>>>8,e[r+2]=t>>>16,e[r+3]=t>>>24}function ap(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16)+(e[t+3]<<24)}function Ug(e,t,r){for(var n="",i=t;i<r;){var o=e[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s>r)break;var l,u,c;s===1?o<128&&(a=o):s===2?(l=e[i+1],(l&192)===128&&(a=(o&31)<<6|l&63,a<=127&&(a=null))):s===3?(l=e[i+1],u=e[i+2],(l&192)===128&&(u&192)===128&&(a=(o&15)<<12|(l&63)<<6|u&63,(a<=2047||a>=55296&&a<=57343)&&(a=null))):s===4&&(l=e[i+1],u=e[i+2],c=e[i+3],(l&192)===128&&(u&192)===128&&(c&192)===128&&(a=(o&15)<<18|(l&63)<<12|(u&63)<<6|c&63,(a<=65535||a>=1114112)&&(a=null))),a===null?(a=65533,s=1):a>65535&&(a-=65536,n+=String.fromCharCode(a>>>10&1023|55296),a=56320|a&1023),n+=String.fromCharCode(a),i+=s}return n}function $g(e,t,r){return sp.decode(e.subarray(t,r))}function Gg(e,t,r){for(var n=0,i,o;n<t.length;n++){if(i=t.charCodeAt(n),i>55295&&i<57344)if(o)if(i<56320){e[r++]=239,e[r++]=191,e[r++]=189,o=i;continue}else i=o-55296<<10|i-56320|65536,o=null;else{i>56319||n+1===t.length?(e[r++]=239,e[r++]=191,e[r++]=189):o=i;continue}else o&&(e[r++]=239,e[r++]=191,e[r++]=189,o=null);i<128?e[r++]=i:(i<2048?e[r++]=i>>6|192:(i<65536?e[r++]=i>>12|224:(e[r++]=i>>18|240,e[r++]=i>>12&63|128),e[r++]=i>>6&63|128),e[r++]=i&63|128)}return r}});var nf=we((k_,rf)=>{rf.exports=na;function na(e,t){var r=e&&e.type,n;if(r==="FeatureCollection")for(n=0;n<e.features.length;n++)na(e.features[n],t);else if(r==="GeometryCollection")for(n=0;n<e.geometries.length;n++)na(e.geometries[n],t);else if(r==="Feature")na(e.geometry,t);else if(r==="Polygon")ef(e.coordinates,t);else if(r==="MultiPolygon")for(n=0;n<e.coordinates.length;n++)ef(e.coordinates[n],t);return e}function ef(e,t){if(e.length!==0){tf(e[0],t);for(var r=1;r<e.length;r++)tf(e[r],!t)}}function tf(e,t){for(var r=0,n=0,i=0,o=e.length,a=o-1;i<o;a=i++){var s=(e[i][0]-e[a][0])*(e[a][1]+e[i][1]),l=r+s;n+=Math.abs(r)>=Math.abs(s)?r-l+s:s-l+r,r=l}r+n>=0!=!!t&&e.reverse()}});var lf=we((F_,sf)=>{"use strict";var Ix=he(),Cx=It().VectorTileFeature;sf.exports=af;function af(e,t){this.options=t||{},this.features=e,this.length=e.length}af.prototype.feature=function(e){return new oa(this.features[e],this.options.extent)};function oa(e,t){this.id=typeof e.id=="number"?e.id:void 0,this.type=e.type,this.rawGeometry=e.type===1?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=t||4096}oa.prototype.loadGeometry=function(){var e=this.rawGeometry;this.geometry=[];for(var t=0;t<e.length;t++){for(var r=e[t],n=[],i=0;i<r.length;i++)n.push(new Ix(r[i][0],r[i][1]));this.geometry.push(n)}return this.geometry};oa.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-1/0,n=1/0,i=-1/0,o=0;o<e.length;o++)for(var a=e[o],s=0;s<a.length;s++){var l=a[s];t=Math.min(t,l.x),r=Math.max(r,l.x),n=Math.min(n,l.y),i=Math.max(i,l.y)}return[t,n,r,i]};oa.prototype.toGeoJSON=Cx.prototype.toGeoJSON});var pf=we((M_,oi)=>{var kx=$n(),cf=lf();oi.exports=Us;oi.exports.fromVectorTileJs=Us;oi.exports.fromGeojsonVt=Tx;oi.exports.GeoJSONWrapper=cf;function Us(e){var t=new kx;return Ex(e,t),t.finish()}function Tx(e,t){t=t||{};var r={};for(var n in e)r[n]=new cf(e[n].features,t),r[n].name=n,r[n].version=t.version,r[n].extent=t.extent;return Us({layers:r})}function Ex(e,t){for(var r in e.layers)t.writeMessage(3,Fx,e.layers[r])}function Fx(e,t){t.writeVarintField(15,e.version||1),t.writeStringField(1,e.name||""),t.writeVarintField(5,e.extent||4096);var r,n={keys:[],values:[],keycache:{},valuecache:{}};for(r=0;r<e.length;r++)n.feature=e.feature(r),t.writeMessage(2,Mx,n);var i=n.keys;for(r=0;r<i.length;r++)t.writeStringField(3,i[r]);var o=n.values;for(r=0;r<o.length;r++)t.writeMessage(4,Vx,o[r])}function Mx(e,t){var r=e.feature;r.id!==void 0&&t.writeVarintField(1,r.id),t.writeMessage(2,Lx,e),t.writeVarintField(3,r.type),t.writeMessage(4,Dx,r)}function Lx(e,t){var r=e.feature,n=e.keys,i=e.values,o=e.keycache,a=e.valuecache;for(var s in r.properties){var l=r.properties[s],u=o[s];if(l!==null){typeof u>"u"&&(n.push(s),u=n.length-1,o[s]=u),t.writeVarint(u);var c=typeof l;c!=="string"&&c!=="boolean"&&c!=="number"&&(l=JSON.stringify(l));var p=c+":"+l,f=a[p];typeof f>"u"&&(i.push(l),f=i.length-1,a[p]=f),t.writeVarint(f)}}}function Ns(e,t){return(t<<3)+(e&7)}function uf(e){return e<<1^e>>31}function Dx(e,t){for(var r=e.loadGeometry(),n=e.type,i=0,o=0,a=r.length,s=0;s<a;s++){var l=r[s],u=1;n===1&&(u=l.length),t.writeVarint(Ns(1,u));for(var c=n===3?l.length-1:l.length,p=0;p<c;p++){p===1&&n!==1&&t.writeVarint(Ns(2,c-1));var f=l[p].x-i,y=l[p].y-o;t.writeVarint(uf(f)),t.writeVarint(uf(y)),i+=f,o+=y}n===3&&t.writeVarint(Ns(7,1))}}function Vx(e,t){var r=typeof e;r==="string"?t.writeStringField(1,e):r==="boolean"?t.writeBooleanField(7,e):r==="number"&&(e%1!==0?t.writeDoubleField(3,e):e<0?t.writeSVarintField(6,e):t.writeVarintField(5,e))}});var Vf=Z(he(),1),fl=Z(ga(),1);function yl(e){if(e<=0)return 0;if(e>=1)return 1;let t=e*e,r=t*e;return 4*(e<.5?r:3*(e-t)+r-.75)}function Bf(e,t,r,n){let i=new fl.default(e,t,r,n);return function(o){return i.solve(o)}}var Xx=Bf(.25,.1,.25,1);function rt(e,t,r){return Math.min(r,Math.max(t,e))}function ml(e,t,r){let n=r-t,i=((e-t)%n+n)%n+t;return i===t?r:i}function Ae(e,...t){for(let r of t)for(let n in r)e[n]=r[n];return e}function hl(e){return Math.log(e)/Math.LN2%1===0}function Rr(e,t,r){let n={};for(let i in e)n[i]=t.call(r||this,e[i],i,e);return n}function dl(e,t,r){let n={};for(let i in e)t.call(r||this,e[i],i,e)&&(n[i]=e[i]);return n}function tt(e){return Array.isArray(e)?e.map(tt):typeof e=="object"&&e?Rr(e,tt):e}function gl(e,t){for(let r=0;r<e.length;r++)if(t.indexOf(e[r])>=0)return!0;return!1}var pl={};function ce(e){pl[e]||(typeof console<"u"&&console.warn(e),pl[e]=!0)}function nt(e,t,r){return(r.y-e.y)*(t.x-e.x)>(t.y-e.y)*(r.x-e.x)}function xl(e){let t=0;for(let r=0,n=e.length,i=n-1,o,a;r<n;i=r++)o=e[r],a=e[i],t+=(a.x-o.x)*(o.y+a.y);return t}function Ie(){return typeof WorkerGlobalScope<"u"&&typeof self<"u"&&self instanceof WorkerGlobalScope}var xa=null;function ba(e){if(xa==null){let t=e.navigator?e.navigator.userAgent:null;xa=!!e.safari||!!(t&&(/\\b(iPad|iPhone|iPod)\\b/.test(t)||t.match("Safari")&&!t.match("Chrome")))}return xa}function Or(e){return typeof ImageBitmap<"u"&&e instanceof ImageBitmap}var Ft=class e{constructor(t,r,n){let i=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;let a=new Int32Array(this.arrayBuffer);t=a[0],r=a[1],n=a[2],this.d=r+2*n;for(let u=0;u<this.d*this.d;u++){let c=a[3+u],p=a[3+u+1];i.push(c===p?null:a.subarray(c,p))}let s=a[3+i.length],l=a[3+i.length+1];this.keys=a.subarray(s,l),this.bboxes=a.subarray(l),this.insert=this._insertReadonly}else{this.d=r+2*n;for(let a=0;a<this.d*this.d;a++)i.push([]);this.keys=[],this.bboxes=[]}this.n=r,this.extent=t,this.padding=n,this.scale=r/t,this.uid=0;let o=n/r*t;this.min=-o,this.max=t+o}insert(t,r,n,i,o){this._forEachCell(r,n,i,o,this._insertCell,this.uid++,void 0,void 0),this.keys.push(t),this.bboxes.push(r),this.bboxes.push(n),this.bboxes.push(i),this.bboxes.push(o)}_insertReadonly(){throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")}_insertCell(t,r,n,i,o,a){this.cells[o].push(a)}query(t,r,n,i,o){let a=this.min,s=this.max;if(t<=a&&r<=a&&s<=n&&s<=i&&!o)return Array.prototype.slice.call(this.keys);{let l=[],u={};return this._forEachCell(t,r,n,i,this._queryCell,l,u,o),l}}_queryCell(t,r,n,i,o,a,s,l){let u=this.cells[o];if(u!==null){let c=this.keys,p=this.bboxes;for(let f=0;f<u.length;f++){let y=u[f];if(s[y]===void 0){let m=y*4;(l?l(p[m+0],p[m+1],p[m+2],p[m+3]):t<=p[m+2]&&r<=p[m+3]&&n>=p[m+0]&&i>=p[m+1])?(s[y]=!0,a.push(c[y])):s[y]=!1}}}}_forEachCell(t,r,n,i,o,a,s,l){let u=this._convertToCellCoord(t),c=this._convertToCellCoord(r),p=this._convertToCellCoord(n),f=this._convertToCellCoord(i);for(let y=u;y<=p;y++)for(let m=c;m<=f;m++){let h=this.d*m+y;if(!(l&&!l(this._convertFromCellCoord(y),this._convertFromCellCoord(m),this._convertFromCellCoord(y+1),this._convertFromCellCoord(m+1)))&&o.call(this,t,r,n,i,h,a,s,l))return}}_convertFromCellCoord(t){return(t-this.padding)/this.scale}_convertToCellCoord(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))}toArrayBuffer(){if(this.arrayBuffer)return this.arrayBuffer;let t=this.cells,r=3+this.cells.length+1+1,n=0;for(let a=0;a<this.cells.length;a++)n+=this.cells[a].length;let i=new Int32Array(r+n+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;let o=r;for(let a=0;a<t.length;a++){let s=t[a];i[3+a]=o,i.set(s,o),o+=s.length}return i[3+t.length]=o,i.set(this.keys,o),o+=this.keys.length,i[3+t.length+1]=o,i.set(this.bboxes,o),o+=this.bboxes.length,i.buffer}static serialize(t,r){let n=t.toArrayBuffer();return r&&r.push(n),{buffer:n}}static deserialize(t){return new e(t.buffer)}};var Ll=Z(ga(),1),zf=8,Rf={version:{required:!0,type:"enum",values:[8]},name:{type:"string"},metadata:{type:"*"},center:{type:"array",value:"number"},zoom:{type:"number"},bearing:{type:"number",default:0,period:360,units:"degrees"},pitch:{type:"number",default:0,units:"degrees"},light:{type:"light"},terrain:{type:"terrain"},sources:{required:!0,type:"sources"},sprite:{type:"sprite"},glyphs:{type:"string"},transition:{type:"transition"},layers:{required:!0,type:"array",value:"layer"}},Of={"*":{type:"source"}},Nf=["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],Uf={type:{required:!0,type:"enum",values:{vector:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},attribution:{type:"string"},promoteId:{type:"promoteId"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},$f={type:{required:!0,type:"enum",values:{raster:{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},scheme:{type:"enum",values:{xyz:{},tms:{}},default:"xyz"},attribution:{type:"string"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},Gf={type:{required:!0,type:"enum",values:{"raster-dem":{}}},url:{type:"string"},tiles:{type:"array",value:"string"},bounds:{type:"array",value:"number",length:4,default:[-180,-85.051129,180,85.051129]},minzoom:{type:"number",default:0},maxzoom:{type:"number",default:22},tileSize:{type:"number",default:512,units:"pixels"},attribution:{type:"string"},encoding:{type:"enum",values:{terrarium:{},mapbox:{}},default:"mapbox"},volatile:{type:"boolean",default:!1},"*":{type:"*"}},qf={type:{required:!0,type:"enum",values:{geojson:{}}},data:{required:!0,type:"*"},maxzoom:{type:"number",default:18},attribution:{type:"string"},buffer:{type:"number",default:128,maximum:512,minimum:0},filter:{type:"*"},tolerance:{type:"number",default:.375},cluster:{type:"boolean",default:!1},clusterRadius:{type:"number",default:50,minimum:0},clusterMaxZoom:{type:"number"},clusterMinPoints:{type:"number"},clusterProperties:{type:"*"},lineMetrics:{type:"boolean",default:!1},generateId:{type:"boolean",default:!1},promoteId:{type:"promoteId"}},jf={type:{required:!0,type:"enum",values:{video:{}}},urls:{required:!0,type:"array",value:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Zf={type:{required:!0,type:"enum",values:{image:{}}},url:{required:!0,type:"string"},coordinates:{required:!0,type:"array",length:4,value:{type:"array",length:2,value:"number"}}},Jf={id:{type:"string",required:!0},type:{type:"enum",values:{fill:{},line:{},symbol:{},circle:{},heatmap:{},"fill-extrusion":{},raster:{},hillshade:{},background:{}},required:!0},metadata:{type:"*"},source:{type:"string"},"source-layer":{type:"string"},minzoom:{type:"number",minimum:0,maximum:24},maxzoom:{type:"number",minimum:0,maximum:24},filter:{type:"filter"},layout:{type:"layout"},paint:{type:"paint"}},Wf=["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background"],Hf={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Kf={"fill-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Yf={"circle-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Xf={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},Qf={"line-cap":{type:"enum",values:{butt:{},round:{},square:{}},default:"butt",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-join":{type:"enum",values:{bevel:{},round:{},miter:{}},default:"miter",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{type:"number",default:2,requires:[{"line-join":"miter"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-round-limit":{type:"number",default:1.05,requires:[{"line-join":"round"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},ey={"symbol-placement":{type:"enum",values:{point:{},line:{},"line-center":{}},default:"point",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-spacing":{type:"number",default:250,minimum:1,units:"pixels",requires:[{"symbol-placement":"line"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{type:"boolean",default:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{type:"number",expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{type:"enum",values:{auto:{},"viewport-y":{},source:{}},default:"auto",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{type:"boolean",default:!1,requires:["icon-image",{"!":"icon-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{type:"boolean",default:!1,requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-optional":{type:"boolean",default:!1,requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-size":{type:"number",default:1,minimum:0,units:"factor of the original icon size",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{type:"enum",values:{none:{},width:{},height:{},both:{}},default:"none",requires:["icon-image","text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{type:"array",value:"number",length:4,default:[0,0,0,0],units:"pixels",requires:["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-image":{type:"resolvedImage",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{type:"padding",default:[2],units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-keep-upright":{type:"boolean",default:!1,requires:["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"icon-offset":{type:"array",value:"number",length:2,default:[0,0],requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{type:"enum",values:{map:{},viewport:{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{type:"enum",values:{map:{},viewport:{},"viewport-glyph":{},auto:{}},default:"auto",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-field":{type:"formatted",default:"",tokens:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-font":{type:"array",value:"string",default:["Open Sans Regular","Arial Unicode MS Regular"],requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-size":{type:"number",default:16,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{type:"number",default:10,minimum:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{type:"number",default:1.2,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-letter-spacing":{type:"number",default:0,units:"ems",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-justify":{type:"enum",values:{auto:{},left:{},center:{},right:{}},default:"center",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{type:"number",units:"ems",default:0,requires:["text-field"],"property-type":"data-driven",expression:{interpolated:!0,parameters:["zoom","feature"]}},"text-variable-anchor":{type:"array",value:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-variable-anchor-offset":{type:"variableAnchorOffsetCollection",requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-anchor":{type:"enum",values:{center:{},left:{},right:{},top:{},bottom:{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},default:"center",requires:["text-field",{"!":"text-variable-anchor"}],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{type:"number",default:45,units:"degrees",requires:["text-field",{"symbol-placement":["line","line-center"]}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-writing-mode":{type:"array",value:"enum",values:{horizontal:{},vertical:{}},requires:["text-field",{"symbol-placement":["point"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-rotate":{type:"number",default:0,period:360,units:"degrees",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-padding":{type:"number",default:2,minimum:0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-keep-upright":{type:"boolean",default:!0,requires:["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-transform":{type:"enum",values:{none:{},uppercase:{},lowercase:{}},default:"none",requires:["text-field"],expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-offset":{type:"array",value:"number",units:"ems",length:2,default:[0,0],requires:["text-field",{"!":"text-radial-offset"}],expression:{interpolated:!0,parameters:["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{type:"boolean",default:!1,requires:["text-field",{"!":"text-overlap"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-overlap":{type:"enum",values:{never:{},always:{},cooperative:{}},requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{type:"boolean",default:!1,requires:["text-field"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-optional":{type:"boolean",default:!1,requires:["text-field","icon-image"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},ty={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},ry={visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},ny={type:"array",value:"*"},iy={type:"enum",values:{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},in:{},"!in":{},all:{},any:{},none:{},has:{},"!has":{},within:{}}},oy={type:"enum",values:{Point:{},LineString:{},Polygon:{}}},ay={type:"array",minimum:0,maximum:24,value:["number","color"],length:2},sy={type:"array",value:"*",minimum:1},ly={anchor:{type:"enum",default:"viewport",values:{map:{},viewport:{}},"property-type":"data-constant",transition:!1,expression:{interpolated:!1,parameters:["zoom"]}},position:{type:"array",default:[1.15,210,30],length:3,value:"number","property-type":"data-constant",transition:!0,expression:{interpolated:!0,parameters:["zoom"]}},color:{type:"color","property-type":"data-constant",default:"#ffffff",expression:{interpolated:!0,parameters:["zoom"]},transition:!0},intensity:{type:"number","property-type":"data-constant",default:.5,minimum:0,maximum:1,expression:{interpolated:!0,parameters:["zoom"]},transition:!0}},uy={source:{type:"string",required:!0},exaggeration:{type:"number",minimum:0,default:1}},cy=["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background"],py={"fill-antialias":{type:"boolean",default:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{type:"color",transition:!0,requires:[{"!":"fill-pattern"},{"fill-antialias":!0}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"}},fy={"line-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"line-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["line-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"line-width":{type:"number",default:1,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{type:"number",default:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{type:"array",value:"number",minimum:0,transition:!0,units:"line widths",requires:[{"!":"line-pattern"}],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"line-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"line-gradient":{type:"color",transition:!1,requires:[{"!":"line-dasharray"},{"!":"line-pattern"},{source:"geojson",has:{lineMetrics:!0}}],expression:{interpolated:!0,parameters:["line-progress"]},"property-type":"color-ramp"}},yy={"circle-radius":{type:"number",default:5,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{type:"number",default:0,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["circle-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{type:"enum",values:{map:{},viewport:{}},default:"map",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"}},my={"heatmap-radius":{type:"number",default:30,minimum:1,transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{type:"number",default:1,minimum:0,transition:!1,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{type:"number",default:1,minimum:0,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"heatmap-color":{type:"color",default:["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",.1,"royalblue",.3,"cyan",.5,"lime",.7,"yellow",1,"red"],transition:!1,expression:{interpolated:!0,parameters:["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},hy={"icon-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{type:"color",default:"#000000",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["icon-image"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["icon-image","icon-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"text-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{type:"color",default:"#000000",transition:!0,overridable:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{type:"color",default:"rgba(0, 0, 0, 0)",transition:!0,requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{type:"number",default:0,minimum:0,transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",requires:["text-field"],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["text-field","text-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},dy={"raster-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{type:"number",default:0,period:360,transition:!0,units:"degrees",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{type:"number",default:0,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-saturation":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-contrast":{type:"number",default:0,minimum:-1,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"raster-resampling":{type:"enum",values:{linear:{},nearest:{}},default:"linear",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{type:"number",default:300,minimum:0,transition:!1,units:"milliseconds",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},gy={"hillshade-illumination-direction":{type:"number",default:335,minimum:0,maximum:359,transition:!1,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{type:"enum",values:{map:{},viewport:{}},default:"viewport",expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{type:"number",default:.5,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{type:"color",default:"#FFFFFF",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{type:"color",default:"#000000",transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},xy={"background-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"background-pattern"}],expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"background-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"cross-faded"},"background-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"}},by={duration:{type:"number",default:300,minimum:0,units:"milliseconds"},delay:{type:"number",default:0,minimum:0,units:"milliseconds"}},vy={"*":{type:"string"}},S={$version:zf,$root:Rf,sources:Of,source:Nf,source_vector:Uf,source_raster:$f,source_raster_dem:Gf,source_geojson:qf,source_video:jf,source_image:Zf,layer:Jf,layout:Wf,layout_background:Hf,layout_fill:Kf,layout_circle:Yf,layout_heatmap:Xf,"layout_fill-extrusion":{visibility:{type:"enum",values:{visible:{},none:{}},default:"visible","property-type":"constant"}},layout_line:Qf,layout_symbol:ey,layout_raster:ty,layout_hillshade:ry,filter:ny,filter_operator:iy,geometry_type:oy,function:{expression:{type:"expression"},stops:{type:"array",value:"function_stop"},base:{type:"number",default:1,minimum:0},property:{type:"string",default:"$zoom"},type:{type:"enum",values:{identity:{},exponential:{},interval:{},categorical:{}},default:"exponential"},colorSpace:{type:"enum",values:{rgb:{},lab:{},hcl:{}},default:"rgb"},default:{type:"*",required:!1}},function_stop:ay,expression:sy,light:ly,terrain:uy,paint:cy,paint_fill:py,"paint_fill-extrusion":{"fill-extrusion-opacity":{type:"number",default:1,minimum:0,maximum:1,transition:!0,expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{type:"color",default:"#000000",transition:!0,requires:[{"!":"fill-extrusion-pattern"}],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{type:"array",value:"number",length:2,default:[0,0],transition:!0,units:"pixels",expression:{interpolated:!0,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{type:"enum",values:{map:{},viewport:{}},default:"map",requires:["fill-extrusion-translate"],expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{type:"resolvedImage",transition:!0,expression:{interpolated:!1,parameters:["zoom","feature"]},"property-type":"cross-faded-data-driven"},"fill-extrusion-height":{type:"number",default:0,minimum:0,units:"meters",transition:!0,expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{type:"number",default:0,minimum:0,units:"meters",transition:!0,requires:["fill-extrusion-height"],expression:{interpolated:!0,parameters:["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{type:"boolean",default:!0,transition:!1,expression:{interpolated:!1,parameters:["zoom"]},"property-type":"data-constant"}},paint_line:fy,paint_circle:yy,paint_heatmap:my,paint_symbol:hy,paint_raster:dy,paint_hillshade:gy,paint_background:xy,transition:by,"property-type":{"data-driven":{type:"property-type"},"cross-faded":{type:"property-type"},"cross-faded-data-driven":{type:"property-type"},"color-ramp":{type:"property-type"},"data-constant":{type:"property-type"},constant:{type:"property-type"}},promoteId:vy},Py=["type","source","source-layer","minzoom","maxzoom","filter","layout"];var D=class{constructor(t,r,n,i){this.message=(t?"".concat(t,": "):"")+n,i&&(this.identifier=i),r!=null&&r.__line__&&(this.line=r.__line__)}};function sr(e,...t){for(let r of t)for(let n in r)e[n]=r[n];return e}var Ve=class extends Error{constructor(t,r){super(r),this.message=r,this.key=t}},Ca=class e{constructor(t,r=[]){this.parent=t,this.bindings={};for(let[n,i]of r)this.bindings[n]=i}concat(t){return new e(this,t)}get(t){if(this.bindings[t])return this.bindings[t];if(this.parent)return this.parent.get(t);throw new Error("".concat(t," not found in scope."))}has(t){return this.bindings[t]?!0:this.parent?this.parent.has(t):!1}},cr={kind:"null"},L={kind:"number"},G={kind:"string"},U={kind:"boolean"},ze={kind:"color"},or={kind:"object"},$={kind:"value"},Sy={kind:"error"},Fi={kind:"collator"},pr={kind:"formatted"},Mi={kind:"padding"},Xr={kind:"resolvedImage"},Li={kind:"variableAnchorOffsetCollection"};function Fe(e,t){return{kind:"array",itemType:e,N:t}}function ne(e){if(e.kind==="array"){let t=ne(e.itemType);return typeof e.N=="number"?"array<".concat(t,", ").concat(e.N,">"):e.itemType.kind==="value"?"array":"array<".concat(t,">")}else return e.kind}var wy=[cr,L,G,U,ze,pr,or,Fe($),Mi,Xr,Li];function Gr(e,t){if(t.kind==="error")return null;if(e.kind==="array"){if(t.kind==="array"&&(t.N===0&&t.itemType.kind==="value"||!Gr(e.itemType,t.itemType))&&(typeof e.N!="number"||e.N===t.N))return null}else{if(e.kind===t.kind)return null;if(e.kind==="value"){for(let r of wy)if(!Gr(r,t))return null}}return"Expected ".concat(ne(e)," but found ").concat(ne(t)," instead.")}function Oa(e,t){return t.some(r=>r.kind===e.kind)}function qr(e,t){return t.some(r=>r==="null"?e===null:r==="array"?Array.isArray(e):r==="object"?e&&!Array.isArray(e)&&typeof e=="object":r===typeof e)}function Nr(e,t){return e.kind==="array"&&t.kind==="array"?e.itemType.kind===t.itemType.kind&&typeof e.N=="number":e.kind===t.kind}var Dl=.96422,Vl=1,Bl=.82521,zl=4/29,ar=6/29,Rl=3*ar*ar,Ay=ar*ar*ar,_y=Math.PI/180,Iy=180/Math.PI;function Ol(e){return e=e%360,e<0&&(e+=360),e}function Nl([e,t,r,n]){e=va(e),t=va(t),r=va(r);let i,o,a=Pa((.2225045*e+.7168786*t+.0606169*r)/Vl);e===t&&t===r?i=o=a:(i=Pa((.4360747*e+.3850649*t+.1430804*r)/Dl),o=Pa((.0139322*e+.0971045*t+.7141733*r)/Bl));let s=116*a-16;return[s<0?0:s,500*(i-a),200*(a-o),n]}function va(e){return e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4)}function Pa(e){return e>Ay?Math.pow(e,1/3):e/Rl+zl}function Ul([e,t,r,n]){let i=(e+16)/116,o=isNaN(t)?i:i+t/500,a=isNaN(r)?i:i-r/200;return i=Vl*wa(i),o=Dl*wa(o),a=Bl*wa(a),[Sa(3.1338561*o-1.6168667*i-.4906146*a),Sa(-.9787684*o+1.9161415*i+.033454*a),Sa(.0719453*o-.2289914*i+1.4052427*a),n]}function Sa(e){return e=e<=.00304?12.92*e:1.055*Math.pow(e,1/2.4)-.055,e<0?0:e>1?1:e}function wa(e){return e>ar?e*e*e:Rl*(e-zl)}function Cy(e){let[t,r,n,i]=Nl(e),o=Math.sqrt(r*r+n*n);return[Math.round(o*1e4)?Ol(Math.atan2(n,r)*Iy):NaN,o,t,i]}function ky([e,t,r,n]){return e=isNaN(e)?0:e*_y,Ul([r,Math.cos(e)*t,Math.sin(e)*t,n])}function Ty([e,t,r,n]){e=Ol(e),t/=100,r/=100;function i(o){let a=(o+e/30)%12,s=t*Math.min(r,1-r);return r-s*Math.max(-1,Math.min(a-3,9-a,1))}return[i(0),i(8),i(4),n]}function Ey(e){if(e=e.toLowerCase().trim(),e==="transparent")return[0,0,0,0];let t=Fy[e];if(t){let[i,o,a]=t;return[i/255,o/255,a/255,1]}if(e.startsWith("#")&&/^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e)){let o=e.length<6?1:2,a=1;return[di(e.slice(a,a+=o)),di(e.slice(a,a+=o)),di(e.slice(a,a+=o)),di(e.slice(a,a+o)||"ff")]}if(e.startsWith("rgb")){let i=/^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,o=e.match(i);if(o){let[a,s,l,u,c,p,f,y,m,h,d,g]=o,v=[u||" ",f||" ",h].join("");if(v==="  "||v==="  /"||v===",,"||v===",,,"){let b=[l,p,m].join(""),x=b==="%%%"?100:b===""?255:0;if(x){let P=[nr(+s/x,0,1),nr(+c/x,0,1),nr(+y/x,0,1),d?bl(+d,g):1];if(vl(P))return P}}return}}let r=/^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,n=e.match(r);if(n){let[i,o,a,s,l,u,c,p,f]=n,y=[a||" ",l||" ",c].join("");if(y==="  "||y==="  /"||y===",,"||y===",,,"){let m=[+o,nr(+s,0,100),nr(+u,0,100),p?bl(+p,f):1];if(vl(m))return Ty(m)}}}function di(e){return parseInt(e.padEnd(2,e),16)/255}function bl(e,t){return nr(t?e/100:e,0,1)}function nr(e,t,r){return Math.min(Math.max(t,e),r)}function vl(e){return!e.some(Number.isNaN)}var Fy={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]},W=class e{constructor(t,r,n,i=1,o=!0){this.r=t,this.g=r,this.b=n,this.a=i,o||(this.r*=i,this.g*=i,this.b*=i,i||this.overwriteGetter("rgb",[t,r,n,i]))}static parse(t){if(t instanceof e)return t;if(typeof t!="string")return;let r=Ey(t);if(r)return new e(...r,!1)}get rgb(){let{r:t,g:r,b:n,a:i}=this,o=i||1/0;return this.overwriteGetter("rgb",[t/o,r/o,n/o,i])}get hcl(){return this.overwriteGetter("hcl",Cy(this.rgb))}get lab(){return this.overwriteGetter("lab",Nl(this.rgb))}overwriteGetter(t,r){return Object.defineProperty(this,t,{value:r}),r}toString(){let[t,r,n,i]=this.rgb;return"rgba(".concat([t,r,n].map(o=>Math.round(o*255)).join(","),",").concat(i,")")}};W.black=new W(0,0,0,1);W.white=new W(1,1,1,1);W.transparent=new W(0,0,0,0);W.red=new W(1,0,0,1);var jr=class{constructor(t,r,n){t?this.sensitivity=r?"variant":"case":this.sensitivity=r?"accent":"base",this.locale=n,this.collator=new Intl.Collator(this.locale?this.locale:[],{sensitivity:this.sensitivity,usage:"search"})}compare(t,r){return this.collator.compare(t,r)}resolvedLocale(){return new Intl.Collator(this.locale?this.locale:[]).resolvedOptions().locale}},Zr=class{constructor(t,r,n,i,o){this.text=t,this.image=r,this.scale=n,this.fontStack=i,this.textColor=o}},Me=class e{constructor(t){this.sections=t}static fromString(t){return new e([new Zr(t,null,null,null,null)])}isEmpty(){return this.sections.length===0?!0:!this.sections.some(t=>t.text.length!==0||t.image&&t.image.name.length!==0)}static factory(t){return t instanceof e?t:e.fromString(t)}toString(){return this.sections.length===0?"":this.sections.map(t=>t.text).join("")}},je=class e{constructor(t){this.values=t.slice()}static parse(t){if(t instanceof e)return t;if(typeof t=="number")return new e([t,t,t,t]);if(Array.isArray(t)&&!(t.length<1||t.length>4)){for(let r of t)if(typeof r!="number")return;switch(t.length){case 1:t=[t[0],t[0],t[0],t[0]];break;case 2:t=[t[0],t[1],t[0],t[1]];break;case 3:t=[t[0],t[1],t[2],t[1]];break}return new e(t)}}toString(){return JSON.stringify(this.values)}},My=new Set(["center","left","right","top","bottom","top-left","top-right","bottom-left","bottom-right"]),it=class e{constructor(t){this.values=t.slice()}static parse(t){if(t instanceof e)return t;if(!(!Array.isArray(t)||t.length<1||t.length%2!==0)){for(let r=0;r<t.length;r+=2){let n=t[r],i=t[r+1];if(typeof n!="string"||!My.has(n)||!Array.isArray(i)||i.length!==2||typeof i[0]!="number"||typeof i[1]!="number")return}return new e(t)}}toString(){return JSON.stringify(this.values)}},Ce=class e{constructor(t){this.name=t.name,this.available=t.available}toString(){return this.name}static fromString(t){return t?new e({name:t,available:!1}):null}};function $l(e,t,r,n){if(!(typeof e=="number"&&e>=0&&e<=255&&typeof t=="number"&&t>=0&&t<=255&&typeof r=="number"&&r>=0&&r<=255)){let i=typeof n=="number"?[e,t,r,n]:[e,t,r];return"Invalid rgba value [".concat(i.join(", "),"]: 'r', 'g', and 'b' must be between 0 and 255.")}return typeof n>"u"||typeof n=="number"&&n>=0&&n<=1?null:"Invalid rgba value [".concat([e,t,r,n].join(", "),"]: 'a' must be between 0 and 1.")}function vi(e){if(e===null||typeof e=="string"||typeof e=="boolean"||typeof e=="number"||e instanceof W||e instanceof jr||e instanceof Me||e instanceof je||e instanceof it||e instanceof Ce)return!0;if(Array.isArray(e)){for(let t of e)if(!vi(t))return!1;return!0}else if(typeof e=="object"){for(let t in e)if(!vi(e[t]))return!1;return!0}else return!1}function fe(e){if(e===null)return cr;if(typeof e=="string")return G;if(typeof e=="boolean")return U;if(typeof e=="number")return L;if(e instanceof W)return ze;if(e instanceof jr)return Fi;if(e instanceof Me)return pr;if(e instanceof je)return Mi;if(e instanceof it)return Li;if(e instanceof Ce)return Xr;if(Array.isArray(e)){let t=e.length,r;for(let n of e){let i=fe(n);if(!r)r=i;else{if(r===i)continue;r=$;break}}return Fe(r||$,t)}else return or}function Ur(e){let t=typeof e;return e===null?"":t==="string"||t==="number"||t==="boolean"?String(e):e instanceof W||e instanceof Me||e instanceof je||e instanceof it||e instanceof Ce?e.toString():JSON.stringify(e)}var mt=class e{constructor(t,r){this.type=t,this.value=r}static parse(t,r){if(t.length!==2)return r.error("'literal' expression requires exactly one argument, but found ".concat(t.length-1," instead."));if(!vi(t[1]))return r.error("invalid value");let n=t[1],i=fe(n),o=r.expectedType;return i.kind==="array"&&i.N===0&&o&&o.kind==="array"&&(typeof o.N!="number"||o.N===0)&&(i=o),new e(i,n)}evaluate(){return this.value}eachChild(){}outputDefined(){return!0}},oe=class{constructor(t){this.name="ExpressionEvaluationError",this.message=t}toJSON(){return this.message}},gi={string:G,number:L,boolean:U,object:or},Ge=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=1,i,o=t[0];if(o==="array"){let s;if(t.length>2){let u=t[1];if(typeof u!="string"||!(u in gi)||u==="object")return r.error('The item type argument of "array" must be one of string, number, boolean',1);s=gi[u],n++}else s=$;let l;if(t.length>3){if(t[2]!==null&&(typeof t[2]!="number"||t[2]<0||t[2]!==Math.floor(t[2])))return r.error('The length argument to "array" must be a positive integer literal',2);l=t[2],n++}i=Fe(s,l)}else{if(!gi[o])throw new Error("Types doesn't contain name = ".concat(o));i=gi[o]}let a=[];for(;n<t.length;n++){let s=r.parse(t[n],n,$);if(!s)return null;a.push(s)}return new e(i,a)}evaluate(t){for(let r=0;r<this.args.length;r++){let n=this.args[r].evaluate(t);if(Gr(this.type,fe(n))){if(r===this.args.length-1)throw new oe("Expected value to be of type ".concat(ne(this.type),", but found ").concat(ne(fe(n))," instead."))}else return n}throw new Error}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Pl={"to-boolean":U,"to-color":ze,"to-number":L,"to-string":G},ft=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=t[0];if(!Pl[n])throw new Error("Can't parse ".concat(n," as it is not part of the known types"));if((n==="to-boolean"||n==="to-string")&&t.length!==2)return r.error("Expected one argument.");let i=Pl[n],o=[];for(let a=1;a<t.length;a++){let s=r.parse(t[a],a,$);if(!s)return null;o.push(s)}return new e(i,o)}evaluate(t){switch(this.type.kind){case"boolean":return!!this.args[0].evaluate(t);case"color":{let r,n;for(let i of this.args){if(r=i.evaluate(t),n=null,r instanceof W)return r;if(typeof r=="string"){let o=t.parseColor(r);if(o)return o}else if(Array.isArray(r)&&(r.length<3||r.length>4?n="Invalid rbga value ".concat(JSON.stringify(r),": expected an array containing either three or four numeric values."):n=$l(r[0],r[1],r[2],r[3]),!n))return new W(r[0]/255,r[1]/255,r[2]/255,r[3])}throw new oe(n||"Could not parse color from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"padding":{let r;for(let n of this.args){r=n.evaluate(t);let i=je.parse(r);if(i)return i}throw new oe("Could not parse padding from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"variableAnchorOffsetCollection":{let r;for(let n of this.args){r=n.evaluate(t);let i=it.parse(r);if(i)return i}throw new oe("Could not parse variableAnchorOffsetCollection from value '".concat(typeof r=="string"?r:JSON.stringify(r),"'"))}case"number":{let r=null;for(let n of this.args){if(r=n.evaluate(t),r===null)return 0;let i=Number(r);if(!isNaN(i))return i}throw new oe("Could not convert ".concat(JSON.stringify(r)," to number."))}case"formatted":return Me.fromString(Ur(this.args[0].evaluate(t)));case"resolvedImage":return Ce.fromString(Ur(this.args[0].evaluate(t)));default:return Ur(this.args[0].evaluate(t))}}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Ly=["Unknown","Point","LineString","Polygon"],Pi=class{constructor(){this.globals=null,this.feature=null,this.featureState=null,this.formattedSection=null,this._parseColorCache={},this.availableImages=null,this.canonical=null}id(){return this.feature&&"id"in this.feature?this.feature.id:null}geometryType(){return this.feature?typeof this.feature.type=="number"?Ly[this.feature.type]:this.feature.type:null}geometry(){return this.feature&&"geometry"in this.feature?this.feature.geometry:null}canonicalID(){return this.canonical}properties(){return this.feature&&this.feature.properties||{}}parseColor(t){let r=this._parseColorCache[t];return r||(r=this._parseColorCache[t]=W.parse(t)),r}},Si=class e{constructor(t,r,n=[],i,o=new Ca,a=[]){this.registry=t,this.path=n,this.key=n.map(s=>"[".concat(s,"]")).join(""),this.scope=o,this.errors=a,this.expectedType=i,this._isConstant=r}parse(t,r,n,i,o={}){return r?this.concat(r,n,i)._parse(t,o):this._parse(t,o)}_parse(t,r){(t===null||typeof t=="string"||typeof t=="boolean"||typeof t=="number")&&(t=["literal",t]);function n(i,o,a){return a==="assert"?new Ge(o,[i]):a==="coerce"?new ft(o,[i]):i}if(Array.isArray(t)){if(t.length===0)return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');let i=t[0];if(typeof i!="string")return this.error("Expression name must be a string, but found ".concat(typeof i,' instead. If you wanted a literal array, use ["literal", [...]].'),0),null;let o=this.registry[i];if(o){let a=o.parse(t,this);if(!a)return null;if(this.expectedType){let s=this.expectedType,l=a.type;if((s.kind==="string"||s.kind==="number"||s.kind==="boolean"||s.kind==="object"||s.kind==="array")&&l.kind==="value")a=n(a,s,r.typeAnnotation||"assert");else if((s.kind==="color"||s.kind==="formatted"||s.kind==="resolvedImage")&&(l.kind==="value"||l.kind==="string"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="padding"&&(l.kind==="value"||l.kind==="number"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(s.kind==="variableAnchorOffsetCollection"&&(l.kind==="value"||l.kind==="array"))a=n(a,s,r.typeAnnotation||"coerce");else if(this.checkSubtype(s,l))return null}if(!(a instanceof mt)&&a.type.kind!=="resolvedImage"&&this._isConstant(a)){let s=new Pi;try{a=new mt(a.type,a.evaluate(s))}catch(l){return this.error(l.message),null}}return a}return this.error('Unknown expression "'.concat(i,'". If you wanted a literal array, use ["literal", [...]].'),0)}else return typeof t>"u"?this.error("'undefined' value invalid. Use null instead."):typeof t=="object"?this.error('Bare objects invalid. Use ["literal", {...}] instead.'):this.error("Expected an array, but found ".concat(typeof t," instead."))}concat(t,r,n){let i=typeof t=="number"?this.path.concat(t):this.path,o=n?this.scope.concat(n):this.scope;return new e(this.registry,this._isConstant,i,r||null,o,this.errors)}error(t,...r){let n="".concat(this.key).concat(r.map(i=>"[".concat(i,"]")).join(""));this.errors.push(new Ve(n,t))}checkSubtype(t,r){let n=Gr(t,r);return n&&this.error(n),n}},wi=class e{constructor(t,r,n){this.type=Fi,this.locale=n,this.caseSensitive=t,this.diacriticSensitive=r}static parse(t,r){if(t.length!==2)return r.error("Expected one argument.");let n=t[1];if(typeof n!="object"||Array.isArray(n))return r.error("Collator options argument must be an object.");let i=r.parse(n["case-sensitive"]===void 0?!1:n["case-sensitive"],1,U);if(!i)return null;let o=r.parse(n["diacritic-sensitive"]===void 0?!1:n["diacritic-sensitive"],1,U);if(!o)return null;let a=null;return n.locale&&(a=r.parse(n.locale,1,G),!a)?null:new e(i,o,a)}evaluate(t){return new jr(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale?this.locale.evaluate(t):null)}eachChild(t){t(this.caseSensitive),t(this.diacriticSensitive),this.locale&&t(this.locale)}outputDefined(){return!1}},yt=8192;function Na(e,t){e[0]=Math.min(e[0],t[0]),e[1]=Math.min(e[1],t[1]),e[2]=Math.max(e[2],t[0]),e[3]=Math.max(e[3],t[1])}function Dy(e){return(180+e)/360}function Vy(e){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+e*Math.PI/360)))/360}function Ai(e,t){return!(e[0]<=t[0]||e[2]>=t[2]||e[1]<=t[1]||e[3]>=t[3])}function By(e,t){let r=Dy(e[0]),n=Vy(e[1]),i=Math.pow(2,t.z);return[Math.round(r*i*yt),Math.round(n*i*yt)]}function zy(e,t,r){let n=e[0]-t[0],i=e[1]-t[1],o=e[0]-r[0],a=e[1]-r[1];return n*a-o*i===0&&n*o<=0&&i*a<=0}function Ry(e,t,r){return t[1]>e[1]!=r[1]>e[1]&&e[0]<(r[0]-t[0])*(e[1]-t[1])/(r[1]-t[1])+t[0]}function Ua(e,t){let r=!1;for(let n=0,i=t.length;n<i;n++){let o=t[n];for(let a=0,s=o.length;a<s-1;a++){if(zy(e,o[a],o[a+1]))return!1;Ry(e,o[a],o[a+1])&&(r=!r)}}return r}function Oy(e,t){for(let r=0;r<t.length;r++)if(Ua(e,t[r]))return!0;return!1}function Ny(e,t){return e[0]*t[1]-e[1]*t[0]}function Sl(e,t,r,n){let i=e[0]-r[0],o=e[1]-r[1],a=t[0]-r[0],s=t[1]-r[1],l=n[0]-r[0],u=n[1]-r[1],c=i*u-l*o,p=a*u-l*s;return c>0&&p<0||c<0&&p>0}function Uy(e,t,r,n){let i=[t[0]-e[0],t[1]-e[1]],o=[n[0]-r[0],n[1]-r[1]];return Ny(o,i)===0?!1:!!(Sl(e,t,r,n)&&Sl(r,n,e,t))}function $y(e,t,r){for(let n of r)for(let i=0;i<n.length-1;++i)if(Uy(e,t,n[i],n[i+1]))return!0;return!1}function Gl(e,t){for(let r=0;r<e.length;++r)if(!Ua(e[r],t))return!1;for(let r=0;r<e.length-1;++r)if($y(e[r],e[r+1],t))return!1;return!0}function Gy(e,t){for(let r=0;r<t.length;r++)if(Gl(e,t[r]))return!0;return!1}function $a(e,t,r){let n=[];for(let i=0;i<e.length;i++){let o=[];for(let a=0;a<e[i].length;a++){let s=By(e[i][a],r);Na(t,s),o.push(s)}n.push(o)}return n}function ql(e,t,r){let n=[];for(let i=0;i<e.length;i++){let o=$a(e[i],t,r);n.push(o)}return n}function jl(e,t,r,n){if(e[0]<r[0]||e[0]>r[2]){let i=n*.5,o=e[0]-r[0]>i?-n:r[0]-e[0]>i?n:0;o===0&&(o=e[0]-r[2]>i?-n:r[2]-e[0]>i?n:0),e[0]+=o}Na(t,e)}function qy(e){e[0]=e[1]=1/0,e[2]=e[3]=-1/0}function wl(e,t,r,n){let i=Math.pow(2,n.z)*yt,o=[n.x*yt,n.y*yt],a=[];for(let s of e)for(let l of s){let u=[l.x+o[0],l.y+o[1]];jl(u,t,r,i),a.push(u)}return a}function Al(e,t,r,n){let i=Math.pow(2,n.z)*yt,o=[n.x*yt,n.y*yt],a=[];for(let s of e){let l=[];for(let u of s){let c=[u.x+o[0],u.y+o[1]];Na(t,c),l.push(c)}a.push(l)}if(t[2]-t[0]<=i/2){qy(t);for(let s of a)for(let l of s)jl(l,t,r,i)}return a}function jy(e,t){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=e.canonicalID();if(t.type==="Polygon"){let o=$a(t.coordinates,n,i),a=wl(e.geometry(),r,n,i);if(!Ai(r,n))return!1;for(let s of a)if(!Ua(s,o))return!1}if(t.type==="MultiPolygon"){let o=ql(t.coordinates,n,i),a=wl(e.geometry(),r,n,i);if(!Ai(r,n))return!1;for(let s of a)if(!Oy(s,o))return!1}return!0}function Zy(e,t){let r=[1/0,1/0,-1/0,-1/0],n=[1/0,1/0,-1/0,-1/0],i=e.canonicalID();if(t.type==="Polygon"){let o=$a(t.coordinates,n,i),a=Al(e.geometry(),r,n,i);if(!Ai(r,n))return!1;for(let s of a)if(!Gl(s,o))return!1}if(t.type==="MultiPolygon"){let o=ql(t.coordinates,n,i),a=Al(e.geometry(),r,n,i);if(!Ai(r,n))return!1;for(let s of a)if(!Gy(s,o))return!1}return!0}var Jr=class e{constructor(t,r){this.type=U,this.geojson=t,this.geometries=r}static parse(t,r){if(t.length!==2)return r.error("'within' expression requires exactly one argument, but found ".concat(t.length-1," instead."));if(vi(t[1])){let n=t[1];if(n.type==="FeatureCollection")for(let i=0;i<n.features.length;++i){let o=n.features[i].geometry.type;if(o==="Polygon"||o==="MultiPolygon")return new e(n,n.features[i].geometry)}else if(n.type==="Feature"){let i=n.geometry.type;if(i==="Polygon"||i==="MultiPolygon")return new e(n,n.geometry)}else if(n.type==="Polygon"||n.type==="MultiPolygon")return new e(n,n)}return r.error("'within' expression requires valid geojson object that contains polygon geometry type.")}evaluate(t){if(t.geometry()!=null&&t.canonicalID()!=null){if(t.geometryType()==="Point")return jy(t,this.geometries);if(t.geometryType()==="LineString")return Zy(t,this.geometries)}return!1}eachChild(){}outputDefined(){return!0}},_i=class e{constructor(t,r){this.type=r.type,this.name=t,this.boundExpression=r}static parse(t,r){if(t.length!==2||typeof t[1]!="string")return r.error("'var' expression requires exactly one string literal argument.");let n=t[1];return r.scope.has(n)?new e(n,r.scope.get(n)):r.error('Unknown variable "'.concat(n,'". Make sure "').concat(n,'" has been bound in an enclosing "let" expression before using it.'),1)}evaluate(t){return this.boundExpression.evaluate(t)}eachChild(){}outputDefined(){return!1}},Ye=class e{constructor(t,r,n,i){this.name=t,this.type=r,this._evaluate=n,this.args=i}evaluate(t){return this._evaluate(t,this.args)}eachChild(t){this.args.forEach(t)}outputDefined(){return!1}static parse(t,r){let n=t[0],i=e.definitions[n];if(!i)return r.error('Unknown expression "'.concat(n,'". If you wanted a literal array, use ["literal", [...]].'),0);let o=Array.isArray(i)?i[0]:i.type,a=Array.isArray(i)?[[i[1],i[2]]]:i.overloads,s=a.filter(([u])=>!Array.isArray(u)||u.length===t.length-1),l=null;for(let[u,c]of s){l=new Si(r.registry,Ii,r.path,null,r.scope);let p=[],f=!1;for(let y=1;y<t.length;y++){let m=t[y],h=Array.isArray(u)?u[y-1]:u.type,d=l.parse(m,1+p.length,h);if(!d){f=!0;break}p.push(d)}if(!f){if(Array.isArray(u)&&u.length!==p.length){l.error("Expected ".concat(u.length," arguments, but found ").concat(p.length," instead."));continue}for(let y=0;y<p.length;y++){let m=Array.isArray(u)?u[y]:u.type,h=p[y];l.concat(y+1).checkSubtype(m,h.type)}if(l.errors.length===0)return new e(n,o,c,p)}}if(s.length===1)r.errors.push(...l.errors);else{let c=(s.length?s:a).map(([f])=>Jy(f)).join(" | "),p=[];for(let f=1;f<t.length;f++){let y=r.parse(t[f],1+p.length);if(!y)return null;p.push(ne(y.type))}r.error("Expected arguments of type ".concat(c,", but found (").concat(p.join(", "),") instead."))}return null}static register(t,r){e.definitions=r;for(let n in r)t[n]=e}};function Jy(e){return Array.isArray(e)?"(".concat(e.map(ne).join(", "),")"):"(".concat(ne(e.type),"...)")}function Ii(e){if(e instanceof _i)return Ii(e.boundExpression);if(e instanceof Ye&&e.name==="error")return!1;if(e instanceof wi)return!1;if(e instanceof Jr)return!1;let t=e instanceof ft||e instanceof Ge,r=!0;return e.eachChild(n=>{t?r=r&&Ii(n):r=r&&n instanceof mt}),r?Di(e)&&Vi(e,["zoom","heatmap-density","line-progress","accumulated","is-supported-script"]):!1}function Di(e){if(e instanceof Ye){if(e.name==="get"&&e.args.length===1)return!1;if(e.name==="feature-state")return!1;if(e.name==="has"&&e.args.length===1)return!1;if(e.name==="properties"||e.name==="geometry-type"||e.name==="id")return!1;if(/^filter-/.test(e.name))return!1}if(e instanceof Jr)return!1;let t=!0;return e.eachChild(r=>{t&&!Di(r)&&(t=!1)}),t}function Wr(e){if(e instanceof Ye&&e.name==="feature-state")return!1;let t=!0;return e.eachChild(r=>{t&&!Wr(r)&&(t=!1)}),t}function Vi(e,t){if(e instanceof Ye&&t.indexOf(e.name)>=0)return!1;let r=!0;return e.eachChild(n=>{r&&!Vi(n,t)&&(r=!1)}),r}function Bi(e,t){let r=e.length-1,n=0,i=r,o=0,a,s;for(;n<=i;)if(o=Math.floor((n+i)/2),a=e[o],s=e[o+1],a<=t){if(o===r||t<s)return o;n=o+1}else if(a>t)i=o-1;else throw new oe("Input is not a number.");return 0}var lr=class e{constructor(t,r,n){this.type=t,this.input=r,this.labels=[],this.outputs=[];for(let[i,o]of n)this.labels.push(i),this.outputs.push(o)}static parse(t,r){if(t.length-1<4)return r.error("Expected at least 4 arguments, but found only ".concat(t.length-1,"."));if((t.length-1)%2!==0)return r.error("Expected an even number of arguments.");let n=r.parse(t[1],1,L);if(!n)return null;let i=[],o=null;r.expectedType&&r.expectedType.kind!=="value"&&(o=r.expectedType);for(let a=1;a<t.length;a+=2){let s=a===1?-1/0:t[a],l=t[a+1],u=a,c=a+1;if(typeof s!="number")return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',u);if(i.length&&i[i.length-1][0]>=s)return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',u);let p=r.parse(l,c,o);if(!p)return null;o=o||p.type,i.push([s,p])}return new e(o,n,i)}evaluate(t){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(t);let i=this.input.evaluate(t);if(i<=r[0])return n[0].evaluate(t);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(t);let a=Bi(r,i);return n[a].evaluate(t)}eachChild(t){t(this.input);for(let r of this.outputs)t(r)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}};function Wy(e){return e==="rgb"||e==="hcl"||e==="lab"}function Lt(e,t,r){return e+r*(t-e)}function Hy(e,t,r,n="rgb"){switch(n){case"rgb":{let[i,o,a,s]=Ci(e.rgb,t.rgb,r);return new W(i,o,a,s,!1)}case"hcl":{let[i,o,a,s]=e.hcl,[l,u,c,p]=t.hcl,f,y;if(!isNaN(i)&&!isNaN(l)){let v=l-i;l>i&&v>180?v-=360:l<i&&i-l>180&&(v+=360),f=i+r*v}else isNaN(i)?isNaN(l)?f=NaN:(f=l,(a===1||a===0)&&(y=u)):(f=i,(c===1||c===0)&&(y=o));let[m,h,d,g]=ky([f,y!=null?y:Lt(o,u,r),Lt(a,c,r),Lt(s,p,r)]);return new W(m,h,d,g,!1)}case"lab":{let[i,o,a,s]=Ul(Ci(e.lab,t.lab,r));return new W(i,o,a,s,!1)}}}function Ci(e,t,r){return e.map((n,i)=>Lt(n,t[i],r))}function Ky(e,t,r){return new je(Ci(e.values,t.values,r))}function Yy(e,t,r){let n=e.values,i=t.values;if(n.length!==i.length)throw new oe("Cannot interpolate values of different length. from: ".concat(e.toString(),", to: ").concat(t.toString()));let o=[];for(let a=0;a<n.length;a+=2){if(n[a]!==i[a])throw new oe("Cannot interpolate values containing mismatched anchors. from[".concat(a,"]: ").concat(n[a],", to[").concat(a,"]: ").concat(i[a]));o.push(n[a]);let[s,l]=n[a+1],[u,c]=i[a+1];o.push([Lt(s,u,r),Lt(l,c,r)])}return new it(o)}var Re={number:Lt,color:Hy,array:Ci,padding:Ky,variableAnchorOffsetCollection:Yy},qe=class e{constructor(t,r,n,i,o){this.type=t,this.operator=r,this.interpolation=n,this.input=i,this.labels=[],this.outputs=[];for(let[a,s]of o)this.labels.push(a),this.outputs.push(s)}static interpolationFactor(t,r,n,i){let o=0;if(t.name==="exponential")o=Aa(r,t.base,n,i);else if(t.name==="linear")o=Aa(r,1,n,i);else if(t.name==="cubic-bezier"){let a=t.controlPoints;o=new Ll.default(a[0],a[1],a[2],a[3]).solve(Aa(r,1,n,i))}return o}static parse(t,r){let[n,i,o,...a]=t;if(!Array.isArray(i)||i.length===0)return r.error("Expected an interpolation type expression.",1);if(i[0]==="linear")i={name:"linear"};else if(i[0]==="exponential"){let u=i[1];if(typeof u!="number")return r.error("Exponential interpolation requires a numeric base.",1,1);i={name:"exponential",base:u}}else if(i[0]==="cubic-bezier"){let u=i.slice(1);if(u.length!==4||u.some(c=>typeof c!="number"||c<0||c>1))return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",1);i={name:"cubic-bezier",controlPoints:u}}else return r.error("Unknown interpolation type ".concat(String(i[0])),1,0);if(t.length-1<4)return r.error("Expected at least 4 arguments, but found only ".concat(t.length-1,"."));if((t.length-1)%2!==0)return r.error("Expected an even number of arguments.");if(o=r.parse(o,2,L),!o)return null;let s=[],l=null;n==="interpolate-hcl"||n==="interpolate-lab"?l=ze:r.expectedType&&r.expectedType.kind!=="value"&&(l=r.expectedType);for(let u=0;u<a.length;u+=2){let c=a[u],p=a[u+1],f=u+3,y=u+4;if(typeof c!="number")return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',f);if(s.length&&s[s.length-1][0]>=c)return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',f);let m=r.parse(p,y,l);if(!m)return null;l=l||m.type,s.push([c,m])}return!Nr(l,L)&&!Nr(l,ze)&&!Nr(l,Mi)&&!Nr(l,Li)&&!Nr(l,Fe(L))?r.error("Type ".concat(ne(l)," is not interpolatable.")):new e(l,n,i,o,s)}evaluate(t){let r=this.labels,n=this.outputs;if(r.length===1)return n[0].evaluate(t);let i=this.input.evaluate(t);if(i<=r[0])return n[0].evaluate(t);let o=r.length;if(i>=r[o-1])return n[o-1].evaluate(t);let a=Bi(r,i),s=r[a],l=r[a+1],u=e.interpolationFactor(this.interpolation,i,s,l),c=n[a].evaluate(t),p=n[a+1].evaluate(t);switch(this.operator){case"interpolate":return Re[this.type.kind](c,p,u);case"interpolate-hcl":return Re.color(c,p,u,"hcl");case"interpolate-lab":return Re.color(c,p,u,"lab")}}eachChild(t){t(this.input);for(let r of this.outputs)t(r)}outputDefined(){return this.outputs.every(t=>t.outputDefined())}};function Aa(e,t,r,n){let i=n-r,o=e-r;return i===0?0:t===1?o/i:(Math.pow(t,o)-1)/(Math.pow(t,i)-1)}var ki=class e{constructor(t,r){this.type=t,this.args=r}static parse(t,r){if(t.length<2)return r.error("Expectected at least one argument.");let n=null,i=r.expectedType;i&&i.kind!=="value"&&(n=i);let o=[];for(let s of t.slice(1)){let l=r.parse(s,1+o.length,n,void 0,{typeAnnotation:"omit"});if(!l)return null;n=n||l.type,o.push(l)}if(!n)throw new Error("No output type");return i&&o.some(s=>Gr(i,s.type))?new e($,o):new e(n,o)}evaluate(t){let r=null,n=0,i;for(let o of this.args)if(n++,r=o.evaluate(t),r&&r instanceof Ce&&!r.available&&(i||(i=r.name),r=null,n===this.args.length&&(r=i)),r!==null)break;return r}eachChild(t){this.args.forEach(t)}outputDefined(){return this.args.every(t=>t.outputDefined())}},Ti=class e{constructor(t,r){this.type=r.type,this.bindings=[].concat(t),this.result=r}evaluate(t){return this.result.evaluate(t)}eachChild(t){for(let r of this.bindings)t(r[1]);t(this.result)}static parse(t,r){if(t.length<4)return r.error("Expected at least 3 arguments, but found ".concat(t.length-1," instead."));let n=[];for(let o=1;o<t.length-1;o+=2){let a=t[o];if(typeof a!="string")return r.error("Expected string, but found ".concat(typeof a," instead."),o);if(/[^a-zA-Z0-9_]/.test(a))return r.error("Variable names must contain only alphanumeric characters or '_'.",o);let s=r.parse(t[o+1],o+1);if(!s)return null;n.push([a,s])}let i=r.parse(t[t.length-1],t.length-1,r.expectedType,n);return i?new e(n,i):null}outputDefined(){return this.result.outputDefined()}},ka=class e{constructor(t,r,n){this.type=t,this.index=r,this.input=n}static parse(t,r){if(t.length!==3)return r.error("Expected 2 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,L),i=r.parse(t[2],2,Fe(r.expectedType||$));if(!n||!i)return null;let o=i.type;return new e(o.itemType,n,i)}evaluate(t){let r=this.index.evaluate(t),n=this.input.evaluate(t);if(r<0)throw new oe("Array index out of bounds: ".concat(r," < 0."));if(r>=n.length)throw new oe("Array index out of bounds: ".concat(r," > ").concat(n.length-1,"."));if(r!==Math.floor(r))throw new oe("Array index must be an integer, but found ".concat(r," instead."));return n[r]}eachChild(t){t(this.index),t(this.input)}outputDefined(){return!1}},Ta=class e{constructor(t,r){this.type=U,this.needle=t,this.haystack=r}static parse(t,r){if(t.length!==3)return r.error("Expected 2 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,$),i=r.parse(t[2],2,$);return!n||!i?null:Oa(n.type,[U,G,L,cr,$])?new e(n,i):r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(ne(n.type)," instead"))}evaluate(t){let r=this.needle.evaluate(t),n=this.haystack.evaluate(t);if(!n)return!1;if(!qr(r,["boolean","string","number","null"]))throw new oe("Expected first argument to be of type boolean, string, number or null, but found ".concat(ne(fe(r))," instead."));if(!qr(n,["string","array"]))throw new oe("Expected second argument to be of type array or string, but found ".concat(ne(fe(n))," instead."));return n.indexOf(r)>=0}eachChild(t){t(this.needle),t(this.haystack)}outputDefined(){return!0}},Ea=class e{constructor(t,r,n){this.type=L,this.needle=t,this.haystack=r,this.fromIndex=n}static parse(t,r){if(t.length<=2||t.length>=5)return r.error("Expected 3 or 4 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,$),i=r.parse(t[2],2,$);if(!n||!i)return null;if(!Oa(n.type,[U,G,L,cr,$]))return r.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(ne(n.type)," instead"));if(t.length===4){let o=r.parse(t[3],3,L);return o?new e(n,i,o):null}else return new e(n,i)}evaluate(t){let r=this.needle.evaluate(t),n=this.haystack.evaluate(t);if(!qr(r,["boolean","string","number","null"]))throw new oe("Expected first argument to be of type boolean, string, number or null, but found ".concat(ne(fe(r))," instead."));if(!qr(n,["string","array"]))throw new oe("Expected second argument to be of type array or string, but found ".concat(ne(fe(n))," instead."));if(this.fromIndex){let i=this.fromIndex.evaluate(t);return n.indexOf(r,i)}return n.indexOf(r)}eachChild(t){t(this.needle),t(this.haystack),this.fromIndex&&t(this.fromIndex)}outputDefined(){return!1}},Fa=class e{constructor(t,r,n,i,o,a){this.inputType=t,this.type=r,this.input=n,this.cases=i,this.outputs=o,this.otherwise=a}static parse(t,r){if(t.length<5)return r.error("Expected at least 4 arguments, but found only ".concat(t.length-1,"."));if(t.length%2!==1)return r.error("Expected an even number of arguments.");let n,i;r.expectedType&&r.expectedType.kind!=="value"&&(i=r.expectedType);let o={},a=[];for(let u=2;u<t.length-1;u+=2){let c=t[u],p=t[u+1];Array.isArray(c)||(c=[c]);let f=r.concat(u);if(c.length===0)return f.error("Expected at least one branch label.");for(let m of c){if(typeof m!="number"&&typeof m!="string")return f.error("Branch labels must be numbers or strings.");if(typeof m=="number"&&Math.abs(m)>Number.MAX_SAFE_INTEGER)return f.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER,"."));if(typeof m=="number"&&Math.floor(m)!==m)return f.error("Numeric branch labels must be integer values.");if(!n)n=fe(m);else if(f.checkSubtype(n,fe(m)))return null;if(typeof o[String(m)]<"u")return f.error("Branch labels must be unique.");o[String(m)]=a.length}let y=r.parse(p,u,i);if(!y)return null;i=i||y.type,a.push(y)}let s=r.parse(t[1],1,$);if(!s)return null;let l=r.parse(t[t.length-1],t.length-1,i);return!l||s.type.kind!=="value"&&r.concat(1).checkSubtype(n,s.type)?null:new e(n,i,s,o,a,l)}evaluate(t){let r=this.input.evaluate(t);return(fe(r)===this.inputType&&this.outputs[this.cases[r]]||this.otherwise).evaluate(t)}eachChild(t){t(this.input),this.outputs.forEach(t),t(this.otherwise)}outputDefined(){return this.outputs.every(t=>t.outputDefined())&&this.otherwise.outputDefined()}},Ma=class e{constructor(t,r,n){this.type=t,this.branches=r,this.otherwise=n}static parse(t,r){if(t.length<4)return r.error("Expected at least 3 arguments, but found only ".concat(t.length-1,"."));if(t.length%2!==0)return r.error("Expected an odd number of arguments.");let n;r.expectedType&&r.expectedType.kind!=="value"&&(n=r.expectedType);let i=[];for(let a=1;a<t.length-1;a+=2){let s=r.parse(t[a],a,U);if(!s)return null;let l=r.parse(t[a+1],a+1,n);if(!l)return null;i.push([s,l]),n=n||l.type}let o=r.parse(t[t.length-1],t.length-1,n);if(!o)return null;if(!n)throw new Error("Can't infer output type");return new e(n,i,o)}evaluate(t){for(let[r,n]of this.branches)if(r.evaluate(t))return n.evaluate(t);return this.otherwise.evaluate(t)}eachChild(t){for(let[r,n]of this.branches)t(r),t(n);t(this.otherwise)}outputDefined(){return this.branches.every(([t,r])=>r.outputDefined())&&this.otherwise.outputDefined()}},La=class e{constructor(t,r,n,i){this.type=t,this.input=r,this.beginIndex=n,this.endIndex=i}static parse(t,r){if(t.length<=2||t.length>=5)return r.error("Expected 3 or 4 arguments, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1,$),i=r.parse(t[2],2,L);if(!n||!i)return null;if(!Oa(n.type,[Fe($),G,$]))return r.error("Expected first argument to be of type array or string, but found ".concat(ne(n.type)," instead"));if(t.length===4){let o=r.parse(t[3],3,L);return o?new e(n.type,n,i,o):null}else return new e(n.type,n,i)}evaluate(t){let r=this.input.evaluate(t),n=this.beginIndex.evaluate(t);if(!qr(r,["string","array"]))throw new oe("Expected first argument to be of type array or string, but found ".concat(ne(fe(r))," instead."));if(this.endIndex){let i=this.endIndex.evaluate(t);return r.slice(n,i)}return r.slice(n)}eachChild(t){t(this.input),t(this.beginIndex),this.endIndex&&t(this.endIndex)}outputDefined(){return!1}};function _l(e,t){return e==="=="||e==="!="?t.kind==="boolean"||t.kind==="string"||t.kind==="number"||t.kind==="null"||t.kind==="value":t.kind==="string"||t.kind==="number"||t.kind==="value"}function Xy(e,t,r){return t===r}function Qy(e,t,r){return t!==r}function em(e,t,r){return t<r}function tm(e,t,r){return t>r}function rm(e,t,r){return t<=r}function nm(e,t,r){return t>=r}function Zl(e,t,r,n){return n.compare(t,r)===0}function im(e,t,r,n){return!Zl(e,t,r,n)}function om(e,t,r,n){return n.compare(t,r)<0}function am(e,t,r,n){return n.compare(t,r)>0}function sm(e,t,r,n){return n.compare(t,r)<=0}function lm(e,t,r,n){return n.compare(t,r)>=0}function fr(e,t,r){let n=e!=="=="&&e!=="!=";return class Jl{constructor(o,a,s){this.type=U,this.lhs=o,this.rhs=a,this.collator=s,this.hasUntypedArgument=o.type.kind==="value"||a.type.kind==="value"}static parse(o,a){if(o.length!==3&&o.length!==4)return a.error("Expected two or three arguments.");let s=o[0],l=a.parse(o[1],1,$);if(!l)return null;if(!_l(s,l.type))return a.concat(1).error('"'.concat(s,"\\" comparisons are not supported for type '").concat(ne(l.type),"'."));let u=a.parse(o[2],2,$);if(!u)return null;if(!_l(s,u.type))return a.concat(2).error('"'.concat(s,"\\" comparisons are not supported for type '").concat(ne(u.type),"'."));if(l.type.kind!==u.type.kind&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot compare types '".concat(ne(l.type),"' and '").concat(ne(u.type),"'."));n&&(l.type.kind==="value"&&u.type.kind!=="value"?l=new Ge(u.type,[l]):l.type.kind!=="value"&&u.type.kind==="value"&&(u=new Ge(l.type,[u])));let c=null;if(o.length===4){if(l.type.kind!=="string"&&u.type.kind!=="string"&&l.type.kind!=="value"&&u.type.kind!=="value")return a.error("Cannot use collator to compare non-string types.");if(c=a.parse(o[3],3,Fi),!c)return null}return new Jl(l,u,c)}evaluate(o){let a=this.lhs.evaluate(o),s=this.rhs.evaluate(o);if(n&&this.hasUntypedArgument){let l=fe(a),u=fe(s);if(l.kind!==u.kind||!(l.kind==="string"||l.kind==="number"))throw new oe('Expected arguments for "'.concat(e,'" to be (string, string) or (number, number), but found (').concat(l.kind,", ").concat(u.kind,") instead."))}if(this.collator&&!n&&this.hasUntypedArgument){let l=fe(a),u=fe(s);if(l.kind!=="string"||u.kind!=="string")return t(o,a,s)}return this.collator?r(o,a,s,this.collator.evaluate(o)):t(o,a,s)}eachChild(o){o(this.lhs),o(this.rhs),this.collator&&o(this.collator)}outputDefined(){return!0}}}var um=fr("==",Xy,Zl),cm=fr("!=",Qy,im),pm=fr("<",em,om),fm=fr(">",tm,am),ym=fr("<=",rm,sm),mm=fr(">=",nm,lm),Da=class e{constructor(t,r,n,i,o){this.type=G,this.number=t,this.locale=r,this.currency=n,this.minFractionDigits=i,this.maxFractionDigits=o}static parse(t,r){if(t.length!==3)return r.error("Expected two arguments.");let n=r.parse(t[1],1,L);if(!n)return null;let i=t[2];if(typeof i!="object"||Array.isArray(i))return r.error("NumberFormat options argument must be an object.");let o=null;if(i.locale&&(o=r.parse(i.locale,1,G),!o))return null;let a=null;if(i.currency&&(a=r.parse(i.currency,1,G),!a))return null;let s=null;if(i["min-fraction-digits"]&&(s=r.parse(i["min-fraction-digits"],1,L),!s))return null;let l=null;return i["max-fraction-digits"]&&(l=r.parse(i["max-fraction-digits"],1,L),!l)?null:new e(n,o,a,s,l)}evaluate(t){return new Intl.NumberFormat(this.locale?this.locale.evaluate(t):[],{style:this.currency?"currency":"decimal",currency:this.currency?this.currency.evaluate(t):void 0,minimumFractionDigits:this.minFractionDigits?this.minFractionDigits.evaluate(t):void 0,maximumFractionDigits:this.maxFractionDigits?this.maxFractionDigits.evaluate(t):void 0}).format(this.number.evaluate(t))}eachChild(t){t(this.number),this.locale&&t(this.locale),this.currency&&t(this.currency),this.minFractionDigits&&t(this.minFractionDigits),this.maxFractionDigits&&t(this.maxFractionDigits)}outputDefined(){return!1}},Hr=class e{constructor(t){this.type=pr,this.sections=t}static parse(t,r){if(t.length<2)return r.error("Expected at least one argument.");let n=t[1];if(!Array.isArray(n)&&typeof n=="object")return r.error("First argument must be an image or text section.");let i=[],o=!1;for(let a=1;a<=t.length-1;++a){let s=t[a];if(o&&typeof s=="object"&&!Array.isArray(s)){o=!1;let l=null;if(s["font-scale"]&&(l=r.parse(s["font-scale"],1,L),!l))return null;let u=null;if(s["text-font"]&&(u=r.parse(s["text-font"],1,Fe(G)),!u))return null;let c=null;if(s["text-color"]&&(c=r.parse(s["text-color"],1,ze),!c))return null;let p=i[i.length-1];p.scale=l,p.font=u,p.textColor=c}else{let l=r.parse(t[a],1,$);if(!l)return null;let u=l.type.kind;if(u!=="string"&&u!=="value"&&u!=="null"&&u!=="resolvedImage")return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");o=!0,i.push({content:l,scale:null,font:null,textColor:null})}}return new e(i)}evaluate(t){let r=n=>{let i=n.content.evaluate(t);return fe(i)===Xr?new Zr("",i,null,null,null):new Zr(Ur(i),null,n.scale?n.scale.evaluate(t):null,n.font?n.font.evaluate(t).join(","):null,n.textColor?n.textColor.evaluate(t):null)};return new Me(this.sections.map(r))}eachChild(t){for(let r of this.sections)t(r.content),r.scale&&t(r.scale),r.font&&t(r.font),r.textColor&&t(r.textColor)}outputDefined(){return!1}},Va=class e{constructor(t){this.type=Xr,this.input=t}static parse(t,r){if(t.length!==2)return r.error("Expected two arguments.");let n=r.parse(t[1],1,G);return n?new e(n):r.error("No image name provided.")}evaluate(t){let r=this.input.evaluate(t),n=Ce.fromString(r);return n&&t.availableImages&&(n.available=t.availableImages.indexOf(r)>-1),n}eachChild(t){t(this.input)}outputDefined(){return!1}},Ba=class e{constructor(t){this.type=L,this.input=t}static parse(t,r){if(t.length!==2)return r.error("Expected 1 argument, but found ".concat(t.length-1," instead."));let n=r.parse(t[1],1);return n?n.type.kind!=="array"&&n.type.kind!=="string"&&n.type.kind!=="value"?r.error("Expected argument of type string or array, but found ".concat(ne(n.type)," instead.")):new e(n):null}evaluate(t){let r=this.input.evaluate(t);if(typeof r=="string")return r.length;if(Array.isArray(r))return r.length;throw new oe("Expected value to be of type string or array, but found ".concat(ne(fe(r))," instead."))}eachChild(t){t(this.input)}outputDefined(){return!1}},zt={"==":um,"!=":cm,">":fm,"<":pm,">=":mm,"<=":ym,array:Ge,at:ka,boolean:Ge,case:Ma,coalesce:ki,collator:wi,format:Hr,image:Va,in:Ta,"index-of":Ea,interpolate:qe,"interpolate-hcl":qe,"interpolate-lab":qe,length:Ba,let:Ti,literal:mt,match:Fa,number:Ge,"number-format":Da,object:Ge,slice:La,step:lr,string:Ge,"to-boolean":ft,"to-color":ft,"to-number":ft,"to-string":ft,var:_i,within:Jr};function Il(e,[t,r,n,i]){t=t.evaluate(e),r=r.evaluate(e),n=n.evaluate(e);let o=i?i.evaluate(e):1,a=$l(t,r,n,o);if(a)throw new oe(a);return new W(t/255,r/255,n/255,o,!1)}function Cl(e,t){return e in t}function _a(e,t){let r=t[e];return typeof r>"u"?null:r}function hm(e,t,r,n){for(;r<=n;){let i=r+n>>1;if(t[i]===e)return!0;t[i]>e?n=i-1:r=i+1}return!1}function Mt(e){return{type:e}}Ye.register(zt,{error:[Sy,[G],(e,[t])=>{throw new oe(t.evaluate(e))}],typeof:[G,[$],(e,[t])=>ne(fe(t.evaluate(e)))],"to-rgba":[Fe(L,4),[ze],(e,[t])=>{let[r,n,i,o]=t.evaluate(e).rgb;return[r*255,n*255,i*255,o]}],rgb:[ze,[L,L,L],Il],rgba:[ze,[L,L,L,L],Il],has:{type:U,overloads:[[[G],(e,[t])=>Cl(t.evaluate(e),e.properties())],[[G,or],(e,[t,r])=>Cl(t.evaluate(e),r.evaluate(e))]]},get:{type:$,overloads:[[[G],(e,[t])=>_a(t.evaluate(e),e.properties())],[[G,or],(e,[t,r])=>_a(t.evaluate(e),r.evaluate(e))]]},"feature-state":[$,[G],(e,[t])=>_a(t.evaluate(e),e.featureState||{})],properties:[or,[],e=>e.properties()],"geometry-type":[G,[],e=>e.geometryType()],id:[$,[],e=>e.id()],zoom:[L,[],e=>e.globals.zoom],"heatmap-density":[L,[],e=>e.globals.heatmapDensity||0],"line-progress":[L,[],e=>e.globals.lineProgress||0],accumulated:[$,[],e=>e.globals.accumulated===void 0?null:e.globals.accumulated],"+":[L,Mt(L),(e,t)=>{let r=0;for(let n of t)r+=n.evaluate(e);return r}],"*":[L,Mt(L),(e,t)=>{let r=1;for(let n of t)r*=n.evaluate(e);return r}],"-":{type:L,overloads:[[[L,L],(e,[t,r])=>t.evaluate(e)-r.evaluate(e)],[[L],(e,[t])=>-t.evaluate(e)]]},"/":[L,[L,L],(e,[t,r])=>t.evaluate(e)/r.evaluate(e)],"%":[L,[L,L],(e,[t,r])=>t.evaluate(e)%r.evaluate(e)],ln2:[L,[],()=>Math.LN2],pi:[L,[],()=>Math.PI],e:[L,[],()=>Math.E],"^":[L,[L,L],(e,[t,r])=>Math.pow(t.evaluate(e),r.evaluate(e))],sqrt:[L,[L],(e,[t])=>Math.sqrt(t.evaluate(e))],log10:[L,[L],(e,[t])=>Math.log(t.evaluate(e))/Math.LN10],ln:[L,[L],(e,[t])=>Math.log(t.evaluate(e))],log2:[L,[L],(e,[t])=>Math.log(t.evaluate(e))/Math.LN2],sin:[L,[L],(e,[t])=>Math.sin(t.evaluate(e))],cos:[L,[L],(e,[t])=>Math.cos(t.evaluate(e))],tan:[L,[L],(e,[t])=>Math.tan(t.evaluate(e))],asin:[L,[L],(e,[t])=>Math.asin(t.evaluate(e))],acos:[L,[L],(e,[t])=>Math.acos(t.evaluate(e))],atan:[L,[L],(e,[t])=>Math.atan(t.evaluate(e))],min:[L,Mt(L),(e,t)=>Math.min(...t.map(r=>r.evaluate(e)))],max:[L,Mt(L),(e,t)=>Math.max(...t.map(r=>r.evaluate(e)))],abs:[L,[L],(e,[t])=>Math.abs(t.evaluate(e))],round:[L,[L],(e,[t])=>{let r=t.evaluate(e);return r<0?-Math.round(-r):Math.round(r)}],floor:[L,[L],(e,[t])=>Math.floor(t.evaluate(e))],ceil:[L,[L],(e,[t])=>Math.ceil(t.evaluate(e))],"filter-==":[U,[G,$],(e,[t,r])=>e.properties()[t.value]===r.value],"filter-id-==":[U,[$],(e,[t])=>e.id()===t.value],"filter-type-==":[U,[G],(e,[t])=>e.geometryType()===t.value],"filter-<":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n<i}],"filter-id-<":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r<n}],"filter->":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n>i}],"filter-id->":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r>n}],"filter-<=":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n<=i}],"filter-id-<=":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r<=n}],"filter->=":[U,[G,$],(e,[t,r])=>{let n=e.properties()[t.value],i=r.value;return typeof n==typeof i&&n>=i}],"filter-id->=":[U,[$],(e,[t])=>{let r=e.id(),n=t.value;return typeof r==typeof n&&r>=n}],"filter-has":[U,[$],(e,[t])=>t.value in e.properties()],"filter-has-id":[U,[],e=>e.id()!==null&&e.id()!==void 0],"filter-type-in":[U,[Fe(G)],(e,[t])=>t.value.indexOf(e.geometryType())>=0],"filter-id-in":[U,[Fe($)],(e,[t])=>t.value.indexOf(e.id())>=0],"filter-in-small":[U,[G,Fe($)],(e,[t,r])=>r.value.indexOf(e.properties()[t.value])>=0],"filter-in-large":[U,[G,Fe($)],(e,[t,r])=>hm(e.properties()[t.value],r.value,0,r.value.length-1)],all:{type:U,overloads:[[[U,U],(e,[t,r])=>t.evaluate(e)&&r.evaluate(e)],[Mt(U),(e,t)=>{for(let r of t)if(!r.evaluate(e))return!1;return!0}]]},any:{type:U,overloads:[[[U,U],(e,[t,r])=>t.evaluate(e)||r.evaluate(e)],[Mt(U),(e,t)=>{for(let r of t)if(r.evaluate(e))return!0;return!1}]]},"!":[U,[U],(e,[t])=>!t.evaluate(e)],"is-supported-script":[U,[G],(e,[t])=>{let r=e.globals&&e.globals.isSupportedScript;return r?r(t.evaluate(e)):!0}],upcase:[G,[G],(e,[t])=>t.evaluate(e).toUpperCase()],downcase:[G,[G],(e,[t])=>t.evaluate(e).toLowerCase()],concat:[G,Mt($),(e,t)=>t.map(r=>Ur(r.evaluate(e))).join("")],"resolved-locale":[G,[Fi],(e,[t])=>t.evaluate(e).resolvedLocale()]});function za(e){return{result:"success",value:e}}function ir(e){return{result:"error",value:e}}function ht(e){return e["property-type"]==="data-driven"||e["property-type"]==="cross-faded-data-driven"}function Wl(e){return!!e.expression&&e.expression.parameters.indexOf("zoom")>-1}function Ga(e){return!!e.expression&&e.expression.interpolated}function j(e){return e instanceof Number?"number":e instanceof String?"string":e instanceof Boolean?"boolean":Array.isArray(e)?"array":e===null?"null":typeof e}function zi(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}function dm(e){return e}function Hl(e,t){let r=t.type==="color",n=e.stops&&typeof e.stops[0][0]=="object",i=n||e.property!==void 0,o=n||!i,a=e.type||(Ga(t)?"exponential":"interval");if(r||t.type==="padding"){let c=r?W.parse:je.parse;e=sr({},e),e.stops&&(e.stops=e.stops.map(p=>[p[0],c(p[1])])),e.default?e.default=c(e.default):e.default=c(t.default)}if(e.colorSpace&&!Wy(e.colorSpace))throw new Error('Unknown color space: "'.concat(e.colorSpace,'"'));let s,l,u;if(a==="exponential")s=kl;else if(a==="interval")s=xm;else if(a==="categorical"){s=gm,l=Object.create(null);for(let c of e.stops)l[c[0]]=c[1];u=typeof e.stops[0][0]}else if(a==="identity")s=bm;else throw new Error('Unknown function type "'.concat(a,'"'));if(n){let c={},p=[];for(let m=0;m<e.stops.length;m++){let h=e.stops[m],d=h[0].zoom;c[d]===void 0&&(c[d]={zoom:d,type:e.type,property:e.property,default:e.default,stops:[]},p.push(d)),c[d].stops.push([h[0].value,h[1]])}let f=[];for(let m of p)f.push([c[m].zoom,Hl(c[m],t)]);let y={name:"linear"};return{kind:"composite",interpolationType:y,interpolationFactor:qe.interpolationFactor.bind(void 0,y),zoomStops:f.map(m=>m[0]),evaluate({zoom:m},h){return kl({stops:f,base:e.base},t,m).evaluate(m,h)}}}else if(o){let c=a==="exponential"?{name:"exponential",base:e.base!==void 0?e.base:1}:null;return{kind:"camera",interpolationType:c,interpolationFactor:qe.interpolationFactor.bind(void 0,c),zoomStops:e.stops.map(p=>p[0]),evaluate:({zoom:p})=>s(e,t,p,l,u)}}else return{kind:"source",evaluate(c,p){let f=p&&p.properties?p.properties[e.property]:void 0;return f===void 0?Qr(e.default,t.default):s(e,t,f,l,u)}}}function Qr(e,t,r){if(e!==void 0)return e;if(t!==void 0)return t;if(r!==void 0)return r}function gm(e,t,r,n,i){let o=typeof r===i?n[r]:void 0;return Qr(o,e.default,t.default)}function xm(e,t,r){if(j(r)!=="number")return Qr(e.default,t.default);let n=e.stops.length;if(n===1||r<=e.stops[0][0])return e.stops[0][1];if(r>=e.stops[n-1][0])return e.stops[n-1][1];let i=Bi(e.stops.map(o=>o[0]),r);return e.stops[i][1]}function kl(e,t,r){let n=e.base!==void 0?e.base:1;if(j(r)!=="number")return Qr(e.default,t.default);let i=e.stops.length;if(i===1||r<=e.stops[0][0])return e.stops[0][1];if(r>=e.stops[i-1][0])return e.stops[i-1][1];let o=Bi(e.stops.map(c=>c[0]),r),a=vm(r,n,e.stops[o][0],e.stops[o+1][0]),s=e.stops[o][1],l=e.stops[o+1][1],u=Re[t.type]||dm;return typeof s.evaluate=="function"?{evaluate(...c){let p=s.evaluate.apply(void 0,c),f=l.evaluate.apply(void 0,c);if(!(p===void 0||f===void 0))return u(p,f,a,e.colorSpace)}}:u(s,l,a,e.colorSpace)}function bm(e,t,r){switch(t.type){case"color":r=W.parse(r);break;case"formatted":r=Me.fromString(r.toString());break;case"resolvedImage":r=Ce.fromString(r.toString());break;case"padding":r=je.parse(r);break;default:j(r)!==t.type&&(t.type!=="enum"||!t.values[r])&&(r=void 0)}return Qr(r,e.default,t.default)}function vm(e,t,r,n){let i=n-r,o=e-r;return i===0?0:t===1?o/i:(Math.pow(t,o)-1)/(Math.pow(t,i)-1)}var Dt=class{constructor(t,r){this.expression=t,this._warningHistory={},this._evaluator=new Pi,this._defaultValue=r?Sm(r):null,this._enumValues=r&&r.type==="enum"?r.values:null}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._evaluator.globals=t,this._evaluator.feature=r,this._evaluator.featureState=n,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a,this.expression.evaluate(this._evaluator)}evaluate(t,r,n,i,o,a){this._evaluator.globals=t,this._evaluator.feature=r||null,this._evaluator.featureState=n||null,this._evaluator.canonical=i,this._evaluator.availableImages=o||null,this._evaluator.formattedSection=a||null;try{let s=this.expression.evaluate(this._evaluator);if(s==null||typeof s=="number"&&s!==s)return this._defaultValue;if(this._enumValues&&!(s in this._enumValues))throw new oe("Expected value to be one of ".concat(Object.keys(this._enumValues).map(l=>JSON.stringify(l)).join(", "),", but found ").concat(JSON.stringify(s)," instead."));return s}catch(s){return this._warningHistory[s.message]||(this._warningHistory[s.message]=!0,typeof console<"u"&&console.warn(s.message)),this._defaultValue}}};function en(e){return Array.isArray(e)&&e.length>0&&typeof e[0]=="string"&&e[0]in zt}function Rt(e,t){let r=new Si(zt,Ii,[],t?Pm(t):void 0),n=r.parse(e,void 0,void 0,void 0,t&&t.type==="string"?{typeAnnotation:"coerce"}:void 0);return n?za(new Dt(n,t)):ir(r.errors)}var dt=class{constructor(t,r){this.kind=t,this._styleExpression=r,this.isStateDependent=t!=="constant"&&!Wr(r.expression)}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(t,r,n,i,o,a)}evaluate(t,r,n,i,o,a){return this._styleExpression.evaluate(t,r,n,i,o,a)}},gt=class{constructor(t,r,n,i){this.kind=t,this.zoomStops=n,this._styleExpression=r,this.isStateDependent=t!=="camera"&&!Wr(r.expression),this.interpolationType=i}evaluateWithoutErrorHandling(t,r,n,i,o,a){return this._styleExpression.evaluateWithoutErrorHandling(t,r,n,i,o,a)}evaluate(t,r,n,i,o,a){return this._styleExpression.evaluate(t,r,n,i,o,a)}interpolationFactor(t,r,n){return this.interpolationType?qe.interpolationFactor(this.interpolationType,t,r,n):0}};function Kl(e,t){let r=Rt(e,t);if(r.result==="error")return r;let n=r.value.expression,i=Di(n);if(!i&&!ht(t))return ir([new Ve("","data expressions not supported")]);let o=Vi(n,["zoom"]);if(!o&&!Wl(t))return ir([new Ve("","zoom expressions not supported")]);let a=bi(n);if(!a&&!o)return ir([new Ve("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);if(a instanceof Ve)return ir([a]);if(a instanceof qe&&!Ga(t))return ir([new Ve("",'"interpolate" expressions cannot be used with this property')]);if(!a)return za(i?new dt("constant",r.value):new dt("source",r.value));let s=a instanceof qe?a.interpolation:void 0;return za(i?new gt("camera",r.value,a.labels,s):new gt("composite",r.value,a.labels,s))}var Kr=class e{constructor(t,r){this._parameters=t,this._specification=r,sr(this,Hl(this._parameters,this._specification))}static deserialize(t){return new e(t._parameters,t._specification)}static serialize(t){return{_parameters:t._parameters,_specification:t._specification}}};function Yl(e,t){if(zi(e))return new Kr(e,t);if(en(e)){let r=Kl(e,t);if(r.result==="error")throw new Error(r.value.map(n=>"".concat(n.key,": ").concat(n.message)).join(", "));return r.value}else{let r=e;return t.type==="color"&&typeof e=="string"?r=W.parse(e):t.type==="padding"&&(typeof e=="number"||Array.isArray(e))?r=je.parse(e):t.type==="variableAnchorOffsetCollection"&&Array.isArray(e)&&(r=it.parse(e)),{kind:"constant",evaluate:()=>r}}}function bi(e){let t=null;if(e instanceof Ti)t=bi(e.result);else if(e instanceof ki){for(let r of e.args)if(t=bi(r),t)break}else(e instanceof lr||e instanceof qe)&&e.input instanceof Ye&&e.input.name==="zoom"&&(t=e);return t instanceof Ve||e.eachChild(r=>{let n=bi(r);n instanceof Ve?t=n:!t&&n?t=new Ve("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.'):t&&n&&t!==n&&(t=new Ve("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))}),t}function Pm(e){let t={color:ze,string:G,number:L,enum:G,boolean:U,formatted:pr,padding:Mi,resolvedImage:Xr,variableAnchorOffsetCollection:Li};return e.type==="array"?Fe(t[e.value]||$,e.length):t[e.type]}function Sm(e){return e.type==="color"&&zi(e.default)?new W(0,0,0,0):e.type==="color"?W.parse(e.default)||null:e.type==="padding"?je.parse(e.default)||null:e.type==="variableAnchorOffsetCollection"?it.parse(e.default)||null:e.default===void 0?null:e.default}function qa(e){if(e===!0||e===!1)return!0;if(!Array.isArray(e)||e.length===0)return!1;switch(e[0]){case"has":return e.length>=2&&e[1]!=="$id"&&e[1]!=="$type";case"in":return e.length>=3&&(typeof e[1]!="string"||Array.isArray(e[2]));case"!in":case"!has":case"none":return!1;case"==":case"!=":case">":case">=":case"<":case"<=":return e.length!==3||Array.isArray(e[1])||Array.isArray(e[2]);case"any":case"all":for(let t of e.slice(1))if(!qa(t)&&typeof t!="boolean")return!1;return!0;default:return!0}}var wm={type:"boolean",default:!1,transition:!1,"property-type":"data-driven",expression:{interpolated:!1,parameters:["zoom","feature"]}};function tn(e){if(e==null)return{filter:()=>!0,needGeometry:!1};qa(e)||(e=Ei(e));let t=Rt(e,wm);if(t.result==="error")throw new Error(t.value.map(r=>"".concat(r.key,": ").concat(r.message)).join(", "));{let r=Xl(e);return{filter:(n,i,o)=>t.value.evaluate(n,i,{},o),needGeometry:r}}}function Am(e,t){return e<t?-1:e>t?1:0}function Xl(e){if(!Array.isArray(e))return!1;if(e[0]==="within")return!0;for(let t=1;t<e.length;t++)if(Xl(e[t]))return!0;return!1}function Ei(e){if(!e)return!0;let t=e[0];return e.length<=1?t!=="any":t==="=="?Ia(e[1],e[2],"=="):t==="!="?xi(Ia(e[1],e[2],"==")):t==="<"||t===">"||t==="<="||t===">="?Ia(e[1],e[2],t):t==="any"?_m(e.slice(1)):t==="all"?["all"].concat(e.slice(1).map(Ei)):t==="none"?["all"].concat(e.slice(1).map(Ei).map(xi)):t==="in"?Tl(e[1],e.slice(2)):t==="!in"?xi(Tl(e[1],e.slice(2))):t==="has"?El(e[1]):t==="!has"?xi(El(e[1])):t==="within"?e:!0}function Ia(e,t,r){switch(e){case"$type":return["filter-type-".concat(r),t];case"$id":return["filter-id-".concat(r),t];default:return["filter-".concat(r),e,t]}}function _m(e){return["any"].concat(e.map(Ei))}function Tl(e,t){if(t.length===0)return!1;switch(e){case"$type":return["filter-type-in",["literal",t]];case"$id":return["filter-id-in",["literal",t]];default:return t.length>200&&!t.some(r=>typeof r!=typeof t[0])?["filter-in-large",e,["literal",t.sort(Am)]]:["filter-in-small",e,["literal",t]]}}function El(e){switch(e){case"$type":return!0;case"$id":return["filter-has-id"];default:return["filter-has",e]}}function xi(e){return["!",e]}function Ra(e){let t=typeof e;if(t==="number"||t==="boolean"||t==="string"||e===void 0||e===null)return JSON.stringify(e);if(Array.isArray(e)){let i="[";for(let o of e)i+="".concat(Ra(o),",");return"".concat(i,"]")}let r=Object.keys(e).sort(),n="{";for(let i=0;i<r.length;i++)n+="".concat(JSON.stringify(r[i]),":").concat(Ra(e[r[i]]),",");return"".concat(n,"}")}function Im(e){let t="";for(let r of Py)t+="/".concat(Ra(e[r]));return t}function Ql(e,t){let r={};for(let i=0;i<e.length;i++){let o=t&&t[e[i].id]||Im(e[i]);t&&(t[e[i].id]=o);let a=r[o];a||(a=r[o]=[]),a.push(e[i])}let n=[];for(let i in r)n.push(r[i]);return n}function eu(e){let t=e.key,r=e.value;return r?[new D(t,r,"constants have been deprecated as of v8")]:[]}function pe(e){return e instanceof Number||e instanceof String||e instanceof Boolean?e.valueOf():e}function Vt(e){if(Array.isArray(e))return e.map(Vt);if(e instanceof Object&&!(e instanceof Number||e instanceof String||e instanceof Boolean)){let t={};for(let r in e)t[r]=Vt(e[r]);return t}return pe(e)}function Be(e){let t=e.key,r=e.value,n=e.valueSpec||{},i=e.objectElementValidators||{},o=e.style,a=e.styleSpec,s=e.validateSpec,l=[],u=j(r);if(u!=="object")return[new D(t,r,"object expected, ".concat(u," found"))];for(let c in r){let p=c.split(".")[0],f=n[p]||n["*"],y;if(i[p])y=i[p];else if(n[p])y=s;else if(i["*"])y=i["*"];else if(n["*"])y=s;else{l.push(new D(t,r[c],'unknown property "'.concat(c,'"')));continue}l=l.concat(y({key:(t&&"".concat(t,"."))+c,value:r[c],valueSpec:f,style:o,styleSpec:a,object:r,objectKey:c,validateSpec:s},r))}for(let c in n)i[c]||n[c].required&&n[c].default===void 0&&r[c]===void 0&&l.push(new D(t,r,'missing required property "'.concat(c,'"')));return l}function ja(e){let t=e.value,r=e.valueSpec,n=e.validateSpec,i=e.style,o=e.styleSpec,a=e.key,s=e.arrayElementValidator||n;if(j(t)!=="array")return[new D(a,t,"array expected, ".concat(j(t)," found"))];if(r.length&&t.length!==r.length)return[new D(a,t,"array length ".concat(r.length," expected, length ").concat(t.length," found"))];if(r["min-length"]&&t.length<r["min-length"])return[new D(a,t,"array length at least ".concat(r["min-length"]," expected, length ").concat(t.length," found"))];let l={type:r.value,values:r.values};o.$version<7&&(l.function=r.function),j(r.value)==="object"&&(l=r.value);let u=[];for(let c=0;c<t.length;c++)u=u.concat(s({array:t,arrayIndex:c,value:t[c],valueSpec:l,validateSpec:e.validateSpec,style:i,styleSpec:o,key:"".concat(a,"[").concat(c,"]")}));return u}function Za(e){let t=e.key,r=e.value,n=e.valueSpec,i=j(r);return i==="number"&&r!==r&&(i="NaN"),i!=="number"?[new D(t,r,"number expected, ".concat(i," found"))]:"minimum"in n&&r<n.minimum?[new D(t,r,"".concat(r," is less than the minimum value ").concat(n.minimum))]:"maximum"in n&&r>n.maximum?[new D(t,r,"".concat(r," is greater than the maximum value ").concat(n.maximum))]:[]}function tu(e){let t=e.valueSpec,r=pe(e.value.type),n,i={},o,a,s=r!=="categorical"&&e.value.property===void 0,l=!s,u=j(e.value.stops)==="array"&&j(e.value.stops[0])==="array"&&j(e.value.stops[0][0])==="object",c=Be({key:e.key,value:e.value,valueSpec:e.styleSpec.function,validateSpec:e.validateSpec,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{stops:p,default:m}});return r==="identity"&&s&&c.push(new D(e.key,e.value,'missing required property "property"')),r!=="identity"&&!e.value.stops&&c.push(new D(e.key,e.value,'missing required property "stops"')),r==="exponential"&&e.valueSpec.expression&&!Ga(e.valueSpec)&&c.push(new D(e.key,e.value,"exponential functions not supported")),e.styleSpec.$version>=8&&(l&&!ht(e.valueSpec)?c.push(new D(e.key,e.value,"property functions not supported")):s&&!Wl(e.valueSpec)&&c.push(new D(e.key,e.value,"zoom functions not supported"))),(r==="categorical"||u)&&e.value.property===void 0&&c.push(new D(e.key,e.value,'"property" property is required')),c;function p(h){if(r==="identity")return[new D(h.key,h.value,'identity function may not have a "stops" property')];let d=[],g=h.value;return d=d.concat(ja({key:h.key,value:g,valueSpec:h.valueSpec,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,arrayElementValidator:f})),j(g)==="array"&&g.length===0&&d.push(new D(h.key,g,"array must have at least one stop")),d}function f(h){let d=[],g=h.value,v=h.key;if(j(g)!=="array")return[new D(v,g,"array expected, ".concat(j(g)," found"))];if(g.length!==2)return[new D(v,g,"array length 2 expected, length ".concat(g.length," found"))];if(u){if(j(g[0])!=="object")return[new D(v,g,"object expected, ".concat(j(g[0])," found"))];if(g[0].zoom===void 0)return[new D(v,g,"object stop key must have zoom")];if(g[0].value===void 0)return[new D(v,g,"object stop key must have value")];if(a&&a>pe(g[0].zoom))return[new D(v,g[0].zoom,"stop zoom values must appear in ascending order")];pe(g[0].zoom)!==a&&(a=pe(g[0].zoom),o=void 0,i={}),d=d.concat(Be({key:"".concat(v,"[0]"),value:g[0],valueSpec:{zoom:{}},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec,objectElementValidators:{zoom:Za,value:y}}))}else d=d.concat(y({key:"".concat(v,"[0]"),value:g[0],valueSpec:{},validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec},g));return en(Vt(g[1]))?d.concat([new D("".concat(v,"[1]"),g[1],"expressions are not allowed in function stops.")]):d.concat(h.validateSpec({key:"".concat(v,"[1]"),value:g[1],valueSpec:t,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec}))}function y(h,d){let g=j(h.value),v=pe(h.value),b=h.value!==null?h.value:d;if(!n)n=g;else if(g!==n)return[new D(h.key,b,"".concat(g," stop domain type must match previous stop domain type ").concat(n))];if(g!=="number"&&g!=="string"&&g!=="boolean")return[new D(h.key,b,"stop domain value must be a number, string, or boolean")];if(g!=="number"&&r!=="categorical"){let x="number expected, ".concat(g," found");return ht(t)&&r===void 0&&(x+='\\nIf you intended to use a categorical function, specify \`"type": "categorical"\`.'),[new D(h.key,b,x)]}return r==="categorical"&&g==="number"&&(!isFinite(v)||Math.floor(v)!==v)?[new D(h.key,b,"integer expected, found ".concat(v))]:r!=="categorical"&&g==="number"&&o!==void 0&&v<o?[new D(h.key,b,"stop domain values must appear in ascending order")]:(o=v,r==="categorical"&&v in i?[new D(h.key,b,"stop domain values must be unique")]:(i[v]=!0,[]))}function m(h){return h.validateSpec({key:h.key,value:h.value,valueSpec:t,validateSpec:h.validateSpec,style:h.style,styleSpec:h.styleSpec})}}function ur(e){let t=(e.expressionContext==="property"?Kl:Rt)(Vt(e.value),e.valueSpec);if(t.result==="error")return t.value.map(n=>new D("".concat(e.key).concat(n.key),e.value,n.message));let r=t.value.expression||t.value._styleExpression.expression;if(e.expressionContext==="property"&&e.propertyKey==="text-font"&&!r.outputDefined())return[new D(e.key,e.value,'Invalid data expression for "'.concat(e.propertyKey,'". Output values must be contained as literals within the expression.'))];if(e.expressionContext==="property"&&e.propertyType==="layout"&&!Wr(r))return[new D(e.key,e.value,'"feature-state" data expressions are not supported with layout properties.')];if(e.expressionContext==="filter"&&!Wr(r))return[new D(e.key,e.value,'"feature-state" data expressions are not supported with filters.')];if(e.expressionContext&&e.expressionContext.indexOf("cluster")===0){if(!Vi(r,["zoom","feature-state"]))return[new D(e.key,e.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];if(e.expressionContext==="cluster-initial"&&!Di(r))return[new D(e.key,e.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]}return[]}function Cm(e){let t=e.value,r=e.key,n=j(t);return n!=="boolean"?[new D(r,t,"boolean expected, ".concat(n," found"))]:[]}function km(e){let t=e.key,r=e.value,n=j(r);return n!=="string"?[new D(t,r,"color expected, ".concat(n," found"))]:W.parse(String(r))?[]:[new D(t,r,'color expected, "'.concat(r,'" found'))]}function Yr(e){let t=e.key,r=e.value,n=e.valueSpec,i=[];return Array.isArray(n.values)?n.values.indexOf(pe(r))===-1&&i.push(new D(t,r,"expected one of [".concat(n.values.join(", "),"], ").concat(JSON.stringify(r)," found"))):Object.keys(n.values).indexOf(pe(r))===-1&&i.push(new D(t,r,"expected one of [".concat(Object.keys(n.values).join(", "),"], ").concat(JSON.stringify(r)," found"))),i}function Ja(e){return qa(Vt(e.value))?ur(sr({},e,{expressionContext:"filter",valueSpec:{value:"boolean"}})):ru(e)}function ru(e){let t=e.value,r=e.key;if(j(t)!=="array")return[new D(r,t,"array expected, ".concat(j(t)," found"))];let n=e.styleSpec,i,o=[];if(t.length<1)return[new D(r,t,"filter array must have at least 1 element")];switch(o=o.concat(Yr({key:"".concat(r,"[0]"),value:t[0],valueSpec:n.filter_operator,style:e.style,styleSpec:e.styleSpec})),pe(t[0])){case"<":case"<=":case">":case">=":t.length>=2&&pe(t[1])==="$type"&&o.push(new D(r,t,'"$type" cannot be use with operator "'.concat(t[0],'"')));case"==":case"!=":t.length!==3&&o.push(new D(r,t,'filter array for operator "'.concat(t[0],'" must have 3 elements')));case"in":case"!in":t.length>=2&&(i=j(t[1]),i!=="string"&&o.push(new D("".concat(r,"[1]"),t[1],"string expected, ".concat(i," found"))));for(let a=2;a<t.length;a++)i=j(t[a]),pe(t[1])==="$type"?o=o.concat(Yr({key:"".concat(r,"[").concat(a,"]"),value:t[a],valueSpec:n.geometry_type,style:e.style,styleSpec:e.styleSpec})):i!=="string"&&i!=="number"&&i!=="boolean"&&o.push(new D("".concat(r,"[").concat(a,"]"),t[a],"string, number, or boolean expected, ".concat(i," found")));break;case"any":case"all":case"none":for(let a=1;a<t.length;a++)o=o.concat(ru({key:"".concat(r,"[").concat(a,"]"),value:t[a],style:e.style,styleSpec:e.styleSpec}));break;case"has":case"!has":i=j(t[1]),t.length!==2?o.push(new D(r,t,'filter array for "'.concat(t[0],'" operator must have 2 elements'))):i!=="string"&&o.push(new D("".concat(r,"[1]"),t[1],"string expected, ".concat(i," found")));break;case"within":i=j(t[1]),t.length!==2?o.push(new D(r,t,'filter array for "'.concat(t[0],'" operator must have 2 elements'))):i!=="object"&&o.push(new D("".concat(r,"[1]"),t[1],"object expected, ".concat(i," found")));break}return o}function nu(e,t){let r=e.key,n=e.validateSpec,i=e.style,o=e.styleSpec,a=e.value,s=e.objectKey,l=o["".concat(t,"_").concat(e.layerType)];if(!l)return[];let u=s.match(/^(.*)-transition$/);if(t==="paint"&&u&&l[u[1]]&&l[u[1]].transition)return n({key:r,value:a,valueSpec:o.transition,style:i,styleSpec:o});let c=e.valueSpec||l[s];if(!c)return[new D(r,a,'unknown property "'.concat(s,'"'))];let p;if(j(a)==="string"&&ht(c)&&!c.tokens&&(p=/^{([^}]+)}$/.exec(a)))return[new D(r,a,'"'.concat(s,'" does not support interpolation syntax\\n')+'Use an identity property function instead: \`{ "type": "identity", "property": '.concat(JSON.stringify(p[1])," }\`."))];let f=[];return e.layerType==="symbol"&&(s==="text-field"&&i&&!i.glyphs&&f.push(new D(r,a,'use of "text-field" requires a style "glyphs" property')),s==="text-font"&&zi(Vt(a))&&pe(a.type)==="identity"&&f.push(new D(r,a,'"text-font" does not support identity functions'))),f.concat(n({key:e.key,value:a,valueSpec:c,style:i,styleSpec:o,expressionContext:"property",propertyType:t,propertyKey:s}))}function iu(e){return nu(e,"paint")}function ou(e){return nu(e,"layout")}function au(e){let t=[],r=e.value,n=e.key,i=e.style,o=e.styleSpec;!r.type&&!r.ref&&t.push(new D(n,r,'either "type" or "ref" is required'));let a=pe(r.type),s=pe(r.ref);if(r.id){let l=pe(r.id);for(let u=0;u<e.arrayIndex;u++){let c=i.layers[u];pe(c.id)===l&&t.push(new D(n,r.id,'duplicate layer id "'.concat(r.id,'", previously used at line ').concat(c.id.__line__)))}}if("ref"in r){["type","source","source-layer","filter","layout"].forEach(u=>{u in r&&t.push(new D(n,r[u],'"'.concat(u,'" is prohibited for ref layers')))});let l;i.layers.forEach(u=>{pe(u.id)===s&&(l=u)}),l?l.ref?t.push(new D(n,r.ref,"ref cannot reference another ref layer")):a=pe(l.type):t.push(new D(n,r.ref,'ref layer "'.concat(s,'" not found')))}else if(a!=="background")if(!r.source)t.push(new D(n,r,'missing required property "source"'));else{let l=i.sources&&i.sources[r.source],u=l&&pe(l.type);l?u==="vector"&&a==="raster"?t.push(new D(n,r.source,'layer "'.concat(r.id,'" requires a raster source'))):u==="raster"&&a!=="raster"?t.push(new D(n,r.source,'layer "'.concat(r.id,'" requires a vector source'))):u==="vector"&&!r["source-layer"]?t.push(new D(n,r,'layer "'.concat(r.id,'" must specify a "source-layer"'))):u==="raster-dem"&&a!=="hillshade"?t.push(new D(n,r.source,"raster-dem source can only be used with layer type 'hillshade'.")):a==="line"&&r.paint&&r.paint["line-gradient"]&&(u!=="geojson"||!l.lineMetrics)&&t.push(new D(n,r,'layer "'.concat(r.id,'" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.'))):t.push(new D(n,r.source,'source "'.concat(r.source,'" not found')))}return t=t.concat(Be({key:n,value:r,valueSpec:o.layer,style:e.style,styleSpec:e.styleSpec,validateSpec:e.validateSpec,objectElementValidators:{"*"(){return[]},type(){return e.validateSpec({key:"".concat(n,".type"),value:r.type,valueSpec:o.layer.type,style:e.style,styleSpec:e.styleSpec,validateSpec:e.validateSpec,object:r,objectKey:"type"})},filter:Ja,layout(l){return Be({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return ou(sr({layerType:a},u))}}})},paint(l){return Be({layer:r,key:l.key,value:l.value,style:l.style,styleSpec:l.styleSpec,validateSpec:l.validateSpec,objectElementValidators:{"*"(u){return iu(sr({layerType:a},u))}}})}}})),t}function Bt(e){let t=e.value,r=e.key,n=j(t);return n!=="string"?[new D(r,t,"string expected, ".concat(n," found"))]:[]}var Fl={promoteId:Tm};function su(e){let t=e.value,r=e.key,n=e.styleSpec,i=e.style,o=e.validateSpec;if(!t.type)return[new D(r,t,'"type" is required')];let a=pe(t.type),s;switch(a){case"vector":case"raster":case"raster-dem":return s=Be({key:r,value:t,valueSpec:n["source_".concat(a.replace("-","_"))],style:e.style,styleSpec:n,objectElementValidators:Fl,validateSpec:o}),s;case"geojson":if(s=Be({key:r,value:t,valueSpec:n.source_geojson,style:i,styleSpec:n,validateSpec:o,objectElementValidators:Fl}),t.cluster)for(let l in t.clusterProperties){let[u,c]=t.clusterProperties[l],p=typeof u=="string"?[u,["accumulated"],["get",l]]:u;s.push(...ur({key:"".concat(r,".").concat(l,".map"),value:c,validateSpec:o,expressionContext:"cluster-map"})),s.push(...ur({key:"".concat(r,".").concat(l,".reduce"),value:p,validateSpec:o,expressionContext:"cluster-reduce"}))}return s;case"video":return Be({key:r,value:t,valueSpec:n.source_video,style:i,validateSpec:o,styleSpec:n});case"image":return Be({key:r,value:t,valueSpec:n.source_image,style:i,validateSpec:o,styleSpec:n});case"canvas":return[new D(r,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];default:return Yr({key:"".concat(r,".type"),value:t.type,valueSpec:{values:["vector","raster","raster-dem","geojson","video","image"]},style:i,validateSpec:o,styleSpec:n})}}function Tm({key:e,value:t}){if(j(t)==="string")return Bt({key:e,value:t});{let r=[];for(let n in t)r.push(...Bt({key:"".concat(e,".").concat(n),value:t[n]}));return r}}function lu(e){let t=e.value,r=e.styleSpec,n=r.light,i=e.style,o=[],a=j(t);if(t===void 0)return o;if(a!=="object")return o=o.concat([new D("light",t,"object expected, ".concat(a," found"))]),o;for(let s in t){let l=s.match(/^(.*)-transition$/);l&&n[l[1]]&&n[l[1]].transition?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:r.transition,validateSpec:e.validateSpec,style:i,styleSpec:r})):n[s]?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],validateSpec:e.validateSpec,style:i,styleSpec:r})):o=o.concat([new D(s,t[s],'unknown property "'.concat(s,'"'))])}return o}function uu(e){let t=e.value,r=e.styleSpec,n=r.terrain,i=e.style,o=[],a=j(t);if(t===void 0)return o;if(a!=="object")return o=o.concat([new D("terrain",t,"object expected, ".concat(a," found"))]),o;for(let s in t)n[s]?o=o.concat(e.validateSpec({key:s,value:t[s],valueSpec:n[s],validateSpec:e.validateSpec,style:i,styleSpec:r})):o=o.concat([new D(s,t[s],'unknown property "'.concat(s,'"'))]);return o}function Em(e){return Bt(e).length===0?[]:ur(e)}function Fm(e){return Bt(e).length===0?[]:ur(e)}function Mm(e){let t=e.key,r=e.value;if(j(r)==="array"){if(r.length<1||r.length>4)return[new D(t,r,"padding requires 1 to 4 values; ".concat(r.length," values found"))];let i={type:"number"},o=[];for(let a=0;a<r.length;a++)o=o.concat(e.validateSpec({key:"".concat(t,"[").concat(a,"]"),value:r[a],validateSpec:e.validateSpec,valueSpec:i}));return o}else return Za({key:t,value:r,valueSpec:{}})}function Lm(e){let t=e.key,r=e.value,n=j(r),i=e.styleSpec;if(n!=="array"||r.length<1||r.length%2!==0)return[new D(t,r,"variableAnchorOffsetCollection requires a non-empty array of even length")];let o=[];for(let a=0;a<r.length;a+=2)o=o.concat(Yr({key:"".concat(t,"[").concat(a,"]"),value:r[a],valueSpec:i.layout_symbol["text-anchor"]})),o=o.concat(ja({key:"".concat(t,"[").concat(a+1,"]"),value:r[a+1],valueSpec:{length:2,value:"number"},validateSpec:e.validateSpec,style:e.style,styleSpec:i}));return o}function cu(e){let t=[],r=e.value,n=e.key;if(Array.isArray(r)){let i=[],o=[];for(let a in r){r[a].id&&i.includes(r[a].id)&&t.push(new D(n,r,"all the sprites' ids must be unique, but ".concat(r[a].id," is duplicated"))),i.push(r[a].id),r[a].url&&o.includes(r[a].url)&&t.push(new D(n,r,"all the sprites' URLs must be unique, but ".concat(r[a].url," is duplicated"))),o.push(r[a].url);let s={id:{type:"string",required:!0},url:{type:"string",required:!0}};t=t.concat(Be({key:"".concat(n,"[").concat(a,"]"),value:r[a],valueSpec:s,validateSpec:e.validateSpec}))}return t}else return Bt({key:n,value:r})}var Ml={"*"(){return[]},array:ja,boolean:Cm,number:Za,color:km,constants:eu,enum:Yr,filter:Ja,function:tu,layer:au,object:Be,source:su,light:lu,terrain:uu,string:Bt,formatted:Em,resolvedImage:Fm,padding:Mm,variableAnchorOffsetCollection:Lm,sprite:cu};function $r(e){let t=e.value,r=e.valueSpec,n=e.styleSpec;return e.validateSpec=$r,r.expression&&zi(pe(t))?tu(e):r.expression&&en(Vt(t))?ur(e):r.type&&Ml[r.type]?Ml[r.type](e):Be(sr({},e,{valueSpec:r.type?n[r.type]:r}))}function pu(e){let t=e.value,r=e.key,n=Bt(e);return n.length||(t.indexOf("{fontstack}")===-1&&n.push(new D(r,t,'"glyphs" url must include a "{fontstack}" token')),t.indexOf("{range}")===-1&&n.push(new D(r,t,'"glyphs" url must include a "{range}" token'))),n}function Ze(e,t=S){let r=[];return r=r.concat($r({key:"",value:e,valueSpec:t.$root,styleSpec:t,style:e,validateSpec:$r,objectElementValidators:{glyphs:pu,"*"(){return[]}}})),e.constants&&(r=r.concat(eu({key:"constants",value:e.constants,style:e,styleSpec:t,validateSpec:$r}))),fu(r)}Ze.source=at(ot(su));Ze.sprite=at(ot(cu));Ze.glyphs=at(ot(pu));Ze.light=at(ot(lu));Ze.terrain=at(ot(uu));Ze.layer=at(ot(au));Ze.filter=at(ot(Ja));Ze.paintProperty=at(ot(iu));Ze.layoutProperty=at(ot(ou));function ot(e){return function(t){return e({...t,validateSpec:$r})}}function fu(e){return[].concat(e).sort((t,r)=>t.line-r.line)}function at(e){return function(...t){return fu(e.apply(this,t))}}var yu={MAX_PARALLEL_IMAGE_REQUESTS:16,MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME:8,MAX_TILE_CACHE_ZOOM_LEVELS:5,REGISTERED_PROTOCOLS:{},WORKER_URL:""};var yr=class extends Error{constructor(r,n,i,o){super("AJAXError: ".concat(n," (").concat(r,"): ").concat(i));this.status=r,this.statusText=n,this.url=i,this.body=o}},hu=Ie()?()=>self.worker&&self.worker.referrer:()=>(window.location.protocol==="blob:"?window.parent:window).location.href,Dm=e=>yu.REGISTERED_PROTOCOLS[e.substring(0,e.indexOf("://"))],Vm=e=>/^file:/.test(e)||/^file:/.test(hu())&&!/^\\w+:/.test(e);function mu(e,t){let r=new AbortController,n=new Request(e.url,{method:e.method||"GET",body:e.body,credentials:e.credentials,headers:e.headers,referrer:hu(),signal:r.signal}),i=!1,o=!1;e.type==="json"&&n.headers.set("Accept","application/json");let a=(l,u,c)=>{if(!o){if(l&&l.message!=="SecurityError"&&ce(l),u&&c)return s(u);fetch(n).then(p=>p.ok?s(p):p.blob().then(f=>t(new yr(p.status,p.statusText,e.url,f)))).catch(p=>{p.code!==20&&t(new Error(p.message))})}},s=l=>{(e.type==="arrayBuffer"||e.type==="image"?l.arrayBuffer():e.type==="json"?l.json():l.text()).then(u=>{o||(i=!0,t(null,u,l.headers.get("Cache-Control"),l.headers.get("Expires")))}).catch(u=>{o||t(new Error(u.message))})};return a(null,null),{cancel:()=>{o=!0,i||r.abort()}}}function Bm(e,t){let r=new XMLHttpRequest;r.open(e.method||"GET",e.url,!0),(e.type==="arrayBuffer"||e.type==="image")&&(r.responseType="arraybuffer");for(let n in e.headers)r.setRequestHeader(n,e.headers[n]);return e.type==="json"&&(r.responseType="text",r.setRequestHeader("Accept","application/json")),r.withCredentials=e.credentials==="include",r.onerror=()=>{t(new Error(r.statusText))},r.onload=()=>{if((r.status>=200&&r.status<300||r.status===0)&&r.response!==null){let n=r.response;if(e.type==="json")try{n=JSON.parse(r.response)}catch(i){return t(i)}t(null,n,r.getResponseHeader("Cache-Control"),r.getResponseHeader("Expires"))}else{let n=new Blob([r.response],{type:r.getResponseHeader("Content-Type")});t(new yr(r.status,r.statusText,e.url,n))}},r.send(e.body),{cancel:()=>r.abort()}}var du=function(e,t){if(/:\\/\\//.test(e.url)&&!/^https?:|^file:/.test(e.url)){if(Ie()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",e,t);if(!Ie())return(Dm(e.url)||mu)(e,t)}if(!Vm(e.url)){if(fetch&&Request&&AbortController&&Object.prototype.hasOwnProperty.call(Request.prototype,"signal"))return mu(e,t);if(Ie()&&self.worker&&self.worker.actor)return self.worker.actor.send("getResource",e,t,void 0,!0)}return Bm(e,t)},gu=function(e,t){return du(Ae(e,{type:"json"}),t)},Wa=function(e,t){return du(Ae(e,{type:"arrayBuffer"}),t)};var xt={};function k(e,t,r={}){if(xt[e])throw new Error("".concat(e," is already registered."));Object.defineProperty(t,"_classRegistryKey",{value:e,writeable:!1}),xt[e]={klass:t,omit:r.omit||[],shallow:r.shallow||[]}}k("Object",Object);k("TransferableGridIndex",Ft);k("Color",W);k("Error",Error);k("AJAXError",yr);k("ResolvedImage",Ce);k("StylePropertyFunction",Kr);k("StyleExpression",Dt,{omit:["_evaluator"]});k("ZoomDependentExpression",gt);k("ZoomConstantExpression",dt);k("CompoundExpression",Ye,{omit:["_evaluate"]});for(let e in zt)zt[e]._classRegistryKey||k("Expression_".concat(e),zt[e]);function xu(e){return e&&typeof ArrayBuffer<"u"&&(e instanceof ArrayBuffer||e.constructor&&e.constructor.name==="ArrayBuffer")}function mr(e,t){if(e==null||typeof e=="boolean"||typeof e=="number"||typeof e=="string"||e instanceof Boolean||e instanceof Number||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof Blob)return e;if(xu(e)||Or(e))return t&&t.push(e),e;if(ArrayBuffer.isView(e)){let r=e;return t&&t.push(r.buffer),r}if(e instanceof ImageData)return t&&t.push(e.data.buffer),e;if(Array.isArray(e)){let r=[];for(let n of e)r.push(mr(n,t));return r}if(typeof e=="object"){let r=e.constructor,n=r._classRegistryKey;if(!n)throw new Error("can't serialize object of unregistered class");if(!xt[n])throw new Error("".concat(n," is not registered."));let i=r.serialize?r.serialize(e,t):{};if(r.serialize){if(t&&i===t[t.length-1])throw new Error("statically serialized object won't survive transfer of $name property")}else{for(let o in e){if(!e.hasOwnProperty(o)||xt[n].omit.indexOf(o)>=0)continue;let a=e[o];i[o]=xt[n].shallow.indexOf(o)>=0?a:mr(a,t)}e instanceof Error&&(i.message=e.message)}if(i.$name)throw new Error("$name property is reserved for worker serialization logic.");return n!=="Object"&&(i.$name=n),i}throw new Error("can't serialize object of type ".concat(typeof e))}function hr(e){if(e==null||typeof e=="boolean"||typeof e=="number"||typeof e=="string"||e instanceof Boolean||e instanceof Number||e instanceof String||e instanceof Date||e instanceof RegExp||e instanceof Blob||xu(e)||Or(e)||ArrayBuffer.isView(e)||e instanceof ImageData)return e;if(Array.isArray(e))return e.map(hr);if(typeof e=="object"){let t=e.$name||"Object";if(!xt[t])throw new Error("can't deserialize unregistered class ".concat(t));let{klass:r}=xt[t];if(!r)throw new Error("can't deserialize unregistered class ".concat(t));if(r.deserialize)return r.deserialize(e);let n=Object.create(r.prototype);for(let i of Object.keys(e)){if(i==="$name")continue;let o=e[i];n[i]=xt[t].shallow.indexOf(i)>=0?o:hr(o)}return n}throw new Error("can't deserialize object of type ".concat(typeof e))}var Ri=class{constructor(t){this._callback=t,this._triggered=!1,typeof MessageChannel<"u"&&(this._channel=new MessageChannel,this._channel.port2.onmessage=()=>{this._triggered=!1,this._callback()})}trigger(){this._triggered||(this._triggered=!0,this._channel?this._channel.port1.postMessage(!0):setTimeout(()=>{this._triggered=!1,this._callback()},0))}remove(){delete this._channel,this._callback=()=>{}}};var Oi=class{constructor(t,r,n){this.receive=t=>{let r=t.data,n=r.id;if(n&&!(r.targetMapId&&this.mapId!==r.targetMapId))if(r.type==="<cancel>"){delete this.tasks[n];let i=this.cancelCallbacks[n];delete this.cancelCallbacks[n],i&&i()}else Ie()||r.mustQueue?(this.tasks[n]=r,this.taskQueue.push(n),this.invoker.trigger()):this.processTask(n,r)};this.process=()=>{if(!this.taskQueue.length)return;let t=this.taskQueue.shift(),r=this.tasks[t];delete this.tasks[t],this.taskQueue.length&&this.invoker.trigger(),r&&this.processTask(t,r)};this.target=t,this.parent=r,this.mapId=n,this.callbacks={},this.tasks={},this.taskQueue=[],this.cancelCallbacks={},this.invoker=new Ri(this.process),this.target.addEventListener("message",this.receive,!1),this.globalScope=Ie()?t:window}send(t,r,n,i,o=!1){let a=Math.round(Math.random()*1e18).toString(36).substring(0,10);n&&(this.callbacks[a]=n);let s=ba(this.globalScope)?void 0:[];return this.target.postMessage({id:a,type:t,hasCallback:!!n,targetMapId:i,mustQueue:o,sourceMapId:this.mapId,data:mr(r,s)},s),{cancel:()=>{n&&delete this.callbacks[a],this.target.postMessage({id:a,type:"<cancel>",targetMapId:i,sourceMapId:this.mapId})}}}processTask(t,r){if(r.type==="<response>"){let n=this.callbacks[t];delete this.callbacks[t],n&&(r.error?n(hr(r.error)):n(null,hr(r.data)))}else{let n=!1,i=ba(this.globalScope)?void 0:[],o=r.hasCallback?(l,u)=>{n=!0,delete this.cancelCallbacks[t],this.target.postMessage({id:t,type:"<response>",sourceMapId:this.mapId,error:l?mr(l):null,data:mr(u,i)},i)}:l=>{n=!0},a=null,s=hr(r.data);if(this.parent[r.type])a=this.parent[r.type](r.sourceMapId,s,o);else if(this.parent.getWorkerSource){let l=r.type.split(".");a=this.parent.getWorkerSource(r.sourceMapId,l[0],s.source)[l[1]](s,o)}else o(new Error("Could not find function ".concat(r.type)));!n&&a&&a.cancel&&(this.cancelCallbacks[t]=a.cancel)}}remove(){this.invoker.remove(),this.target.removeEventListener("message",this.receive,!1)}};function bu(e,t,r){r[e]&&r[e].indexOf(t)!==-1||(r[e]=r[e]||[],r[e].push(t))}function Ha(e,t,r){if(r&&r[e]){let n=r[e].indexOf(t);n!==-1&&r[e].splice(n,1)}}var rn=class{constructor(t,r={}){Ae(this,r),this.type=t}},nn=class extends rn{constructor(r,n={}){super("error",Ae({error:r},n))}},dr=class{on(t,r){return this._listeners=this._listeners||{},bu(t,r,this._listeners),this}off(t,r){return Ha(t,r,this._listeners),Ha(t,r,this._oneTimeListeners),this}once(t,r){return r?(this._oneTimeListeners=this._oneTimeListeners||{},bu(t,r,this._oneTimeListeners),this):new Promise(n=>this.once(t,n))}fire(t,r){typeof t=="string"&&(t=new rn(t,r||{}));let n=t.type;if(this.listens(n)){t.target=this;let i=this._listeners&&this._listeners[n]?this._listeners[n].slice():[];for(let s of i)s.call(this,t);let o=this._oneTimeListeners&&this._oneTimeListeners[n]?this._oneTimeListeners[n].slice():[];for(let s of o)Ha(n,s,this._oneTimeListeners),s.call(this,t);let a=this._eventedParent;a&&(Ae(t,typeof this._eventedParentData=="function"?this._eventedParentData():this._eventedParentData),a.fire(t))}else t instanceof nn&&console.error(t.error);return this}listens(t){return this._listeners&&this._listeners[t]&&this._listeners[t].length>0||this._oneTimeListeners&&this._oneTimeListeners[t]&&this._oneTimeListeners[t].length>0||this._eventedParent&&this._eventedParent.listens(t)}setEventedParent(t,r){return this._eventedParent=t,this._eventedParentData=r,this}};var bt=Ze,vb=bt.source,Pb=bt.light,Sb=bt.terrain,wb=bt.filter,vu=bt.paintProperty,Pu=bt.layoutProperty;function Su(e,t){let r=!1;if(t&&t.length)for(let n of t)e.fire(new nn(new Error(n.message))),r=!0;return r}var Ni=class{constructor(){this.first=!0}update(t,r){let n=Math.floor(t);return this.first?(this.first=!1,this.lastIntegerZoom=n,this.lastIntegerZoomTime=0,this.lastZoom=t,this.lastFloorZoom=n,!0):(this.lastFloorZoom>n?(this.lastIntegerZoom=n+1,this.lastIntegerZoomTime=r):this.lastFloorZoom<n&&(this.lastIntegerZoom=n,this.lastIntegerZoomTime=r),t!==this.lastZoom?(this.lastZoom=t,this.lastFloorZoom=n,!0):!1)}};var V={"Latin-1 Supplement":e=>e>=128&&e<=255,Arabic:e=>e>=1536&&e<=1791,"Arabic Supplement":e=>e>=1872&&e<=1919,"Arabic Extended-A":e=>e>=2208&&e<=2303,"Hangul Jamo":e=>e>=4352&&e<=4607,"Unified Canadian Aboriginal Syllabics":e=>e>=5120&&e<=5759,Khmer:e=>e>=6016&&e<=6143,"Unified Canadian Aboriginal Syllabics Extended":e=>e>=6320&&e<=6399,"General Punctuation":e=>e>=8192&&e<=8303,"Letterlike Symbols":e=>e>=8448&&e<=8527,"Number Forms":e=>e>=8528&&e<=8591,"Miscellaneous Technical":e=>e>=8960&&e<=9215,"Control Pictures":e=>e>=9216&&e<=9279,"Optical Character Recognition":e=>e>=9280&&e<=9311,"Enclosed Alphanumerics":e=>e>=9312&&e<=9471,"Geometric Shapes":e=>e>=9632&&e<=9727,"Miscellaneous Symbols":e=>e>=9728&&e<=9983,"Miscellaneous Symbols and Arrows":e=>e>=11008&&e<=11263,"CJK Radicals Supplement":e=>e>=11904&&e<=12031,"Kangxi Radicals":e=>e>=12032&&e<=12255,"Ideographic Description Characters":e=>e>=12272&&e<=12287,"CJK Symbols and Punctuation":e=>e>=12288&&e<=12351,Hiragana:e=>e>=12352&&e<=12447,Katakana:e=>e>=12448&&e<=12543,Bopomofo:e=>e>=12544&&e<=12591,"Hangul Compatibility Jamo":e=>e>=12592&&e<=12687,Kanbun:e=>e>=12688&&e<=12703,"Bopomofo Extended":e=>e>=12704&&e<=12735,"CJK Strokes":e=>e>=12736&&e<=12783,"Katakana Phonetic Extensions":e=>e>=12784&&e<=12799,"Enclosed CJK Letters and Months":e=>e>=12800&&e<=13055,"CJK Compatibility":e=>e>=13056&&e<=13311,"CJK Unified Ideographs Extension A":e=>e>=13312&&e<=19903,"Yijing Hexagram Symbols":e=>e>=19904&&e<=19967,"CJK Unified Ideographs":e=>e>=19968&&e<=40959,"Yi Syllables":e=>e>=40960&&e<=42127,"Yi Radicals":e=>e>=42128&&e<=42191,"Hangul Jamo Extended-A":e=>e>=43360&&e<=43391,"Hangul Syllables":e=>e>=44032&&e<=55215,"Hangul Jamo Extended-B":e=>e>=55216&&e<=55295,"Private Use Area":e=>e>=57344&&e<=63743,"CJK Compatibility Ideographs":e=>e>=63744&&e<=64255,"Arabic Presentation Forms-A":e=>e>=64336&&e<=65023,"Vertical Forms":e=>e>=65040&&e<=65055,"CJK Compatibility Forms":e=>e>=65072&&e<=65103,"Small Form Variants":e=>e>=65104&&e<=65135,"Arabic Presentation Forms-B":e=>e>=65136&&e<=65279,"Halfwidth and Fullwidth Forms":e=>e>=65280&&e<=65519};function on(e){for(let t of e)if(Ui(t.charCodeAt(0)))return!0;return!1}function wu(e){for(let t of e)if(!zm(t.charCodeAt(0)))return!1;return!0}function zm(e){return!(V.Arabic(e)||V["Arabic Supplement"](e)||V["Arabic Extended-A"](e)||V["Arabic Presentation Forms-A"](e)||V["Arabic Presentation Forms-B"](e))}function Au(e){return e<11904?!1:!!(V["Bopomofo Extended"](e)||V.Bopomofo(e)||V["CJK Compatibility Forms"](e)||V["CJK Compatibility Ideographs"](e)||V["CJK Compatibility"](e)||V["CJK Radicals Supplement"](e)||V["CJK Strokes"](e)||V["CJK Symbols and Punctuation"](e)||V["CJK Unified Ideographs Extension A"](e)||V["CJK Unified Ideographs"](e)||V["Enclosed CJK Letters and Months"](e)||V["Halfwidth and Fullwidth Forms"](e)||V.Hiragana(e)||V["Ideographic Description Characters"](e)||V["Kangxi Radicals"](e)||V["Katakana Phonetic Extensions"](e)||V.Katakana(e)||V["Vertical Forms"](e)||V["Yi Radicals"](e)||V["Yi Syllables"](e))}function Ui(e){return e===746||e===747?!0:e<4352?!1:!!(V["Bopomofo Extended"](e)||V.Bopomofo(e)||V["CJK Compatibility Forms"](e)&&!(e>=65097&&e<=65103)||V["CJK Compatibility Ideographs"](e)||V["CJK Compatibility"](e)||V["CJK Radicals Supplement"](e)||V["CJK Strokes"](e)||V["CJK Symbols and Punctuation"](e)&&!(e>=12296&&e<=12305)&&!(e>=12308&&e<=12319)&&e!==12336||V["CJK Unified Ideographs Extension A"](e)||V["CJK Unified Ideographs"](e)||V["Enclosed CJK Letters and Months"](e)||V["Hangul Compatibility Jamo"](e)||V["Hangul Jamo Extended-A"](e)||V["Hangul Jamo Extended-B"](e)||V["Hangul Jamo"](e)||V["Hangul Syllables"](e)||V.Hiragana(e)||V["Ideographic Description Characters"](e)||V.Kanbun(e)||V["Kangxi Radicals"](e)||V["Katakana Phonetic Extensions"](e)||V.Katakana(e)&&e!==12540||V["Halfwidth and Fullwidth Forms"](e)&&e!==65288&&e!==65289&&e!==65293&&!(e>=65306&&e<=65310)&&e!==65339&&e!==65341&&e!==65343&&!(e>=65371&&e<=65503)&&e!==65507&&!(e>=65512&&e<=65519)||V["Small Form Variants"](e)&&!(e>=65112&&e<=65118)&&!(e>=65123&&e<=65126)||V["Unified Canadian Aboriginal Syllabics"](e)||V["Unified Canadian Aboriginal Syllabics Extended"](e)||V["Vertical Forms"](e)||V["Yijing Hexagram Symbols"](e)||V["Yi Syllables"](e)||V["Yi Radicals"](e))}function Rm(e){return!!(V["Latin-1 Supplement"](e)&&(e===167||e===169||e===174||e===177||e===188||e===189||e===190||e===215||e===247)||V["General Punctuation"](e)&&(e===8214||e===8224||e===8225||e===8240||e===8241||e===8251||e===8252||e===8258||e===8263||e===8264||e===8265||e===8273)||V["Letterlike Symbols"](e)||V["Number Forms"](e)||V["Miscellaneous Technical"](e)&&(e>=8960&&e<=8967||e>=8972&&e<=8991||e>=8996&&e<=9e3||e===9003||e>=9085&&e<=9114||e>=9150&&e<=9165||e===9167||e>=9169&&e<=9179||e>=9186&&e<=9215)||V["Control Pictures"](e)&&e!==9251||V["Optical Character Recognition"](e)||V["Enclosed Alphanumerics"](e)||V["Geometric Shapes"](e)||V["Miscellaneous Symbols"](e)&&!(e>=9754&&e<=9759)||V["Miscellaneous Symbols and Arrows"](e)&&(e>=11026&&e<=11055||e>=11088&&e<=11097||e>=11192&&e<=11243)||V["CJK Symbols and Punctuation"](e)||V.Katakana(e)||V["Private Use Area"](e)||V["CJK Compatibility Forms"](e)||V["Small Form Variants"](e)||V["Halfwidth and Fullwidth Forms"](e)||e===8734||e===8756||e===8757||e>=9984&&e<=10087||e>=10102&&e<=10131||e===65532||e===65533)}function Ka(e){return!(Ui(e)||Rm(e))}function _u(e){return V.Arabic(e)||V["Arabic Supplement"](e)||V["Arabic Extended-A"](e)||V["Arabic Presentation Forms-A"](e)||V["Arabic Presentation Forms-B"](e)}function Iu(e){return e>=1424&&e<=2303||V["Arabic Presentation Forms-A"](e)||V["Arabic Presentation Forms-B"](e)}function Om(e,t){return!(!t&&Iu(e)||e>=2304&&e<=3583||e>=3840&&e<=4255||V.Khmer(e))}function Cu(e){for(let t of e)if(Iu(t.charCodeAt(0)))return!0;return!1}function ku(e,t){for(let r of e)if(!Om(r.charCodeAt(0),t))return!1;return!0}var Nm=typeof performance<"u"&&performance&&performance.now?performance.now.bind(performance):Date.now.bind(Date),$i,Ya,Um={now:Nm,frame(e){let t=requestAnimationFrame(e);return{cancel:()=>cancelAnimationFrame(t)}},getImageData(e,t=0){return this.getImageCanvasContext(e).getImageData(-t,-t,e.width+2*t,e.height+2*t)},getImageCanvasContext(e){let t=window.document.createElement("canvas"),r=t.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("failed to create canvas 2d context");return t.width=e.width,t.height=e.height,r.drawImage(e,0,0,e.width,e.height),r},resolveURL(e){return $i||($i=document.createElement("a")),$i.href=e,$i.href},hardwareConcurrency:typeof navigator<"u"&&navigator.hardwareConcurrency||4,get prefersReducedMotion(){return matchMedia?(Ya==null&&(Ya=matchMedia("(prefers-reduced-motion: reduce)")),Ya.matches):!1}};var Xa={unavailable:"unavailable",deferred:"deferred",loading:"loading",loaded:"loaded",error:"error"};var Gi=Xa.unavailable,Tu=null;var Db=new dr,Eu=function(){return Gi};var ae={applyArabicShaping:null,processBidirectionalText:null,processStyledBidirectionalText:null,isLoaded(){return Gi===Xa.loaded||ae.applyArabicShaping!=null},isLoading(){return Gi===Xa.loading},setState(e){if(!Ie())throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");Gi=e.pluginStatus,Tu=e.pluginURL},isParsed(){if(!Ie())throw new Error("rtl-text-plugin is only parsed on the worker-threads");return ae.applyArabicShaping!=null&&ae.processBidirectionalText!=null&&ae.processStyledBidirectionalText!=null},getPluginURL(){if(!Ie())throw new Error("rtl-text-plugin url can only be queried from the worker threads");return Tu}};var q=class{constructor(t,r){this.zoom=t,r?(this.now=r.now,this.fadeDuration=r.fadeDuration,this.zoomHistory=r.zoomHistory,this.transition=r.transition):(this.now=0,this.fadeDuration=0,this.zoomHistory=new Ni,this.transition={})}isSupportedScript(t){return ku(t,ae.isLoaded())}crossFadingFactor(){return this.fadeDuration===0?1:Math.min((this.now-this.zoomHistory.lastIntegerZoomTime)/this.fadeDuration,1)}getCrossfadeParameters(){let t=this.zoom,r=t-Math.floor(t),n=this.crossFadingFactor();return t>this.zoomHistory.lastIntegerZoom?{fromScale:2,toScale:1,t:r+(1-r)*n}:{fromScale:.5,toScale:1,t:1-(1-n)*r}}};var gr=class{constructor(t,r){this.property=t,this.value=r,this.expression=Yl(r===void 0?t.specification.default:r,t.specification)}isDataDriven(){return this.expression.kind==="source"||this.expression.kind==="composite"}possiblyEvaluate(t,r,n){return this.property.possiblyEvaluate(this,t,r,n)}},an=class{constructor(t){this.property=t,this.value=new gr(t,void 0)}transitioned(t,r){return new ji(this.property,this.value,r,Ae({},t.transition,this.transition),t.now)}untransitioned(){return new ji(this.property,this.value,null,{},0)}},qi=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitionablePropertyValues)}getValue(t){return tt(this._values[t].value.value)}setValue(t,r){Object.prototype.hasOwnProperty.call(this._values,t)||(this._values[t]=new an(this._values[t].property)),this._values[t].value=new gr(this._values[t].property,r===null?void 0:tt(r))}getTransition(t){return tt(this._values[t].transition)}setTransition(t,r){Object.prototype.hasOwnProperty.call(this._values,t)||(this._values[t]=new an(this._values[t].property)),this._values[t].transition=tt(r)||void 0}serialize(){let t={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(t[r]=n);let i=this.getTransition(r);i!==void 0&&(t["".concat(r,"-transition")]=i)}return t}transitioned(t,r){let n=new Zi(this._properties);for(let i of Object.keys(this._values))n._values[i]=this._values[i].transitioned(t,r._values[i]);return n}untransitioned(){let t=new Zi(this._properties);for(let r of Object.keys(this._values))t._values[r]=this._values[r].untransitioned();return t}},ji=class{constructor(t,r,n,i,o){this.property=t,this.value=r,this.begin=o+i.delay||0,this.end=this.begin+i.duration||0,t.specification.transition&&(i.delay||i.duration)&&(this.prior=n)}possiblyEvaluate(t,r,n){let i=t.now||0,o=this.value.possiblyEvaluate(t,r,n),a=this.prior;if(a){if(i>this.end)return this.prior=null,o;if(this.value.isDataDriven())return this.prior=null,o;if(i<this.begin)return a.possiblyEvaluate(t,r,n);{let s=(i-this.begin)/(this.end-this.begin);return this.property.interpolate(a.possiblyEvaluate(t,r,n),o,yl(s))}}else return o}},Zi=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultTransitioningPropertyValues)}possiblyEvaluate(t,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(t,r,n);return i}hasTransition(){for(let t of Object.keys(this._values))if(this._values[t].prior)return!0;return!1}},Ji=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultPropertyValues)}getValue(t){return tt(this._values[t].value)}setValue(t,r){this._values[t]=new gr(this._values[t].property,r===null?void 0:tt(r))}serialize(){let t={};for(let r of Object.keys(this._values)){let n=this.getValue(r);n!==void 0&&(t[r]=n)}return t}possiblyEvaluate(t,r,n){let i=new vt(this._properties);for(let o of Object.keys(this._values))i._values[o]=this._values[o].possiblyEvaluate(t,r,n);return i}},be=class{constructor(t,r,n){this.property=t,this.value=r,this.parameters=n}isConstant(){return this.value.kind==="constant"}constantOr(t){return this.value.kind==="constant"?this.value.value:t}evaluate(t,r,n,i){return this.property.evaluate(this.value,this.parameters,t,r,n,i)}},vt=class{constructor(t){this._properties=t,this._values=Object.create(t.defaultPossiblyEvaluatedValues)}get(t){return this._values[t]}},z=class{constructor(t){this.specification=t}possiblyEvaluate(t,r){if(t.isDataDriven())throw new Error("Value should not be data driven");return t.expression.evaluate(r)}interpolate(t,r,n){let i=this.specification.type,o=Re[i];return o?o(t,r,n):t}},R=class{constructor(t,r){this.specification=t,this.overrides=r}possiblyEvaluate(t,r,n,i){return t.expression.kind==="constant"||t.expression.kind==="camera"?new be(this,{kind:"constant",value:t.expression.evaluate(r,null,{},n,i)},r):new be(this,t.expression,r)}interpolate(t,r,n){if(t.value.kind!=="constant"||r.value.kind!=="constant")return t;if(t.value.value===void 0||r.value.value===void 0)return new be(this,{kind:"constant",value:void 0},t.parameters);let i=this.specification.type,o=Re[i];if(o){let a=o(t.value.value,r.value.value,n);return new be(this,{kind:"constant",value:a},t.parameters)}else return t}evaluate(t,r,n,i,o,a){return t.kind==="constant"?t.value:t.evaluate(r,n,i,o,a)}},st=class extends R{possiblyEvaluate(t,r,n,i){if(t.value===void 0)return new be(this,{kind:"constant",value:void 0},r);if(t.expression.kind==="constant"){let o=t.expression.evaluate(r,null,{},n,i),s=t.property.specification.type==="resolvedImage"&&typeof o!="string"?o.name:o,l=this._calculate(s,s,s,r);return new be(this,{kind:"constant",value:l},r)}else if(t.expression.kind==="camera"){let o=this._calculate(t.expression.evaluate({zoom:r.zoom-1}),t.expression.evaluate({zoom:r.zoom}),t.expression.evaluate({zoom:r.zoom+1}),r);return new be(this,{kind:"constant",value:o},r)}else return new be(this,t.expression,r)}evaluate(t,r,n,i,o,a){if(t.kind==="source"){let s=t.evaluate(r,n,i,o,a);return this._calculate(s,s,s,r)}else return t.kind==="composite"?this._calculate(t.evaluate({zoom:Math.floor(r.zoom)-1},n,i),t.evaluate({zoom:Math.floor(r.zoom)},n,i),t.evaluate({zoom:Math.floor(r.zoom)+1},n,i),r):t.value}_calculate(t,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:t,to:r}:{from:n,to:r}}interpolate(t){return t}},Ot=class{constructor(t){this.specification=t}possiblyEvaluate(t,r,n,i){if(t.value!==void 0)if(t.expression.kind==="constant"){let o=t.expression.evaluate(r,null,{},n,i);return this._calculate(o,o,o,r)}else return this._calculate(t.expression.evaluate(new q(Math.floor(r.zoom-1),r)),t.expression.evaluate(new q(Math.floor(r.zoom),r)),t.expression.evaluate(new q(Math.floor(r.zoom+1),r)),r)}_calculate(t,r,n,i){return i.zoom>i.zoomHistory.lastIntegerZoom?{from:t,to:r}:{from:n,to:r}}interpolate(t){return t}},Nt=class{constructor(t){this.specification=t}possiblyEvaluate(t,r,n,i){return!!t.expression.evaluate(r,null,{},n,i)}interpolate(){return!1}},ie=class{constructor(t){this.properties=t,this.defaultPropertyValues={},this.defaultTransitionablePropertyValues={},this.defaultTransitioningPropertyValues={},this.defaultPossiblyEvaluatedValues={},this.overridableProperties=[];for(let r in t){let n=t[r];n.specification.overridable&&this.overridableProperties.push(r);let i=this.defaultPropertyValues[r]=new gr(n,void 0),o=this.defaultTransitionablePropertyValues[r]=new an(n);this.defaultTransitioningPropertyValues[r]=o.untransitioned(),this.defaultPossiblyEvaluatedValues[r]=i.possiblyEvaluate({})}}};k("DataDrivenProperty",R);k("DataConstantProperty",z);k("CrossFadedDataDrivenProperty",st);k("CrossFadedProperty",Ot);k("ColorRampProperty",Nt);var Wi="-transition",le=class extends dr{constructor(r,n){super();if(this.id=r.id,this.type=r.type,this._featureFilter={filter:()=>!0,needGeometry:!1},r.type!=="custom"&&(r=r,this.metadata=r.metadata,this.minzoom=r.minzoom,this.maxzoom=r.maxzoom,r.type!=="background"&&(this.source=r.source,this.sourceLayer=r["source-layer"],this.filter=r.filter),n.layout&&(this._unevaluatedLayout=new Ji(n.layout)),n.paint)){this._transitionablePaint=new qi(n.paint);for(let i in r.paint)this.setPaintProperty(i,r.paint[i],{validate:!1});for(let i in r.layout)this.setLayoutProperty(i,r.layout[i],{validate:!1});this._transitioningPaint=this._transitionablePaint.untransitioned(),this.paint=new vt(n.paint)}}getCrossfadeParameters(){return this._crossfadeParameters}getLayoutProperty(r){return r==="visibility"?this.visibility:this._unevaluatedLayout.getValue(r)}setLayoutProperty(r,n,i={}){if(n!=null){let o="layers.".concat(this.id,".layout.").concat(r);if(this._validate(Pu,o,r,n,i))return}if(r==="visibility"){this.visibility=n;return}this._unevaluatedLayout.setValue(r,n)}getPaintProperty(r){return r.endsWith(Wi)?this._transitionablePaint.getTransition(r.slice(0,-Wi.length)):this._transitionablePaint.getValue(r)}setPaintProperty(r,n,i={}){if(n!=null){let o="layers.".concat(this.id,".paint.").concat(r);if(this._validate(vu,o,r,n,i))return!1}if(r.endsWith(Wi))return this._transitionablePaint.setTransition(r.slice(0,-Wi.length),n||void 0),!1;{let o=this._transitionablePaint._values[r],a=o.property.specification["property-type"]==="cross-faded-data-driven",s=o.value.isDataDriven(),l=o.value;this._transitionablePaint.setValue(r,n),this._handleSpecialPaintPropertyUpdate(r);let u=this._transitionablePaint._values[r].value;return u.isDataDriven()||s||a||this._handleOverridablePaintPropertyUpdate(r,l,u)}}_handleSpecialPaintPropertyUpdate(r){}_handleOverridablePaintPropertyUpdate(r,n,i){return!1}isHidden(r){return this.minzoom&&r<this.minzoom||this.maxzoom&&r>=this.maxzoom?!0:this.visibility==="none"}updateTransitions(r){this._transitioningPaint=this._transitionablePaint.transitioned(r,this._transitioningPaint)}hasTransition(){return this._transitioningPaint.hasTransition()}recalculate(r,n){r.getCrossfadeParameters&&(this._crossfadeParameters=r.getCrossfadeParameters()),this._unevaluatedLayout&&(this.layout=this._unevaluatedLayout.possiblyEvaluate(r,void 0,n)),this.paint=this._transitioningPaint.possiblyEvaluate(r,void 0,n)}serialize(){let r={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:this._unevaluatedLayout&&this._unevaluatedLayout.serialize(),paint:this._transitionablePaint&&this._transitionablePaint.serialize()};return this.visibility&&(r.layout=r.layout||{},r.layout.visibility=this.visibility),dl(r,(n,i)=>n!==void 0&&!(i==="layout"&&!Object.keys(n).length)&&!(i==="paint"&&!Object.keys(n).length))}_validate(r,n,i,o,a={}){return a&&a.validate===!1?!1:Su(this,r.call(bt,{key:n,layerType:this.type,objectKey:i,value:o,styleSpec:S,style:{glyphs:!0,sprite:!0}}))}is3D(){return!1}isTileClipped(){return!1}hasOffscreenPass(){return!1}resize(){}isStateDependent(){for(let r in this.paint._values){let n=this.paint.get(r);if(!(!(n instanceof be)||!ht(n.property.specification))&&(n.value.kind==="source"||n.value.kind==="composite")&&n.value.isStateDependent)return!0}return!1}};var $m={Int8:Int8Array,Uint8:Uint8Array,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array},Ut=class{constructor(t,r){this._structArray=t,this._pos1=r*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8}},Gm=128,qm=5,te=class{constructor(){this.isTransferred=!1,this.capacity=-1,this.resize(0)}static serialize(t,r){return t._trim(),r&&(t.isTransferred=!0,r.push(t.arrayBuffer)),{length:t.length,arrayBuffer:t.arrayBuffer}}static deserialize(t){let r=Object.create(this.prototype);return r.arrayBuffer=t.arrayBuffer,r.length=t.length,r.capacity=t.arrayBuffer.byteLength/r.bytesPerElement,r._refreshViews(),r}_trim(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews())}clear(){this.length=0}resize(t){this.reserve(t),this.length=t}reserve(t){if(t>this.capacity){this.capacity=Math.max(t,Math.floor(this.capacity*qm),Gm),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);let r=this.uint8;this._refreshViews(),r&&this.uint8.set(r)}}_refreshViews(){throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")}};function ee(e,t=1){let r=0,n=0,i=e.map(a=>{let s=jm(a.type),l=r=Fu(r,Math.max(t,s)),u=a.components||1;return n=Math.max(n,s),r+=s*u,{name:a.name,type:a.type,components:u,offset:l}}),o=Fu(r,Math.max(n,t));return{members:i,size:o,alignment:t}}function jm(e){return $m[e].BYTES_PER_ELEMENT}function Fu(e,t){return Math.ceil(e/t)*t}var Mu=Z(he(),1),$t=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n){let i=this.length;return this.resize(i+1),this.emplace(i,r,n)}emplace(r,n,i){let o=r*2;return this.int16[o+0]=n,this.int16[o+1]=i,r}};$t.prototype.bytesPerElement=4;k("StructArrayLayout2i4",$t);var sn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,r,n,i)}emplace(r,n,i,o){let a=r*3;return this.int16[a+0]=n,this.int16[a+1]=i,this.int16[a+2]=o,r}};sn.prototype.bytesPerElement=6;k("StructArrayLayout3i6",sn);var Hi=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,r,n,i,o)}emplace(r,n,i,o,a){let s=r*4;return this.int16[s+0]=n,this.int16[s+1]=i,this.int16[s+2]=o,this.int16[s+3]=a,r}};Hi.prototype.bytesPerElement=8;k("StructArrayLayout4i8",Hi);var ln=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s){let l=this.length;return this.resize(l+1),this.emplace(l,r,n,i,o,a,s)}emplace(r,n,i,o,a,s,l){let u=r*6;return this.int16[u+0]=n,this.int16[u+1]=i,this.int16[u+2]=o,this.int16[u+3]=a,this.int16[u+4]=s,this.int16[u+5]=l,r}};ln.prototype.bytesPerElement=12;k("StructArrayLayout2i4i12",ln);var un=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s){let l=this.length;return this.resize(l+1),this.emplace(l,r,n,i,o,a,s)}emplace(r,n,i,o,a,s,l){let u=r*4,c=r*8;return this.int16[u+0]=n,this.int16[u+1]=i,this.uint8[c+4]=o,this.uint8[c+5]=a,this.uint8[c+6]=s,this.uint8[c+7]=l,r}};un.prototype.bytesPerElement=8;k("StructArrayLayout2i4ub8",un);var Pt=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r,n){let i=this.length;return this.resize(i+1),this.emplace(i,r,n)}emplace(r,n,i){let o=r*2;return this.float32[o+0]=n,this.float32[o+1]=i,r}};Pt.prototype.bytesPerElement=8;k("StructArrayLayout2f8",Pt);var cn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s,l,u,c,p){let f=this.length;return this.resize(f+1),this.emplace(f,r,n,i,o,a,s,l,u,c,p)}emplace(r,n,i,o,a,s,l,u,c,p,f){let y=r*10;return this.uint16[y+0]=n,this.uint16[y+1]=i,this.uint16[y+2]=o,this.uint16[y+3]=a,this.uint16[y+4]=s,this.uint16[y+5]=l,this.uint16[y+6]=u,this.uint16[y+7]=c,this.uint16[y+8]=p,this.uint16[y+9]=f,r}};cn.prototype.bytesPerElement=20;k("StructArrayLayout10ui20",cn);var pn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s,l,u,c,p,f,y){let m=this.length;return this.resize(m+1),this.emplace(m,r,n,i,o,a,s,l,u,c,p,f,y)}emplace(r,n,i,o,a,s,l,u,c,p,f,y,m){let h=r*12;return this.int16[h+0]=n,this.int16[h+1]=i,this.int16[h+2]=o,this.int16[h+3]=a,this.uint16[h+4]=s,this.uint16[h+5]=l,this.uint16[h+6]=u,this.uint16[h+7]=c,this.int16[h+8]=p,this.int16[h+9]=f,this.int16[h+10]=y,this.int16[h+11]=m,r}};pn.prototype.bytesPerElement=24;k("StructArrayLayout4i4ui4i24",pn);var fn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,r,n,i)}emplace(r,n,i,o){let a=r*3;return this.float32[a+0]=n,this.float32[a+1]=i,this.float32[a+2]=o,r}};fn.prototype.bytesPerElement=12;k("StructArrayLayout3f12",fn);var yn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer)}emplaceBack(r){let n=this.length;return this.resize(n+1),this.emplace(n,r)}emplace(r,n){let i=r*1;return this.uint32[i+0]=n,r}};yn.prototype.bytesPerElement=4;k("StructArrayLayout1ul4",yn);var mn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s,l,u,c){let p=this.length;return this.resize(p+1),this.emplace(p,r,n,i,o,a,s,l,u,c)}emplace(r,n,i,o,a,s,l,u,c,p){let f=r*10,y=r*5;return this.int16[f+0]=n,this.int16[f+1]=i,this.int16[f+2]=o,this.int16[f+3]=a,this.int16[f+4]=s,this.int16[f+5]=l,this.uint32[y+3]=u,this.uint16[f+8]=c,this.uint16[f+9]=p,r}};mn.prototype.bytesPerElement=20;k("StructArrayLayout6i1ul2ui20",mn);var hn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s){let l=this.length;return this.resize(l+1),this.emplace(l,r,n,i,o,a,s)}emplace(r,n,i,o,a,s,l){let u=r*6;return this.int16[u+0]=n,this.int16[u+1]=i,this.int16[u+2]=o,this.int16[u+3]=a,this.int16[u+4]=s,this.int16[u+5]=l,r}};hn.prototype.bytesPerElement=12;k("StructArrayLayout2i2i2i12",hn);var Ki=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a){let s=this.length;return this.resize(s+1),this.emplace(s,r,n,i,o,a)}emplace(r,n,i,o,a,s){let l=r*4,u=r*8;return this.float32[l+0]=n,this.float32[l+1]=i,this.float32[l+2]=o,this.int16[u+6]=a,this.int16[u+7]=s,r}};Ki.prototype.bytesPerElement=16;k("StructArrayLayout2f1f2i16",Ki);var dn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,r,n,i,o)}emplace(r,n,i,o,a){let s=r*12,l=r*3;return this.uint8[s+0]=n,this.uint8[s+1]=i,this.float32[l+1]=o,this.float32[l+2]=a,r}};dn.prototype.bytesPerElement=12;k("StructArrayLayout2ub2f12",dn);var gn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,r,n,i)}emplace(r,n,i,o){let a=r*3;return this.uint16[a+0]=n,this.uint16[a+1]=i,this.uint16[a+2]=o,r}};gn.prototype.bytesPerElement=6;k("StructArrayLayout3ui6",gn);var xn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v){let b=this.length;return this.resize(b+1),this.emplace(b,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v)}emplace(r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v,b){let x=r*24,P=r*12,w=r*48;return this.int16[x+0]=n,this.int16[x+1]=i,this.uint16[x+2]=o,this.uint16[x+3]=a,this.uint32[P+2]=s,this.uint32[P+3]=l,this.uint32[P+4]=u,this.uint16[x+10]=c,this.uint16[x+11]=p,this.uint16[x+12]=f,this.float32[P+7]=y,this.float32[P+8]=m,this.uint8[w+36]=h,this.uint8[w+37]=d,this.uint8[w+38]=g,this.uint32[P+10]=v,this.int16[x+22]=b,r}};xn.prototype.bytesPerElement=48;k("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48",xn);var bn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.int16=new Int16Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v,b,x,P,w,A,T,I,E,_,F,M){let B=this.length;return this.resize(B+1),this.emplace(B,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v,b,x,P,w,A,T,I,E,_,F,M)}emplace(r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v,b,x,P,w,A,T,I,E,_,F,M,B){let C=r*34,O=r*17;return this.int16[C+0]=n,this.int16[C+1]=i,this.int16[C+2]=o,this.int16[C+3]=a,this.int16[C+4]=s,this.int16[C+5]=l,this.int16[C+6]=u,this.int16[C+7]=c,this.uint16[C+8]=p,this.uint16[C+9]=f,this.uint16[C+10]=y,this.uint16[C+11]=m,this.uint16[C+12]=h,this.uint16[C+13]=d,this.uint16[C+14]=g,this.uint16[C+15]=v,this.uint16[C+16]=b,this.uint16[C+17]=x,this.uint16[C+18]=P,this.uint16[C+19]=w,this.uint16[C+20]=A,this.uint16[C+21]=T,this.uint16[C+22]=I,this.uint32[O+12]=E,this.float32[O+13]=_,this.float32[O+14]=F,this.float32[O+15]=M,this.float32[O+16]=B,r}};bn.prototype.bytesPerElement=68;k("StructArrayLayout8i15ui1ul4f68",bn);var Gt=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r){let n=this.length;return this.resize(n+1),this.emplace(n,r)}emplace(r,n){let i=r*1;return this.float32[i+0]=n,r}};Gt.prototype.bytesPerElement=4;k("StructArrayLayout1f4",Gt);var vn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint32=new Uint32Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r,n,i){let o=this.length;return this.resize(o+1),this.emplace(o,r,n,i)}emplace(r,n,i,o){let a=r*2,s=r*4;return this.uint32[a+0]=n,this.uint16[s+2]=i,this.uint16[s+3]=o,r}};vn.prototype.bytesPerElement=8;k("StructArrayLayout1ul2ui8",vn);var Pn=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r,n){let i=this.length;return this.resize(i+1),this.emplace(i,r,n)}emplace(r,n,i){let o=r*2;return this.uint16[o+0]=n,this.uint16[o+1]=i,r}};Pn.prototype.bytesPerElement=4;k("StructArrayLayout2ui4",Pn);var Yi=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.uint16=new Uint16Array(this.arrayBuffer)}emplaceBack(r){let n=this.length;return this.resize(n+1),this.emplace(n,r)}emplace(r,n){let i=r*1;return this.uint16[i+0]=n,r}};Yi.prototype.bytesPerElement=2;k("StructArrayLayout1ui2",Yi);var xr=class extends te{_refreshViews(){this.uint8=new Uint8Array(this.arrayBuffer),this.float32=new Float32Array(this.arrayBuffer)}emplaceBack(r,n,i,o){let a=this.length;return this.resize(a+1),this.emplace(a,r,n,i,o)}emplace(r,n,i,o,a){let s=r*4;return this.float32[s+0]=n,this.float32[s+1]=i,this.float32[s+2]=o,this.float32[s+3]=a,r}};xr.prototype.bytesPerElement=16;k("StructArrayLayout4f16",xr);var Xi=class extends Ut{get anchorPointX(){return this._structArray.int16[this._pos2+0]}get anchorPointY(){return this._structArray.int16[this._pos2+1]}get x1(){return this._structArray.int16[this._pos2+2]}get y1(){return this._structArray.int16[this._pos2+3]}get x2(){return this._structArray.int16[this._pos2+4]}get y2(){return this._structArray.int16[this._pos2+5]}get featureIndex(){return this._structArray.uint32[this._pos4+3]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+8]}get bucketIndex(){return this._structArray.uint16[this._pos2+9]}get anchorPoint(){return new Mu.default(this.anchorPointX,this.anchorPointY)}};Xi.prototype.size=20;var Sn=class extends mn{get(t){return new Xi(this,t)}};k("CollisionBoxArray",Sn);var Qi=class extends Ut{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get glyphStartIndex(){return this._structArray.uint16[this._pos2+2]}get numGlyphs(){return this._structArray.uint16[this._pos2+3]}get vertexStartIndex(){return this._structArray.uint32[this._pos4+2]}get lineStartIndex(){return this._structArray.uint32[this._pos4+3]}get lineLength(){return this._structArray.uint32[this._pos4+4]}get segment(){return this._structArray.uint16[this._pos2+10]}get lowerSize(){return this._structArray.uint16[this._pos2+11]}get upperSize(){return this._structArray.uint16[this._pos2+12]}get lineOffsetX(){return this._structArray.float32[this._pos4+7]}get lineOffsetY(){return this._structArray.float32[this._pos4+8]}get writingMode(){return this._structArray.uint8[this._pos1+36]}get placedOrientation(){return this._structArray.uint8[this._pos1+37]}set placedOrientation(r){this._structArray.uint8[this._pos1+37]=r}get hidden(){return this._structArray.uint8[this._pos1+38]}set hidden(r){this._structArray.uint8[this._pos1+38]=r}get crossTileID(){return this._structArray.uint32[this._pos4+10]}set crossTileID(r){this._structArray.uint32[this._pos4+10]=r}get associatedIconIndex(){return this._structArray.int16[this._pos2+22]}};Qi.prototype.size=48;var wn=class extends xn{get(t){return new Qi(this,t)}};k("PlacedSymbolArray",wn);var eo=class extends Ut{get anchorX(){return this._structArray.int16[this._pos2+0]}get anchorY(){return this._structArray.int16[this._pos2+1]}get rightJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+2]}get centerJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+3]}get leftJustifiedTextSymbolIndex(){return this._structArray.int16[this._pos2+4]}get verticalPlacedTextSymbolIndex(){return this._structArray.int16[this._pos2+5]}get placedIconSymbolIndex(){return this._structArray.int16[this._pos2+6]}get verticalPlacedIconSymbolIndex(){return this._structArray.int16[this._pos2+7]}get key(){return this._structArray.uint16[this._pos2+8]}get textBoxStartIndex(){return this._structArray.uint16[this._pos2+9]}get textBoxEndIndex(){return this._structArray.uint16[this._pos2+10]}get verticalTextBoxStartIndex(){return this._structArray.uint16[this._pos2+11]}get verticalTextBoxEndIndex(){return this._structArray.uint16[this._pos2+12]}get iconBoxStartIndex(){return this._structArray.uint16[this._pos2+13]}get iconBoxEndIndex(){return this._structArray.uint16[this._pos2+14]}get verticalIconBoxStartIndex(){return this._structArray.uint16[this._pos2+15]}get verticalIconBoxEndIndex(){return this._structArray.uint16[this._pos2+16]}get featureIndex(){return this._structArray.uint16[this._pos2+17]}get numHorizontalGlyphVertices(){return this._structArray.uint16[this._pos2+18]}get numVerticalGlyphVertices(){return this._structArray.uint16[this._pos2+19]}get numIconVertices(){return this._structArray.uint16[this._pos2+20]}get numVerticalIconVertices(){return this._structArray.uint16[this._pos2+21]}get useRuntimeCollisionCircles(){return this._structArray.uint16[this._pos2+22]}get crossTileID(){return this._structArray.uint32[this._pos4+12]}set crossTileID(r){this._structArray.uint32[this._pos4+12]=r}get textBoxScale(){return this._structArray.float32[this._pos4+13]}get textOffset0(){return this._structArray.float32[this._pos4+14]}get textOffset1(){return this._structArray.float32[this._pos4+15]}get collisionCircleDiameter(){return this._structArray.float32[this._pos4+16]}};eo.prototype.size=68;var An=class extends bn{get(t){return new eo(this,t)}};k("SymbolInstanceArray",An);var _n=class extends Gt{getoffsetX(t){return this.float32[t*1+0]}};k("GlyphOffsetArray",_n);var In=class extends sn{getx(t){return this.int16[t*3+0]}gety(t){return this.int16[t*3+1]}gettileUnitDistanceFromAnchor(t){return this.int16[t*3+2]}};k("SymbolLineVertexArray",In);var to=class extends Ut{get featureIndex(){return this._structArray.uint32[this._pos4+0]}get sourceLayerIndex(){return this._structArray.uint16[this._pos2+2]}get bucketIndex(){return this._structArray.uint16[this._pos2+3]}};to.prototype.size=8;var Cn=class extends vn{get(t){return new to(this,t)}};k("FeatureIndexArray",Cn);var ro=class extends $t{};var no=class extends $t{},io=class extends $t{},oo=class extends ln{};var ao=class extends un{},so=class extends Pt{},lt=class extends cn{},lo=class extends pn{},uo=class extends fn{},co=class extends yn{},kn=class extends hn{};var po=class extends dn{};var Le=class extends gn{},St=class extends Pn{};var Zm=ee([{name:"a_pos",components:2,type:"Int16"}],4);var{members:Lu,size:y0,alignment:m0}=Zm;var me=class e{constructor(t=[]){this.segments=t}prepareSegment(t,r,n,i){let o=this.segments[this.segments.length-1];return t>e.MAX_VERTEX_ARRAY_LENGTH&&ce("Max vertices per segment is ".concat(e.MAX_VERTEX_ARRAY_LENGTH,": bucket requested ").concat(t)),(!o||o.vertexLength+t>e.MAX_VERTEX_ARRAY_LENGTH||o.sortKey!==i)&&(o={vertexOffset:r.length,primitiveOffset:n.length,vertexLength:0,primitiveLength:0},i!==void 0&&(o.sortKey=i),this.segments.push(o)),o}get(){return this.segments}destroy(){for(let t of this.segments)for(let r in t.vaos)t.vaos[r].destroy()}static simpleSegment(t,r,n,i){return new e([{vertexOffset:t,primitiveOffset:r,vertexLength:n,primitiveLength:i,vaos:{},sortKey:0}])}};me.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1;k("SegmentVector",me);function Qa(e,t){return e=rt(Math.floor(e),0,255),t=rt(Math.floor(t),0,255),256*e+t}var Tn=ee([{name:"a_pattern_from",components:4,type:"Uint16"},{name:"a_pattern_to",components:4,type:"Uint16"},{name:"a_pixel_ratio_from",components:1,type:"Uint16"},{name:"a_pixel_ratio_to",components:1,type:"Uint16"}]);var Ru=Z(rs(),1);var En=class e{constructor(){this.ids=[],this.positions=[],this.indexed=!1}add(t,r,n,i){this.ids.push(zu(t)),this.positions.push(r,n,i)}getPositions(t){if(!this.indexed)throw new Error("Trying to get index, but feature positions are not indexed");let r=zu(t),n=0,i=this.ids.length-1;for(;n<i;){let a=n+i>>1;this.ids[a]>=r?i=a:n=a+1}let o=[];for(;this.ids[n]===r;){let a=this.positions[3*n],s=this.positions[3*n+1],l=this.positions[3*n+2];o.push({index:a,start:s,end:l}),n++}return o}static serialize(t,r){let n=new Float64Array(t.ids),i=new Uint32Array(t.positions);return ns(n,i,0,n.length-1),r&&r.push(n.buffer,i.buffer),{ids:n,positions:i}}static deserialize(t){let r=new e;return r.ids=t.ids,r.positions=t.positions,r.indexed=!0,r}};function zu(e){let t=+e;return!isNaN(t)&&t<=Number.MAX_SAFE_INTEGER?t:(0,Ru.default)(String(e))}function ns(e,t,r,n){for(;r<n;){let i=e[r+n>>1],o=r-1,a=n+1;for(;;){do o++;while(e[o]<i);do a--;while(e[a]>i);if(o>=a)break;yo(e,o,a),yo(t,3*o,3*a),yo(t,3*o+1,3*a+1),yo(t,3*o+2,3*a+2)}a-r<n-a?(ns(e,t,r,a),r=a+1):(ns(e,t,a+1,n),n=a)}}function yo(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}k("FeaturePositionMap",En);var Fn=class{constructor(t,r){this.gl=t.gl,this.location=r}};var br=class extends Fn{constructor(t,r){super(t,r),this.current=0}set(t){this.current!==t&&(this.current=t,this.gl.uniform1f(this.location,t))}};var mo=class extends Fn{constructor(t,r){super(t,r),this.current=[0,0,0,0]}set(t){(t[0]!==this.current[0]||t[1]!==this.current[1]||t[2]!==this.current[2]||t[3]!==this.current[3])&&(this.current=t,this.gl.uniform4f(this.location,t[0],t[1],t[2],t[3]))}},ho=class extends Fn{constructor(t,r){super(t,r),this.current=W.transparent}set(t){(t.r!==this.current.r||t.g!==this.current.g||t.b!==this.current.b||t.a!==this.current.a)&&(this.current=t,this.gl.uniform4f(this.location,t.r,t.g,t.b,t.a))}},T0=new Float32Array(16);function is(e){return[Qa(255*e.r,255*e.g),Qa(255*e.b,255*e.a)]}var qt=class{constructor(t,r,n){this.value=t,this.uniformNames=r.map(i=>"u_".concat(i)),this.type=n}setUniform(t,r,n){t.set(n.constantOr(this.value))}getBinding(t,r,n){return this.type==="color"?new ho(t,r):new br(t,r)}},wt=class{constructor(t,r){this.uniformNames=r.map(n=>"u_".concat(n)),this.patternFrom=null,this.patternTo=null,this.pixelRatioFrom=1,this.pixelRatioTo=1}setConstantPatternPositions(t,r){this.pixelRatioFrom=r.pixelRatio,this.pixelRatioTo=t.pixelRatio,this.patternFrom=r.tlbr,this.patternTo=t.tlbr}setUniform(t,r,n,i){let o=i==="u_pattern_to"?this.patternTo:i==="u_pattern_from"?this.patternFrom:i==="u_pixel_ratio_to"?this.pixelRatioTo:i==="u_pixel_ratio_from"?this.pixelRatioFrom:null;o&&t.set(o)}getBinding(t,r,n){return n.substr(0,9)==="u_pattern"?new mo(t,r):new br(t,r)}},Je=class{constructor(t,r,n,i){this.expression=t,this.type=n,this.maxValue=0,this.paintVertexAttributes=r.map(o=>({name:"a_".concat(o),type:"Float32",components:n==="color"?2:1,offset:0})),this.paintVertexArray=new i}populatePaintArray(t,r,n,i,o){let a=this.paintVertexArray.length,s=this.expression.evaluate(new q(0),r,{},i,[],o);this.paintVertexArray.resize(t),this._setPaintValue(a,t,s)}updatePaintArray(t,r,n,i){let o=this.expression.evaluate({zoom:0},n,i);this._setPaintValue(t,r,o)}_setPaintValue(t,r,n){if(this.type==="color"){let i=is(n);for(let o=t;o<r;o++)this.paintVertexArray.emplace(o,i[0],i[1])}else{for(let i=t;i<r;i++)this.paintVertexArray.emplace(i,n);this.maxValue=Math.max(this.maxValue,Math.abs(n))}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}},De=class{constructor(t,r,n,i,o,a){this.expression=t,this.uniformNames=r.map(s=>"u_".concat(s,"_t")),this.type=n,this.useIntegerZoom=i,this.zoom=o,this.maxValue=0,this.paintVertexAttributes=r.map(s=>({name:"a_".concat(s),type:"Float32",components:n==="color"?4:2,offset:0})),this.paintVertexArray=new a}populatePaintArray(t,r,n,i,o){let a=this.expression.evaluate(new q(this.zoom),r,{},i,[],o),s=this.expression.evaluate(new q(this.zoom+1),r,{},i,[],o),l=this.paintVertexArray.length;this.paintVertexArray.resize(t),this._setPaintValue(l,t,a,s)}updatePaintArray(t,r,n,i){let o=this.expression.evaluate({zoom:this.zoom},n,i),a=this.expression.evaluate({zoom:this.zoom+1},n,i);this._setPaintValue(t,r,o,a)}_setPaintValue(t,r,n,i){if(this.type==="color"){let o=is(n),a=is(i);for(let s=t;s<r;s++)this.paintVertexArray.emplace(s,o[0],o[1],a[0],a[1])}else{for(let o=t;o<r;o++)this.paintVertexArray.emplace(o,n,i);this.maxValue=Math.max(this.maxValue,Math.abs(n),Math.abs(i))}}upload(t){this.paintVertexArray&&this.paintVertexArray.arrayBuffer&&(this.paintVertexBuffer&&this.paintVertexBuffer.buffer?this.paintVertexBuffer.updateData(this.paintVertexArray):this.paintVertexBuffer=t.createVertexBuffer(this.paintVertexArray,this.paintVertexAttributes,this.expression.isStateDependent))}destroy(){this.paintVertexBuffer&&this.paintVertexBuffer.destroy()}setUniform(t,r){let n=this.useIntegerZoom?Math.floor(r.zoom):r.zoom,i=rt(this.expression.interpolationFactor(n,this.zoom,this.zoom+1),0,1);t.set(i)}getBinding(t,r,n){return new br(t,r)}},Xe=class{constructor(t,r,n,i,o,a){this.expression=t,this.type=r,this.useIntegerZoom=n,this.zoom=i,this.layerId=a,this.zoomInPaintVertexArray=new o,this.zoomOutPaintVertexArray=new o}populatePaintArray(t,r,n){let i=this.zoomInPaintVertexArray.length;this.zoomInPaintVertexArray.resize(t),this.zoomOutPaintVertexArray.resize(t),this._setPaintValues(i,t,r.patterns&&r.patterns[this.layerId],n)}updatePaintArray(t,r,n,i,o){this._setPaintValues(t,r,n.patterns&&n.patterns[this.layerId],o)}_setPaintValues(t,r,n,i){if(!i||!n)return;let{min:o,mid:a,max:s}=n,l=i[o],u=i[a],c=i[s];if(!(!l||!u||!c))for(let p=t;p<r;p++)this.zoomInPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],l.tl[0],l.tl[1],l.br[0],l.br[1],u.pixelRatio,l.pixelRatio),this.zoomOutPaintVertexArray.emplace(p,u.tl[0],u.tl[1],u.br[0],u.br[1],c.tl[0],c.tl[1],c.br[0],c.br[1],u.pixelRatio,c.pixelRatio)}upload(t){this.zoomInPaintVertexArray&&this.zoomInPaintVertexArray.arrayBuffer&&this.zoomOutPaintVertexArray&&this.zoomOutPaintVertexArray.arrayBuffer&&(this.zoomInPaintVertexBuffer=t.createVertexBuffer(this.zoomInPaintVertexArray,Tn.members,this.expression.isStateDependent),this.zoomOutPaintVertexBuffer=t.createVertexBuffer(this.zoomOutPaintVertexArray,Tn.members,this.expression.isStateDependent))}destroy(){this.zoomOutPaintVertexBuffer&&this.zoomOutPaintVertexBuffer.destroy(),this.zoomInPaintVertexBuffer&&this.zoomInPaintVertexBuffer.destroy()}},go=class{constructor(t,r,n){this.binders={},this._buffers=[];let i=[];for(let o in t.paint._values){if(!n(o))continue;let a=t.paint.get(o);if(!(a instanceof be)||!ht(a.property.specification))continue;let s=Km(o,t.type),l=a.value,u=a.property.specification.type,c=a.property.useIntegerZoom,p=a.property.specification["property-type"],f=p==="cross-faded"||p==="cross-faded-data-driven";if(l.kind==="constant")this.binders[o]=f?new wt(l.value,s):new qt(l.value,s,u),i.push("/u_".concat(o));else if(l.kind==="source"||f){let y=Ou(o,u,"source");this.binders[o]=f?new Xe(l,u,c,r,y,t.id):new Je(l,s,u,y),i.push("/a_".concat(o))}else{let y=Ou(o,u,"composite");this.binders[o]=new De(l,s,u,c,r,y),i.push("/z_".concat(o))}}this.cacheKey=i.sort().join("")}getMaxValue(t){let r=this.binders[t];return r instanceof Je||r instanceof De?r.maxValue:0}populatePaintArrays(t,r,n,i,o){for(let a in this.binders){let s=this.binders[a];(s instanceof Je||s instanceof De||s instanceof Xe)&&s.populatePaintArray(t,r,n,i,o)}}setConstantPatternPositions(t,r){for(let n in this.binders){let i=this.binders[n];i instanceof wt&&i.setConstantPatternPositions(t,r)}}updatePaintArrays(t,r,n,i,o){let a=!1;for(let s in t){let l=r.getPositions(s);for(let u of l){let c=n.feature(u.index);for(let p in this.binders){let f=this.binders[p];if((f instanceof Je||f instanceof De||f instanceof Xe)&&f.expression.isStateDependent===!0){let y=i.paint.get(p);f.expression=y.value,f.updatePaintArray(u.start,u.end,c,t[s],o),a=!0}}}}return a}defines(){let t=[];for(let r in this.binders){let n=this.binders[r];(n instanceof qt||n instanceof wt)&&t.push(...n.uniformNames.map(i=>"#define HAS_UNIFORM_".concat(i)))}return t}getBinderAttributes(){let t=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof Je||n instanceof De)for(let i=0;i<n.paintVertexAttributes.length;i++)t.push(n.paintVertexAttributes[i].name);else if(n instanceof Xe)for(let i=0;i<Tn.members.length;i++)t.push(Tn.members[i].name)}return t}getBinderUniforms(){let t=[];for(let r in this.binders){let n=this.binders[r];if(n instanceof qt||n instanceof wt||n instanceof De)for(let i of n.uniformNames)t.push(i)}return t}getPaintVertexBuffers(){return this._buffers}getUniforms(t,r){let n=[];for(let i in this.binders){let o=this.binders[i];if(o instanceof qt||o instanceof wt||o instanceof De){for(let a of o.uniformNames)if(r[a]){let s=o.getBinding(t,r[a],a);n.push({name:a,property:i,binding:s})}}}return n}setUniforms(t,r,n,i){for(let{name:o,property:a,binding:s}of r)this.binders[a].setUniform(s,i,n.get(a),o)}updatePaintBuffers(t){this._buffers=[];for(let r in this.binders){let n=this.binders[r];if(t&&n instanceof Xe){let i=t.fromScale===2?n.zoomInPaintVertexBuffer:n.zoomOutPaintVertexBuffer;i&&this._buffers.push(i)}else(n instanceof Je||n instanceof De)&&n.paintVertexBuffer&&this._buffers.push(n.paintVertexBuffer)}}upload(t){for(let r in this.binders){let n=this.binders[r];(n instanceof Je||n instanceof De||n instanceof Xe)&&n.upload(t)}this.updatePaintBuffers()}destroy(){for(let t in this.binders){let r=this.binders[t];(r instanceof Je||r instanceof De||r instanceof Xe)&&r.destroy()}}},ke=class{constructor(t,r,n=()=>!0){this.programConfigurations={};for(let i of t)this.programConfigurations[i.id]=new go(i,r,n);this.needsUpload=!1,this._featureMap=new En,this._bufferOffset=0}populatePaintArrays(t,r,n,i,o,a){for(let s in this.programConfigurations)this.programConfigurations[s].populatePaintArrays(t,r,i,o,a);r.id!==void 0&&this._featureMap.add(r.id,n,this._bufferOffset,t),this._bufferOffset=t,this.needsUpload=!0}updatePaintArrays(t,r,n,i){for(let o of n)this.needsUpload=this.programConfigurations[o.id].updatePaintArrays(t,this._featureMap,r,o,i)||this.needsUpload}get(t){return this.programConfigurations[t]}upload(t){if(this.needsUpload){for(let r in this.programConfigurations)this.programConfigurations[r].upload(t);this.needsUpload=!1}}destroy(){for(let t in this.programConfigurations)this.programConfigurations[t].destroy()}};function Km(e,t){return{"text-opacity":["opacity"],"icon-opacity":["opacity"],"text-color":["fill_color"],"icon-color":["fill_color"],"text-halo-color":["halo_color"],"icon-halo-color":["halo_color"],"text-halo-blur":["halo_blur"],"icon-halo-blur":["halo_blur"],"text-halo-width":["halo_width"],"icon-halo-width":["halo_width"],"line-gap-width":["gapwidth"],"line-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"],"fill-extrusion-pattern":["pattern_to","pattern_from","pixel_ratio_to","pixel_ratio_from"]}[e]||[e.replace("".concat(t,"-"),"").replace(/-/g,"_")]}function Ym(e){return{"line-pattern":{source:lt,composite:lt},"fill-pattern":{source:lt,composite:lt},"fill-extrusion-pattern":{source:lt,composite:lt}}[e]}function Ou(e,t,r){let n={color:{source:Pt,composite:xr},number:{source:Gt,composite:Pt}},i=Ym(e);return i&&i[r]||n[t][r]}k("ConstantBinder",qt);k("CrossFadedConstantBinder",wt);k("SourceExpressionBinder",Je);k("CrossFadedCompositeBinder",Xe);k("CompositeExpressionBinder",De);k("ProgramConfiguration",go,{omit:["_buffers"]});k("ProgramConfigurationSet",ke);var Xm=15,os=Math.pow(2,Xm-1)-1,Nu=-os-1;function Te(e){let t=8192/e.extent,r=e.loadGeometry();for(let n=0;n<r.length;n++){let i=r[n];for(let o=0;o<i.length;o++){let a=i[o],s=Math.round(a.x*t),l=Math.round(a.y*t);a.x=rt(s,Nu,os),a.y=rt(l,Nu,os),(s<a.x||s>a.x+1||l<a.y||l>a.y+1)&&ce("Geometry exceeds allowed extent, reduce your vector tile buffer size")}}return r}function Oe(e,t){return{type:e.type,id:e.id,properties:e.properties,geometry:t?Te(e):[]}}function xo(e,t,r,n,i){e.emplaceBack(t*2+(n+1)/2,r*2+(i+1)/2)}var jt=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new no,this.indexArray=new Le,this.segments=new me,this.programConfigurations=new ke(t.layers,t.zoom),this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){let i=this.layers[0],o=[],a=null,s=!1;i.type==="circle"&&(a=i.layout.get("circle-sort-key"),s=!a.isConstant());for(let{feature:l,id:u,index:c,sourceLayerIndex:p}of t){let f=this.layers[0]._featureFilter.needGeometry,y=Oe(l,f);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),y,n))continue;let m=s?a.evaluate(y,{},n):void 0,h={id:u,properties:l.properties,type:l.type,sourceLayerIndex:p,index:c,geometry:f?y.geometry:Te(l),patterns:{},sortKey:m};o.push(h)}s&&o.sort((l,u)=>l.sortKey-u.sortKey);for(let l of o){let{geometry:u,index:c,sourceLayerIndex:p}=l,f=t[c].feature;this.addFeature(l,u,c,n),r.featureIndex.insert(f,u,c,p,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Lu),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}addFeature(t,r,n,i){for(let o of r)for(let a of o){let s=a.x,l=a.y;if(s<0||s>=8192||l<0||l>=8192)continue;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray,t.sortKey),c=u.vertexLength;xo(this.layoutVertexArray,s,l,-1,-1),xo(this.layoutVertexArray,s,l,1,-1),xo(this.layoutVertexArray,s,l,1,1),xo(this.layoutVertexArray,s,l,-1,1),this.indexArray.emplaceBack(c,c+1,c+2),this.indexArray.emplaceBack(c,c+3,c+2),u.vertexLength+=4,u.primitiveLength+=2}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,{},i)}};k("CircleBucket",jt,{omit:["layers"]});var Mn=Z(he(),1);function $u(e,t){for(let r=0;r<e.length;r++)if(vr(t,e[r]))return!0;for(let r=0;r<t.length;r++)if(vr(e,t[r]))return!0;return!!ss(e,t)}function Gu(e,t,r){return!!(vr(e,t)||as(t,e,r))}function bo(e,t){if(e.length===1)return Uu(t,e[0]);for(let r=0;r<t.length;r++){let n=t[r];for(let i=0;i<n.length;i++)if(vr(e,n[i]))return!0}for(let r=0;r<e.length;r++)if(Uu(t,e[r]))return!0;for(let r=0;r<t.length;r++)if(ss(e,t[r]))return!0;return!1}function qu(e,t,r){for(let n=0;n<t.length;n++){let i=t[n];if(e.length>=3){for(let o=0;o<i.length;o++)if(vr(e,i[o]))return!0}if(Qm(e,i,r))return!0}return!1}function Qm(e,t,r){if(e.length>1){if(ss(e,t))return!0;for(let n=0;n<t.length;n++)if(as(t[n],e,r))return!0}for(let n=0;n<e.length;n++)if(as(e[n],t,r))return!0;return!1}function ss(e,t){if(e.length===0||t.length===0)return!1;for(let r=0;r<e.length-1;r++){let n=e[r],i=e[r+1];for(let o=0;o<t.length-1;o++){let a=t[o],s=t[o+1];if(eh(n,i,a,s))return!0}}return!1}function eh(e,t,r,n){return nt(e,r,n)!==nt(t,r,n)&&nt(e,t,r)!==nt(e,t,n)}function as(e,t,r){let n=r*r;if(t.length===1)return e.distSqr(t[0])<n;for(let i=1;i<t.length;i++){let o=t[i-1],a=t[i];if(ls(e,o,a)<n)return!0}return!1}function ls(e,t,r){let n=t.distSqr(r);if(n===0)return e.distSqr(t);let i=((e.x-t.x)*(r.x-t.x)+(e.y-t.y)*(r.y-t.y))/n;return i<0?e.distSqr(t):i>1?e.distSqr(r):e.distSqr(r.sub(t)._mult(i)._add(t))}function Uu(e,t){let r=!1,n,i,o;for(let a=0;a<e.length;a++){n=e[a];for(let s=0,l=n.length-1;s<n.length;l=s++)i=n[s],o=n[l],i.y>t.y!=o.y>t.y&&t.x<(o.x-i.x)*(t.y-i.y)/(o.y-i.y)+i.x&&(r=!r)}return r}function vr(e,t){let r=!1;for(let n=0,i=e.length-1;n<e.length;i=n++){let o=e[n],a=e[i];o.y>t.y!=a.y>t.y&&t.x<(a.x-o.x)*(t.y-o.y)/(a.y-o.y)+o.x&&(r=!r)}return r}function ju(e,t,r,n,i){for(let a of e)if(t<=a.x&&r<=a.y&&n>=a.x&&i>=a.y)return!0;let o=[new Mn.default(t,r),new Mn.default(t,i),new Mn.default(n,i),new Mn.default(n,r)];if(e.length>2){for(let a of o)if(vr(e,a))return!0}for(let a=0;a<e.length-1;a++){let s=e[a],l=e[a+1];if(th(s,l,o))return!0}return!1}function th(e,t,r){let n=r[0],i=r[2];if(e.x<n.x&&t.x<n.x||e.x>i.x&&t.x>i.x||e.y<n.y&&t.y<n.y||e.y>i.y&&t.y>i.y)return!1;let o=nt(e,t,r[0]);return o!==nt(e,t,r[1])||o!==nt(e,t,r[2])||o!==nt(e,t,r[3])}var vo=Z(he(),1);function Zt(e,t,r){let n=t.paint.get(e).value;return n.kind==="constant"?n.value:r.programConfigurations.get(t.id).getMaxValue(e)}function At(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function _t(e,t,r,n,i){if(!t[0]&&!t[1])return e;let o=vo.default.convert(t)._mult(i);r==="viewport"&&o._rotate(-n);let a=[];for(let s=0;s<e.length;s++){let l=e[s];a.push(l.sub(o))}return a}function Zu(e,t){let r=[];for(let n=0;n<e.length;n++){let i=e[n],o=[];for(let a=0;a<i.length;a++){let s=i[a-1],l=i[a],u=i[a+1],c=a===0?new vo.default(0,0):l.sub(s)._unit()._perp(),p=a===i.length-1?new vo.default(0,0):u.sub(l)._unit()._perp(),f=c._add(p)._unit(),y=f.x*p.x+f.y*p.y;y!==0&&f._mult(1/y),o.push(f._mult(t)._add(l))}r.push(o)}return r}var Ju,rh=()=>Ju=Ju||new ie({"circle-sort-key":new R(S.layout_circle["circle-sort-key"])}),Wu,nh=()=>Wu=Wu||new ie({"circle-radius":new R(S.paint_circle["circle-radius"]),"circle-color":new R(S.paint_circle["circle-color"]),"circle-blur":new R(S.paint_circle["circle-blur"]),"circle-opacity":new R(S.paint_circle["circle-opacity"]),"circle-translate":new z(S.paint_circle["circle-translate"]),"circle-translate-anchor":new z(S.paint_circle["circle-translate-anchor"]),"circle-pitch-scale":new z(S.paint_circle["circle-pitch-scale"]),"circle-pitch-alignment":new z(S.paint_circle["circle-pitch-alignment"]),"circle-stroke-width":new R(S.paint_circle["circle-stroke-width"]),"circle-stroke-color":new R(S.paint_circle["circle-stroke-color"]),"circle-stroke-opacity":new R(S.paint_circle["circle-stroke-opacity"])}),Hu={get paint(){return nh()},get layout(){return rh()}};var X=1e-6,Ne=typeof Float32Array<"u"?Float32Array:Array,Ln=Math.random;var Pv=Math.PI/180;Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var Dn={};sl(Dn,{add:()=>Uh,adjoint:()=>ph,clone:()=>oh,copy:()=>ah,create:()=>ih,determinant:()=>fh,equals:()=>jh,exactEquals:()=>qh,frob:()=>Nh,fromQuat:()=>Eh,fromQuat2:()=>_h,fromRotation:()=>Ph,fromRotationTranslation:()=>Qu,fromRotationTranslationScale:()=>kh,fromRotationTranslationScaleOrigin:()=>Th,fromScaling:()=>vh,fromTranslation:()=>bh,fromValues:()=>sh,fromXRotation:()=>Sh,fromYRotation:()=>wh,fromZRotation:()=>Ah,frustum:()=>Fh,getRotation:()=>Ch,getScaling:()=>ec,getTranslation:()=>Ih,identity:()=>Yu,invert:()=>ch,lookAt:()=>zh,mul:()=>Zh,multiply:()=>Xu,multiplyScalar:()=>$h,multiplyScalarAndAdd:()=>Gh,ortho:()=>Vh,orthoNO:()=>rc,orthoZO:()=>Bh,perspective:()=>Mh,perspectiveFromFieldOfView:()=>Dh,perspectiveNO:()=>tc,perspectiveZO:()=>Lh,rotate:()=>hh,rotateX:()=>dh,rotateY:()=>gh,rotateZ:()=>xh,scale:()=>mh,set:()=>lh,str:()=>Oh,sub:()=>Jh,subtract:()=>nc,targetTo:()=>Rh,translate:()=>yh,transpose:()=>uh});function ih(){var e=new Ne(16);return Ne!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function oh(e){var t=new Ne(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function ah(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function sh(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h){var d=new Ne(16);return d[0]=e,d[1]=t,d[2]=r,d[3]=n,d[4]=i,d[5]=o,d[6]=a,d[7]=s,d[8]=l,d[9]=u,d[10]=c,d[11]=p,d[12]=f,d[13]=y,d[14]=m,d[15]=h,d}function lh(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e[4]=o,e[5]=a,e[6]=s,e[7]=l,e[8]=u,e[9]=c,e[10]=p,e[11]=f,e[12]=y,e[13]=m,e[14]=h,e[15]=d,e}function Yu(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function uh(e,t){if(e===t){var r=t[1],n=t[2],i=t[3],o=t[6],a=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=o,e[11]=t[14],e[12]=i,e[13]=a,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function ch(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15],v=r*s-n*a,b=r*l-i*a,x=r*u-o*a,P=n*l-i*s,w=n*u-o*s,A=i*u-o*l,T=c*h-p*m,I=c*d-f*m,E=c*g-y*m,_=p*d-f*h,F=p*g-y*h,M=f*g-y*d,B=v*M-b*F+x*_+P*E-w*I+A*T;return B?(B=1/B,e[0]=(s*M-l*F+u*_)*B,e[1]=(i*F-n*M-o*_)*B,e[2]=(h*A-d*w+g*P)*B,e[3]=(f*w-p*A-y*P)*B,e[4]=(l*E-a*M-u*I)*B,e[5]=(r*M-i*E+o*I)*B,e[6]=(d*x-m*A-g*b)*B,e[7]=(c*A-f*x+y*b)*B,e[8]=(a*F-s*E+u*T)*B,e[9]=(n*E-r*F-o*T)*B,e[10]=(m*w-h*x+g*v)*B,e[11]=(p*x-c*w-y*v)*B,e[12]=(s*I-a*_-l*T)*B,e[13]=(r*_-n*I+i*T)*B,e[14]=(h*b-m*P-d*v)*B,e[15]=(c*P-p*b+f*v)*B,e):null}function ph(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=t[4],s=t[5],l=t[6],u=t[7],c=t[8],p=t[9],f=t[10],y=t[11],m=t[12],h=t[13],d=t[14],g=t[15];return e[0]=s*(f*g-y*d)-p*(l*g-u*d)+h*(l*y-u*f),e[1]=-(n*(f*g-y*d)-p*(i*g-o*d)+h*(i*y-o*f)),e[2]=n*(l*g-u*d)-s*(i*g-o*d)+h*(i*u-o*l),e[3]=-(n*(l*y-u*f)-s*(i*y-o*f)+p*(i*u-o*l)),e[4]=-(a*(f*g-y*d)-c*(l*g-u*d)+m*(l*y-u*f)),e[5]=r*(f*g-y*d)-c*(i*g-o*d)+m*(i*y-o*f),e[6]=-(r*(l*g-u*d)-a*(i*g-o*d)+m*(i*u-o*l)),e[7]=r*(l*y-u*f)-a*(i*y-o*f)+c*(i*u-o*l),e[8]=a*(p*g-y*h)-c*(s*g-u*h)+m*(s*y-u*p),e[9]=-(r*(p*g-y*h)-c*(n*g-o*h)+m*(n*y-o*p)),e[10]=r*(s*g-u*h)-a*(n*g-o*h)+m*(n*u-o*s),e[11]=-(r*(s*y-u*p)-a*(n*y-o*p)+c*(n*u-o*s)),e[12]=-(a*(p*d-f*h)-c*(s*d-l*h)+m*(s*f-l*p)),e[13]=r*(p*d-f*h)-c*(n*d-i*h)+m*(n*f-i*p),e[14]=-(r*(s*d-l*h)-a*(n*d-i*h)+m*(n*l-i*s)),e[15]=r*(s*f-l*p)-a*(n*f-i*p)+c*(n*l-i*s),e}function fh(e){var t=e[0],r=e[1],n=e[2],i=e[3],o=e[4],a=e[5],s=e[6],l=e[7],u=e[8],c=e[9],p=e[10],f=e[11],y=e[12],m=e[13],h=e[14],d=e[15],g=t*a-r*o,v=t*s-n*o,b=t*l-i*o,x=r*s-n*a,P=r*l-i*a,w=n*l-i*s,A=u*m-c*y,T=u*h-p*y,I=u*d-f*y,E=c*h-p*m,_=c*d-f*m,F=p*d-f*h;return g*F-v*_+b*E+x*I-P*T+w*A}function Xu(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=t[4],l=t[5],u=t[6],c=t[7],p=t[8],f=t[9],y=t[10],m=t[11],h=t[12],d=t[13],g=t[14],v=t[15],b=r[0],x=r[1],P=r[2],w=r[3];return e[0]=b*n+x*s+P*p+w*h,e[1]=b*i+x*l+P*f+w*d,e[2]=b*o+x*u+P*y+w*g,e[3]=b*a+x*c+P*m+w*v,b=r[4],x=r[5],P=r[6],w=r[7],e[4]=b*n+x*s+P*p+w*h,e[5]=b*i+x*l+P*f+w*d,e[6]=b*o+x*u+P*y+w*g,e[7]=b*a+x*c+P*m+w*v,b=r[8],x=r[9],P=r[10],w=r[11],e[8]=b*n+x*s+P*p+w*h,e[9]=b*i+x*l+P*f+w*d,e[10]=b*o+x*u+P*y+w*g,e[11]=b*a+x*c+P*m+w*v,b=r[12],x=r[13],P=r[14],w=r[15],e[12]=b*n+x*s+P*p+w*h,e[13]=b*i+x*l+P*f+w*d,e[14]=b*o+x*u+P*y+w*g,e[15]=b*a+x*c+P*m+w*v,e}function yh(e,t,r){var n=r[0],i=r[1],o=r[2],a,s,l,u,c,p,f,y,m,h,d,g;return t===e?(e[12]=t[0]*n+t[4]*i+t[8]*o+t[12],e[13]=t[1]*n+t[5]*i+t[9]*o+t[13],e[14]=t[2]*n+t[6]*i+t[10]*o+t[14],e[15]=t[3]*n+t[7]*i+t[11]*o+t[15]):(a=t[0],s=t[1],l=t[2],u=t[3],c=t[4],p=t[5],f=t[6],y=t[7],m=t[8],h=t[9],d=t[10],g=t[11],e[0]=a,e[1]=s,e[2]=l,e[3]=u,e[4]=c,e[5]=p,e[6]=f,e[7]=y,e[8]=m,e[9]=h,e[10]=d,e[11]=g,e[12]=a*n+c*i+m*o+t[12],e[13]=s*n+p*i+h*o+t[13],e[14]=l*n+f*i+d*o+t[14],e[15]=u*n+y*i+g*o+t[15]),e}function mh(e,t,r){var n=r[0],i=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*i,e[5]=t[5]*i,e[6]=t[6]*i,e[7]=t[7]*i,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function hh(e,t,r,n){var i=n[0],o=n[1],a=n[2],s=Math.hypot(i,o,a),l,u,c,p,f,y,m,h,d,g,v,b,x,P,w,A,T,I,E,_,F,M,B,C;return s<X?null:(s=1/s,i*=s,o*=s,a*=s,l=Math.sin(r),u=Math.cos(r),c=1-u,p=t[0],f=t[1],y=t[2],m=t[3],h=t[4],d=t[5],g=t[6],v=t[7],b=t[8],x=t[9],P=t[10],w=t[11],A=i*i*c+u,T=o*i*c+a*l,I=a*i*c-o*l,E=i*o*c-a*l,_=o*o*c+u,F=a*o*c+i*l,M=i*a*c+o*l,B=o*a*c-i*l,C=a*a*c+u,e[0]=p*A+h*T+b*I,e[1]=f*A+d*T+x*I,e[2]=y*A+g*T+P*I,e[3]=m*A+v*T+w*I,e[4]=p*E+h*_+b*F,e[5]=f*E+d*_+x*F,e[6]=y*E+g*_+P*F,e[7]=m*E+v*_+w*F,e[8]=p*M+h*B+b*C,e[9]=f*M+d*B+x*C,e[10]=y*M+g*B+P*C,e[11]=m*M+v*B+w*C,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function dh(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[4],a=t[5],s=t[6],l=t[7],u=t[8],c=t[9],p=t[10],f=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*i+u*n,e[5]=a*i+c*n,e[6]=s*i+p*n,e[7]=l*i+f*n,e[8]=u*i-o*n,e[9]=c*i-a*n,e[10]=p*i-s*n,e[11]=f*i-l*n,e}function gh(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[0],a=t[1],s=t[2],l=t[3],u=t[8],c=t[9],p=t[10],f=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i-u*n,e[1]=a*i-c*n,e[2]=s*i-p*n,e[3]=l*i-f*n,e[8]=o*n+u*i,e[9]=a*n+c*i,e[10]=s*n+p*i,e[11]=l*n+f*i,e}function xh(e,t,r){var n=Math.sin(r),i=Math.cos(r),o=t[0],a=t[1],s=t[2],l=t[3],u=t[4],c=t[5],p=t[6],f=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*i+u*n,e[1]=a*i+c*n,e[2]=s*i+p*n,e[3]=l*i+f*n,e[4]=u*i-o*n,e[5]=c*i-a*n,e[6]=p*i-s*n,e[7]=f*i-l*n,e}function bh(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function vh(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Ph(e,t,r){var n=r[0],i=r[1],o=r[2],a=Math.hypot(n,i,o),s,l,u;return a<X?null:(a=1/a,n*=a,i*=a,o*=a,s=Math.sin(t),l=Math.cos(t),u=1-l,e[0]=n*n*u+l,e[1]=i*n*u+o*s,e[2]=o*n*u-i*s,e[3]=0,e[4]=n*i*u-o*s,e[5]=i*i*u+l,e[6]=o*i*u+n*s,e[7]=0,e[8]=n*o*u+i*s,e[9]=i*o*u-n*s,e[10]=o*o*u+l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function Sh(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function wh(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Ah(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Qu(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3],s=n+n,l=i+i,u=o+o,c=n*s,p=n*l,f=n*u,y=i*l,m=i*u,h=o*u,d=a*s,g=a*l,v=a*u;return e[0]=1-(y+h),e[1]=p+v,e[2]=f-g,e[3]=0,e[4]=p-v,e[5]=1-(c+h),e[6]=m+d,e[7]=0,e[8]=f+g,e[9]=m-d,e[10]=1-(c+y),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function _h(e,t){var r=new Ne(3),n=-t[0],i=-t[1],o=-t[2],a=t[3],s=t[4],l=t[5],u=t[6],c=t[7],p=n*n+i*i+o*o+a*a;return p>0?(r[0]=(s*a+c*n+l*o-u*i)*2/p,r[1]=(l*a+c*i+u*n-s*o)*2/p,r[2]=(u*a+c*o+s*i-l*n)*2/p):(r[0]=(s*a+c*n+l*o-u*i)*2,r[1]=(l*a+c*i+u*n-s*o)*2,r[2]=(u*a+c*o+s*i-l*n)*2),Qu(e,t,r),e}function Ih(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function ec(e,t){var r=t[0],n=t[1],i=t[2],o=t[4],a=t[5],s=t[6],l=t[8],u=t[9],c=t[10];return e[0]=Math.hypot(r,n,i),e[1]=Math.hypot(o,a,s),e[2]=Math.hypot(l,u,c),e}function Ch(e,t){var r=new Ne(3);ec(r,t);var n=1/r[0],i=1/r[1],o=1/r[2],a=t[0]*n,s=t[1]*i,l=t[2]*o,u=t[4]*n,c=t[5]*i,p=t[6]*o,f=t[8]*n,y=t[9]*i,m=t[10]*o,h=a+c+m,d=0;return h>0?(d=Math.sqrt(h+1)*2,e[3]=.25*d,e[0]=(p-y)/d,e[1]=(f-l)/d,e[2]=(s-u)/d):a>c&&a>m?(d=Math.sqrt(1+a-c-m)*2,e[3]=(p-y)/d,e[0]=.25*d,e[1]=(s+u)/d,e[2]=(f+l)/d):c>m?(d=Math.sqrt(1+c-a-m)*2,e[3]=(f-l)/d,e[0]=(s+u)/d,e[1]=.25*d,e[2]=(p+y)/d):(d=Math.sqrt(1+m-a-c)*2,e[3]=(s-u)/d,e[0]=(f+l)/d,e[1]=(p+y)/d,e[2]=.25*d),e}function kh(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=t[3],l=i+i,u=o+o,c=a+a,p=i*l,f=i*u,y=i*c,m=o*u,h=o*c,d=a*c,g=s*l,v=s*u,b=s*c,x=n[0],P=n[1],w=n[2];return e[0]=(1-(m+d))*x,e[1]=(f+b)*x,e[2]=(y-v)*x,e[3]=0,e[4]=(f-b)*P,e[5]=(1-(p+d))*P,e[6]=(h+g)*P,e[7]=0,e[8]=(y+v)*w,e[9]=(h-g)*w,e[10]=(1-(p+m))*w,e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}function Th(e,t,r,n,i){var o=t[0],a=t[1],s=t[2],l=t[3],u=o+o,c=a+a,p=s+s,f=o*u,y=o*c,m=o*p,h=a*c,d=a*p,g=s*p,v=l*u,b=l*c,x=l*p,P=n[0],w=n[1],A=n[2],T=i[0],I=i[1],E=i[2],_=(1-(h+g))*P,F=(y+x)*P,M=(m-b)*P,B=(y-x)*w,C=(1-(f+g))*w,O=(d+v)*w,N=(m+b)*A,K=(d-v)*A,Y=(1-(f+h))*A;return e[0]=_,e[1]=F,e[2]=M,e[3]=0,e[4]=B,e[5]=C,e[6]=O,e[7]=0,e[8]=N,e[9]=K,e[10]=Y,e[11]=0,e[12]=r[0]+T-(_*T+B*I+N*E),e[13]=r[1]+I-(F*T+C*I+K*E),e[14]=r[2]+E-(M*T+O*I+Y*E),e[15]=1,e}function Eh(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=r+r,s=n+n,l=i+i,u=r*a,c=n*a,p=n*s,f=i*a,y=i*s,m=i*l,h=o*a,d=o*s,g=o*l;return e[0]=1-p-m,e[1]=c+g,e[2]=f-d,e[3]=0,e[4]=c-g,e[5]=1-u-m,e[6]=y+h,e[7]=0,e[8]=f+d,e[9]=y-h,e[10]=1-u-p,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function Fh(e,t,r,n,i,o,a){var s=1/(r-t),l=1/(i-n),u=1/(o-a);return e[0]=o*2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o*2*l,e[6]=0,e[7]=0,e[8]=(r+t)*s,e[9]=(i+n)*l,e[10]=(a+o)*u,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*o*2*u,e[15]=0,e}function tc(e,t,r,n,i){var o=1/Math.tan(t/2),a;return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(a=1/(n-i),e[10]=(i+n)*a,e[14]=2*i*n*a):(e[10]=-1,e[14]=-2*n),e}var Mh=tc;function Lh(e,t,r,n,i){var o=1/Math.tan(t/2),a;return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,i!=null&&i!==1/0?(a=1/(n-i),e[10]=i*a,e[14]=i*n*a):(e[10]=-1,e[14]=-n),e}function Dh(e,t,r,n){var i=Math.tan(t.upDegrees*Math.PI/180),o=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(a+s),u=2/(i+o);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=u,e[6]=0,e[7]=0,e[8]=-((a-s)*l*.5),e[9]=(i-o)*u*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e}function rc(e,t,r,n,i,o,a){var s=1/(t-r),l=1/(n-i),u=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*u,e[11]=0,e[12]=(t+r)*s,e[13]=(i+n)*l,e[14]=(a+o)*u,e[15]=1,e}var Vh=rc;function Bh(e,t,r,n,i,o,a){var s=1/(t-r),l=1/(n-i),u=1/(o-a);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=u,e[11]=0,e[12]=(t+r)*s,e[13]=(i+n)*l,e[14]=o*u,e[15]=1,e}function zh(e,t,r,n){var i,o,a,s,l,u,c,p,f,y,m=t[0],h=t[1],d=t[2],g=n[0],v=n[1],b=n[2],x=r[0],P=r[1],w=r[2];return Math.abs(m-x)<X&&Math.abs(h-P)<X&&Math.abs(d-w)<X?Yu(e):(c=m-x,p=h-P,f=d-w,y=1/Math.hypot(c,p,f),c*=y,p*=y,f*=y,i=v*f-b*p,o=b*c-g*f,a=g*p-v*c,y=Math.hypot(i,o,a),y?(y=1/y,i*=y,o*=y,a*=y):(i=0,o=0,a=0),s=p*a-f*o,l=f*i-c*a,u=c*o-p*i,y=Math.hypot(s,l,u),y?(y=1/y,s*=y,l*=y,u*=y):(s=0,l=0,u=0),e[0]=i,e[1]=s,e[2]=c,e[3]=0,e[4]=o,e[5]=l,e[6]=p,e[7]=0,e[8]=a,e[9]=u,e[10]=f,e[11]=0,e[12]=-(i*m+o*h+a*d),e[13]=-(s*m+l*h+u*d),e[14]=-(c*m+p*h+f*d),e[15]=1,e)}function Rh(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=n[0],l=n[1],u=n[2],c=i-r[0],p=o-r[1],f=a-r[2],y=c*c+p*p+f*f;y>0&&(y=1/Math.sqrt(y),c*=y,p*=y,f*=y);var m=l*f-u*p,h=u*c-s*f,d=s*p-l*c;return y=m*m+h*h+d*d,y>0&&(y=1/Math.sqrt(y),m*=y,h*=y,d*=y),e[0]=m,e[1]=h,e[2]=d,e[3]=0,e[4]=p*d-f*h,e[5]=f*m-c*d,e[6]=c*h-p*m,e[7]=0,e[8]=c,e[9]=p,e[10]=f,e[11]=0,e[12]=i,e[13]=o,e[14]=a,e[15]=1,e}function Oh(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Nh(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Uh(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e}function nc(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e}function $h(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*r,e[9]=t[9]*r,e[10]=t[10]*r,e[11]=t[11]*r,e[12]=t[12]*r,e[13]=t[13]*r,e[14]=t[14]*r,e[15]=t[15]*r,e}function Gh(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e[4]=t[4]+r[4]*n,e[5]=t[5]+r[5]*n,e[6]=t[6]+r[6]*n,e[7]=t[7]+r[7]*n,e[8]=t[8]+r[8]*n,e[9]=t[9]+r[9]*n,e[10]=t[10]+r[10]*n,e[11]=t[11]+r[11]*n,e[12]=t[12]+r[12]*n,e[13]=t[13]+r[13]*n,e[14]=t[14]+r[14]*n,e[15]=t[15]+r[15]*n,e}function qh(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function jh(e,t){var r=e[0],n=e[1],i=e[2],o=e[3],a=e[4],s=e[5],l=e[6],u=e[7],c=e[8],p=e[9],f=e[10],y=e[11],m=e[12],h=e[13],d=e[14],g=e[15],v=t[0],b=t[1],x=t[2],P=t[3],w=t[4],A=t[5],T=t[6],I=t[7],E=t[8],_=t[9],F=t[10],M=t[11],B=t[12],C=t[13],O=t[14],N=t[15];return Math.abs(r-v)<=X*Math.max(1,Math.abs(r),Math.abs(v))&&Math.abs(n-b)<=X*Math.max(1,Math.abs(n),Math.abs(b))&&Math.abs(i-x)<=X*Math.max(1,Math.abs(i),Math.abs(x))&&Math.abs(o-P)<=X*Math.max(1,Math.abs(o),Math.abs(P))&&Math.abs(a-w)<=X*Math.max(1,Math.abs(a),Math.abs(w))&&Math.abs(s-A)<=X*Math.max(1,Math.abs(s),Math.abs(A))&&Math.abs(l-T)<=X*Math.max(1,Math.abs(l),Math.abs(T))&&Math.abs(u-I)<=X*Math.max(1,Math.abs(u),Math.abs(I))&&Math.abs(c-E)<=X*Math.max(1,Math.abs(c),Math.abs(E))&&Math.abs(p-_)<=X*Math.max(1,Math.abs(p),Math.abs(_))&&Math.abs(f-F)<=X*Math.max(1,Math.abs(f),Math.abs(F))&&Math.abs(y-M)<=X*Math.max(1,Math.abs(y),Math.abs(M))&&Math.abs(m-B)<=X*Math.max(1,Math.abs(m),Math.abs(B))&&Math.abs(h-C)<=X*Math.max(1,Math.abs(h),Math.abs(C))&&Math.abs(d-O)<=X*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(g-N)<=X*Math.max(1,Math.abs(g),Math.abs(N))}var Zh=Xu,Jh=nc;var Jt={};sl(Jt,{add:()=>Xh,ceil:()=>Qh,clone:()=>Wh,copy:()=>Kh,create:()=>ic,cross:()=>cd,dist:()=>Sd,distance:()=>lc,div:()=>Pd,divide:()=>sc,dot:()=>ud,equals:()=>xd,exactEquals:()=>gd,floor:()=>ed,forEach:()=>Id,fromValues:()=>Hh,inverse:()=>sd,len:()=>Ad,length:()=>cc,lerp:()=>pd,max:()=>rd,min:()=>td,mul:()=>vd,multiply:()=>ac,negate:()=>ad,normalize:()=>ld,random:()=>fd,round:()=>nd,scale:()=>id,scaleAndAdd:()=>od,set:()=>Yh,sqrDist:()=>wd,sqrLen:()=>_d,squaredDistance:()=>uc,squaredLength:()=>pc,str:()=>dd,sub:()=>bd,subtract:()=>oc,transformMat4:()=>yd,transformQuat:()=>md,zero:()=>hd});function ic(){var e=new Ne(4);return Ne!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0,e[3]=0),e}function Wh(e){var t=new Ne(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}function Hh(e,t,r,n){var i=new Ne(4);return i[0]=e,i[1]=t,i[2]=r,i[3]=n,i}function Kh(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e}function Yh(e,t,r,n,i){return e[0]=t,e[1]=r,e[2]=n,e[3]=i,e}function Xh(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e}function oc(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e}function ac(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e[3]=t[3]*r[3],e}function sc(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e[3]=t[3]/r[3],e}function Qh(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e[3]=Math.ceil(t[3]),e}function ed(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e[3]=Math.floor(t[3]),e}function td(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e[3]=Math.min(t[3],r[3]),e}function rd(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e[3]=Math.max(t[3],r[3]),e}function nd(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e[3]=Math.round(t[3]),e}function id(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e}function od(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e[3]=t[3]+r[3]*n,e}function lc(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],o=t[3]-e[3];return Math.hypot(r,n,i,o)}function uc(e,t){var r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2],o=t[3]-e[3];return r*r+n*n+i*i+o*o}function cc(e){var t=e[0],r=e[1],n=e[2],i=e[3];return Math.hypot(t,r,n,i)}function pc(e){var t=e[0],r=e[1],n=e[2],i=e[3];return t*t+r*r+n*n+i*i}function ad(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e}function sd(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e[3]=1/t[3],e}function ld(e,t){var r=t[0],n=t[1],i=t[2],o=t[3],a=r*r+n*n+i*i+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=r*a,e[1]=n*a,e[2]=i*a,e[3]=o*a,e}function ud(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function cd(e,t,r,n){var i=r[0]*n[1]-r[1]*n[0],o=r[0]*n[2]-r[2]*n[0],a=r[0]*n[3]-r[3]*n[0],s=r[1]*n[2]-r[2]*n[1],l=r[1]*n[3]-r[3]*n[1],u=r[2]*n[3]-r[3]*n[2],c=t[0],p=t[1],f=t[2],y=t[3];return e[0]=p*u-f*l+y*s,e[1]=-(c*u)+f*a-y*o,e[2]=c*l-p*a+y*i,e[3]=-(c*s)+p*o-f*i,e}function pd(e,t,r,n){var i=t[0],o=t[1],a=t[2],s=t[3];return e[0]=i+n*(r[0]-i),e[1]=o+n*(r[1]-o),e[2]=a+n*(r[2]-a),e[3]=s+n*(r[3]-s),e}function fd(e,t){t=t||1;var r,n,i,o,a,s;do r=Ln()*2-1,n=Ln()*2-1,a=r*r+n*n;while(a>=1);do i=Ln()*2-1,o=Ln()*2-1,s=i*i+o*o;while(s>=1);var l=Math.sqrt((1-a)/s);return e[0]=t*r,e[1]=t*n,e[2]=t*i*l,e[3]=t*o*l,e}function yd(e,t,r){var n=t[0],i=t[1],o=t[2],a=t[3];return e[0]=r[0]*n+r[4]*i+r[8]*o+r[12]*a,e[1]=r[1]*n+r[5]*i+r[9]*o+r[13]*a,e[2]=r[2]*n+r[6]*i+r[10]*o+r[14]*a,e[3]=r[3]*n+r[7]*i+r[11]*o+r[15]*a,e}function md(e,t,r){var n=t[0],i=t[1],o=t[2],a=r[0],s=r[1],l=r[2],u=r[3],c=u*n+s*o-l*i,p=u*i+l*n-a*o,f=u*o+a*i-s*n,y=-a*n-s*i-l*o;return e[0]=c*u+y*-a+p*-l-f*-s,e[1]=p*u+y*-s+f*-a-c*-l,e[2]=f*u+y*-l+c*-s-p*-a,e[3]=t[3],e}function hd(e){return e[0]=0,e[1]=0,e[2]=0,e[3]=0,e}function dd(e){return"vec4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+")"}function gd(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}function xd(e,t){var r=e[0],n=e[1],i=e[2],o=e[3],a=t[0],s=t[1],l=t[2],u=t[3];return Math.abs(r-a)<=X*Math.max(1,Math.abs(r),Math.abs(a))&&Math.abs(n-s)<=X*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(i-l)<=X*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(o-u)<=X*Math.max(1,Math.abs(o),Math.abs(u))}var bd=oc,vd=ac,Pd=sc,Sd=lc,wd=uc,Ad=cc,_d=pc,Id=function(){var e=ic();return function(t,r,n,i,o,a){var s,l;for(r||(r=4),n||(n=0),i?l=Math.min(i*r+n,t.length):l=t.length,s=n;s<l;s+=r)e[0]=t[s],e[1]=t[s+1],e[2]=t[s+2],e[3]=t[s+3],o(e,e,a),t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3];return t}}();var fc=Z(he(),1),Po=class extends le{constructor(r){super(r,Hu)}createBucket(r){return new jt(r)}queryRadius(r){let n=r;return Zt("circle-radius",this,n)+Zt("circle-stroke-width",this,n)+At(this.paint.get("circle-translate"))}queryIntersectsFeature(r,n,i,o,a,s,l,u){let c=_t(r,this.paint.get("circle-translate"),this.paint.get("circle-translate-anchor"),s.angle,l),p=this.paint.get("circle-radius").evaluate(n,i),f=this.paint.get("circle-stroke-width").evaluate(n,i),y=p+f,m=this.paint.get("circle-pitch-alignment")==="map",h=m?c:Cd(c,u),d=m?y*l:y;for(let g of o)for(let v of g){let b=m?v:yc(v,u),x=d,P=Jt.transformMat4([],[v.x,v.y,0,1],u);if(this.paint.get("circle-pitch-scale")==="viewport"&&this.paint.get("circle-pitch-alignment")==="map"?x*=P[3]/s.cameraToCenterDistance:this.paint.get("circle-pitch-scale")==="map"&&this.paint.get("circle-pitch-alignment")==="viewport"&&(x*=s.cameraToCenterDistance/P[3]),Gu(h,b,x))return!0}return!1}};function yc(e,t){let r=Jt.transformMat4([],[e.x,e.y,0,1],t);return new fc.default(r[0]/r[3],r[1]/r[3])}function Cd(e,t){return e.map(r=>yc(r,t))}var Vn=class extends jt{};k("HeatmapBucket",Vn,{omit:["layers"]});var mc,kd=()=>mc=mc||new ie({"heatmap-radius":new R(S.paint_heatmap["heatmap-radius"]),"heatmap-weight":new R(S.paint_heatmap["heatmap-weight"]),"heatmap-intensity":new z(S.paint_heatmap["heatmap-intensity"]),"heatmap-color":new Nt(S.paint_heatmap["heatmap-color"]),"heatmap-opacity":new z(S.paint_heatmap["heatmap-opacity"])}),hc={get paint(){return kd()}};function us(e,{width:t,height:r},n,i){if(!i)i=new Uint8Array(t*r*n);else if(i instanceof Uint8ClampedArray)i=new Uint8Array(i.buffer);else if(i.length!==t*r*n)throw new RangeError("mismatched image size. expected: ".concat(i.length," but got: ").concat(t*r*n));return e.width=t,e.height=r,e.data=i,e}function dc(e,{width:t,height:r},n){if(t===e.width&&r===e.height)return;let i=us({},{width:t,height:r},n);cs(e,i,{x:0,y:0},{x:0,y:0},{width:Math.min(e.width,t),height:Math.min(e.height,r)},n),e.width=t,e.height=r,e.data=i.data}function cs(e,t,r,n,i,o){if(i.width===0||i.height===0)return t;if(i.width>e.width||i.height>e.height||r.x>e.width-i.width||r.y>e.height-i.height)throw new RangeError("out of range source coordinates for image copy");if(i.width>t.width||i.height>t.height||n.x>t.width-i.width||n.y>t.height-i.height)throw new RangeError("out of range destination coordinates for image copy");let a=e.data,s=t.data;if(a===s)throw new Error("srcData equals dstData, so image is already copied");for(let l=0;l<i.height;l++){let u=((r.y+l)*e.width+r.x)*o,c=((n.y+l)*t.width+n.x)*o;for(let p=0;p<i.width*o;p++)s[c+p]=a[u+p]}return t}var Wt=class e{constructor(t,r){us(this,t,1,r)}resize(t){dc(this,t,1)}clone(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,r,n,i,o){cs(t,r,n,i,o,1)}},de=class e{constructor(t,r){us(this,t,4,r)}resize(t){dc(this,t,4)}replace(t,r){r?this.data.set(t):t instanceof Uint8ClampedArray?this.data=new Uint8Array(t.buffer):this.data=t}clone(){return new e({width:this.width,height:this.height},new Uint8Array(this.data))}static copy(t,r,n,i,o){cs(t,r,n,i,o,4)}};k("AlphaImage",Wt);k("RGBAImage",de);function gc(e){let t={},r=e.resolution||256,n=e.clips?e.clips.length:1,i=e.image||new de({width:r,height:n});if(!hl(r))throw new Error("width is not a power of 2 - ".concat(r));let o=(a,s,l)=>{t[e.evaluationKey]=l;let u=e.expression.evaluate(t);i.data[a+s+0]=Math.floor(u.r*255/u.a),i.data[a+s+1]=Math.floor(u.g*255/u.a),i.data[a+s+2]=Math.floor(u.b*255/u.a),i.data[a+s+3]=Math.floor(u.a*255)};if(e.clips)for(let a=0,s=0;a<n;++a,s+=r*4)for(let l=0,u=0;l<r;l++,u+=4){let c=l/(r-1),{start:p,end:f}=e.clips[a],y=p*(1-c)+f*c;o(s,u,y)}else for(let a=0,s=0;a<r;a++,s+=4){let l=a/(r-1);o(0,s,l)}return i}var So=class extends le{constructor(r){super(r,hc);this._updateColorRamp()}createBucket(r){return new Vn(r)}_handleSpecialPaintPropertyUpdate(r){r==="heatmap-color"&&this._updateColorRamp()}_updateColorRamp(){let r=this._transitionablePaint._values["heatmap-color"].value.expression;this.colorRamp=gc({expression:r,evaluationKey:"heatmapDensity",image:this.colorRamp}),this.colorRampTexture=null}resize(){this.heatmapFbo&&(this.heatmapFbo.destroy(),this.heatmapFbo=null)}queryRadius(){return 0}queryIntersectsFeature(){return!1}hasOffscreenPass(){return this.paint.get("heatmap-opacity")!==0&&this.visibility!=="none"}};var xc,Td=()=>xc=xc||new ie({"hillshade-illumination-direction":new z(S.paint_hillshade["hillshade-illumination-direction"]),"hillshade-illumination-anchor":new z(S.paint_hillshade["hillshade-illumination-anchor"]),"hillshade-exaggeration":new z(S.paint_hillshade["hillshade-exaggeration"]),"hillshade-shadow-color":new z(S.paint_hillshade["hillshade-shadow-color"]),"hillshade-highlight-color":new z(S.paint_hillshade["hillshade-highlight-color"]),"hillshade-accent-color":new z(S.paint_hillshade["hillshade-accent-color"])}),bc={get paint(){return Td()}};var wo=class extends le{constructor(r){super(r,bc)}hasOffscreenPass(){return this.paint.get("hillshade-exaggeration")!==0&&this.visibility!=="none"}};var Ed=ee([{name:"a_pos",components:2,type:"Int16"}],4);var{members:vc,size:m1,alignment:h1}=Ed;var Ic=Z(hs(),1);function ds(e,t,r,n,i){_c(e,t,r||0,n||e.length-1,i||Zd)}function _c(e,t,r,n,i){for(;n>r;){if(n-r>600){var o=n-r+1,a=t-r+1,s=Math.log(o),l=.5*Math.exp(2*s/3),u=.5*Math.sqrt(s*l*(o-l)/o)*(a-o/2<0?-1:1),c=Math.max(r,Math.floor(t-a*l/o+u)),p=Math.min(n,Math.floor(t+(o-a)*l/o+u));_c(e,t,c,p,i)}var f=e[t],y=r,m=n;for(On(e,r,t),i(e[n],f)>0&&On(e,r,n);y<m;){for(On(e,y,m),y++,m--;i(e[y],f)<0;)y++;for(;i(e[m],f)>0;)m--}i(e[r],f)===0?On(e,r,m):(m++,On(e,m,n)),m<=t&&(r=m+1),t<=m&&(n=m-1)}}function On(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function Zd(e,t){return e<t?-1:e>t?1:0}function Sr(e,t){let r=e.length;if(r<=1)return[e];let n=[],i,o;for(let a=0;a<r;a++){let s=xl(e[a]);s!==0&&(e[a].area=Math.abs(s),o===void 0&&(o=s<0),o===s<0?(i&&n.push(i),i=[e[a]]):i.push(e[a]))}if(i&&n.push(i),t>1)for(let a=0;a<n.length;a++)n[a].length<=t||(ds(n[a],t,1,n[a].length-1,Jd),n[a]=n[a].slice(0,t));return n}function Jd(e,t){return t.area-e.area}function wr(e,t,r){let n=r.patternDependencies,i=!1;for(let o of t){let a=o.paint.get("".concat(e,"-pattern"));a.isConstant()||(i=!0);let s=a.constantOr(null);s&&(i=!0,n[s.to]=!0,n[s.from]=!0)}return i}function Ar(e,t,r,n,i){let o=i.patternDependencies;for(let a of t){let l=a.paint.get("".concat(e,"-pattern")).value;if(l.kind!=="constant"){let u=l.evaluate({zoom:n-1},r,{},i.availableImages),c=l.evaluate({zoom:n},r,{},i.availableImages),p=l.evaluate({zoom:n+1},r,{},i.availableImages);u=u&&u.name?u.name:u,c=c&&c.name?c.name:c,p=p&&p.name?p.name:p,o[u]=!0,o[c]=!0,o[p]=!0,r.patterns[a.id]={min:u,mid:c,max:p}}}return r}var Wd=500,Kt=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.layoutVertexArray=new io,this.indexArray=new Le,this.indexArray2=new St,this.programConfigurations=new ke(t.layers,t.zoom),this.segments=new me,this.segments2=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.hasPattern=wr("fill",this.layers,r);let i=this.layers[0].layout.get("fill-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of t){let p=this.layers[0]._featureFilter.needGeometry,f=Oe(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n,r.availableImages):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:Te(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Ar("fill",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=t[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}addFeatures(t,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,vc),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.indexBuffer2=t.createIndexBuffer(this.indexArray2)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.indexBuffer2.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.segments2.destroy())}addFeature(t,r,n,i,o){for(let a of Sr(r,Wd)){let s=0;for(let y of a)s+=y.length;let l=this.segments.prepareSegment(s,this.layoutVertexArray,this.indexArray),u=l.vertexLength,c=[],p=[];for(let y of a){if(y.length===0)continue;y!==a[0]&&p.push(c.length/2);let m=this.segments2.prepareSegment(y.length,this.layoutVertexArray,this.indexArray2),h=m.vertexLength;this.layoutVertexArray.emplaceBack(y[0].x,y[0].y),this.indexArray2.emplaceBack(h+y.length-1,h),c.push(y[0].x),c.push(y[0].y);for(let d=1;d<y.length;d++)this.layoutVertexArray.emplaceBack(y[d].x,y[d].y),this.indexArray2.emplaceBack(h+d-1,h+d),c.push(y[d].x),c.push(y[d].y);m.vertexLength+=y.length,m.primitiveLength+=y.length}let f=(0,Ic.default)(c,p);for(let y=0;y<f.length;y+=3)this.indexArray.emplaceBack(u+f[y],u+f[y+1],u+f[y+2]);l.vertexLength+=s,l.primitiveLength+=f.length/3}this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}};k("FillBucket",Kt,{omit:["layers","patternFeatures"]});var Cc,Hd=()=>Cc=Cc||new ie({"fill-sort-key":new R(S.layout_fill["fill-sort-key"])}),kc,Kd=()=>kc=kc||new ie({"fill-antialias":new z(S.paint_fill["fill-antialias"]),"fill-opacity":new R(S.paint_fill["fill-opacity"]),"fill-color":new R(S.paint_fill["fill-color"]),"fill-outline-color":new R(S.paint_fill["fill-outline-color"]),"fill-translate":new z(S.paint_fill["fill-translate"]),"fill-translate-anchor":new z(S.paint_fill["fill-translate-anchor"]),"fill-pattern":new st(S.paint_fill["fill-pattern"])}),Tc={get paint(){return Kd()},get layout(){return Hd()}};var ko=class extends le{constructor(r){super(r,Tc)}recalculate(r,n){super.recalculate(r,n);let i=this.paint._values["fill-outline-color"];i.value.kind==="constant"&&i.value.value===void 0&&(this.paint._values["fill-outline-color"]=this.paint._values["fill-color"])}createBucket(r){return new Kt(r)}queryRadius(){return At(this.paint.get("fill-translate"))}queryIntersectsFeature(r,n,i,o,a,s,l){let u=_t(r,this.paint.get("fill-translate"),this.paint.get("fill-translate-anchor"),s.angle,l);return bo(u,o)}isTileClipped(){return!0}};var Yd=ee([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal_ed",components:4,type:"Int16"}],4),Ec=ee([{name:"a_centroid",components:2,type:"Int16"}],4);var{members:Fc,size:Y1,alignment:X1}=Yd;var zc=Z(hs(),1),Rc=Z(It(),1);var ug=Rc.default.VectorTileFeature.types,cg=500,bs=Math.pow(2,13);function Nn(e,t,r,n,i,o,a,s){e.emplaceBack(t,r,Math.floor(n*bs)*2+a,i*bs*2,o*bs*2,Math.round(s))}var Yt=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.layoutVertexArray=new oo,this.centroidVertexArray=new ro,this.indexArray=new Le,this.programConfigurations=new ke(t.layers,t.zoom),this.segments=new me,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.features=[],this.hasPattern=wr("fill-extrusion",this.layers,r);for(let{feature:i,id:o,index:a,sourceLayerIndex:s}of t){let l=this.layers[0]._featureFilter.needGeometry,u=Oe(i,l);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),u,n))continue;let c={id:o,sourceLayerIndex:s,index:a,geometry:l?u.geometry:Te(i),properties:i.properties,type:i.type,patterns:{}};this.hasPattern?this.features.push(Ar("fill-extrusion",this.layers,c,this.zoom,r)):this.addFeature(c,c.geometry,a,n,{}),r.featureIndex.insert(i,c.geometry,a,s,this.index,!0)}}addFeatures(t,r,n){for(let i of this.features){let{geometry:o}=i;this.addFeature(i,o,i.index,r,n)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}isEmpty(){return this.layoutVertexArray.length===0&&this.centroidVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Fc),this.centroidVertexBuffer=t.createVertexBuffer(this.centroidVertexArray,Ec.members,!0),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.centroidVertexBuffer.destroy())}addFeature(t,r,n,i,o){let a={x:0,y:0,vertexCount:0};for(let s of Sr(r,cg)){let l=0;for(let m of s)l+=m.length;let u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray);for(let m of s){if(m.length===0||fg(m))continue;let h=0;for(let d=0;d<m.length;d++){let g=m[d];if(d>=1){let v=m[d-1];if(!pg(g,v)){u.vertexLength+4>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(4,this.layoutVertexArray,this.indexArray));let b=g.sub(v)._perp()._unit(),x=v.dist(g);h+x>32768&&(h=0),Nn(this.layoutVertexArray,g.x,g.y,b.x,b.y,0,0,h),Nn(this.layoutVertexArray,g.x,g.y,b.x,b.y,0,1,h),a.x+=2*g.x,a.y+=2*g.y,a.vertexCount+=2,h+=x,Nn(this.layoutVertexArray,v.x,v.y,b.x,b.y,0,0,h),Nn(this.layoutVertexArray,v.x,v.y,b.x,b.y,0,1,h),a.x+=2*v.x,a.y+=2*v.y,a.vertexCount+=2;let P=u.vertexLength;this.indexArray.emplaceBack(P,P+2,P+1),this.indexArray.emplaceBack(P+1,P+2,P+3),u.vertexLength+=4,u.primitiveLength+=2}}}}if(u.vertexLength+l>me.MAX_VERTEX_ARRAY_LENGTH&&(u=this.segments.prepareSegment(l,this.layoutVertexArray,this.indexArray)),ug[t.type]!=="Polygon")continue;let c=[],p=[],f=u.vertexLength;for(let m of s)if(m.length!==0){m!==s[0]&&p.push(c.length/2);for(let h=0;h<m.length;h++){let d=m[h];Nn(this.layoutVertexArray,d.x,d.y,0,0,1,1,0),a.x+=d.x,a.y+=d.y,a.vertexCount+=1,c.push(d.x),c.push(d.y)}}let y=(0,zc.default)(c,p);for(let m=0;m<y.length;m+=3)this.indexArray.emplaceBack(f+y[m],f+y[m+2],f+y[m+1]);u.primitiveLength+=y.length/3,u.vertexLength+=l}for(let s=0;s<a.vertexCount;s++)this.centroidVertexArray.emplaceBack(Math.floor(a.x/a.vertexCount),Math.floor(a.y/a.vertexCount));this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}};k("FillExtrusionBucket",Yt,{omit:["layers","features"]});function pg(e,t){return e.x===t.x&&(e.x<0||e.x>8192)||e.y===t.y&&(e.y<0||e.y>8192)}function fg(e){return e.every(t=>t.x<0)||e.every(t=>t.x>8192)||e.every(t=>t.y<0)||e.every(t=>t.y>8192)}var Oc,yg=()=>Oc=Oc||new ie({"fill-extrusion-opacity":new z(S["paint_fill-extrusion"]["fill-extrusion-opacity"]),"fill-extrusion-color":new R(S["paint_fill-extrusion"]["fill-extrusion-color"]),"fill-extrusion-translate":new z(S["paint_fill-extrusion"]["fill-extrusion-translate"]),"fill-extrusion-translate-anchor":new z(S["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),"fill-extrusion-pattern":new st(S["paint_fill-extrusion"]["fill-extrusion-pattern"]),"fill-extrusion-height":new R(S["paint_fill-extrusion"]["fill-extrusion-height"]),"fill-extrusion-base":new R(S["paint_fill-extrusion"]["fill-extrusion-base"]),"fill-extrusion-vertical-gradient":new z(S["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])}),Nc={get paint(){return yg()}};var Eo=Z(he(),1);var Fo=class extends le{constructor(r){super(r,Nc)}createBucket(r){return new Yt(r)}queryRadius(){return At(this.paint.get("fill-extrusion-translate"))}is3D(){return!0}queryIntersectsFeature(r,n,i,o,a,s,l,u){let c=_t(r,this.paint.get("fill-extrusion-translate"),this.paint.get("fill-extrusion-translate-anchor"),s.angle,l),p=this.paint.get("fill-extrusion-height").evaluate(n,i),f=this.paint.get("fill-extrusion-base").evaluate(n,i),y=dg(c,u,s,0),m=hg(o,f,p,u),h=m[0],d=m[1];return mg(h,d,y)}};function Un(e,t){return e.x*t.x+e.y*t.y}function Uc(e,t){if(e.length===1){let r=0,n=t[r++],i;for(;!i||n.equals(i);)if(i=t[r++],!i)return 1/0;for(;r<t.length;r++){let o=t[r],a=e[0],s=i.sub(n),l=o.sub(n),u=a.sub(n),c=Un(s,s),p=Un(s,l),f=Un(l,l),y=Un(u,s),m=Un(u,l),h=c*f-p*p,d=(f*y-p*m)/h,g=(c*m-p*y)/h,v=1-d-g,b=n.z*v+i.z*d+o.z*g;if(isFinite(b))return b}return 1/0}else{let r=1/0;for(let n of t)r=Math.min(r,n.z);return r}}function mg(e,t,r){let n=1/0;bo(r,t)&&(n=Uc(r,t[0]));for(let i=0;i<t.length;i++){let o=t[i],a=e[i];for(let s=0;s<o.length-1;s++){let l=o[s],u=o[s+1],c=a[s],p=a[s+1],f=[l,u,p,c,l];$u(r,f)&&(n=Math.min(n,Uc(r,f)))}}return n===1/0?!1:n}function hg(e,t,r,n){let i=[],o=[],a=n[8]*t,s=n[9]*t,l=n[10]*t,u=n[11]*t,c=n[8]*r,p=n[9]*r,f=n[10]*r,y=n[11]*r;for(let m of e){let h=[],d=[];for(let g of m){let v=g.x,b=g.y,x=n[0]*v+n[4]*b+n[12],P=n[1]*v+n[5]*b+n[13],w=n[2]*v+n[6]*b+n[14],A=n[3]*v+n[7]*b+n[15],T=x+a,I=P+s,E=w+l,_=A+u,F=x+c,M=P+p,B=w+f,C=A+y,O=new Eo.default(T/_,I/_);O.z=E/_,h.push(O);let N=new Eo.default(F/C,M/C);N.z=B/C,d.push(N)}i.push(h),o.push(d)}return[i,o]}function dg(e,t,r,n){let i=[];for(let o of e){let a=[o.x,o.y,n,1];Jt.transformMat4(a,a,t),i.push(new Eo.default(a[0]/a[3],a[1]/a[3]))}return i}var gg=ee([{name:"a_pos_normal",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}],4),{members:$c,size:DP,alignment:VP}=gg;var xg=ee([{name:"a_uv_x",components:1,type:"Float32"},{name:"a_split_index",components:1,type:"Float32"}]),{members:Gc,size:RP,alignment:OP}=xg;var Zc=Z(It(),1);var bg=Zc.default.VectorTileFeature.types,qc=63,vg=Math.cos(75/2*(Math.PI/180)),Pg=15,Sg=20,wg=15,Jc=1/2,jc=Math.pow(2,wg-1)/Jc,Xt=class{constructor(t){this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(r=>r.id),this.index=t.index,this.hasPattern=!1,this.patternFeatures=[],this.lineClipsArray=[],this.gradients={},this.layers.forEach(r=>{this.gradients[r.id]={}}),this.layoutVertexArray=new ao,this.layoutVertexArray2=new so,this.indexArray=new Le,this.programConfigurations=new ke(t.layers,t.zoom),this.segments=new me,this.maxLineLength=0,this.stateDependentLayerIds=this.layers.filter(r=>r.isStateDependent()).map(r=>r.id)}populate(t,r,n){this.hasPattern=wr("line",this.layers,r);let i=this.layers[0].layout.get("line-sort-key"),o=!i.isConstant(),a=[];for(let{feature:s,id:l,index:u,sourceLayerIndex:c}of t){let p=this.layers[0]._featureFilter.needGeometry,f=Oe(s,p);if(!this.layers[0]._featureFilter.filter(new q(this.zoom),f,n))continue;let y=o?i.evaluate(f,{},n):void 0,m={id:l,properties:s.properties,type:s.type,sourceLayerIndex:c,index:u,geometry:p?f.geometry:Te(s),patterns:{},sortKey:y};a.push(m)}o&&a.sort((s,l)=>s.sortKey-l.sortKey);for(let s of a){let{geometry:l,index:u,sourceLayerIndex:c}=s;if(this.hasPattern){let f=Ar("line",this.layers,s,this.zoom,r);this.patternFeatures.push(f)}else this.addFeature(s,l,u,n,{});let p=t[u].feature;r.featureIndex.insert(p,l,u,c,this.index)}}update(t,r,n){this.stateDependentLayers.length&&this.programConfigurations.updatePaintArrays(t,r,this.stateDependentLayers,n)}addFeatures(t,r,n){for(let i of this.patternFeatures)this.addFeature(i,i.geometry,i.index,r,n)}isEmpty(){return this.layoutVertexArray.length===0}uploadPending(){return!this.uploaded||this.programConfigurations.needsUpload}upload(t){this.uploaded||(this.layoutVertexArray2.length!==0&&(this.layoutVertexBuffer2=t.createVertexBuffer(this.layoutVertexArray2,Gc)),this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,$c),this.indexBuffer=t.createIndexBuffer(this.indexArray)),this.programConfigurations.upload(t),this.uploaded=!0}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy())}lineFeatureClips(t){if(t.properties&&Object.prototype.hasOwnProperty.call(t.properties,"mapbox_clip_start")&&Object.prototype.hasOwnProperty.call(t.properties,"mapbox_clip_end")){let r=+t.properties.mapbox_clip_start,n=+t.properties.mapbox_clip_end;return{start:r,end:n}}}addFeature(t,r,n,i,o){let a=this.layers[0].layout,s=a.get("line-join").evaluate(t,{}),l=a.get("line-cap"),u=a.get("line-miter-limit"),c=a.get("line-round-limit");this.lineClips=this.lineFeatureClips(t);for(let p of r)this.addLine(p,t,s,l,u,c);this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length,t,n,o,i)}addLine(t,r,n,i,o,a){if(this.distance=0,this.scaledDistance=0,this.totalDistance=0,this.lineClips){this.lineClipsArray.push(this.lineClips);for(let g=0;g<t.length-1;g++)this.totalDistance+=t[g].dist(t[g+1]);this.updateScaledDistance(),this.maxLineLength=Math.max(this.maxLineLength,this.totalDistance)}let s=bg[r.type]==="Polygon",l=t.length;for(;l>=2&&t[l-1].equals(t[l-2]);)l--;let u=0;for(;u<l-1&&t[u].equals(t[u+1]);)u++;if(l<(s?3:2))return;n==="bevel"&&(o=1.05);let c=this.overscaling<=16?Pg*8192/(512*this.overscaling):0,p=this.segments.prepareSegment(l*10,this.layoutVertexArray,this.indexArray),f,y,m,h,d;this.e1=this.e2=-1,s&&(f=t[l-2],d=t[u].sub(f)._unit()._perp());for(let g=u;g<l;g++){if(m=g===l-1?s?t[u+1]:void 0:t[g+1],m&&t[g].equals(m))continue;d&&(h=d),f&&(y=f),f=t[g],d=m?m.sub(f)._unit()._perp():h,h=h||d;let v=h.add(d);(v.x!==0||v.y!==0)&&v._unit();let b=h.x*d.x+h.y*d.y,x=v.x*d.x+v.y*d.y,P=x!==0?1/x:1/0,w=2*Math.sqrt(2-2*x),A=x<vg&&y&&m,T=h.x*d.y-h.y*d.x>0;if(A&&g>u){let _=f.dist(y);if(_>2*c){let F=f.sub(f.sub(y)._mult(c/_)._round());this.updateDistance(y,F),this.addCurrentVertex(F,h,0,0,p),y=F}}let I=y&&m,E=I?n:s?"butt":i;if(I&&E==="round"&&(P<a?E="miter":P<=2&&(E="fakeround")),E==="miter"&&P>o&&(E="bevel"),E==="bevel"&&(P>2&&(E="flipbevel"),P<o&&(E="miter")),y&&this.updateDistance(y,f),E==="miter")v._mult(P),this.addCurrentVertex(f,v,0,0,p);else if(E==="flipbevel"){if(P>100)v=d.mult(-1);else{let _=P*h.add(d).mag()/h.sub(d).mag();v._perp()._mult(_*(T?-1:1))}this.addCurrentVertex(f,v,0,0,p),this.addCurrentVertex(f,v.mult(-1),0,0,p)}else if(E==="bevel"||E==="fakeround"){let _=-Math.sqrt(P*P-1),F=T?_:0,M=T?0:_;if(y&&this.addCurrentVertex(f,h,F,M,p),E==="fakeround"){let B=Math.round(w*180/Math.PI/Sg);for(let C=1;C<B;C++){let O=C/B;if(O!==.5){let K=O-.5,Y=1.0904+b*(-3.2452+b*(3.55645-b*1.43519)),Q=.848013+b*(-1.06021+b*.215638);O=O+O*K*(O-1)*(Y*K*K+Q)}let N=d.sub(h)._mult(O)._add(h)._unit()._mult(T?-1:1);this.addHalfVertex(f,N.x,N.y,!1,T,0,p)}}m&&this.addCurrentVertex(f,d,-F,-M,p)}else if(E==="butt")this.addCurrentVertex(f,v,0,0,p);else if(E==="square"){let _=y?1:-1;this.addCurrentVertex(f,v,_,_,p)}else E==="round"&&(y&&(this.addCurrentVertex(f,h,0,0,p),this.addCurrentVertex(f,h,1,1,p,!0)),m&&(this.addCurrentVertex(f,d,-1,-1,p,!0),this.addCurrentVertex(f,d,0,0,p)));if(A&&g<l-1){let _=f.dist(m);if(_>2*c){let F=f.add(m.sub(f)._mult(c/_)._round());this.updateDistance(f,F),this.addCurrentVertex(F,d,0,0,p),f=F}}}}addCurrentVertex(t,r,n,i,o,a=!1){let s=r.x+r.y*n,l=r.y-r.x*n,u=-r.x+r.y*i,c=-r.y-r.x*i;this.addHalfVertex(t,s,l,a,!1,n,o),this.addHalfVertex(t,u,c,a,!0,-i,o),this.distance>jc/2&&this.totalDistance===0&&(this.distance=0,this.updateScaledDistance(),this.addCurrentVertex(t,r,n,i,o,a))}addHalfVertex({x:t,y:r},n,i,o,a,s,l){let c=(this.lineClips?this.scaledDistance*(jc-1):this.scaledDistance)*Jc;if(this.layoutVertexArray.emplaceBack((t<<1)+(o?1:0),(r<<1)+(a?1:0),Math.round(qc*n)+128,Math.round(qc*i)+128,(s===0?0:s<0?-1:1)+1|(c&63)<<2,c>>6),this.lineClips){let f=this.scaledDistance-this.lineClips.start,y=this.lineClips.end-this.lineClips.start,m=f/y;this.layoutVertexArray2.emplaceBack(m,this.lineClipsArray.length)}let p=l.vertexLength++;this.e1>=0&&this.e2>=0&&(this.indexArray.emplaceBack(this.e1,this.e2,p),l.primitiveLength++),a?this.e2=p:this.e1=p}updateScaledDistance(){this.scaledDistance=this.lineClips?this.lineClips.start+(this.lineClips.end-this.lineClips.start)*this.distance/this.totalDistance:this.distance}updateDistance(t,r){this.distance+=t.dist(r),this.updateScaledDistance()}};k("LineBucket",Xt,{omit:["layers","patternFeatures"]});var Wc,Ag=()=>Wc=Wc||new ie({"line-cap":new z(S.layout_line["line-cap"]),"line-join":new R(S.layout_line["line-join"]),"line-miter-limit":new z(S.layout_line["line-miter-limit"]),"line-round-limit":new z(S.layout_line["line-round-limit"]),"line-sort-key":new R(S.layout_line["line-sort-key"])}),Hc,_g=()=>Hc=Hc||new ie({"line-opacity":new R(S.paint_line["line-opacity"]),"line-color":new R(S.paint_line["line-color"]),"line-translate":new z(S.paint_line["line-translate"]),"line-translate-anchor":new z(S.paint_line["line-translate-anchor"]),"line-width":new R(S.paint_line["line-width"]),"line-gap-width":new R(S.paint_line["line-gap-width"]),"line-offset":new R(S.paint_line["line-offset"]),"line-blur":new R(S.paint_line["line-blur"]),"line-dasharray":new Ot(S.paint_line["line-dasharray"]),"line-pattern":new st(S.paint_line["line-pattern"]),"line-gradient":new Nt(S.paint_line["line-gradient"])}),vs={get paint(){return _g()},get layout(){return Ag()}};var Ps=class extends R{possiblyEvaluate(r,n){return n=new q(Math.floor(n.zoom),{now:n.now,fadeDuration:n.fadeDuration,zoomHistory:n.zoomHistory,transition:n.transition}),super.possiblyEvaluate(r,n)}evaluate(r,n,i,o){return n=Ae({},n,{zoom:Math.floor(n.zoom)}),super.evaluate(r,n,i,o)}},Mo,Lo=class extends le{constructor(r){super(r,vs);this.gradientVersion=0,Mo||(Mo=new Ps(vs.paint.properties["line-width"].specification),Mo.useIntegerZoom=!0)}_handleSpecialPaintPropertyUpdate(r){if(r==="line-gradient"){let n=this._transitionablePaint._values["line-gradient"].value.expression;this.stepInterpolant=n._styleExpression.expression instanceof lr,this.gradientVersion=(this.gradientVersion+1)%Number.MAX_SAFE_INTEGER}}gradientExpression(){return this._transitionablePaint._values["line-gradient"].value.expression}recalculate(r,n){super.recalculate(r,n),this.paint._values["line-floorwidth"]=Mo.possiblyEvaluate(this._transitioningPaint._values["line-width"].value,r)}createBucket(r){return new Xt(r)}queryRadius(r){let n=r,i=Kc(Zt("line-width",this,n),Zt("line-gap-width",this,n)),o=Zt("line-offset",this,n);return i/2+Math.abs(o)+At(this.paint.get("line-translate"))}queryIntersectsFeature(r,n,i,o,a,s,l){let u=_t(r,this.paint.get("line-translate"),this.paint.get("line-translate-anchor"),s.angle,l),c=l/2*Kc(this.paint.get("line-width").evaluate(n,i),this.paint.get("line-gap-width").evaluate(n,i)),p=this.paint.get("line-offset").evaluate(n,i);return p&&(o=Zu(o,p*l)),qu(u,o,c)}isTileClipped(){return!0}};function Kc(e,t){return t>0?t+2*e:e}var Yc=ee([{name:"a_pos_offset",components:4,type:"Int16"},{name:"a_data",components:4,type:"Uint16"},{name:"a_pixeloffset",components:4,type:"Int16"}],4),Xc=ee([{name:"a_projected_pos",components:3,type:"Float32"}],4),SS=ee([{name:"a_fade_opacity",components:1,type:"Uint32"}],4),Qc=ee([{name:"a_placed",components:2,type:"Uint8"},{name:"a_shift",components:2,type:"Float32"}]),wS=ee([{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]),Ss=ee([{name:"a_pos",components:2,type:"Int16"},{name:"a_anchor_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"}],4),AS=ee([{name:"a_pos",components:2,type:"Float32"},{name:"a_radius",components:1,type:"Float32"},{name:"a_flags",components:2,type:"Int16"}],4),_S=ee([{name:"triangle",components:3,type:"Uint16"}]),IS=ee([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Uint16",name:"glyphStartIndex"},{type:"Uint16",name:"numGlyphs"},{type:"Uint32",name:"vertexStartIndex"},{type:"Uint32",name:"lineStartIndex"},{type:"Uint32",name:"lineLength"},{type:"Uint16",name:"segment"},{type:"Uint16",name:"lowerSize"},{type:"Uint16",name:"upperSize"},{type:"Float32",name:"lineOffsetX"},{type:"Float32",name:"lineOffsetY"},{type:"Uint8",name:"writingMode"},{type:"Uint8",name:"placedOrientation"},{type:"Uint8",name:"hidden"},{type:"Uint32",name:"crossTileID"},{type:"Int16",name:"associatedIconIndex"}]),CS=ee([{type:"Int16",name:"anchorX"},{type:"Int16",name:"anchorY"},{type:"Int16",name:"rightJustifiedTextSymbolIndex"},{type:"Int16",name:"centerJustifiedTextSymbolIndex"},{type:"Int16",name:"leftJustifiedTextSymbolIndex"},{type:"Int16",name:"verticalPlacedTextSymbolIndex"},{type:"Int16",name:"placedIconSymbolIndex"},{type:"Int16",name:"verticalPlacedIconSymbolIndex"},{type:"Uint16",name:"key"},{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"verticalTextBoxStartIndex"},{type:"Uint16",name:"verticalTextBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"verticalIconBoxStartIndex"},{type:"Uint16",name:"verticalIconBoxEndIndex"},{type:"Uint16",name:"featureIndex"},{type:"Uint16",name:"numHorizontalGlyphVertices"},{type:"Uint16",name:"numVerticalGlyphVertices"},{type:"Uint16",name:"numIconVertices"},{type:"Uint16",name:"numVerticalIconVertices"},{type:"Uint16",name:"useRuntimeCollisionCircles"},{type:"Uint32",name:"crossTileID"},{type:"Float32",name:"textBoxScale"},{type:"Float32",components:2,name:"textOffset"},{type:"Float32",name:"collisionCircleDiameter"}]),kS=ee([{type:"Float32",name:"offsetX"}]),TS=ee([{type:"Int16",name:"x"},{type:"Int16",name:"y"},{type:"Int16",name:"tileUnitDistanceFromAnchor"}]);var Jn=Z(he(),1);function Ig(e,t,r){let n=t.layout.get("text-transform").evaluate(r,{});return n==="uppercase"?e=e.toLocaleUpperCase():n==="lowercase"&&(e=e.toLocaleLowerCase()),ae.applyArabicShaping&&(e=ae.applyArabicShaping(e)),e}function ep(e,t,r){return e.sections.forEach(n=>{n.text=Ig(n.text,t,r)}),e}function tp(e){let t={},r={},n=[],i=0;function o(u){n.push(e[u]),i++}function a(u,c,p){let f=r[u];return delete r[u],r[c]=f,n[f].geometry[0].pop(),n[f].geometry[0]=n[f].geometry[0].concat(p[0]),f}function s(u,c,p){let f=t[c];return delete t[c],t[u]=f,n[f].geometry[0].shift(),n[f].geometry[0]=p[0].concat(n[f].geometry[0]),f}function l(u,c,p){let f=p?c[0][c[0].length-1]:c[0][0];return"".concat(u,":").concat(f.x,":").concat(f.y)}for(let u=0;u<e.length;u++){let c=e[u],p=c.geometry,f=c.text?c.text.toString():null;if(!f){o(u);continue}let y=l(f,p),m=l(f,p,!0);if(y in r&&m in t&&r[y]!==t[m]){let h=s(y,m,p),d=a(y,m,n[h].geometry);delete t[y],delete r[m],r[l(f,n[d].geometry,!0)]=d,n[h].geometry=null}else y in r?a(y,m,p):m in t?s(y,m,p):(o(u),t[y]=i-1,r[m]=i-1)}return n.filter(u=>u.geometry)}var Ir={"!":"\\uFE15","#":"\\uFF03",$:"\\uFF04","%":"\\uFF05","&":"\\uFF06","(":"\\uFE35",")":"\\uFE36","*":"\\uFF0A","+":"\\uFF0B",",":"\\uFE10","-":"\\uFE32",".":"\\u30FB","/":"\\uFF0F",":":"\\uFE13",";":"\\uFE14","<":"\\uFE3F","=":"\\uFF1D",">":"\\uFE40","?":"\\uFE16","@":"\\uFF20","[":"\\uFE47","\\\\":"\\uFF3C","]":"\\uFE48","^":"\\uFF3E",_:"\\uFE33","\`":"\\uFF40","{":"\\uFE37","|":"\\u2015","}":"\\uFE38","~":"\\uFF5E","\\xA2":"\\uFFE0","\\xA3":"\\uFFE1","\\xA5":"\\uFFE5","\\xA6":"\\uFFE4","\\xAC":"\\uFFE2","\\xAF":"\\uFFE3","\\u2013":"\\uFE32","\\u2014":"\\uFE31","\\u2018":"\\uFE43","\\u2019":"\\uFE44","\\u201C":"\\uFE41","\\u201D":"\\uFE42","\\u2026":"\\uFE19","\\u2027":"\\u30FB","\\u20A9":"\\uFFE6","\\u3001":"\\uFE11","\\u3002":"\\uFE12","\\u3008":"\\uFE3F","\\u3009":"\\uFE40","\\u300A":"\\uFE3D","\\u300B":"\\uFE3E","\\u300C":"\\uFE41","\\u300D":"\\uFE42","\\u300E":"\\uFE43","\\u300F":"\\uFE44","\\u3010":"\\uFE3B","\\u3011":"\\uFE3C","\\u3014":"\\uFE39","\\u3015":"\\uFE3A","\\u3016":"\\uFE17","\\u3017":"\\uFE18","\\uFF01":"\\uFE15","\\uFF08":"\\uFE35","\\uFF09":"\\uFE36","\\uFF0C":"\\uFE10","\\uFF0D":"\\uFE32","\\uFF0E":"\\u30FB","\\uFF1A":"\\uFE13","\\uFF1B":"\\uFE14","\\uFF1C":"\\uFE3F","\\uFF1E":"\\uFE40","\\uFF1F":"\\uFE16","\\uFF3B":"\\uFE47","\\uFF3D":"\\uFE48","\\uFF3F":"\\uFE33","\\uFF5B":"\\uFE37","\\uFF5C":"\\u2015","\\uFF5D":"\\uFE38","\\uFF5F":"\\uFE35","\\uFF60":"\\uFE36","\\uFF61":"\\uFE12","\\uFF62":"\\uFE41","\\uFF63":"\\uFE42"};function rp(e){let t="";for(let r=0;r<e.length;r++){let n=e.charCodeAt(r+1)||null,i=e.charCodeAt(r-1)||null;(!n||!Ka(n)||Ir[e[r+1]])&&(!i||!Ka(i)||Ir[e[r-1]])&&Ir[e[r]]?t+=Ir[e[r]]:t+=e[r]}return t}var ue=24;var qg=Z($n(),1),jg=3;var Bo=jg;function Gn(e){let t=0,r=0;for(let s of e)t+=s.w*s.h,r=Math.max(r,s.w);e.sort((s,l)=>l.h-s.h);let i=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(t/.95)),r),h:1/0}],o=0,a=0;for(let s of e)for(let l=i.length-1;l>=0;l--){let u=i[l];if(!(s.w>u.w||s.h>u.h)){if(s.x=u.x,s.y=u.y,a=Math.max(a,s.y+s.h),o=Math.max(o,s.x+s.w),s.w===u.w&&s.h===u.h){let c=i.pop();l<i.length&&(i[l]=c)}else s.h===u.h?(u.x+=s.w,u.w-=s.w):s.w===u.w?(u.y+=s.h,u.h-=s.h):(i.push({x:u.x+s.w,y:u.y,w:u.w-s.w,h:s.h}),u.y+=s.h,u.h-=s.h);break}}return{w:o,h:a,fill:t/(o*a)||0}}var ge=1;var zo=class{constructor(t,{pixelRatio:r,version:n,stretchX:i,stretchY:o,content:a}){this.paddedRect=t,this.pixelRatio=r,this.stretchX=i,this.stretchY=o,this.content=a,this.version=n}get tl(){return[this.paddedRect.x+ge,this.paddedRect.y+ge]}get br(){return[this.paddedRect.x+this.paddedRect.w-ge,this.paddedRect.y+this.paddedRect.h-ge]}get tlbr(){return this.tl.concat(this.br)}get displaySize(){return[(this.paddedRect.w-ge*2)/this.pixelRatio,(this.paddedRect.h-ge*2)/this.pixelRatio]}},qn=class{constructor(t,r){let n={},i={};this.haveRenderCallbacks=[];let o=[];this.addImages(t,n,o),this.addImages(r,i,o);let{w:a,h:s}=Gn(o),l=new de({width:a||1,height:s||1});for(let u in t){let c=t[u],p=n[u].paddedRect;de.copy(c.data,l,{x:0,y:0},{x:p.x+ge,y:p.y+ge},c.data)}for(let u in r){let c=r[u],p=i[u].paddedRect,f=p.x+ge,y=p.y+ge,m=c.data.width,h=c.data.height;de.copy(c.data,l,{x:0,y:0},{x:f,y},c.data),de.copy(c.data,l,{x:0,y:h-1},{x:f,y:y-1},{width:m,height:1}),de.copy(c.data,l,{x:0,y:0},{x:f,y:y+h},{width:m,height:1}),de.copy(c.data,l,{x:m-1,y:0},{x:f-1,y},{width:1,height:h}),de.copy(c.data,l,{x:0,y:0},{x:f+m,y},{width:1,height:h})}this.image=l,this.iconPositions=n,this.patternPositions=i}addImages(t,r,n){for(let i in t){let o=t[i],a={x:0,y:0,w:o.data.width+2*ge,h:o.data.height+2*ge};n.push(a),r[i]=new zo(a,o),o.hasRenderCallback&&this.haveRenderCallbacks.push(i)}}patchUpdatedImages(t,r){t.dispatchRenderCallbacks(this.haveRenderCallbacks);for(let n in t.updatedImages)this.patchUpdatedImage(this.iconPositions[n],t.getImage(n),r),this.patchUpdatedImage(this.patternPositions[n],t.getImage(n),r)}patchUpdatedImage(t,r,n){if(!t||!r||t.version===r.version)return;t.version=r.version;let[i,o]=t.tl;n.update(r.data,void 0,{x:i,y:o})}};k("ImagePosition",zo);k("ImageAtlas",qn);var No=(i=>(i[i.none=0]="none",i[i.horizontal=1]="horizontal",i[i.vertical=2]="vertical",i[i.horizontalOnly=3]="horizontalOnly",i))(No||{}),Tr=-17;function Zg(e){for(let t of e)if(t.positionedGlyphs.length!==0)return!1;return!0}var up=57344,cp=63743,Ro=class e{constructor(){this.scale=1,this.fontStack="",this.imageName=null}static forText(t,r){let n=new e;return n.scale=t||1,n.fontStack=r,n}static forImage(t){let r=new e;return r.imageName=t,r}},jn=class e{constructor(){this.text="",this.sectionIndex=[],this.sections=[],this.imageSectionID=null}static fromFeature(t,r){let n=new e;for(let i=0;i<t.sections.length;i++){let o=t.sections[i];o.image?n.addImageSection(o):n.addTextSection(o,r)}return n}length(){return this.text.length}getSection(t){return this.sections[this.sectionIndex[t]]}getSectionIndex(t){return this.sectionIndex[t]}getCharCode(t){return this.text.charCodeAt(t)}verticalizePunctuation(){this.text=rp(this.text)}trim(){let t=0;for(let n=0;n<this.text.length&&Oo[this.text.charCodeAt(n)];n++)t++;let r=this.text.length;for(let n=this.text.length-1;n>=0&&n>=t&&Oo[this.text.charCodeAt(n)];n--)r--;this.text=this.text.substring(t,r),this.sectionIndex=this.sectionIndex.slice(t,r)}substring(t,r){let n=new e;return n.text=this.text.substring(t,r),n.sectionIndex=this.sectionIndex.slice(t,r),n.sections=this.sections,n}toString(){return this.text}getMaxScale(){return this.sectionIndex.reduce((t,r)=>Math.max(t,this.sections[r].scale),0)}addTextSection(t,r){this.text+=t.text,this.sections.push(Ro.forText(t.scale,t.fontStack||r));let n=this.sections.length-1;for(let i=0;i<t.text.length;++i)this.sectionIndex.push(n)}addImageSection(t){let r=t.image?t.image.name:"";if(r.length===0){ce("Can't add FormattedSection with an empty image.");return}let n=this.getNextImageSectionCharCode();if(!n){ce("Reached maximum number of images ".concat(cp-up+2));return}this.text+=String.fromCharCode(n),this.sections.push(Ro.forImage(r)),this.sectionIndex.push(this.sections.length-1)}getNextImageSectionCharCode(){return this.imageSectionID?this.imageSectionID>=cp?null:++this.imageSectionID:(this.imageSectionID=up,this.imageSectionID)}};function Jg(e,t){let r=[],n=e.text,i=0;for(let o of t)r.push(e.substring(i,o)),i=o;return i<n.length&&r.push(e.substring(i,n.length)),r}function Zn(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h){let d=jn.fromFeature(e,i);p===2&&d.verticalizePunctuation();let g,{processBidirectionalText:v,processStyledBidirectionalText:b}=ae;if(v&&d.sections.length===1){g=[];let w=v(d.toString(),_s(d,u,o,t,n,y,m));for(let A of w){let T=new jn;T.text=A,T.sections=d.sections;for(let I=0;I<A.length;I++)T.sectionIndex.push(0);g.push(T)}}else if(b){g=[];let w=b(d.text,d.sectionIndex,_s(d,u,o,t,n,y,m));for(let A of w){let T=new jn;T.text=A[0],T.sectionIndex=A[1],T.sections=d.sections,g.push(T)}}else g=Jg(d,_s(d,u,o,t,n,y,m));let x=[],P={positionedLines:x,text:d.toString(),top:c[1],bottom:c[1],left:c[0],right:c[0],writingMode:p,iconsInText:!1,verticalizable:!1};return Yg(P,t,r,n,g,a,s,l,p,u,f,h),Zg(x)?!1:P}var Oo={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},Wg={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};function yp(e,t,r,n,i,o){if(t.imageName){let a=n[t.imageName];return a?a.displaySize[0]*t.scale*ue/o+i:0}else{let a=r[t.fontStack],s=a&&a[e];return s?s.metrics.advance*t.scale+i:0}}function Hg(e,t,r,n,i,o){let a=0;for(let l=0;l<e.length();l++){let u=e.getSection(l);a+=yp(e.getCharCode(l),u,n,i,t,o)}let s=Math.max(1,Math.ceil(a/r));return a/s}function pp(e,t,r,n){let i=Math.pow(e-t,2);return n?e<t?i/2:i*2:i+Math.abs(r)*r}function Kg(e,t,r){let n=0;return e===10&&(n-=1e4),r&&(n+=150),(e===40||e===65288)&&(n+=50),(t===41||t===65289)&&(n+=50),n}function fp(e,t,r,n,i,o){let a=null,s=pp(t,r,i,o);for(let l of n){let u=t-l.x,c=pp(u,r,i,o)+l.badness;c<=s&&(a=l,s=c)}return{index:e,x:t,priorBreak:a,badness:s}}function mp(e){return e?mp(e.priorBreak).concat(e.index):[]}function _s(e,t,r,n,i,o,a){if(o!=="point")return[];if(!e)return[];let s=[],l=Hg(e,t,r,n,i,a),u=e.text.indexOf("\\u200B")>=0,c=0;for(let p=0;p<e.length();p++){let f=e.getSection(p),y=e.getCharCode(p);if(Oo[y]||(c+=yp(y,f,n,i,t,a)),p<e.length()-1){let m=Au(y);(Wg[y]||m||f.imageName)&&s.push(fp(p+1,c,l,s,Kg(y,e.getCharCode(p+1),m&&u),!1))}}return mp(fp(e.length(),c,l,s,0,!0))}function hp(e){let t=.5,r=.5;switch(e){case"right":case"top-right":case"bottom-right":t=1;break;case"left":case"top-left":case"bottom-left":t=0;break}switch(e){case"bottom":case"bottom-right":case"bottom-left":r=1;break;case"top":case"top-right":case"top-left":r=0;break}return{horizontalAlign:t,verticalAlign:r}}function Yg(e,t,r,n,i,o,a,s,l,u,c,p){let f=0,y=Tr,m=0,h=0,d=s==="right"?1:s==="left"?0:.5,g=0;for(let P of i){P.trim();let w=P.getMaxScale(),A=(w-1)*ue,T={positionedGlyphs:[],lineOffset:0};e.positionedLines[g]=T;let I=T.positionedGlyphs,E=0;if(!P.length()){y+=o,++g;continue}for(let F=0;F<P.length();F++){let M=P.getSection(F),B=P.getSectionIndex(F),C=P.getCharCode(F),O=0,N=null,K=null,Y=null,Q=ue,ye=!(l===1||!c&&!Ui(C)||c&&(Oo[C]||_u(C)));if(M.imageName){let _e=n[M.imageName];if(!_e)continue;Y=M.imageName,e.iconsInText=e.iconsInText||!0,K=_e.paddedRect;let re=_e.displaySize;M.scale=M.scale*ue/p,N={width:re[0],height:re[1],left:ge,top:-Bo,advance:ye?re[1]:re[0]};let Pe=ue-re[1]*M.scale;O=A+Pe,Q=N.advance;let $e=ye?re[0]*M.scale-ue*w:re[1]*M.scale-ue*w;$e>0&&$e>E&&(E=$e)}else{let _e=r[M.fontStack],re=_e&&_e[C];if(re&&re.rect)K=re.rect,N=re.metrics;else{let Pe=t[M.fontStack],$e=Pe&&Pe[C];if(!$e)continue;N=$e.metrics}O=(w-M.scale)*ue}ye?(e.verticalizable=!0,I.push({glyph:C,imageName:Y,x:f,y:y+O,vertical:ye,scale:M.scale,fontStack:M.fontStack,sectionIndex:B,metrics:N,rect:K}),f+=Q*M.scale+u):(I.push({glyph:C,imageName:Y,x:f,y:y+O,vertical:ye,scale:M.scale,fontStack:M.fontStack,sectionIndex:B,metrics:N,rect:K}),f+=N.advance*M.scale+u)}if(I.length!==0){let F=f-u;m=Math.max(F,m),Xg(I,0,I.length-1,d,E)}f=0;let _=o*w+E;T.lineOffset=Math.max(E,A),y+=_,h=Math.max(_,h),++g}let v=y-Tr,{horizontalAlign:b,verticalAlign:x}=hp(a);Qg(e.positionedLines,d,b,x,m,h,o,v,i.length),e.top+=-x*v,e.bottom=e.top+v,e.left+=-b*m,e.right=e.left+m}function Xg(e,t,r,n,i){if(!n&&!i)return;let o=e[r],a=o.metrics.advance*o.scale,s=(e[r].x+a)*n;for(let l=t;l<=r;l++)e[l].x-=s,e[l].y+=i}function Qg(e,t,r,n,i,o,a,s,l){let u=(t-r)*i,c=0;o!==a?c=-s*n-Tr:c=(-n*l+.5)*a;for(let p of e)for(let f of p.positionedGlyphs)f.x+=u,f.y+=c}function dp(e,t,r){let{horizontalAlign:n,verticalAlign:i}=hp(r),o=t[0],a=t[1],s=o-e.displaySize[0]*n,l=s+e.displaySize[0],u=a-e.displaySize[1]*i,c=u+e.displaySize[1];return{image:e,top:u,bottom:c,left:s,right:l}}function Is(e,t,r,n,i,o){let a=e.image,s;if(a.content){let d=a.content,g=a.pixelRatio||1;s=[d[0]/g,d[1]/g,a.displaySize[0]-d[2]/g,a.displaySize[1]-d[3]/g]}let l=t.left*o,u=t.right*o,c,p,f,y;r==="width"||r==="both"?(y=i[0]+l-n[3],p=i[0]+u+n[1]):(y=i[0]+(l+u-a.displaySize[0])/2,p=y+a.displaySize[0]);let m=t.top*o,h=t.bottom*o;return r==="height"||r==="both"?(c=i[1]+m-n[0],f=i[1]+h+n[2]):(c=i[1]+(m+h-a.displaySize[1])/2,f=c+a.displaySize[1]),{image:a,top:c,right:p,bottom:f,left:y,collisionPadding:s}}var gp=Z(It(),1);var Er=255,Ct=128,Qe=Er*Ct;function Cs(e,t){let{expression:r}=t;if(r.kind==="constant")return{kind:"constant",layoutSize:r.evaluate(new q(e+1))};if(r.kind==="source")return{kind:"source"};{let{zoomStops:n,interpolationType:i}=r,o=0;for(;o<n.length&&n[o]<=e;)o++;o=Math.max(0,o-1);let a=o;for(;a<n.length&&n[a]<e+1;)a++;a=Math.min(n.length-1,a);let s=n[o],l=n[a];if(r.kind==="composite")return{kind:"composite",minZoom:s,maxZoom:l,interpolationType:i};let u=r.evaluate(new q(s)),c=r.evaluate(new q(l));return{kind:"camera",minZoom:s,maxZoom:l,minSize:u,maxSize:c,interpolationType:i}}}function ks(e,t,r){let n="never",i=e.get(t);return i?n=i:e.get(r)&&(n="always"),n}var ex=gp.default.VectorTileFeature.types,tx=[{name:"a_fade_opacity",components:1,type:"Uint8",offset:0}];function Uo(e,t,r,n,i,o,a,s,l,u,c,p,f){let y=s?Math.min(Qe,Math.round(s[0])):0,m=s?Math.min(Qe,Math.round(s[1])):0;e.emplaceBack(t,r,Math.round(n*32),Math.round(i*32),o,a,(y<<1)+(l?1:0),m,u*16,c*16,p*256,f*256)}function xp(e,t,r){e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r),e.emplaceBack(t.x,t.y,r)}function rx(e){for(let t of e.sections)if(Cu(t.text))return!0;return!1}var Wn=class{constructor(t){this.layoutVertexArray=new lo,this.indexArray=new Le,this.programConfigurations=t,this.segments=new me,this.dynamicLayoutVertexArray=new uo,this.opacityVertexArray=new co,this.hasVisibleVertices=!1,this.placedSymbolArray=new wn}isEmpty(){return this.layoutVertexArray.length===0&&this.indexArray.length===0&&this.dynamicLayoutVertexArray.length===0&&this.opacityVertexArray.length===0}upload(t,r,n,i){this.isEmpty()||(n&&(this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,Yc.members),this.indexBuffer=t.createIndexBuffer(this.indexArray,r),this.dynamicLayoutVertexBuffer=t.createVertexBuffer(this.dynamicLayoutVertexArray,Xc.members,!0),this.opacityVertexBuffer=t.createVertexBuffer(this.opacityVertexArray,tx,!0),this.opacityVertexBuffer.itemSize=1),(n||i)&&this.programConfigurations.upload(t))}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.programConfigurations.destroy(),this.segments.destroy(),this.dynamicLayoutVertexBuffer.destroy(),this.opacityVertexBuffer.destroy())}};k("SymbolBuffers",Wn);var Hn=class{constructor(t,r,n){this.layoutVertexArray=new t,this.layoutAttributes=r,this.indexArray=new n,this.segments=new me,this.collisionVertexArray=new po}upload(t){this.layoutVertexBuffer=t.createVertexBuffer(this.layoutVertexArray,this.layoutAttributes),this.indexBuffer=t.createIndexBuffer(this.indexArray),this.collisionVertexBuffer=t.createVertexBuffer(this.collisionVertexArray,Qc.members,!0)}destroy(){this.layoutVertexBuffer&&(this.layoutVertexBuffer.destroy(),this.indexBuffer.destroy(),this.segments.destroy(),this.collisionVertexBuffer.destroy())}};k("CollisionBuffers",Hn);var We=class{constructor(t){this.collisionBoxArray=t.collisionBoxArray,this.zoom=t.zoom,this.overscaling=t.overscaling,this.layers=t.layers,this.layerIds=this.layers.map(l=>l.id),this.index=t.index,this.pixelRatio=t.pixelRatio,this.sourceLayerIndex=t.sourceLayerIndex,this.hasPattern=!1,this.hasRTLText=!1,this.sortKeyRanges=[],this.collisionCircleArray=[],this.placementInvProjMatrix=Dn.identity([]),this.placementViewportMatrix=Dn.identity([]);let n=this.layers[0]._unevaluatedLayout._values;this.textSizeData=Cs(this.zoom,n["text-size"]),this.iconSizeData=Cs(this.zoom,n["icon-size"]);let i=this.layers[0].layout,o=i.get("symbol-sort-key"),a=i.get("symbol-z-order");this.canOverlap=ks(i,"text-overlap","text-allow-overlap")!=="never"||ks(i,"icon-overlap","icon-allow-overlap")!=="never"||i.get("text-ignore-placement")||i.get("icon-ignore-placement"),this.sortFeaturesByKey=a!=="viewport-y"&&!o.isConstant();let s=a==="viewport-y"||a==="auto"&&!this.sortFeaturesByKey;this.sortFeaturesByY=s&&this.canOverlap,i.get("symbol-placement")==="point"&&(this.writingModes=i.get("text-writing-mode").map(l=>No[l])),this.stateDependentLayerIds=this.layers.filter(l=>l.isStateDependent()).map(l=>l.id),this.sourceID=t.sourceID}createArrays(){this.text=new Wn(new ke(this.layers,this.zoom,t=>/^text/.test(t))),this.icon=new Wn(new ke(this.layers,this.zoom,t=>/^icon/.test(t))),this.glyphOffsetArray=new _n,this.lineVertexArray=new In,this.symbolInstances=new An}calculateGlyphDependencies(t,r,n,i,o){for(let a=0;a<t.length;a++)if(r[t.charCodeAt(a)]=!0,(n||i)&&o){let s=Ir[t.charAt(a)];s&&(r[s.charCodeAt(0)]=!0)}}populate(t,r,n){let i=this.layers[0],o=i.layout,a=o.get("text-font"),s=o.get("text-field"),l=o.get("icon-image"),u=(s.value.kind!=="constant"||s.value.value instanceof Me&&!s.value.value.isEmpty()||s.value.value.toString().length>0)&&(a.value.kind!=="constant"||a.value.value.length>0),c=l.value.kind!=="constant"||!!l.value.value||Object.keys(l.parameters).length>0,p=o.get("symbol-sort-key");if(this.features=[],!u&&!c)return;let f=r.iconDependencies,y=r.glyphDependencies,m=r.availableImages,h=new q(this.zoom);for(let{feature:d,id:g,index:v,sourceLayerIndex:b}of t){let x=i._featureFilter.needGeometry,P=Oe(d,x);if(!i._featureFilter.filter(h,P,n))continue;x||(P.geometry=Te(d));let w;if(u){let E=i.getValueAndResolveTokens("text-field",P,n,m),_=Me.factory(E);rx(_)&&(this.hasRTLText=!0),(!this.hasRTLText||Eu()==="unavailable"||this.hasRTLText&&ae.isParsed())&&(w=ep(_,i,P))}let A;if(c){let E=i.getValueAndResolveTokens("icon-image",P,n,m);E instanceof Ce?A=E:A=Ce.fromString(E)}if(!w&&!A)continue;let T=this.sortFeaturesByKey?p.evaluate(P,{},n):void 0,I={id:g,text:w,icon:A,index:v,sourceLayerIndex:b,geometry:P.geometry,properties:d.properties,type:ex[d.type],sortKey:T};if(this.features.push(I),A&&(f[A.name]=!0),w){let E=a.evaluate(P,{},n).join(","),_=o.get("text-rotation-alignment")!=="viewport"&&o.get("symbol-placement")!=="point";this.allowVerticalPlacement=this.writingModes&&this.writingModes.indexOf(2)>=0;for(let F of w.sections)if(F.image)f[F.image.name]=!0;else{let M=on(w.toString()),B=F.fontStack||E,C=y[B]=y[B]||{};this.calculateGlyphDependencies(F.text,C,_,this.allowVerticalPlacement,M)}}}o.get("symbol-placement")==="line"&&(this.features=tp(this.features)),this.sortFeaturesByKey&&this.features.sort((d,g)=>d.sortKey-g.sortKey)}update(t,r,n){this.stateDependentLayers.length&&(this.text.programConfigurations.updatePaintArrays(t,r,this.layers,n),this.icon.programConfigurations.updatePaintArrays(t,r,this.layers,n))}isEmpty(){return this.symbolInstances.length===0&&!this.hasRTLText}uploadPending(){return!this.uploaded||this.text.programConfigurations.needsUpload||this.icon.programConfigurations.needsUpload}upload(t){!this.uploaded&&this.hasDebugData()&&(this.textCollisionBox.upload(t),this.iconCollisionBox.upload(t)),this.text.upload(t,this.sortFeaturesByY,!this.uploaded,this.text.programConfigurations.needsUpload),this.icon.upload(t,this.sortFeaturesByY,!this.uploaded,this.icon.programConfigurations.needsUpload),this.uploaded=!0}destroyDebugData(){this.textCollisionBox.destroy(),this.iconCollisionBox.destroy()}destroy(){this.text.destroy(),this.icon.destroy(),this.hasDebugData()&&this.destroyDebugData()}addToLineVertexArray(t,r){let n=this.lineVertexArray.length;if(t.segment!==void 0){let i=t.dist(r[t.segment+1]),o=t.dist(r[t.segment]),a={};for(let s=t.segment+1;s<r.length;s++)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:i},s<r.length-1&&(i+=r[s+1].dist(r[s]));for(let s=t.segment||0;s>=0;s--)a[s]={x:r[s].x,y:r[s].y,tileUnitDistanceFromAnchor:o},s>0&&(o+=r[s-1].dist(r[s]));for(let s=0;s<r.length;s++){let l=a[s];this.lineVertexArray.emplaceBack(l.x,l.y,l.tileUnitDistanceFromAnchor)}}return{lineStartIndex:n,lineLength:this.lineVertexArray.length-n}}addSymbols(t,r,n,i,o,a,s,l,u,c,p,f){let y=t.indexArray,m=t.layoutVertexArray,h=t.segments.prepareSegment(4*r.length,m,y,this.canOverlap?a.sortKey:void 0),d=this.glyphOffsetArray.length,g=h.vertexLength,v=this.allowVerticalPlacement&&s===2?Math.PI/2:0,b=a.text&&a.text.sections;for(let x=0;x<r.length;x++){let{tl:P,tr:w,bl:A,br:T,tex:I,pixelOffsetTL:E,pixelOffsetBR:_,minFontScaleX:F,minFontScaleY:M,glyphOffset:B,isSDF:C,sectionIndex:O}=r[x],N=h.vertexLength,K=B[1];Uo(m,l.x,l.y,P.x,K+P.y,I.x,I.y,n,C,E.x,E.y,F,M),Uo(m,l.x,l.y,w.x,K+w.y,I.x+I.w,I.y,n,C,_.x,E.y,F,M),Uo(m,l.x,l.y,A.x,K+A.y,I.x,I.y+I.h,n,C,E.x,_.y,F,M),Uo(m,l.x,l.y,T.x,K+T.y,I.x+I.w,I.y+I.h,n,C,_.x,_.y,F,M),xp(t.dynamicLayoutVertexArray,l,v),y.emplaceBack(N,N+1,N+2),y.emplaceBack(N+1,N+2,N+3),h.vertexLength+=4,h.primitiveLength+=2,this.glyphOffsetArray.emplaceBack(B[0]),(x===r.length-1||O!==r[x+1].sectionIndex)&&t.programConfigurations.populatePaintArrays(m.length,a,a.index,{},f,b&&b[O])}t.placedSymbolArray.emplaceBack(l.x,l.y,d,this.glyphOffsetArray.length-d,g,u,c,l.segment,n?n[0]:0,n?n[1]:0,i[0],i[1],s,0,!1,0,p)}_addCollisionDebugVertex(t,r,n,i,o,a){return r.emplaceBack(0,0),t.emplaceBack(n.x,n.y,i,o,Math.round(a.x),Math.round(a.y))}addCollisionDebugVertices(t,r,n,i,o,a,s){let l=o.segments.prepareSegment(4,o.layoutVertexArray,o.indexArray),u=l.vertexLength,c=o.layoutVertexArray,p=o.collisionVertexArray,f=s.anchorX,y=s.anchorY;this._addCollisionDebugVertex(c,p,a,f,y,new Jn.default(t,r)),this._addCollisionDebugVertex(c,p,a,f,y,new Jn.default(n,r)),this._addCollisionDebugVertex(c,p,a,f,y,new Jn.default(n,i)),this._addCollisionDebugVertex(c,p,a,f,y,new Jn.default(t,i)),l.vertexLength+=4;let m=o.indexArray;m.emplaceBack(u,u+1),m.emplaceBack(u+1,u+2),m.emplaceBack(u+2,u+3),m.emplaceBack(u+3,u),l.primitiveLength+=4}addDebugCollisionBoxes(t,r,n,i){for(let o=t;o<r;o++){let a=this.collisionBoxArray.get(o),s=a.x1,l=a.y1,u=a.x2,c=a.y2;this.addCollisionDebugVertices(s,l,u,c,i?this.textCollisionBox:this.iconCollisionBox,a.anchorPoint,n)}}generateCollisionDebugBuffers(){this.hasDebugData()&&this.destroyDebugData(),this.textCollisionBox=new Hn(kn,Ss.members,St),this.iconCollisionBox=new Hn(kn,Ss.members,St);for(let t=0;t<this.symbolInstances.length;t++){let r=this.symbolInstances.get(t);this.addDebugCollisionBoxes(r.textBoxStartIndex,r.textBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.verticalTextBoxStartIndex,r.verticalTextBoxEndIndex,r,!0),this.addDebugCollisionBoxes(r.iconBoxStartIndex,r.iconBoxEndIndex,r,!1),this.addDebugCollisionBoxes(r.verticalIconBoxStartIndex,r.verticalIconBoxEndIndex,r,!1)}}_deserializeCollisionBoxesForSymbol(t,r,n,i,o,a,s,l,u){let c={};for(let p=r;p<n;p++){let f=t.get(p);c.textBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.textFeatureIndex=f.featureIndex;break}for(let p=i;p<o;p++){let f=t.get(p);c.verticalTextBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalTextFeatureIndex=f.featureIndex;break}for(let p=a;p<s;p++){let f=t.get(p);c.iconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.iconFeatureIndex=f.featureIndex;break}for(let p=l;p<u;p++){let f=t.get(p);c.verticalIconBox={x1:f.x1,y1:f.y1,x2:f.x2,y2:f.y2,anchorPointX:f.anchorPointX,anchorPointY:f.anchorPointY},c.verticalIconFeatureIndex=f.featureIndex;break}return c}deserializeCollisionBoxes(t){this.collisionArrays=[];for(let r=0;r<this.symbolInstances.length;r++){let n=this.symbolInstances.get(r);this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t,n.textBoxStartIndex,n.textBoxEndIndex,n.verticalTextBoxStartIndex,n.verticalTextBoxEndIndex,n.iconBoxStartIndex,n.iconBoxEndIndex,n.verticalIconBoxStartIndex,n.verticalIconBoxEndIndex))}}hasTextData(){return this.text.segments.get().length>0}hasIconData(){return this.icon.segments.get().length>0}hasDebugData(){return this.textCollisionBox&&this.iconCollisionBox}hasTextCollisionBoxData(){return this.hasDebugData()&&this.textCollisionBox.segments.get().length>0}hasIconCollisionBoxData(){return this.hasDebugData()&&this.iconCollisionBox.segments.get().length>0}addIndicesForPlacedSymbol(t,r){let n=t.placedSymbolArray.get(r),i=n.vertexStartIndex+n.numGlyphs*4;for(let o=n.vertexStartIndex;o<i;o+=4)t.indexArray.emplaceBack(o,o+1,o+2),t.indexArray.emplaceBack(o+1,o+2,o+3)}getSortedSymbolIndexes(t){if(this.sortedAngle===t&&this.symbolInstanceIndexes!==void 0)return this.symbolInstanceIndexes;let r=Math.sin(t),n=Math.cos(t),i=[],o=[],a=[];for(let s=0;s<this.symbolInstances.length;++s){a.push(s);let l=this.symbolInstances.get(s);i.push(Math.round(r*l.anchorX+n*l.anchorY)|0),o.push(l.featureIndex)}return a.sort((s,l)=>i[s]-i[l]||o[l]-o[s]),a}addToSortKeyRanges(t,r){let n=this.sortKeyRanges[this.sortKeyRanges.length-1];n&&n.sortKey===r?n.symbolInstanceEnd=t+1:this.sortKeyRanges.push({sortKey:r,symbolInstanceStart:t,symbolInstanceEnd:t+1})}sortFeatures(t){if(this.sortFeaturesByY&&this.sortedAngle!==t&&!(this.text.segments.get().length>1||this.icon.segments.get().length>1)){this.symbolInstanceIndexes=this.getSortedSymbolIndexes(t),this.sortedAngle=t,this.text.indexArray.clear(),this.icon.indexArray.clear(),this.featureSortOrder=[];for(let r of this.symbolInstanceIndexes){let n=this.symbolInstances.get(r);this.featureSortOrder.push(n.featureIndex),[n.rightJustifiedTextSymbolIndex,n.centerJustifiedTextSymbolIndex,n.leftJustifiedTextSymbolIndex].forEach((i,o,a)=>{i>=0&&a.indexOf(i)===o&&this.addIndicesForPlacedSymbol(this.text,i)}),n.verticalPlacedTextSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.text,n.verticalPlacedTextSymbolIndex),n.placedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.placedIconSymbolIndex),n.verticalPlacedIconSymbolIndex>=0&&this.addIndicesForPlacedSymbol(this.icon,n.verticalPlacedIconSymbolIndex)}this.text.indexBuffer&&this.text.indexBuffer.updateData(this.text.indexArray),this.icon.indexBuffer&&this.icon.indexBuffer.updateData(this.icon.indexArray)}}};k("SymbolBucket",We,{omit:["layers","collisionBoxArray","features","compareText"]});We.MAX_GLYPHS=65535;We.addDynamicAttributes=xp;function bp(e,t){return t.replace(/{([^{}]+)}/g,(r,n)=>n in e?String(e[n]):"")}var vp,nx=()=>vp=vp||new ie({"symbol-placement":new z(S.layout_symbol["symbol-placement"]),"symbol-spacing":new z(S.layout_symbol["symbol-spacing"]),"symbol-avoid-edges":new z(S.layout_symbol["symbol-avoid-edges"]),"symbol-sort-key":new R(S.layout_symbol["symbol-sort-key"]),"symbol-z-order":new z(S.layout_symbol["symbol-z-order"]),"icon-allow-overlap":new z(S.layout_symbol["icon-allow-overlap"]),"icon-overlap":new z(S.layout_symbol["icon-overlap"]),"icon-ignore-placement":new z(S.layout_symbol["icon-ignore-placement"]),"icon-optional":new z(S.layout_symbol["icon-optional"]),"icon-rotation-alignment":new z(S.layout_symbol["icon-rotation-alignment"]),"icon-size":new R(S.layout_symbol["icon-size"]),"icon-text-fit":new z(S.layout_symbol["icon-text-fit"]),"icon-text-fit-padding":new z(S.layout_symbol["icon-text-fit-padding"]),"icon-image":new R(S.layout_symbol["icon-image"]),"icon-rotate":new R(S.layout_symbol["icon-rotate"]),"icon-padding":new R(S.layout_symbol["icon-padding"]),"icon-keep-upright":new z(S.layout_symbol["icon-keep-upright"]),"icon-offset":new R(S.layout_symbol["icon-offset"]),"icon-anchor":new R(S.layout_symbol["icon-anchor"]),"icon-pitch-alignment":new z(S.layout_symbol["icon-pitch-alignment"]),"text-pitch-alignment":new z(S.layout_symbol["text-pitch-alignment"]),"text-rotation-alignment":new z(S.layout_symbol["text-rotation-alignment"]),"text-field":new R(S.layout_symbol["text-field"]),"text-font":new R(S.layout_symbol["text-font"]),"text-size":new R(S.layout_symbol["text-size"]),"text-max-width":new R(S.layout_symbol["text-max-width"]),"text-line-height":new z(S.layout_symbol["text-line-height"]),"text-letter-spacing":new R(S.layout_symbol["text-letter-spacing"]),"text-justify":new R(S.layout_symbol["text-justify"]),"text-radial-offset":new R(S.layout_symbol["text-radial-offset"]),"text-variable-anchor":new z(S.layout_symbol["text-variable-anchor"]),"text-variable-anchor-offset":new R(S.layout_symbol["text-variable-anchor-offset"]),"text-anchor":new R(S.layout_symbol["text-anchor"]),"text-max-angle":new z(S.layout_symbol["text-max-angle"]),"text-writing-mode":new z(S.layout_symbol["text-writing-mode"]),"text-rotate":new R(S.layout_symbol["text-rotate"]),"text-padding":new z(S.layout_symbol["text-padding"]),"text-keep-upright":new z(S.layout_symbol["text-keep-upright"]),"text-transform":new R(S.layout_symbol["text-transform"]),"text-offset":new R(S.layout_symbol["text-offset"]),"text-allow-overlap":new z(S.layout_symbol["text-allow-overlap"]),"text-overlap":new z(S.layout_symbol["text-overlap"]),"text-ignore-placement":new z(S.layout_symbol["text-ignore-placement"]),"text-optional":new z(S.layout_symbol["text-optional"])}),Pp,ix=()=>Pp=Pp||new ie({"icon-opacity":new R(S.paint_symbol["icon-opacity"]),"icon-color":new R(S.paint_symbol["icon-color"]),"icon-halo-color":new R(S.paint_symbol["icon-halo-color"]),"icon-halo-width":new R(S.paint_symbol["icon-halo-width"]),"icon-halo-blur":new R(S.paint_symbol["icon-halo-blur"]),"icon-translate":new z(S.paint_symbol["icon-translate"]),"icon-translate-anchor":new z(S.paint_symbol["icon-translate-anchor"]),"text-opacity":new R(S.paint_symbol["text-opacity"]),"text-color":new R(S.paint_symbol["text-color"],{runtimeType:ze,getOverride:e=>e.textColor,hasOverride:e=>!!e.textColor}),"text-halo-color":new R(S.paint_symbol["text-halo-color"]),"text-halo-width":new R(S.paint_symbol["text-halo-width"]),"text-halo-blur":new R(S.paint_symbol["text-halo-blur"]),"text-translate":new z(S.paint_symbol["text-translate"]),"text-translate-anchor":new z(S.paint_symbol["text-translate-anchor"])}),$o={get paint(){return ix()},get layout(){return nx()}};var Kn=class{constructor(t){if(t.property.overrides===void 0)throw new Error("overrides must be provided to instantiate FormatSectionOverride class");this.type=t.property.overrides?t.property.overrides.runtimeType:cr,this.defaultValue=t}evaluate(t){if(t.formattedSection){let r=this.defaultValue.property.overrides;if(r&&r.hasOverride(t.formattedSection))return r.getOverride(t.formattedSection)}return t.feature&&t.featureState?this.defaultValue.evaluate(t.feature,t.featureState):this.defaultValue.property.specification.default}eachChild(t){if(!this.defaultValue.isConstant()){let r=this.defaultValue.value;t(r._styleExpression.expression)}}outputDefined(){return!1}serialize(){return null}};k("FormatSectionOverride",Kn,{omit:["defaultValue"]});var Go=class e extends le{constructor(r){super(r,$o)}recalculate(r,n){if(super.recalculate(r,n),this.layout.get("icon-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["icon-rotation-alignment"]="map":this.layout._values["icon-rotation-alignment"]="viewport"),this.layout.get("text-rotation-alignment")==="auto"&&(this.layout.get("symbol-placement")!=="point"?this.layout._values["text-rotation-alignment"]="map":this.layout._values["text-rotation-alignment"]="viewport"),this.layout.get("text-pitch-alignment")==="auto"&&(this.layout._values["text-pitch-alignment"]=this.layout.get("text-rotation-alignment")==="map"?"map":"viewport"),this.layout.get("icon-pitch-alignment")==="auto"&&(this.layout._values["icon-pitch-alignment"]=this.layout.get("icon-rotation-alignment")),this.layout.get("symbol-placement")==="point"){let i=this.layout.get("text-writing-mode");if(i){let o=[];for(let a of i)o.indexOf(a)<0&&o.push(a);this.layout._values["text-writing-mode"]=o}else this.layout._values["text-writing-mode"]=["horizontal"]}this._setPaintOverrides()}getValueAndResolveTokens(r,n,i,o){let a=this.layout.get(r).evaluate(n,{},i,o),s=this._unevaluatedLayout._values[r];return!s.isDataDriven()&&!en(s.value)&&a?bp(n.properties,a):a}createBucket(r){return new We(r)}queryRadius(){return 0}queryIntersectsFeature(){throw new Error("Should take a different path in FeatureIndex")}_setPaintOverrides(){for(let r of $o.paint.overridableProperties){if(!e.hasPaintOverride(this.layout,r))continue;let n=this.paint.get(r),i=new Kn(n),o=new Dt(i,n.property.specification),a=null;n.value.kind==="constant"||n.value.kind==="source"?a=new dt("source",o):a=new gt("composite",o,n.value.zoomStops),this.paint._values[r]=new be(n.property,a,n.parameters)}}_handleOverridablePaintPropertyUpdate(r,n,i){return!this.layout||n.isDataDriven()||i.isDataDriven()?!1:e.hasPaintOverride(this.layout,r)}static hasPaintOverride(r,n){let i=r.get("text-field"),o=$o.paint.properties[n],a=!1,s=l=>{for(let u of l)if(o.overrides&&o.overrides.hasOverride(u)){a=!0;return}};if(i.value.kind==="constant"&&i.value.value instanceof Me)s(i.value.value.sections);else if(i.value.kind==="source"){let l=c=>{if(!a)if(c instanceof mt&&fe(c.value)===pr){let p=c.value;s(p.sections)}else c instanceof Hr?s(c.sections):c.eachChild(l)},u=i.value;u._styleExpression&&l(u._styleExpression.expression)}return a}};function Sp(e,t,r,n=1){let i=e.get("icon-padding").evaluate(t,{},r),o=i&&i.values;return[o[0]*n,o[1]*n,o[2]*n,o[3]*n]}var wp,ox=()=>wp=wp||new ie({"background-color":new z(S.paint_background["background-color"]),"background-pattern":new Ot(S.paint_background["background-pattern"]),"background-opacity":new z(S.paint_background["background-opacity"])}),Ap={get paint(){return ox()}};var qo=class extends le{constructor(r){super(r,Ap)}};var _p,ax=()=>_p=_p||new ie({"raster-opacity":new z(S.paint_raster["raster-opacity"]),"raster-hue-rotate":new z(S.paint_raster["raster-hue-rotate"]),"raster-brightness-min":new z(S.paint_raster["raster-brightness-min"]),"raster-brightness-max":new z(S.paint_raster["raster-brightness-max"]),"raster-saturation":new z(S.paint_raster["raster-saturation"]),"raster-contrast":new z(S.paint_raster["raster-contrast"]),"raster-resampling":new z(S.paint_raster["raster-resampling"]),"raster-fade-duration":new z(S.paint_raster["raster-fade-duration"])}),Ip={get paint(){return ax()}};var jo=class extends le{constructor(r){super(r,Ip)}};var Zo=class extends le{constructor(r){super(r,{});this.onAdd=r=>{this.implementation.onAdd&&this.implementation.onAdd(r,r.painter.context.gl)};this.onRemove=r=>{this.implementation.onRemove&&this.implementation.onRemove(r,r.painter.context.gl)};this.implementation=r}is3D(){return this.implementation.renderingMode==="3d"}hasOffscreenPass(){return this.implementation.prerender!==void 0}recalculate(){}updateTransitions(){}hasTransition(){return!1}serialize(){throw new Error("Custom layers cannot be serialized")}};function Cp(e){if(e.type==="custom")return new Zo(e);switch(e.type){case"background":return new qo(e);case"circle":return new Po(e);case"fill":return new ko(e);case"fill-extrusion":return new Fo(e);case"heatmap":return new So(e);case"hillshade":return new wo(e);case"line":return new Lo(e);case"raster":return new jo(e);case"symbol":return new Go(e)}}var Jo=class{constructor(t){this.keyCache={},t&&this.replace(t)}replace(t){this._layerConfigs={},this._layers={},this.update(t,[])}update(t,r){for(let i of t){this._layerConfigs[i.id]=i;let o=this._layers[i.id]=Cp(i);o._featureFilter=tn(o.filter),this.keyCache[i.id]&&delete this.keyCache[i.id]}for(let i of r)delete this.keyCache[i],delete this._layerConfigs[i],delete this._layers[i];this.familiesBySource={};let n=Ql(Object.values(this._layerConfigs),this.keyCache);for(let i of n){let o=i.map(p=>this._layers[p.id]),a=o[0];if(a.visibility==="none")continue;let s=a.source||"",l=this.familiesBySource[s];l||(l=this.familiesBySource[s]={});let u=a.sourceLayer||"_geojsonTileLayer",c=l[u];c||(c=l[u]=[]),c.push(o)}}};var Xp=Z(It(),1),Qp=Z($n(),1);var Fr=class{constructor(t){this._stringToNumber={},this._numberToString=[];for(let r=0;r<t.length;r++){let n=t[r];this._stringToNumber[n]=r,this._numberToString[r]=n}}encode(t){return this._stringToNumber[t]}decode(t){if(t>=this._numberToString.length)throw new Error("Out of bounds. Index requested n=".concat(t," can't be >= this._numberToString.length ").concat(this._numberToString.length));return this._numberToString[t]}};var Ep=Z(It(),1),Fp=Z($n(),1);var Wo=class{constructor(t,r,n,i,o){this.type="Feature",this._vectorTileFeature=t,t._z=r,t._x=n,t._y=i,this.properties=t.properties,this.id=o}get geometry(){return this._geometry===void 0&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry}set geometry(t){this._geometry=t}toJSON(){let t={geometry:this.geometry};for(let r in this)r==="_geometry"||r==="_vectorTileFeature"||(t[r]=this[r]);return t}};var Yn=class{constructor(t,r){this.tileID=t,this.x=t.canonical.x,this.y=t.canonical.y,this.z=t.canonical.z,this.grid=new Ft(8192,16,0),this.grid3D=new Ft(8192,16,0),this.featureIndexArray=new Cn,this.promoteId=r}insert(t,r,n,i,o,a){let s=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(n,i,o);let l=a?this.grid3D:this.grid;for(let u=0;u<r.length;u++){let c=r[u],p=[1/0,1/0,-1/0,-1/0];for(let f=0;f<c.length;f++){let y=c[f];p[0]=Math.min(p[0],y.x),p[1]=Math.min(p[1],y.y),p[2]=Math.max(p[2],y.x),p[3]=Math.max(p[3],y.y)}p[0]<8192&&p[1]<8192&&p[2]>=0&&p[3]>=0&&l.insert(s,p[0],p[1],p[2],p[3])}}loadVTLayers(){return this.vtLayers||(this.vtLayers=new Ep.default.VectorTile(new Fp.default(this.rawTileData)).layers,this.sourceLayerCoder=new Fr(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"])),this.vtLayers}query(t,r,n,i){this.loadVTLayers();let o=t.params||{},a=8192/t.tileSize/t.scale,s=tn(o.filter),l=t.queryGeometry,u=t.queryPadding*a,c=Tp(l),p=this.grid.query(c.minX-u,c.minY-u,c.maxX+u,c.maxY+u),f=Tp(t.cameraQueryGeometry),y=this.grid3D.query(f.minX-u,f.minY-u,f.maxX+u,f.maxY+u,(d,g,v,b)=>ju(t.cameraQueryGeometry,d-u,g-u,v+u,b+u));for(let d of y)p.push(d);p.sort(sx);let m={},h;for(let d=0;d<p.length;d++){let g=p[d];if(g===h)continue;h=g;let v=this.featureIndexArray.get(g),b=null;this.loadMatchingFeature(m,v.bucketIndex,v.sourceLayerIndex,v.featureIndex,s,o.layers,o.availableImages,r,n,i,(x,P,w)=>(b||(b=Te(x)),P.queryIntersectsFeature(l,x,w,b,this.z,t.transform,a,t.pixelPosMatrix)))}return m}loadMatchingFeature(t,r,n,i,o,a,s,l,u,c,p){let f=this.bucketLayerIDs[r];if(a&&!gl(a,f))return;let y=this.sourceLayerCoder.decode(n),h=this.vtLayers[y].feature(i);if(o.needGeometry){let g=Oe(h,!0);if(!o.filter(new q(this.tileID.overscaledZ),g,this.tileID.canonical))return}else if(!o.filter(new q(this.tileID.overscaledZ),h))return;let d=this.getId(h,y);for(let g=0;g<f.length;g++){let v=f[g];if(a&&a.indexOf(v)<0)continue;let b=l[v];if(!b)continue;let x={};d&&c&&(x=c.getState(b.sourceLayer||"_geojsonTileLayer",d));let P=Ae({},u[v]);P.paint=kp(P.paint,b.paint,h,x,s),P.layout=kp(P.layout,b.layout,h,x,s);let w=!p||p(h,b,x);if(!w)continue;let A=new Wo(h,this.z,this.x,this.y,d);A.layer=P;let T=t[v];T===void 0&&(T=t[v]=[]),T.push({featureIndex:i,feature:A,intersectionZ:w})}}lookupSymbolFeatures(t,r,n,i,o,a,s,l){let u={};this.loadVTLayers();let c=tn(o);for(let p of t)this.loadMatchingFeature(u,n,i,p,c,a,s,l,r);return u}hasLayer(t){for(let r of this.bucketLayerIDs)for(let n of r)if(t===n)return!0;return!1}getId(t,r){let n=t.id;if(this.promoteId){let i=typeof this.promoteId=="string"?this.promoteId:this.promoteId[r];n=t.properties[i],typeof n=="boolean"&&(n=Number(n))}return n}};k("FeatureIndex",Yn,{omit:["rawTileData","sourceLayerCoder"]});function kp(e,t,r,n,i){return Rr(e,(o,a)=>{let s=t instanceof vt?t.get(a):null;return s&&s.evaluate?s.evaluate(r,n,i):s})}function Tp(e){let t=1/0,r=1/0,n=-1/0,i=-1/0;for(let o of e)t=Math.min(t,o.x),r=Math.min(r,o.y),n=Math.max(n,o.x),i=Math.max(i,o.y);return{minX:t,minY:r,maxX:n,maxY:i}}function sx(e,t){return t-e}var Mp=Z(he(),1);var et=class e extends Mp.default{constructor(r,n,i,o){super(r,n);this.angle=i,o!==void 0&&(this.segment=o)}clone(){return new e(this.x,this.y,this.angle,this.segment)}};k("Anchor",et);function Ts(e,t,r,n,i){if(t.segment===void 0||r===0)return!0;let o=t,a=t.segment+1,s=0;for(;s>-r/2;){if(a--,a<0)return!1;s-=e[a].dist(o),o=e[a]}s+=e[a].dist(e[a+1]),a++;let l=[],u=0;for(;s<r/2;){let c=e[a-1],p=e[a],f=e[a+1];if(!f)return!1;let y=c.angleTo(p)-p.angleTo(f);for(y=Math.abs((y+3*Math.PI)%(Math.PI*2)-Math.PI),l.push({distance:s,angleDelta:y}),u+=y;s-l[0].distance>n;)u-=l.shift().angleDelta;if(u>i)return!1;a++,s+=p.dist(f)}return!0}function Lp(e){let t=0;for(let r=0;r<e.length-1;r++)t+=e[r].dist(e[r+1]);return t}function Dp(e,t,r){return e?3/5*t*r:0}function Vp(e,t){return Math.max(e?e.right-e.left:0,t?t.right-t.left:0)}function Bp(e,t,r,n,i,o){let a=Dp(r,i,o),s=Vp(r,n)*o,l=0,u=Lp(e)/2;for(let c=0;c<e.length-1;c++){let p=e[c],f=e[c+1],y=p.dist(f);if(l+y>u){let m=(u-l)/y,h=Re.number(p.x,f.x,m),d=Re.number(p.y,f.y,m),g=new et(h,d,f.angleTo(p),c);return g._round(),!a||Ts(e,g,s,a,t)?g:void 0}l+=y}}function zp(e,t,r,n,i,o,a,s,l){let u=Dp(n,o,a),c=Vp(n,i),p=c*a,f=e[0].x===0||e[0].x===l||e[0].y===0||e[0].y===l;t-p<t/4&&(t=p+t/4);let y=o*2,m=f?t/2*s%t:(c/2+y)*a*s%t;return Rp(e,m,t,u,r,p,f,!1,l)}function Rp(e,t,r,n,i,o,a,s,l){let u=o/2,c=Lp(e),p=0,f=t-r,y=[];for(let m=0;m<e.length-1;m++){let h=e[m],d=e[m+1],g=h.dist(d),v=d.angleTo(h);for(;f+r<p+g;){f+=r;let b=(f-p)/g,x=Re.number(h.x,d.x,b),P=Re.number(h.y,d.y,b);if(x>=0&&x<l&&P>=0&&P<l&&f-u>=0&&f+u<=c){let w=new et(x,P,v,m);w._round(),(!n||Ts(e,w,o,n,i))&&y.push(w)}}p+=g}return!s&&!y.length&&!a&&(y=Rp(e,p/2,r,n,i,o,a,!0,l)),y}var ct=Z(he(),1);function Op(e,t,r,n,i){let o=[];for(let a=0;a<e.length;a++){let s=e[a],l;for(let u=0;u<s.length-1;u++){let c=s[u],p=s[u+1];c.x<t&&p.x<t||(c.x<t?c=new ct.default(t,c.y+(p.y-c.y)*((t-c.x)/(p.x-c.x)))._round():p.x<t&&(p=new ct.default(t,c.y+(p.y-c.y)*((t-c.x)/(p.x-c.x)))._round()),!(c.y<r&&p.y<r)&&(c.y<r?c=new ct.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round():p.y<r&&(p=new ct.default(c.x+(p.x-c.x)*((r-c.y)/(p.y-c.y)),r)._round()),!(c.x>=n&&p.x>=n)&&(c.x>=n?c=new ct.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round():p.x>=n&&(p=new ct.default(n,c.y+(p.y-c.y)*((n-c.x)/(p.x-c.x)))._round()),!(c.y>=i&&p.y>=i)&&(c.y>=i?c=new ct.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round():p.y>=i&&(p=new ct.default(c.x+(p.x-c.x)*((i-c.y)/(p.y-c.y)),i)._round()),(!l||!c.equals(l[l.length-1]))&&(l=[c],o.push(l)),l.push(p)))))}}return o}var ve=Z(he(),1);var Mr=ge;function Es(e,t,r,n){let i=[],o=e.image,a=o.pixelRatio,s=o.paddedRect.w-2*Mr,l=o.paddedRect.h-2*Mr,u=e.right-e.left,c=e.bottom-e.top,p=o.stretchX||[[0,s]],f=o.stretchY||[[0,l]],y=(_,F)=>_+F[1]-F[0],m=p.reduce(y,0),h=f.reduce(y,0),d=s-m,g=l-h,v=0,b=m,x=0,P=h,w=0,A=d,T=0,I=g;if(o.content&&n){let _=o.content;v=Ho(p,0,_[0]),x=Ho(f,0,_[1]),b=Ho(p,_[0],_[2]),P=Ho(f,_[1],_[3]),w=_[0]-v,T=_[1]-x,A=_[2]-_[0]-b,I=_[3]-_[1]-P}let E=(_,F,M,B)=>{let C=Ko(_.stretch-v,b,u,e.left),O=Yo(_.fixed-w,A,_.stretch,m),N=Ko(F.stretch-x,P,c,e.top),K=Yo(F.fixed-T,I,F.stretch,h),Y=Ko(M.stretch-v,b,u,e.left),Q=Yo(M.fixed-w,A,M.stretch,m),ye=Ko(B.stretch-x,P,c,e.top),_e=Yo(B.fixed-T,I,B.stretch,h),re=new ve.default(C,N),Pe=new ve.default(Y,N),$e=new ve.default(Y,ye),fi=new ve.default(C,ye),ya=new ve.default(O/a,K/a),ma=new ve.default(Q/a,_e/a),zr=t*Math.PI/180;if(zr){let xe=Math.sin(zr),He=Math.cos(zr),Ke=[He,-xe,xe,He];re._matMult(Ke),Pe._matMult(Ke),fi._matMult(Ke),$e._matMult(Ke)}let yi=_.stretch+_.fixed,ha=M.stretch+M.fixed,mi=F.stretch+F.fixed,Ee=B.stretch+B.fixed,tr={x:o.paddedRect.x+Mr+yi,y:o.paddedRect.y+Mr+mi,w:ha-yi,h:Ee-mi},hi=A/a/u,Se=I/a/c;return{tl:re,tr:Pe,bl:fi,br:$e,tex:tr,writingMode:void 0,glyphOffset:[0,0],sectionIndex:0,pixelOffsetTL:ya,pixelOffsetBR:ma,minFontScaleX:hi,minFontScaleY:Se,isSDF:r}};if(!n||!o.stretchX&&!o.stretchY)i.push(E({fixed:0,stretch:-1},{fixed:0,stretch:-1},{fixed:0,stretch:s+1},{fixed:0,stretch:l+1}));else{let _=Np(p,d,m),F=Np(f,g,h);for(let M=0;M<_.length-1;M++){let B=_[M],C=_[M+1];for(let O=0;O<F.length-1;O++){let N=F[O],K=F[O+1];i.push(E(B,N,C,K))}}}return i}function Ho(e,t,r){let n=0;for(let i of e)n+=Math.max(t,Math.min(r,i[1]))-Math.max(t,Math.min(r,i[0]));return n}function Np(e,t,r){let n=[{fixed:-Mr,stretch:0}];for(let[i,o]of e){let a=n[n.length-1];n.push({fixed:i-a.stretch,stretch:a.stretch}),n.push({fixed:i-a.stretch,stretch:a.stretch+(o-i)})}return n.push({fixed:t+Mr,stretch:r}),n}function Ko(e,t,r,n){return e/t*r+n}function Yo(e,t,r,n){return e-t*r/n}function Up(e,t,r,n,i,o,a,s){let l=n.layout.get("text-rotate").evaluate(o,{})*Math.PI/180,u=[];for(let c of t.positionedLines)for(let p of c.positionedGlyphs){if(!p.rect)continue;let f=p.rect||{},m=Bo+1,h=!0,d=1,g=0,v=(i||s)&&p.vertical,b=p.metrics.advance*p.scale/2;if(s&&t.verticalizable){let Y=(p.scale-1)*ue,Q=(ue-p.metrics.width*p.scale)/2;g=c.lineOffset/2-(p.imageName?-Q:Y)}if(p.imageName){let Y=a[p.imageName];h=Y.sdf,d=Y.pixelRatio,m=ge/d}let x=i?[p.x+b,p.y]:[0,0],P=i?[0,0]:[p.x+b+r[0],p.y+r[1]-g],w=[0,0];v&&(w=P,P=[0,0]);let A=(p.metrics.left-m)*p.scale-b+P[0],T=(-p.metrics.top-m)*p.scale+P[1],I=A+f.w*p.scale/d,E=T+f.h*p.scale/d,_=new ve.default(A,T),F=new ve.default(I,T),M=new ve.default(A,E),B=new ve.default(I,E);if(v){let Y=new ve.default(-b,b-Tr),Q=-Math.PI/2,ye=ue/2-b,_e=p.imageName?ye:0,re=new ve.default(5-Tr-ye,-_e),Pe=new ve.default(...w);_._rotateAround(Q,Y)._add(re)._add(Pe),F._rotateAround(Q,Y)._add(re)._add(Pe),M._rotateAround(Q,Y)._add(re)._add(Pe),B._rotateAround(Q,Y)._add(re)._add(Pe)}if(l){let Y=Math.sin(l),Q=Math.cos(l),ye=[Q,-Y,Y,Q];_._matMult(ye),F._matMult(ye),M._matMult(ye),B._matMult(ye)}let C=new ve.default(0,0),O=new ve.default(0,0),N=0,K=0;u.push({tl:_,tr:F,bl:M,br:B,tex:f,writingMode:t.writingMode,glyphOffset:x,sectionIndex:p.sectionIndex,isSDF:h,pixelOffsetTL:C,pixelOffsetBR:O,minFontScaleX:N,minFontScaleY:K})}return u}var Xn=Z(he(),1),Qt=class{constructor(t,r,n,i,o,a,s,l,u,c){if(this.boxStartIndex=t.length,u){let p=a.top,f=a.bottom,y=a.collisionPadding;y&&(p-=y[1],f+=y[3]);let m=f-p;m>0&&(m=Math.max(10,m),this.circleDiameter=m)}else{let p=a.top*s-l[0],f=a.bottom*s+l[2],y=a.left*s-l[3],m=a.right*s+l[1],h=a.collisionPadding;if(h&&(y-=h[0]*s,p-=h[1]*s,m+=h[2]*s,f+=h[3]*s),c){let d=new Xn.default(y,p),g=new Xn.default(m,p),v=new Xn.default(y,f),b=new Xn.default(m,f),x=c*Math.PI/180;d._rotate(x),g._rotate(x),v._rotate(x),b._rotate(x),y=Math.min(d.x,g.x,v.x,b.x),m=Math.max(d.x,g.x,v.x,b.x),p=Math.min(d.y,g.y,v.y,b.y),f=Math.max(d.y,g.y,v.y,b.y)}t.emplaceBack(r.x,r.y,y,p,m,f,n,i,o)}this.boxEndIndex=t.length}};var Qn=class{constructor(t=[],r=lx){if(this.data=t,this.length=this.data.length,this.compare=r,this.length>0)for(let n=(this.length>>1)-1;n>=0;n--)this._down(n)}push(t){this.data.push(t),this.length++,this._up(this.length-1)}pop(){if(this.length===0)return;let t=this.data[0],r=this.data.pop();return this.length--,this.length>0&&(this.data[0]=r,this._down(0)),t}peek(){return this.data[0]}_up(t){let{data:r,compare:n}=this,i=r[t];for(;t>0;){let o=t-1>>1,a=r[o];if(n(i,a)>=0)break;r[t]=a,t=o}r[t]=i}_down(t){let{data:r,compare:n}=this,i=this.length>>1,o=r[t];for(;t<i;){let a=(t<<1)+1,s=r[a],l=a+1;if(l<this.length&&n(r[l],s)<0&&(a=l,s=r[l]),n(s,o)>=0)break;r[t]=s,t=a}r[t]=o}};function lx(e,t){return e<t?-1:e>t?1:0}var Fs=Z(he(),1);function $p(e,t=1,r=!1){let n=1/0,i=1/0,o=-1/0,a=-1/0,s=e[0];for(let h=0;h<s.length;h++){let d=s[h];(!h||d.x<n)&&(n=d.x),(!h||d.y<i)&&(i=d.y),(!h||d.x>o)&&(o=d.x),(!h||d.y>a)&&(a=d.y)}let l=o-n,u=a-i,c=Math.min(l,u),p=c/2,f=new Qn([],ux);if(c===0)return new Fs.default(n,i);for(let h=n;h<o;h+=c)for(let d=i;d<a;d+=c)f.push(new Lr(h+p,d+p,p,e));let y=px(e),m=f.length;for(;f.length;){let h=f.pop();(h.d>y.d||!y.d)&&(y=h,r&&console.log("found best %d after %d probes",Math.round(1e4*h.d)/1e4,m)),!(h.max-y.d<=t)&&(p=h.h/2,f.push(new Lr(h.p.x-p,h.p.y-p,p,e)),f.push(new Lr(h.p.x+p,h.p.y-p,p,e)),f.push(new Lr(h.p.x-p,h.p.y+p,p,e)),f.push(new Lr(h.p.x+p,h.p.y+p,p,e)),m+=4)}return r&&(console.log("num probes: ".concat(m)),console.log("best distance: ".concat(y.d))),y.p}function ux(e,t){return t.max-e.max}function Lr(e,t,r,n){this.p=new Fs.default(e,t),this.h=r,this.d=cx(this.p,n),this.max=this.d+this.h*Math.SQRT2}function cx(e,t){let r=!1,n=1/0;for(let i=0;i<t.length;i++){let o=t[i];for(let a=0,s=o.length,l=s-1;a<s;l=a++){let u=o[a],c=o[l];u.y>e.y!=c.y>e.y&&e.x<(c.x-u.x)*(e.y-u.y)/(c.y-u.y)+u.x&&(r=!r),n=Math.min(n,ls(e,u,c))}}return(r?1:-1)*Math.sqrt(n)}function px(e){let t=0,r=0,n=0,i=e[0];for(let o=0,a=i.length,s=a-1;o<a;s=o++){let l=i[o],u=i[s],c=l.x*u.y-u.x*l.y;r+=(l.x+u.x)*c,n+=(l.y+u.y)*c,t+=c*3}return new Lr(r/t,n/t,0,e)}var Ms=Z(rs(),1);var Dr=7,Ls=Number.POSITIVE_INFINITY;function fx(e,t){function r(i,o){let a=0,s=0;o<0&&(o=0);let l=o/Math.sqrt(2);switch(i){case"top-right":case"top-left":s=l-Dr;break;case"bottom-right":case"bottom-left":s=-l+Dr;break;case"bottom":s=-o+Dr;break;case"top":s=o-Dr;break}switch(i){case"top-right":case"bottom-right":a=-l;break;case"top-left":case"bottom-left":a=l;break;case"left":a=o;break;case"right":a=-o;break}return[a,s]}function n(i,o,a){let s=0,l=0;switch(o=Math.abs(o),a=Math.abs(a),i){case"top-right":case"top-left":case"top":l=a-Dr;break;case"bottom-right":case"bottom-left":case"bottom":l=-a+Dr;break}switch(i){case"top-right":case"bottom-right":case"right":s=-o;break;case"top-left":case"bottom-left":case"left":s=o;break}return[s,l]}return t[1]!==Ls?n(e,t[0],t[1]):r(e,t[0])}function jp(e){e.bucket.createArrays();let t=512*e.bucket.overscaling;e.bucket.tilePixelRatio=8192/t,e.bucket.compareText={},e.bucket.iconsNeedLinear=!1;let r=e.bucket.layers[0].layout,n=e.bucket.layers[0]._unevaluatedLayout._values,i={layoutIconSize:n["icon-size"].possiblyEvaluate(new q(e.bucket.zoom+1),e.canonical),layoutTextSize:n["text-size"].possiblyEvaluate(new q(e.bucket.zoom+1),e.canonical),textMaxSize:n["text-size"].possiblyEvaluate(new q(18))};if(e.bucket.textSizeData.kind==="composite"){let{minZoom:u,maxZoom:c}=e.bucket.textSizeData;i.compositeTextSizes=[n["text-size"].possiblyEvaluate(new q(u),e.canonical),n["text-size"].possiblyEvaluate(new q(c),e.canonical)]}if(e.bucket.iconSizeData.kind==="composite"){let{minZoom:u,maxZoom:c}=e.bucket.iconSizeData;i.compositeIconSizes=[n["icon-size"].possiblyEvaluate(new q(u),e.canonical),n["icon-size"].possiblyEvaluate(new q(c),e.canonical)]}let o=r.get("text-line-height")*ue,a=r.get("text-rotation-alignment")!=="viewport"&&r.get("symbol-placement")!=="point",s=r.get("text-keep-upright"),l=r.get("text-size");for(let u of e.bucket.features){let c=r.get("text-font").evaluate(u,{},e.canonical).join(","),p=l.evaluate(u,{},e.canonical),f=i.layoutTextSize.evaluate(u,{},e.canonical),y=i.layoutIconSize.evaluate(u,{},e.canonical),m={horizontal:{},vertical:void 0},h=u.text,d=[0,0];if(h){let x=h.toString(),P=r.get("text-letter-spacing").evaluate(u,{},e.canonical)*ue,w=wu(x)?P:0,A=r.get("text-anchor").evaluate(u,{},e.canonical),T=r.get("text-variable-anchor");if(!T){let M=r.get("text-radial-offset").evaluate(u,{},e.canonical);M?d=fx(A,[M*ue,Ls]):d=r.get("text-offset").evaluate(u,{},e.canonical).map(B=>B*ue)}let I=a?"center":r.get("text-justify").evaluate(u,{},e.canonical),E=r.get("symbol-placement"),_=E==="point"?r.get("text-max-width").evaluate(u,{},e.canonical)*ue:0,F=()=>{e.bucket.allowVerticalPlacement&&on(x)&&(m.vertical=Zn(h,e.glyphMap,e.glyphPositions,e.imagePositions,c,_,o,A,"left",w,d,2,!0,E,f,p))};if(!a&&T){let M=I==="auto"?T.map(C=>Gp(C)):[I],B=!1;for(let C=0;C<M.length;C++){let O=M[C];if(!m.horizontal[O])if(B)m.horizontal[O]=m.horizontal[0];else{let N=Zn(h,e.glyphMap,e.glyphPositions,e.imagePositions,c,_,o,"center",O,w,d,1,!1,E,f,p);N&&(m.horizontal[O]=N,B=N.positionedLines.length===1)}}F()}else{I==="auto"&&(I=Gp(A));let M=Zn(h,e.glyphMap,e.glyphPositions,e.imagePositions,c,_,o,A,I,w,d,1,!1,E,f,p);M&&(m.horizontal[I]=M),F(),on(x)&&a&&s&&(m.vertical=Zn(h,e.glyphMap,e.glyphPositions,e.imagePositions,c,_,o,A,I,w,d,2,!1,E,f,p))}}let g,v=!1;if(u.icon&&u.icon.name){let x=e.imageMap[u.icon.name];x&&(g=dp(e.imagePositions[u.icon.name],r.get("icon-offset").evaluate(u,{},e.canonical),r.get("icon-anchor").evaluate(u,{},e.canonical)),v=!!x.sdf,e.bucket.sdfIcons===void 0?e.bucket.sdfIcons=v:e.bucket.sdfIcons!==v&&ce("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),(x.pixelRatio!==e.bucket.pixelRatio||r.get("icon-rotate").constantOr(1)!==0)&&(e.bucket.iconsNeedLinear=!0))}let b=Zp(m.horizontal)||m.vertical;e.bucket.iconsInText=b?b.iconsInText:!1,(b||g)&&yx(e.bucket,u,m,g,e.imageMap,i,f,y,d,v,e.canonical)}e.showCollisionBoxes&&e.bucket.generateCollisionDebugBuffers()}function Gp(e){switch(e){case"right":case"top-right":case"bottom-right":return"right";case"left":case"top-left":case"bottom-left":return"left"}return"center"}function yx(e,t,r,n,i,o,a,s,l,u,c){let p=o.textMaxSize.evaluate(t,{});p===void 0&&(p=a);let f=e.layers[0].layout,y=f.get("icon-offset").evaluate(t,{},c),m=Zp(r.horizontal),h=24,d=a/h,g=e.tilePixelRatio*d,v=e.tilePixelRatio*p/h,b=e.tilePixelRatio*s,x=e.tilePixelRatio*f.get("symbol-spacing"),P=f.get("text-padding")*e.tilePixelRatio,w=Sp(f,t,c,e.tilePixelRatio),A=f.get("text-max-angle")/180*Math.PI,T=f.get("text-rotation-alignment")!=="viewport"&&f.get("symbol-placement")!=="point",I=f.get("icon-rotation-alignment")==="map"&&f.get("symbol-placement")!=="point",E=f.get("symbol-placement"),_=x/2,F=f.get("icon-text-fit"),M;n&&F!=="none"&&(e.allowVerticalPlacement&&r.vertical&&(M=Is(n,r.vertical,F,f.get("icon-text-fit-padding"),y,d)),m&&(n=Is(n,m,F,f.get("icon-text-fit-padding"),y,d)));let B=(C,O)=>{O.x<0||O.x>=8192||O.y<0||O.y>=8192||mx(e,O,C,r,n,i,M,e.layers[0],e.collisionBoxArray,t.index,t.sourceLayerIndex,e.index,g,[P,P,P,P],T,l,b,w,I,y,t,o,u,c,a)};if(E==="line")for(let C of Op(t.geometry,0,0,8192,8192)){let O=zp(C,x,A,r.vertical||m,n,h,v,e.overscaling,8192);for(let N of O){let K=m;(!K||!hx(e,K.text,_,N))&&B(C,N)}}else if(E==="line-center"){for(let C of t.geometry)if(C.length>1){let O=Bp(C,A,r.vertical||m,n,h,v);O&&B(C,O)}}else if(t.type==="Polygon")for(let C of Sr(t.geometry,0)){let O=$p(C,16);B(C[0],new et(O.x,O.y,0))}else if(t.type==="LineString")for(let C of t.geometry)B(C,new et(C[0].x,C[0].y,0));else if(t.type==="Point")for(let C of t.geometry)for(let O of C)B([O],new et(O.x,O.y,0))}function qp(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m){let h=Up(t,r,s,i,o,a,n,e.allowVerticalPlacement),d=e.textSizeData,g=null;d.kind==="source"?(g=[Ct*i.layout.get("text-size").evaluate(a,{})],g[0]>Qe&&ce("".concat(e.layerIds[0],': Value for "text-size" is >= ').concat(Er,'. Reduce your "text-size".'))):d.kind==="composite"&&(g=[Ct*y.compositeTextSizes[0].evaluate(a,{},m),Ct*y.compositeTextSizes[1].evaluate(a,{},m)],(g[0]>Qe||g[1]>Qe)&&ce("".concat(e.layerIds[0],': Value for "text-size" is >= ').concat(Er,'. Reduce your "text-size".'))),e.addSymbols(e.text,h,g,s,o,a,u,t,l.lineStartIndex,l.lineLength,f,m);for(let v of c)p[v]=e.text.placedSymbolArray.length-1;return h.length*4}function Zp(e){for(let t in e)return e[t];return null}function mx(e,t,r,n,i,o,a,s,l,u,c,p,f,y,m,h,d,g,v,b,x,P,w,A,T){let I=e.addToLineVertexArray(t,r),E,_,F,M,B=0,C=0,O=0,N=0,K=-1,Y=-1,Q={},ye=(0,Ms.default)(""),_e=0,re=0;if(s._unevaluatedLayout.getValue("text-radial-offset")===void 0?[_e,re]=s.layout.get("text-offset").evaluate(x,{},A).map(Se=>Se*ue):(_e=s.layout.get("text-radial-offset").evaluate(x,{},A)*ue,re=Ls),e.allowVerticalPlacement&&n.vertical){let xe=s.layout.get("text-rotate").evaluate(x,{},A)+90,He=n.vertical;F=new Qt(l,t,u,c,p,He,f,y,m,xe),a&&(M=new Qt(l,t,u,c,p,a,d,g,m,xe))}if(i){let Se=s.layout.get("icon-rotate").evaluate(x,{}),xe=s.layout.get("icon-text-fit")!=="none",He=Es(i,Se,w,xe),Ke=a?Es(a,Se,w,xe):void 0;_=new Qt(l,t,u,c,p,i,d,g,!1,Se),B=He.length*4;let al=e.iconSizeData,Et=null;al.kind==="source"?(Et=[Ct*s.layout.get("icon-size").evaluate(x,{})],Et[0]>Qe&&ce("".concat(e.layerIds[0],': Value for "icon-size" is >= ').concat(Er,'. Reduce your "icon-size".'))):al.kind==="composite"&&(Et=[Ct*P.compositeIconSizes[0].evaluate(x,{},A),Ct*P.compositeIconSizes[1].evaluate(x,{},A)],(Et[0]>Qe||Et[1]>Qe)&&ce("".concat(e.layerIds[0],': Value for "icon-size" is >= ').concat(Er,'. Reduce your "icon-size".'))),e.addSymbols(e.icon,He,Et,b,v,x,0,t,I.lineStartIndex,I.lineLength,-1,A),K=e.icon.placedSymbolArray.length-1,Ke&&(C=Ke.length*4,e.addSymbols(e.icon,Ke,Et,b,v,x,2,t,I.lineStartIndex,I.lineLength,-1,A),Y=e.icon.placedSymbolArray.length-1)}let Pe=Object.keys(n.horizontal);for(let Se of Pe){let xe=n.horizontal[Se];if(!E){ye=(0,Ms.default)(xe.text);let Ke=s.layout.get("text-rotate").evaluate(x,{},A);E=new Qt(l,t,u,c,p,xe,f,y,m,Ke)}let He=xe.positionedLines.length===1;if(O+=qp(e,t,xe,o,s,m,x,h,I,n.vertical?1:3,He?Pe:[Se],Q,K,P,A),He)break}n.vertical&&(N+=qp(e,t,n.vertical,o,s,m,x,h,I,2,["vertical"],Q,Y,P,A));let $e=E?E.boxStartIndex:e.collisionBoxArray.length,fi=E?E.boxEndIndex:e.collisionBoxArray.length,ya=F?F.boxStartIndex:e.collisionBoxArray.length,ma=F?F.boxEndIndex:e.collisionBoxArray.length,zr=_?_.boxStartIndex:e.collisionBoxArray.length,yi=_?_.boxEndIndex:e.collisionBoxArray.length,ha=M?M.boxStartIndex:e.collisionBoxArray.length,mi=M?M.boxEndIndex:e.collisionBoxArray.length,Ee=-1,tr=(Se,xe)=>Se&&Se.circleDiameter?Math.max(Se.circleDiameter,xe):xe;Ee=tr(E,Ee),Ee=tr(F,Ee),Ee=tr(_,Ee),Ee=tr(M,Ee);let hi=Ee>-1?1:0;hi&&(Ee*=T/ue),e.glyphOffsetArray.length>=We.MAX_GLYPHS&&ce("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),x.sortKey!==void 0&&e.addToSortKeyRanges(e.symbolInstances.length,x.sortKey),e.symbolInstances.emplaceBack(t.x,t.y,Q.right>=0?Q.right:-1,Q.center>=0?Q.center:-1,Q.left>=0?Q.left:-1,Q.vertical||-1,K,Y,ye,$e,fi,ya,ma,zr,yi,ha,mi,u,O,N,B,C,hi,0,f,_e,re,Ee)}function hx(e,t,r,n){let i=e.compareText;if(!(t in i))i[t]=[];else{let o=i[t];for(let a=o.length-1;a>=0;a--)if(n.dist(o[a])<r)return!0}return i[t].push(n),!1}var Xo=1,ei=class{constructor(t){let r={},n=[];for(let s in t){let l=t[s],u=r[s]={};for(let c in l){let p=l[+c];if(!p||p.bitmap.width===0||p.bitmap.height===0)continue;let f={x:0,y:0,w:p.bitmap.width+2*Xo,h:p.bitmap.height+2*Xo};n.push(f),u[c]={rect:f,metrics:p.metrics}}}let{w:i,h:o}=Gn(n),a=new Wt({width:i||1,height:o||1});for(let s in t){let l=t[s];for(let u in l){let c=l[+u];if(!c||c.bitmap.width===0||c.bitmap.height===0)continue;let p=r[s][u].rect;Wt.copy(c.bitmap,a,{x:0,y:0},{x:p.x+Xo,y:p.y+Xo},c.bitmap)}}this.image=a,this.positions=r}};k("GlyphAtlas",ei);function Wp(e,t,r){t=Math.pow(2,r)-t-1;var n=Jp(e*256,t*256,r),i=Jp((e+1)*256,(t+1)*256,r);return n[0]+","+n[1]+","+i[0]+","+i[1]}function Jp(e,t,r){var n=2*Math.PI*6378137/256/Math.pow(2,r),i=e*n-2*Math.PI*6378137/2,o=t*n-2*Math.PI*6378137/2;return[i,o]}var Yp=Z(he(),1);var Ds=63710088e-1,ti=class e{constructor(t,r){if(isNaN(t)||isNaN(r))throw new Error("Invalid LngLat object: (".concat(t,", ").concat(r,")"));if(this.lng=+t,this.lat=+r,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")}wrap(){return new e(ml(this.lng,-180,180),this.lat)}toArray(){return[this.lng,this.lat]}toString(){return"LngLat(".concat(this.lng,", ").concat(this.lat,")")}distanceTo(t){let r=Math.PI/180,n=this.lat*r,i=t.lat*r,o=Math.sin(n)*Math.sin(i)+Math.cos(n)*Math.cos(i)*Math.cos((t.lng-this.lng)*r);return Ds*Math.acos(Math.min(o,1))}static convert(t){if(t instanceof e)return t;if(Array.isArray(t)&&(t.length===2||t.length===3))return new e(Number(t[0]),Number(t[1]));if(!Array.isArray(t)&&typeof t=="object"&&t!==null)return new e(Number("lng"in t?t.lng:t.lon),Number(t.lat));throw new Error("\`LngLatLike\` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")}};var Hp=2*Math.PI*Ds;function Kp(e){return Hp*Math.cos(e*Math.PI/180)}function dx(e){return(180+e)/360}function gx(e){return(180-180/Math.PI*Math.log(Math.tan(Math.PI/4+e*Math.PI/360)))/360}function xx(e,t){return e/Kp(t)}function bx(e){return e*360-180}function Vs(e){let t=180-e*360;return 360/Math.PI*Math.atan(Math.exp(t*Math.PI/180))-90}function vx(e,t){return e*Kp(Vs(t))}function Px(e){return 1/Math.cos(e*Math.PI/180)}var Qo=class e{constructor(t,r,n=0){this.x=+t,this.y=+r,this.z=+n}static fromLngLat(t,r=0){let n=ti.convert(t);return new e(dx(n.lng),gx(n.lat),xx(r,n.lat))}toLngLat(){return new ti(bx(this.x),Vs(this.y))}toAltitude(){return vx(this.z,this.y)}meterInMercatorCoordinateUnits(){return 1/Hp*Px(Vs(this.y))}};var ea=class{constructor(t,r,n){if(t<0||t>25||n<0||n>=Math.pow(2,t)||r<0||r>=Math.pow(2,t))throw new Error("x=".concat(r,", y=").concat(n,", z=").concat(t," outside of bounds. 0<=x<").concat(Math.pow(2,t),", 0<=y<").concat(Math.pow(2,t)," 0<=z<=25 "));this.z=t,this.x=r,this.y=n,this.key=ri(0,t,t,r,n)}equals(t){return this.z===t.z&&this.x===t.x&&this.y===t.y}url(t,r,n){let i=Wp(this.x,this.y,this.z),o=Sx(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace(/{prefix}/g,(this.x%16).toString(16)+(this.y%16).toString(16)).replace(/{z}/g,String(this.z)).replace(/{x}/g,String(this.x)).replace(/{y}/g,String(n==="tms"?Math.pow(2,this.z)-this.y-1:this.y)).replace(/{ratio}/g,r>1?"@2x":"").replace(/{quadkey}/g,o).replace(/{bbox-epsg-3857}/g,i)}isChildOf(t){let r=this.z-t.z;return r>0&&t.x===this.x>>r&&t.y===this.y>>r}getTilePoint(t){let r=Math.pow(2,this.z);return new Yp.default((t.x*r-this.x)*8192,(t.y*r-this.y)*8192)}toString(){return"".concat(this.z,"/").concat(this.x,"/").concat(this.y)}},Bs=class{constructor(t,r){this.wrap=t,this.canonical=r,this.key=ri(t,r.z,r.z,r.x,r.y)}},ni=class e{constructor(t,r,n,i,o){if(t<n)throw new Error("overscaledZ should be >= z; overscaledZ = ".concat(t,"; z = ").concat(n));this.overscaledZ=t,this.wrap=r,this.canonical=new ea(n,+i,+o),this.key=ri(r,t,n,i,o)}clone(){return new e(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)}equals(t){return this.overscaledZ===t.overscaledZ&&this.wrap===t.wrap&&this.canonical.equals(t.canonical)}scaledTo(t){if(t>this.overscaledZ)throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t,"; overscaledZ = ").concat(this.overscaledZ));let r=this.canonical.z-t;return t>this.canonical.z?new e(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y):new e(t,this.wrap,t,this.canonical.x>>r,this.canonical.y>>r)}calculateScaledKey(t,r){if(t>this.overscaledZ)throw new Error("targetZ > this.overscaledZ; targetZ = ".concat(t,"; overscaledZ = ").concat(this.overscaledZ));let n=this.canonical.z-t;return t>this.canonical.z?ri(this.wrap*+r,t,this.canonical.z,this.canonical.x,this.canonical.y):ri(this.wrap*+r,t,t,this.canonical.x>>n,this.canonical.y>>n)}isChildOf(t){if(t.wrap!==this.wrap)return!1;let r=this.canonical.z-t.canonical.z;return t.overscaledZ===0||t.overscaledZ<this.overscaledZ&&t.canonical.x===this.canonical.x>>r&&t.canonical.y===this.canonical.y>>r}children(t){if(this.overscaledZ>=t)return[new e(this.overscaledZ+1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];let r=this.canonical.z+1,n=this.canonical.x*2,i=this.canonical.y*2;return[new e(r,this.wrap,r,n,i),new e(r,this.wrap,r,n+1,i),new e(r,this.wrap,r,n,i+1),new e(r,this.wrap,r,n+1,i+1)]}isLessThan(t){return this.wrap<t.wrap?!0:this.wrap>t.wrap?!1:this.overscaledZ<t.overscaledZ?!0:this.overscaledZ>t.overscaledZ?!1:this.canonical.x<t.canonical.x?!0:this.canonical.x>t.canonical.x?!1:this.canonical.y<t.canonical.y}wrapped(){return new e(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)}unwrapTo(t){return new e(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)}overscaleFactor(){return Math.pow(2,this.overscaledZ-this.canonical.z)}toUnwrapped(){return new Bs(this.wrap,this.canonical)}toString(){return"".concat(this.overscaledZ,"/").concat(this.canonical.x,"/").concat(this.canonical.y)}getTilePoint(t){return this.canonical.getTilePoint(new Qo(t.x-this.wrap,t.y))}};function ri(e,t,r,n,i){e*=2,e<0&&(e=e*-1-1);let o=1<<r;return(o*o*e+o*i+n).toString(36)+r.toString(36)+t.toString(36)}function Sx(e,t,r){let n="",i;for(let o=e;o>0;o--)i=1<<o-1,n+=(t&i?1:0)+(r&i?2:0);return n}k("CanonicalTileID",ea);k("OverscaledTileID",ni,{omit:["posMatrix"]});var ta=class{constructor(t){this.tileID=new ni(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),this.uid=t.uid,this.zoom=t.zoom,this.pixelRatio=t.pixelRatio,this.tileSize=t.tileSize,this.source=t.source,this.overscaling=this.tileID.overscaleFactor(),this.showCollisionBoxes=t.showCollisionBoxes,this.collectResourceTiming=!!t.collectResourceTiming,this.returnDependencies=!!t.returnDependencies,this.promoteId=t.promoteId,this.inFlightDependencies=[],this.dependencySentinel=-1}parse(t,r,n,i,o){this.status="parsing",this.data=t,this.collisionBoxArray=new Sn;let a=new Fr(Object.keys(t.layers).sort()),s=new Yn(this.tileID,this.promoteId);s.bucketLayerIDs=[];let l={},u={featureIndex:s,iconDependencies:{},patternDependencies:{},glyphDependencies:{},availableImages:n},c=r.familiesBySource[this.source];for(let x in c){let P=t.layers[x];if(!P)continue;P.version===1&&ce('Vector tile source "'.concat(this.source,'" layer "').concat(x,'" ')+"does not use vector tile spec v2 and therefore may have some rendering errors.");let w=a.encode(x),A=[];for(let T=0;T<P.length;T++){let I=P.feature(T),E=s.getId(I,x);A.push({feature:I,id:E,index:T,sourceLayerIndex:w})}for(let T of c[x]){let I=T[0];if(I.source!==this.source&&ce("layer.source = ".concat(I.source," does not equal this.source = ").concat(this.source)),I.minzoom&&this.zoom<Math.floor(I.minzoom)||I.maxzoom&&this.zoom>=I.maxzoom||I.visibility==="none")continue;zs(T,this.zoom,n),(l[I.id]=I.createBucket({index:s.bucketLayerIDs.length,layers:T,zoom:this.zoom,pixelRatio:this.pixelRatio,overscaling:this.overscaling,collisionBoxArray:this.collisionBoxArray,sourceLayerIndex:w,sourceID:this.source})).populate(A,u,this.tileID.canonical),s.bucketLayerIDs.push(T.map(_=>_.id))}}let p,f,y,m,h=Rr(u.glyphDependencies,x=>Object.keys(x).map(Number));this.inFlightDependencies.forEach(x=>x==null?void 0:x.cancel()),this.inFlightDependencies=[];let d=++this.dependencySentinel;Object.keys(h).length?this.inFlightDependencies.push(i.send("getGlyphs",{uid:this.uid,stacks:h,source:this.source,tileID:this.tileID,type:"glyphs"},(x,P)=>{d===this.dependencySentinel&&(p||(p=x,f=P,b.call(this)))})):f={};let g=Object.keys(u.iconDependencies);g.length?this.inFlightDependencies.push(i.send("getImages",{icons:g,source:this.source,tileID:this.tileID,type:"icons"},(x,P)=>{d===this.dependencySentinel&&(p||(p=x,y=P,b.call(this)))})):y={};let v=Object.keys(u.patternDependencies);v.length?this.inFlightDependencies.push(i.send("getImages",{icons:v,source:this.source,tileID:this.tileID,type:"patterns"},(x,P)=>{d===this.dependencySentinel&&(p||(p=x,m=P,b.call(this)))})):m={},b.call(this);function b(){if(p)return o(p);if(f&&y&&m){let x=new ei(f),P=new qn(y,m);for(let w in l){let A=l[w];A instanceof We?(zs(A.layers,this.zoom,n),jp({bucket:A,glyphMap:f,glyphPositions:x.positions,imageMap:y,imagePositions:P.iconPositions,showCollisionBoxes:this.showCollisionBoxes,canonical:this.tileID.canonical})):A.hasPattern&&(A instanceof Xt||A instanceof Kt||A instanceof Yt)&&(zs(A.layers,this.zoom,n),A.addFeatures(u,this.tileID.canonical,P.patternPositions))}this.status="done",o(null,{buckets:Object.values(l).filter(w=>!w.isEmpty()),featureIndex:s,collisionBoxArray:this.collisionBoxArray,glyphAtlasImage:x.image,imageAtlas:P,glyphMap:this.returnDependencies?f:null,iconMap:this.returnDependencies?y:null,glyphPositions:this.returnDependencies?x.positions:null})}}}};function zs(e,t,r){let n=new q(t);for(let i of e)i.recalculate(n,r)}var wx=60,f_=1e3/wx;var Vr=class{constructor(t){this._marks={start:[t.url,"start"].join("#"),end:[t.url,"end"].join("#"),measure:t.url.toString()},performance.mark(this._marks.start)}finish(){performance.mark(this._marks.end);let t=performance.getEntriesByName(this._marks.measure);return t.length===0&&(performance.measure(this._marks.measure,this._marks.start,this._marks.end),t=performance.getEntriesByName(this._marks.measure),performance.clearMarks(this._marks.start),performance.clearMarks(this._marks.end),performance.clearMeasures(this._marks.measure)),t}};function Ax(e,t){let r=Wa(e.request,(n,i,o,a)=>{n?t(n):i&&t(null,{vectorTile:new Xp.default.VectorTile(new Qp.default(i)),rawData:i,cacheControl:o,expires:a})});return()=>{r.cancel(),t()}}var Br=class{constructor(t,r,n,i){this.actor=t,this.layerIndex=r,this.availableImages=n,this.loadVectorData=i||Ax,this.loading={},this.loaded={}}loadTile(t,r){let n=t.uid;this.loading||(this.loading={});let i=t&&t.request&&t.request.collectResourceTiming?new Vr(t.request):!1,o=this.loading[n]=new ta(t);o.abort=this.loadVectorData(t,(a,s)=>{if(delete this.loading[n],a||!s)return o.status="done",this.loaded[n]=o,r(a);let l=s.rawData,u={};s.expires&&(u.expires=s.expires),s.cacheControl&&(u.cacheControl=s.cacheControl);let c={};if(i){let p=i.finish();p&&(c.resourceTiming=JSON.parse(JSON.stringify(p)))}o.vectorTile=s.vectorTile,o.parse(s.vectorTile,this.layerIndex,this.availableImages,this.actor,(p,f)=>{if(p||!f)return r(p);r(null,Ae({rawTileData:l.slice(0)},f,u,c))}),this.loaded=this.loaded||{},this.loaded[n]=o})}reloadTile(t,r){let n=this.loaded,i=t.uid,o=this;if(n&&n[i]){let a=n[i];a.showCollisionBoxes=t.showCollisionBoxes,a.status==="parsing"?a.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor,r):a.status==="done"&&(a.vectorTile?a.parse(a.vectorTile,this.layerIndex,this.availableImages,this.actor,r):r())}}abortTile(t,r){let n=this.loading,i=t.uid;n&&n[i]&&n[i].abort&&(n[i].abort(),delete n[i]),r()}removeTile(t,r){let n=this.loaded,i=t.uid;n&&n[i]&&delete n[i],r()}};var ii=class{constructor(t,r,n){if(this.uid=t,r.height!==r.width)throw new RangeError("DEM tiles must be square");if(n&&n!=="mapbox"&&n!=="terrarium"){ce('"'.concat(n,'" is not a valid encoding type. Valid types include "mapbox" and "terrarium".'));return}this.stride=r.height;let i=this.dim=r.height-2;this.data=new Uint32Array(r.data.buffer),this.encoding=n||"mapbox";for(let o=0;o<i;o++)this.data[this._idx(-1,o)]=this.data[this._idx(0,o)],this.data[this._idx(i,o)]=this.data[this._idx(i-1,o)],this.data[this._idx(o,-1)]=this.data[this._idx(o,0)],this.data[this._idx(o,i)]=this.data[this._idx(o,i-1)];this.data[this._idx(-1,-1)]=this.data[this._idx(0,0)],this.data[this._idx(i,-1)]=this.data[this._idx(i-1,0)],this.data[this._idx(-1,i)]=this.data[this._idx(0,i-1)],this.data[this._idx(i,i)]=this.data[this._idx(i-1,i-1)],this.min=Number.MAX_SAFE_INTEGER,this.max=Number.MIN_SAFE_INTEGER;for(let o=0;o<i;o++)for(let a=0;a<i;a++){let s=this.get(o,a);s>this.max&&(this.max=s),s<this.min&&(this.min=s)}}get(t,r){let n=new Uint8Array(this.data.buffer),i=this._idx(t,r)*4;return(this.encoding==="terrarium"?this._unpackTerrarium:this._unpackMapbox)(n[i],n[i+1],n[i+2])}getUnpackVector(){return this.encoding==="terrarium"?[256,1,1/256,32768]:[6553.6,25.6,.1,1e4]}_idx(t,r){if(t<-1||t>=this.dim+1||r<-1||r>=this.dim+1)throw new RangeError("out of range source coordinates for DEM data");return(r+1)*this.stride+(t+1)}_unpackMapbox(t,r,n){return(t*256*256+r*256+n)/10-1e4}_unpackTerrarium(t,r,n){return t*256+r+n/256-32768}getPixels(){return new de({width:this.stride,height:this.stride},new Uint8Array(this.data.buffer))}backfillBorder(t,r,n){if(this.dim!==t.dim)throw new Error("dem dimension mismatch");let i=r*this.dim,o=r*this.dim+this.dim,a=n*this.dim,s=n*this.dim+this.dim;switch(r){case-1:i=o-1;break;case 1:o=i+1;break}switch(n){case-1:a=s-1;break;case 1:s=a+1;break}let l=-r*this.dim,u=-n*this.dim;for(let c=a;c<s;c++)for(let p=i;p<o;p++)this.data[this._idx(p,c)]=t.data[this._idx(p+l,c+u)]}};k("DEMData",ii);var ra=class{constructor(){this.loaded={}}loadTile(t,r){let{uid:n,encoding:i,rawImageData:o}=t,a=Or(o)?this.getImageData(o):o,s=new ii(n,a,i);this.loaded=this.loaded||{},this.loaded[n]=s,r(null,s)}getImageData(t){(!this.offscreenCanvas||!this.offscreenCanvasContext)&&(this.offscreenCanvas=new OffscreenCanvas(t.width,t.height),this.offscreenCanvasContext=this.offscreenCanvas.getContext("2d",{willReadFrequently:!0})),this.offscreenCanvas.width=t.width,this.offscreenCanvas.height=t.height,this.offscreenCanvasContext.drawImage(t,0,0,t.width,t.height);let r=this.offscreenCanvasContext.getImageData(-1,-1,t.width+2,t.height+2);return this.offscreenCanvasContext.clearRect(0,0,this.offscreenCanvas.width,this.offscreenCanvas.height),new de({width:r.width,height:r.height},r.data)}removeTile(t){let r=this.loaded,n=t.uid;r&&r[n]&&delete r[n]}};var Cf=Z(nf(),1);var Rs=Z(he(),1),of=Z(It(),1);var _x=of.default.VectorTileFeature.prototype.toGeoJSON,Os=class{constructor(t){this._feature=t,this.extent=8192,this.type=t.type,this.properties=t.tags,"id"in t&&!isNaN(t.id)&&(this.id=parseInt(t.id,10))}loadGeometry(){if(this._feature.type===1){let t=[];for(let r of this._feature.geometry)t.push([new Rs.default(r[0],r[1])]);return t}else{let t=[];for(let r of this._feature.geometry){let n=[];for(let i of r)n.push(new Rs.default(i[0],i[1]));t.push(n)}return t}}toGeoJSON(t,r,n){return _x.call(this,t,r,n)}},ia=class{constructor(t){this.layers={_geojsonTileLayer:this},this.name="_geojsonTileLayer",this.extent=8192,this.length=t.length,this._features=t}feature(t){return new Os(this._features[t])}};var kf=Z(pf(),1);var ff=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],$s=1,ai=8,li=class e{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");let[r,n]=new Uint8Array(t,0,2);if(r!==219)throw new Error("Data does not appear to be in a KDBush format.");let i=n>>4;if(i!==$s)throw new Error("Got v".concat(i," data when expected v").concat($s,"."));let o=ff[n&15];if(!o)throw new Error("Unrecognized array type.");let[a]=new Uint16Array(t,2,1),[s]=new Uint32Array(t,4,1);return new e(s,a,o,t)}constructor(t,r=64,n=Float64Array,i){if(isNaN(t)||t<0)throw new Error("Unpexpected numItems value: ".concat(t,"."));this.numItems=+t,this.nodeSize=Math.min(Math.max(+r,2),65535),this.ArrayType=n,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;let o=ff.indexOf(this.ArrayType),a=t*2*this.ArrayType.BYTES_PER_ELEMENT,s=t*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-s%8)%8;if(o<0)throw new Error("Unexpected typed array class: ".concat(n,"."));i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,ai,t),this.coords=new this.ArrayType(this.data,ai+s+l,t*2),this._pos=t*2,this._finished=!0):(this.data=new ArrayBuffer(ai+a+s+l),this.ids=new this.IndexArrayType(this.data,ai,t),this.coords=new this.ArrayType(this.data,ai+s+l,t*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,($s<<4)+o]),new Uint16Array(this.data,2,1)[0]=r,new Uint32Array(this.data,4,1)[0]=t)}add(t,r){let n=this._pos>>1;return this.ids[n]=n,this.coords[this._pos++]=t,this.coords[this._pos++]=r,n}finish(){let t=this._pos>>1;if(t!==this.numItems)throw new Error("Added ".concat(t," items when expected ").concat(this.numItems,"."));return qs(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,r,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:o,coords:a,nodeSize:s}=this,l=[0,o.length-1,0],u=[];for(;l.length;){let c=l.pop()||0,p=l.pop()||0,f=l.pop()||0;if(p-f<=s){for(let d=f;d<=p;d++){let g=a[2*d],v=a[2*d+1];g>=t&&g<=n&&v>=r&&v<=i&&u.push(o[d])}continue}let y=f+p>>1,m=a[2*y],h=a[2*y+1];m>=t&&m<=n&&h>=r&&h<=i&&u.push(o[y]),(c===0?t<=m:r<=h)&&(l.push(f),l.push(y-1),l.push(1-c)),(c===0?n>=m:i>=h)&&(l.push(y+1),l.push(p),l.push(1-c))}return u}within(t,r,n){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");let{ids:i,coords:o,nodeSize:a}=this,s=[0,i.length-1,0],l=[],u=n*n;for(;s.length;){let c=s.pop()||0,p=s.pop()||0,f=s.pop()||0;if(p-f<=a){for(let d=f;d<=p;d++)yf(o[2*d],o[2*d+1],t,r)<=u&&l.push(i[d]);continue}let y=f+p>>1,m=o[2*y],h=o[2*y+1];yf(m,h,t,r)<=u&&l.push(i[y]),(c===0?t-n<=m:r-n<=h)&&(s.push(f),s.push(y-1),s.push(1-c)),(c===0?t+n>=m:r+n>=h)&&(s.push(y+1),s.push(p),s.push(1-c))}return l}};function qs(e,t,r,n,i,o){if(i-n<=r)return;let a=n+i>>1;mf(e,t,a,n,i,o),qs(e,t,r,n,a-1,1-o),qs(e,t,r,a+1,i,1-o)}function mf(e,t,r,n,i,o){for(;i>n;){if(i-n>600){let u=i-n+1,c=r-n+1,p=Math.log(u),f=.5*Math.exp(2*p/3),y=.5*Math.sqrt(p*f*(u-f)/u)*(c-u/2<0?-1:1),m=Math.max(n,Math.floor(r-c*f/u+y)),h=Math.min(i,Math.floor(r+(u-c)*f/u+y));mf(e,t,r,m,h,o)}let a=t[2*r+o],s=n,l=i;for(si(e,t,n,r),t[2*i+o]>a&&si(e,t,n,i);s<l;){for(si(e,t,s,l),s++,l--;t[2*s+o]<a;)s++;for(;t[2*l+o]>a;)l--}t[2*n+o]===a?si(e,t,n,l):(l++,si(e,t,l,i)),l<=r&&(n=l+1),r<=l&&(i=l-1)}}function si(e,t,r,n){Gs(e,r,n),Gs(t,2*r,2*n),Gs(t,2*r+1,2*n+1)}function Gs(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function yf(e,t,r,n){let i=e-r,o=t-n;return i*i+o*o}var Bx={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:e=>e},hf=Math.fround||(e=>t=>(e[0]=+t,e[0]))(new Float32Array(1)),er=2,Tt=3,js=4,kt=5,gf=6,ui=class{constructor(t){this.options=Object.assign(Object.create(Bx),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){let{log:r,minZoom:n,maxZoom:i}=this.options;r&&console.time("total time");let o="prepare ".concat(t.length," points");r&&console.time(o),this.points=t;let a=[];for(let l=0;l<t.length;l++){let u=t[l];if(!u.geometry)continue;let[c,p]=u.geometry.coordinates,f=hf(aa(c)),y=hf(sa(p));a.push(f,y,1/0,l,-1,1),this.options.reduce&&a.push(0)}let s=this.trees[i+1]=this._createTree(a);r&&console.timeEnd(o);for(let l=i;l>=n;l--){let u=+Date.now();s=this.trees[l]=this._createTree(this._cluster(s,l)),r&&console.log("z%d: %d clusters in %dms",l,s.numItems,+Date.now()-u)}return r&&console.timeEnd("total time"),this}getClusters(t,r){let n=((t[0]+180)%360+360)%360-180,i=Math.max(-90,Math.min(90,t[1])),o=t[2]===180?180:((t[2]+180)%360+360)%360-180,a=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)n=-180,o=180;else if(n>o){let p=this.getClusters([n,i,180,a],r),f=this.getClusters([-180,i,o,a],r);return p.concat(f)}let s=this.trees[this._limitZoom(r)],l=s.range(aa(n),sa(a),aa(o),sa(i)),u=s.data,c=[];for(let p of l){let f=this.stride*p;c.push(u[f+kt]>1?df(u,f,this.clusterProps):this.points[u[f+Tt]])}return c}getChildren(t){let r=this._getOriginId(t),n=this._getOriginZoom(t),i="No cluster with the specified id.",o=this.trees[n];if(!o)throw new Error(i);let a=o.data;if(r*this.stride>=a.length)throw new Error(i);let s=this.options.radius/(this.options.extent*Math.pow(2,n-1)),l=a[r*this.stride],u=a[r*this.stride+1],c=o.within(l,u,s),p=[];for(let f of c){let y=f*this.stride;a[y+js]===t&&p.push(a[y+kt]>1?df(a,y,this.clusterProps):this.points[a[y+Tt]])}if(p.length===0)throw new Error(i);return p}getLeaves(t,r,n){r=r||10,n=n||0;let i=[];return this._appendLeaves(i,t,r,n,0),i}getTile(t,r,n){let i=this.trees[this._limitZoom(t)],o=Math.pow(2,t),{extent:a,radius:s}=this.options,l=s/a,u=(n-l)/o,c=(n+1+l)/o,p={features:[]};return this._addTileFeatures(i.range((r-l)/o,u,(r+1+l)/o,c),i.data,r,n,o,p),r===0&&this._addTileFeatures(i.range(1-l/o,u,1,c),i.data,o,n,o,p),r===o-1&&this._addTileFeatures(i.range(0,u,l/o,c),i.data,-1,n,o,p),p.features.length?p:null}getClusterExpansionZoom(t){let r=this._getOriginZoom(t)-1;for(;r<=this.options.maxZoom;){let n=this.getChildren(t);if(r++,n.length!==1)break;t=n[0].properties.cluster_id}return r}_appendLeaves(t,r,n,i,o){let a=this.getChildren(r);for(let s of a){let l=s.properties;if(l&&l.cluster?o+l.point_count<=i?o+=l.point_count:o=this._appendLeaves(t,l.cluster_id,n,i,o):o<i?o++:t.push(s),t.length===n)break}return o}_createTree(t){let r=new li(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let n=0;n<t.length;n+=this.stride)r.add(t[n],t[n+1]);return r.finish(),r.data=t,r}_addTileFeatures(t,r,n,i,o,a){for(let s of t){let l=s*this.stride,u=r[l+kt]>1,c,p,f;if(u)c=xf(r,l,this.clusterProps),p=r[l],f=r[l+1];else{let h=this.points[r[l+Tt]];c=h.properties;let[d,g]=h.geometry.coordinates;p=aa(d),f=sa(g)}let y={type:1,geometry:[[Math.round(this.options.extent*(p*o-n)),Math.round(this.options.extent*(f*o-i))]],tags:c},m;u||this.options.generateId?m=r[l+Tt]:m=this.points[r[l+Tt]].id,m!==void 0&&(y.id=m),a.features.push(y)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,r){let{radius:n,extent:i,reduce:o,minPoints:a}=this.options,s=n/(i*Math.pow(2,r)),l=t.data,u=[],c=this.stride;for(let p=0;p<l.length;p+=c){if(l[p+er]<=r)continue;l[p+er]=r;let f=l[p],y=l[p+1],m=t.within(l[p],l[p+1],s),h=l[p+kt],d=h;for(let g of m){let v=g*c;l[v+er]>r&&(d+=l[v+kt])}if(d>h&&d>=a){let g=f*h,v=y*h,b,x=-1,P=((p/c|0)<<5)+(r+1)+this.points.length;for(let w of m){let A=w*c;if(l[A+er]<=r)continue;l[A+er]=r;let T=l[A+kt];g+=l[A]*T,v+=l[A+1]*T,l[A+js]=P,o&&(b||(b=this._map(l,p,!0),x=this.clusterProps.length,this.clusterProps.push(b)),o(b,this._map(l,A)))}l[p+js]=P,u.push(g/d,v/d,1/0,P,-1,d),o&&u.push(x)}else{for(let g=0;g<c;g++)u.push(l[p+g]);if(d>1)for(let g of m){let v=g*c;if(!(l[v+er]<=r)){l[v+er]=r;for(let b=0;b<c;b++)u.push(l[v+b])}}}}return u}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,r,n){if(t[r+kt]>1){let a=this.clusterProps[t[r+gf]];return n?Object.assign({},a):a}let i=this.points[t[r+Tt]].properties,o=this.options.map(i);return n&&o===i?Object.assign({},o):o}};function df(e,t,r){return{type:"Feature",id:e[t+Tt],properties:xf(e,t,r),geometry:{type:"Point",coordinates:[zx(e[t]),Rx(e[t+1])]}}}function xf(e,t,r){let n=e[t+kt],i=n>=1e4?"".concat(Math.round(n/1e3),"k"):n>=1e3?"".concat(Math.round(n/100)/10,"k"):n,o=e[t+gf],a=o===-1?{}:Object.assign({},r[o]);return Object.assign(a,{cluster:!0,cluster_id:e[t+Tt],point_count:n,point_count_abbreviated:i})}function aa(e){return e/360+.5}function sa(e){let t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function zx(e){return(e-.5)*360}function Rx(e){let t=(180-e*360)*Math.PI/180;return 360*Math.atan(Math.exp(t))/Math.PI-90}function ci(e,t,r,n){for(var i=n,o=r-t>>1,a=r-t,s,l=e[t],u=e[t+1],c=e[r],p=e[r+1],f=t+3;f<r;f+=3){var y=Ox(e[f],e[f+1],l,u,c,p);if(y>i)s=f,i=y;else if(y===i){var m=Math.abs(f-o);m<a&&(s=f,a=m)}}i>n&&(s-t>3&&ci(e,t,s,n),e[s+2]=i,r-s>3&&ci(e,s,r,n))}function Ox(e,t,r,n,i,o){var a=i-r,s=o-n;if(a!==0||s!==0){var l=((e-r)*a+(t-n)*s)/(a*a+s*s);l>1?(r=i,n=o):l>0&&(r+=a*l,n+=s*l)}return a=e-r,s=t-n,a*a+s*s}function pt(e,t,r,n){var i={id:typeof e>"u"?null:e,type:t,geometry:r,tags:n,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0};return Nx(i),i}function Nx(e){var t=e.geometry,r=e.type;if(r==="Point"||r==="MultiPoint"||r==="LineString")Zs(e,t);else if(r==="Polygon"||r==="MultiLineString")for(var n=0;n<t.length;n++)Zs(e,t[n]);else if(r==="MultiPolygon")for(n=0;n<t.length;n++)for(var i=0;i<t[n].length;i++)Zs(e,t[n][i])}function Zs(e,t){for(var r=0;r<t.length;r+=3)e.minX=Math.min(e.minX,t[r]),e.minY=Math.min(e.minY,t[r+1]),e.maxX=Math.max(e.maxX,t[r]),e.maxY=Math.max(e.maxY,t[r+1])}function Hs(e,t){var r=[];if(e.type==="FeatureCollection")for(var n=0;n<e.features.length;n++)la(r,e.features[n],t,n);else e.type==="Feature"?la(r,e,t):la(r,{geometry:e},t);return r}function la(e,t,r,n){if(t.geometry){var i=t.geometry.coordinates,o=t.geometry.type,a=Math.pow(r.tolerance/((1<<r.maxZoom)*r.extent),2),s=[],l=t.id;if(r.promoteId?l=t.properties[r.promoteId]:r.generateId&&(l=n||0),o==="Point")bf(i,s);else if(o==="MultiPoint")for(var u=0;u<i.length;u++)bf(i[u],s);else if(o==="LineString")Ws(i,s,a,!1);else if(o==="MultiLineString")if(r.lineMetrics){for(u=0;u<i.length;u++)s=[],Ws(i[u],s,a,!1),e.push(pt(l,"LineString",s,t.properties));return}else Js(i,s,a,!1);else if(o==="Polygon")Js(i,s,a,!0);else if(o==="MultiPolygon")for(u=0;u<i.length;u++){var c=[];Js(i[u],c,a,!0),s.push(c)}else if(o==="GeometryCollection"){for(u=0;u<t.geometry.geometries.length;u++)la(e,{id:l,geometry:t.geometry.geometries[u],properties:t.properties},r,n);return}else throw new Error("Input data is not a valid GeoJSON object.");e.push(pt(l,o,s,t.properties))}}function bf(e,t){t.push(vf(e[0])),t.push(Pf(e[1])),t.push(0)}function Ws(e,t,r,n){for(var i,o,a=0,s=0;s<e.length;s++){var l=vf(e[s][0]),u=Pf(e[s][1]);t.push(l),t.push(u),t.push(0),s>0&&(n?a+=(i*u-l*o)/2:a+=Math.sqrt(Math.pow(l-i,2)+Math.pow(u-o,2))),i=l,o=u}var c=t.length-3;t[2]=1,ci(t,0,c,r),t[c+2]=1,t.size=Math.abs(a),t.start=0,t.end=t.size}function Js(e,t,r,n){for(var i=0;i<e.length;i++){var o=[];Ws(e[i],o,r,n),t.push(o)}}function vf(e){return e/360+.5}function Pf(e){var t=Math.sin(e*Math.PI/180),r=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return r<0?0:r>1?1:r}function Ue(e,t,r,n,i,o,a,s){if(r/=t,n/=t,o>=r&&a<n)return e;if(a<r||o>=n)return null;for(var l=[],u=0;u<e.length;u++){var c=e[u],p=c.geometry,f=c.type,y=i===0?c.minX:c.minY,m=i===0?c.maxX:c.maxY;if(y>=r&&m<n){l.push(c);continue}else if(m<r||y>=n)continue;var h=[];if(f==="Point"||f==="MultiPoint")Ux(p,h,r,n,i);else if(f==="LineString")wf(p,h,r,n,i,!1,s.lineMetrics);else if(f==="MultiLineString")Ks(p,h,r,n,i,!1);else if(f==="Polygon")Ks(p,h,r,n,i,!0);else if(f==="MultiPolygon")for(var d=0;d<p.length;d++){var g=[];Ks(p[d],g,r,n,i,!0),g.length&&h.push(g)}if(h.length){if(s.lineMetrics&&f==="LineString"){for(d=0;d<h.length;d++)l.push(pt(c.id,f,h[d],c.tags));continue}(f==="LineString"||f==="MultiLineString")&&(h.length===1?(f="LineString",h=h[0]):f="MultiLineString"),(f==="Point"||f==="MultiPoint")&&(f=h.length===3?"Point":"MultiPoint"),l.push(pt(c.id,f,h,c.tags))}}return l.length?l:null}function Ux(e,t,r,n,i){for(var o=0;o<e.length;o+=3){var a=e[o+i];a>=r&&a<=n&&(t.push(e[o]),t.push(e[o+1]),t.push(e[o+2]))}}function wf(e,t,r,n,i,o,a){for(var s=Sf(e),l=i===0?$x:Gx,u=e.start,c,p,f=0;f<e.length-3;f+=3){var y=e[f],m=e[f+1],h=e[f+2],d=e[f+3],g=e[f+4],v=i===0?y:m,b=i===0?d:g,x=!1;a&&(c=Math.sqrt(Math.pow(y-d,2)+Math.pow(m-g,2))),v<r?b>r&&(p=l(s,y,m,d,g,r),a&&(s.start=u+c*p)):v>n?b<n&&(p=l(s,y,m,d,g,n),a&&(s.start=u+c*p)):Ys(s,y,m,h),b<r&&v>=r&&(p=l(s,y,m,d,g,r),x=!0),b>n&&v<=n&&(p=l(s,y,m,d,g,n),x=!0),!o&&x&&(a&&(s.end=u+c*p),t.push(s),s=Sf(e)),a&&(u+=c)}var P=e.length-3;y=e[P],m=e[P+1],h=e[P+2],v=i===0?y:m,v>=r&&v<=n&&Ys(s,y,m,h),P=s.length-3,o&&P>=3&&(s[P]!==s[0]||s[P+1]!==s[1])&&Ys(s,s[0],s[1],s[2]),s.length&&t.push(s)}function Sf(e){var t=[];return t.size=e.size,t.start=e.start,t.end=e.end,t}function Ks(e,t,r,n,i,o){for(var a=0;a<e.length;a++)wf(e[a],t,r,n,i,o,!1)}function Ys(e,t,r,n){e.push(t),e.push(r),e.push(n)}function $x(e,t,r,n,i,o){var a=(o-t)/(n-t);return e.push(o),e.push(r+(i-r)*a),e.push(1),a}function Gx(e,t,r,n,i,o){var a=(o-r)/(i-r);return e.push(t+(n-t)*a),e.push(o),e.push(1),a}function Qs(e,t){var r=t.buffer/t.extent,n=e,i=Ue(e,1,-1-r,r,0,-1,2,t),o=Ue(e,1,1-r,2+r,0,-1,2,t);return(i||o)&&(n=Ue(e,1,-r,1+r,0,-1,2,t)||[],i&&(n=Af(i,1).concat(n)),o&&(n=n.concat(Af(o,-1)))),n}function Af(e,t){for(var r=[],n=0;n<e.length;n++){var i=e[n],o=i.type,a;if(o==="Point"||o==="MultiPoint"||o==="LineString")a=Xs(i.geometry,t);else if(o==="MultiLineString"||o==="Polygon"){a=[];for(var s=0;s<i.geometry.length;s++)a.push(Xs(i.geometry[s],t))}else if(o==="MultiPolygon")for(a=[],s=0;s<i.geometry.length;s++){for(var l=[],u=0;u<i.geometry[s].length;u++)l.push(Xs(i.geometry[s][u],t));a.push(l)}r.push(pt(i.id,o,a,i.tags))}return r}function Xs(e,t){var r=[];r.size=e.size,e.start!==void 0&&(r.start=e.start,r.end=e.end);for(var n=0;n<e.length;n+=3)r.push(e[n]+t,e[n+1],e[n+2]);return r}function ua(e,t){if(e.transformed)return e;var r=1<<e.z,n=e.x,i=e.y,o,a,s;for(o=0;o<e.features.length;o++){var l=e.features[o],u=l.geometry,c=l.type;if(l.geometry=[],c===1)for(a=0;a<u.length;a+=2)l.geometry.push(_f(u[a],u[a+1],t,r,n,i));else for(a=0;a<u.length;a++){var p=[];for(s=0;s<u[a].length;s+=2)p.push(_f(u[a][s],u[a][s+1],t,r,n,i));l.geometry.push(p)}}return e.transformed=!0,e}function _f(e,t,r,n,i,o){return[Math.round(r*(e*n-i)),Math.round(r*(t*n-o))]}function tl(e,t,r,n,i){for(var o=t===i.maxZoom?0:i.tolerance/((1<<t)*i.extent),a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:n,z:t,transformed:!1,minX:2,minY:1,maxX:-1,maxY:0},s=0;s<e.length;s++){a.numFeatures++,qx(a,e[s],o,i);var l=e[s].minX,u=e[s].minY,c=e[s].maxX,p=e[s].maxY;l<a.minX&&(a.minX=l),u<a.minY&&(a.minY=u),c>a.maxX&&(a.maxX=c),p>a.maxY&&(a.maxY=p)}return a}function qx(e,t,r,n){var i=t.geometry,o=t.type,a=[];if(o==="Point"||o==="MultiPoint")for(var s=0;s<i.length;s+=3)a.push(i[s]),a.push(i[s+1]),e.numPoints++,e.numSimplified++;else if(o==="LineString")el(a,i,e,r,!1,!1);else if(o==="MultiLineString"||o==="Polygon")for(s=0;s<i.length;s++)el(a,i[s],e,r,o==="Polygon",s===0);else if(o==="MultiPolygon")for(var l=0;l<i.length;l++){var u=i[l];for(s=0;s<u.length;s++)el(a,u[s],e,r,!0,s===0)}if(a.length){var c=t.tags||null;if(o==="LineString"&&n.lineMetrics){c={};for(var p in t.tags)c[p]=t.tags[p];c.mapbox_clip_start=i.start/i.size,c.mapbox_clip_end=i.end/i.size}var f={geometry:a,type:o==="Polygon"||o==="MultiPolygon"?3:o==="LineString"||o==="MultiLineString"?2:1,tags:c};t.id!==null&&(f.id=t.id),e.features.push(f)}}function el(e,t,r,n,i,o){var a=n*n;if(n>0&&t.size<(i?a:n)){r.numPoints+=t.length/3;return}for(var s=[],l=0;l<t.length;l+=3)(n===0||t[l+2]>a)&&(r.numSimplified++,s.push(t[l]),s.push(t[l+1])),r.numPoints++;i&&jx(s,o),e.push(s)}function jx(e,t){for(var r=0,n=0,i=e.length,o=i-2;n<i;o=n,n+=2)r+=(e[n]-e[o])*(e[n+1]+e[o+1]);if(r>0===t)for(n=0,i=e.length;n<i/2;n+=2){var a=e[n],s=e[n+1];e[n]=e[i-2-n],e[n+1]=e[i-1-n],e[i-2-n]=a,e[i-1-n]=s}}function nl(e,t){return new ca(e,t)}function ca(e,t){t=this.options=Zx(Object.create(this.options),t);var r=t.debug;if(r&&console.time("preprocess data"),t.maxZoom<0||t.maxZoom>24)throw new Error("maxZoom should be in the 0-24 range");if(t.promoteId&&t.generateId)throw new Error("promoteId and generateId cannot be used together.");var n=Hs(e,t);this.tiles={},this.tileCoords=[],r&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),n=Qs(n,t),n.length&&this.splitTile(n,0,0,0),r&&(n.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}ca.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,tolerance:3,extent:4096,buffer:64,lineMetrics:!1,promoteId:null,generateId:!1,debug:0};ca.prototype.splitTile=function(e,t,r,n,i,o,a){for(var s=[e,t,r,n],l=this.options,u=l.debug;s.length;){n=s.pop(),r=s.pop(),t=s.pop(),e=s.pop();var c=1<<t,p=rl(t,r,n),f=this.tiles[p];if(!f&&(u>1&&console.time("creation"),f=this.tiles[p]=tl(e,t,r,n,l),this.tileCoords.push({z:t,x:r,y:n}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,r,n,f.numFeatures,f.numPoints,f.numSimplified),console.timeEnd("creation"));var y="z"+t;this.stats[y]=(this.stats[y]||0)+1,this.total++}if(f.source=e,i){if(t===l.maxZoom||t===i)continue;var m=1<<i-t;if(r!==Math.floor(o/m)||n!==Math.floor(a/m))continue}else if(t===l.indexMaxZoom||f.numPoints<=l.indexMaxPoints)continue;if(f.source=null,e.length!==0){u>1&&console.time("clipping");var h=.5*l.buffer/l.extent,d=.5-h,g=.5+h,v=1+h,b,x,P,w,A,T;b=x=P=w=null,A=Ue(e,c,r-h,r+g,0,f.minX,f.maxX,l),T=Ue(e,c,r+d,r+v,0,f.minX,f.maxX,l),e=null,A&&(b=Ue(A,c,n-h,n+g,1,f.minY,f.maxY,l),x=Ue(A,c,n+d,n+v,1,f.minY,f.maxY,l),A=null),T&&(P=Ue(T,c,n-h,n+g,1,f.minY,f.maxY,l),w=Ue(T,c,n+d,n+v,1,f.minY,f.maxY,l),T=null),u>1&&console.timeEnd("clipping"),s.push(b||[],t+1,r*2,n*2),s.push(x||[],t+1,r*2,n*2+1),s.push(P||[],t+1,r*2+1,n*2),s.push(w||[],t+1,r*2+1,n*2+1)}}};ca.prototype.getTile=function(e,t,r){var n=this.options,i=n.extent,o=n.debug;if(e<0||e>24)return null;var a=1<<e;t=(t%a+a)%a;var s=rl(e,t,r);if(this.tiles[s])return ua(this.tiles[s],i);o>1&&console.log("drilling down to z%d-%d-%d",e,t,r);for(var l=e,u=t,c=r,p;!p&&l>0;)l--,u=Math.floor(u/2),c=Math.floor(c/2),p=this.tiles[rl(l,u,c)];return!p||!p.source?null:(o>1&&console.log("found parent tile z%d-%d-%d",l,u,c),o>1&&console.time("drilling down"),this.splitTile(p.source,l,u,c,e,t,r),o>1&&console.timeEnd("drilling down"),this.tiles[s]?ua(this.tiles[s],i):null)};function rl(e,t,r){return((1<<e)*r+t)*32+e}function Zx(e,t){for(var r in t)e[r]=t[r];return e}function pi(e,t){return t?e.properties[t]:e.id}function il(e,t){if(e==null)return!0;if(e.type==="Feature")return pi(e,t)!=null;if(e.type==="FeatureCollection"){let r=new Set;for(let n of e.features){let i=pi(n,t);if(i==null||r.has(i))return!1;r.add(i)}return!0}return!1}function ol(e,t){let r=new Map;if(e!=null)if(e.type==="Feature")r.set(pi(e,t),e);else for(let n of e.features)r.set(pi(n,t),n);return r}function If(e,t,r){var n,i,o,a;if(t.removeAll&&e.clear(),t.remove)for(let s of t.remove)e.delete(s);if(t.add)for(let s of t.add){let l=pi(s,r);l!=null&&e.set(l,s)}if(t.update)for(let s of t.update){let l=e.get(s.id);if(l==null)continue;let u=s.newGeometry||s.removeAllProperties,c=!s.removeAllProperties&&(((n=s.removeProperties)==null?void 0:n.length)>0||((i=s.addOrUpdateProperties)==null?void 0:i.length)>0);if((u||c)&&(l={...l},e.set(s.id,l),c&&(l.properties={...l.properties})),s.newGeometry&&(l.geometry=s.newGeometry),s.removeAllProperties)l.properties={};else if(((o=s.removeProperties)==null?void 0:o.length)>0)for(let p of s.removeProperties)Object.prototype.hasOwnProperty.call(l.properties,p)&&delete l.properties[p];if(((a=s.addOrUpdateProperties)==null?void 0:a.length)>0)for(let{key:p,value:f}of s.addOrUpdateProperties)l.properties[p]=f}}function Jx(e,t){let r=e.tileID.canonical;if(!this._geoJSONIndex)return t(null,null);let n=this._geoJSONIndex.getTile(r.z,r.x,r.y);if(!n)return t(null,null);let i=new ia(n.features),o=(0,kf.default)(i);(o.byteOffset!==0||o.byteLength!==o.buffer.byteLength)&&(o=new Uint8Array(o)),t(null,{vectorTile:i,rawData:o.buffer})}var pa=class extends Br{constructor(r,n,i,o){super(r,n,i,Jx);this._dataUpdateable=new Map;this.loadGeoJSON=(r,n)=>{let{promoteId:i}=r;if(r.request)return gu(r.request,(o,a,s,l)=>{this._dataUpdateable=il(a,i)?ol(a,i):void 0,n(o,a,s,l)});if(typeof r.data=="string")try{let o=JSON.parse(r.data);this._dataUpdateable=il(o,i)?ol(o,i):void 0,n(null,o)}catch{n(new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object.")))}else r.dataDiff?this._dataUpdateable?(If(this._dataUpdateable,r.dataDiff,i),n(null,{type:"FeatureCollection",features:Array.from(this._dataUpdateable.values())})):n(new Error("Cannot update existing geojson data in ".concat(r.source))):n(new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object.")));return{cancel:()=>{}}};o&&(this.loadGeoJSON=o)}loadData(r,n){var o;(o=this._pendingRequest)==null||o.cancel(),this._pendingCallback&&this._pendingCallback(null,{abandoned:!0});let i=r&&r.request&&r.request.collectResourceTiming?new Vr(r.request):!1;this._pendingCallback=n,this._pendingRequest=this.loadGeoJSON(r,(a,s)=>{if(delete this._pendingCallback,delete this._pendingRequest,a||!s)return n(a);if(typeof s!="object")return n(new Error("Input data given to '".concat(r.source,"' is not a valid GeoJSON object.")));{(0,Cf.default)(s,!0);try{if(r.filter){let u=Rt(r.filter,{type:"boolean","property-type":"data-driven",overridable:!1,transition:!1});if(u.result==="error")throw new Error(u.value.map(p=>"".concat(p.key,": ").concat(p.message)).join(", "));s={type:"FeatureCollection",features:s.features.filter(p=>u.value.evaluate({zoom:0},p))}}this._geoJSONIndex=r.cluster?new ui(Wx(r)).load(s.features):nl(s,r.geojsonVtOptions)}catch(u){return n(u)}this.loaded={};let l={};if(i){let u=i.finish();u&&(l.resourceTiming={},l.resourceTiming[r.source]=JSON.parse(JSON.stringify(u)))}n(null,l)}})}reloadTile(r,n){let i=this.loaded,o=r.uid;return i&&i[o]?super.reloadTile(r,n):this.loadTile(r,n)}removeSource(r,n){this._pendingCallback&&this._pendingCallback(null,{abandoned:!0}),n()}getClusterExpansionZoom(r,n){try{n(null,this._geoJSONIndex.getClusterExpansionZoom(r.clusterId))}catch(i){n(i)}}getClusterChildren(r,n){try{n(null,this._geoJSONIndex.getChildren(r.clusterId))}catch(i){n(i)}}getClusterLeaves(r,n){try{n(null,this._geoJSONIndex.getLeaves(r.clusterId,r.limit,r.offset))}catch(i){n(i)}}};function Wx({superclusterOptions:e,clusterProperties:t}){if(!t||!e)return e;let r={},n={},i={accumulated:null,zoom:0},o={properties:null},a=Object.keys(t);for(let s of a){let[l,u]=t[s],c=Rt(u),p=Rt(typeof l=="string"?[l,["accumulated"],["get",s]]:l);r[s]=c.value,n[s]=p.value}return e.map=s=>{o.properties=s;let l={};for(let u of a)l[u]=r[u].evaluate(i,o);return l},e.reduce=(s,l)=>{o.properties=l;for(let u of a)i.accumulated=s[u],s[u]=n[u].evaluate(i,o)},e}var fa=class{constructor(t){this.self=t,this.actor=new Oi(t,this),this.layerIndexes={},this.availableImages={},this.workerSourceTypes={vector:Br,geojson:pa},this.workerSources={},this.demWorkerSources={},this.self.registerWorkerSource=(r,n)=>{if(this.workerSourceTypes[r])throw new Error('Worker source with name "'.concat(r,'" already registered.'));this.workerSourceTypes[r]=n},this.self.registerRTLTextPlugin=r=>{if(ae.isParsed())throw new Error("RTL text plugin already registered.");ae.applyArabicShaping=r.applyArabicShaping,ae.processBidirectionalText=r.processBidirectionalText,ae.processStyledBidirectionalText=r.processStyledBidirectionalText}}setReferrer(t,r){this.referrer=r}setImages(t,r,n){this.availableImages[t]=r;for(let i in this.workerSources[t]){let o=this.workerSources[t][i];for(let a in o)o[a].availableImages=r}n()}setLayers(t,r,n){this.getLayerIndex(t).replace(r),n()}updateLayers(t,r,n){this.getLayerIndex(t).update(r.layers,r.removedIds),n()}loadTile(t,r,n){this.getWorkerSource(t,r.type,r.source).loadTile(r,n)}loadDEMTile(t,r,n){this.getDEMWorkerSource(t,r.source).loadTile(r,n)}reloadTile(t,r,n){this.getWorkerSource(t,r.type,r.source).reloadTile(r,n)}abortTile(t,r,n){this.getWorkerSource(t,r.type,r.source).abortTile(r,n)}removeTile(t,r,n){this.getWorkerSource(t,r.type,r.source).removeTile(r,n)}removeDEMTile(t,r){this.getDEMWorkerSource(t,r.source).removeTile(r)}removeSource(t,r,n){if(!this.workerSources[t]||!this.workerSources[t][r.type]||!this.workerSources[t][r.type][r.source])return;let i=this.workerSources[t][r.type][r.source];delete this.workerSources[t][r.type][r.source],i.removeSource!==void 0?i.removeSource(r,n):n()}loadWorkerSource(t,r,n){try{this.self.importScripts(r.url),n()}catch(i){n(i.toString())}}syncRTLPluginState(t,r,n){try{ae.setState(r);let i=ae.getPluginURL();if(ae.isLoaded()&&!ae.isParsed()&&i!=null){this.self.importScripts(i);let o=ae.isParsed(),a=o?void 0:new Error("RTL Text Plugin failed to import scripts from ".concat(i));n(a,o)}}catch(i){n(i.toString())}}getAvailableImages(t){let r=this.availableImages[t];return r||(r=[]),r}getLayerIndex(t){let r=this.layerIndexes[t];return r||(r=this.layerIndexes[t]=new Jo),r}getWorkerSource(t,r,n){if(this.workerSources[t]||(this.workerSources[t]={}),this.workerSources[t][r]||(this.workerSources[t][r]={}),!this.workerSources[t][r][n]){let i={send:(o,a,s)=>{this.actor.send(o,a,s,t)}};this.workerSources[t][r][n]=new this.workerSourceTypes[r](i,this.getLayerIndex(t),this.getAvailableImages(t))}return this.workerSources[t][r][n]}getDEMWorkerSource(t,r){return this.demWorkerSources[t]||(this.demWorkerSources[t]={}),this.demWorkerSources[t][r]||(this.demWorkerSources[t][r]=new ra),this.demWorkerSources[t][r]}};Ie()&&(self.worker=new fa(self));})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
`;
var QM = q(() => URL.createObjectURL(new Blob([Q_], { type: "text/javascript" })), "getWorkerURL");
function ev() {
  return new Worker(QM());
}
q(ev, "workerFactory");
var vl = "mapboxgl_preloaded_worker_pool";
var _l = class e45 {
  constructor() {
    this.active = {};
  }
  acquire(t3) {
    if (!this.workers)
      for (this.workers = []; this.workers.length < e45.workerCount; )
        this.workers.push(ev());
    return this.active[t3] = true, this.workers.slice();
  }
  release(e53) {
    delete this.active[e53], 0 === this.numActive() && (this.workers.forEach((e54) => {
      e54.terminate();
    }), this.workers = null);
  }
  isPreloaded() {
    return !!this.active[vl];
  }
  numActive() {
    return Object.keys(this.active).length;
  }
};
q(_l, "WorkerPool");
var Ha;
var Fr = _l;
var eC = Math.floor(ne.hardwareConcurrency / 2);
function wm() {
  return Ha || (Ha = new Fr()), Ha;
}
function tv() {
  wm().acquire(vl);
}
function rv() {
  let e53 = Ha;
  e53 && (e53.isPreloaded() && 1 === e53.numActive() ? (e53.release(vl), Ha = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
}
Fr.workerCount = qr(globalThis) ? Math.max(Math.min(eC, 3), 1) : 1, q(wm, "getGlobalWorkerPool"), q(tv, "prewarm"), q(rv, "clearPrewarmedResources"), c(), c(), c();
var Zt = u(Pe(), 1);
c();
var sr = u(Pe(), 1);
function Sm(e53, t3, r, i, a) {
  let n = [];
  for (let s3 = 0; s3 < e53.length; s3++) {
    let o, l = e53[s3];
    for (let e54 = 0; e54 < l.length - 1; e54++) {
      let s4 = l[e54], u3 = l[e54 + 1];
      s4.x < t3 && u3.x < t3 || (s4.x < t3 ? s4 = new sr.default(t3, s4.y + (u3.y - s4.y) * ((t3 - s4.x) / (u3.x - s4.x)))._round() : u3.x < t3 && (u3 = new sr.default(t3, s4.y + (u3.y - s4.y) * ((t3 - s4.x) / (u3.x - s4.x)))._round()), !(s4.y < r && u3.y < r) && (s4.y < r ? s4 = new sr.default(s4.x + (u3.x - s4.x) * ((r - s4.y) / (u3.y - s4.y)), r)._round() : u3.y < r && (u3 = new sr.default(s4.x + (u3.x - s4.x) * ((r - s4.y) / (u3.y - s4.y)), r)._round()), !(s4.x >= i && u3.x >= i) && (s4.x >= i ? s4 = new sr.default(i, s4.y + (u3.y - s4.y) * ((i - s4.x) / (u3.x - s4.x)))._round() : u3.x >= i && (u3 = new sr.default(i, s4.y + (u3.y - s4.y) * ((i - s4.x) / (u3.x - s4.x)))._round()), !(s4.y >= a && u3.y >= a) && (s4.y >= a ? s4 = new sr.default(s4.x + (u3.x - s4.x) * ((a - s4.y) / (u3.y - s4.y)), a)._round() : u3.y >= a && (u3 = new sr.default(s4.x + (u3.x - s4.x) * ((a - s4.y) / (u3.y - s4.y)), a)._round()), (!o || !s4.equals(o[o.length - 1])) && (o = [s4], n.push(o)), o.push(u3)))));
    }
  }
  return n;
}
q(Sm, "clipLine"), c();
var Pm = class {
  constructor(e53, t3) {
    this.reset(e53, t3);
  }
  reset(e53, t3) {
    this.points = e53 || [], this._distances = [0];
    for (let e54 = 1; e54 < this.points.length; e54++)
      this._distances[e54] = this._distances[e54 - 1] + this.points[e54].dist(this.points[e54 - 1]);
    this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
  }
  lerp(e53) {
    if (1 === this.points.length)
      return this.points[0];
    e53 = Te(e53, 0, 1);
    let t3 = 1, r = this._distances[t3], i = e53 * this.paddedLength + this.padding;
    for (; r < i && t3 < this._distances.length; )
      r = this._distances[++t3];
    let a = t3 - 1, n = this._distances[a], s3 = r - n, o = s3 > 0 ? (i - n) / s3 : 0;
    return this.points[a].mult(1 - o).add(this.points[t3].mult(o));
  }
};
q(Pm, "PathInterpolator");
var wl = Pm;
function Sl(e53, t3) {
  let r = true;
  return "always" === e53 || ("never" === e53 || "never" === t3) && (r = false), r;
}
c(), q(Sl, "overlapAllowed");
var Tm = class {
  constructor(e53, t3, r) {
    let i = this.boxCells = [], a = this.circleCells = [];
    this.xCellCount = Math.ceil(e53 / r), this.yCellCount = Math.ceil(t3 / r);
    for (let e54 = 0; e54 < this.xCellCount * this.yCellCount; e54++)
      i.push([]), a.push([]);
    this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e53, this.height = t3, this.xScale = this.xCellCount / e53, this.yScale = this.yCellCount / t3, this.boxUid = 0, this.circleUid = 0;
  }
  keysLength() {
    return this.boxKeys.length + this.circleKeys.length;
  }
  insert(e53, t3, r, i, a) {
    this._forEachCell(t3, r, i, a, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e53), this.bboxes.push(t3), this.bboxes.push(r), this.bboxes.push(i), this.bboxes.push(a);
  }
  insertCircle(e53, t3, r, i) {
    this._forEachCell(t3 - i, r - i, t3 + i, r + i, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e53), this.circles.push(t3), this.circles.push(r), this.circles.push(i);
  }
  _insertBoxCell(e53, t3, r, i, a, n) {
    this.boxCells[a].push(n);
  }
  _insertCircleCell(e53, t3, r, i, a, n) {
    this.circleCells[a].push(n);
  }
  _query(e53, t3, r, i, a, n, s3) {
    if (r < 0 || e53 > this.width || i < 0 || t3 > this.height)
      return [];
    let o = [];
    if (e53 <= 0 && t3 <= 0 && this.width <= r && this.height <= i) {
      if (a)
        return [{ key: null, x1: e53, y1: t3, x2: r, y2: i }];
      for (let e54 = 0; e54 < this.boxKeys.length; e54++)
        o.push({ key: this.boxKeys[e54], x1: this.bboxes[4 * e54], y1: this.bboxes[4 * e54 + 1], x2: this.bboxes[4 * e54 + 2], y2: this.bboxes[4 * e54 + 3] });
      for (let e54 = 0; e54 < this.circleKeys.length; e54++) {
        let t4 = this.circles[3 * e54], r3 = this.circles[3 * e54 + 1], i3 = this.circles[3 * e54 + 2];
        o.push({ key: this.circleKeys[e54], x1: t4 - i3, y1: r3 - i3, x2: t4 + i3, y2: r3 + i3 });
      }
    } else {
      let l = { hitTest: a, overlapMode: n, seenUids: { box: {}, circle: {} } };
      this._forEachCell(e53, t3, r, i, this._queryCell, o, l, s3);
    }
    return o;
  }
  query(e53, t3, r, i) {
    return this._query(e53, t3, r, i, false, null);
  }
  hitTest(e53, t3, r, i, a, n) {
    return this._query(e53, t3, r, i, true, a, n).length > 0;
  }
  hitTestCircle(e53, t3, r, i, a) {
    let n = e53 - r, s3 = e53 + r, o = t3 - r, l = t3 + r;
    if (s3 < 0 || n > this.width || l < 0 || o > this.height)
      return false;
    let u3 = [], c3 = { hitTest: true, overlapMode: i, circle: { x: e53, y: t3, radius: r }, seenUids: { box: {}, circle: {} } };
    return this._forEachCell(n, o, s3, l, this._queryCellCircle, u3, c3, a), u3.length > 0;
  }
  _queryCell(e53, t3, r, i, a, n, s3, o) {
    let { seenUids: l, hitTest: u3, overlapMode: c3 } = s3, h = this.boxCells[a];
    if (null !== h) {
      let a3 = this.bboxes;
      for (let s4 of h)
        if (!l.box[s4]) {
          l.box[s4] = true;
          let h3 = 4 * s4, p3 = this.boxKeys[s4];
          if (e53 <= a3[h3 + 2] && t3 <= a3[h3 + 3] && r >= a3[h3 + 0] && i >= a3[h3 + 1] && (!o || o(p3)) && (!u3 || !Sl(c3, p3.overlapMode)) && (n.push({ key: p3, x1: a3[h3], y1: a3[h3 + 1], x2: a3[h3 + 2], y2: a3[h3 + 3] }), u3))
            return true;
        }
    }
    let p = this.circleCells[a];
    if (null !== p) {
      let a3 = this.circles;
      for (let s4 of p)
        if (!l.circle[s4]) {
          l.circle[s4] = true;
          let h3 = 3 * s4, p3 = this.circleKeys[s4];
          if (this._circleAndRectCollide(a3[h3], a3[h3 + 1], a3[h3 + 2], e53, t3, r, i) && (!o || o(p3)) && (!u3 || !Sl(c3, p3.overlapMode))) {
            let e54 = a3[h3], t4 = a3[h3 + 1], r3 = a3[h3 + 2];
            if (n.push({ key: p3, x1: e54 - r3, y1: t4 - r3, x2: e54 + r3, y2: t4 + r3 }), u3)
              return true;
          }
        }
    }
    return false;
  }
  _queryCellCircle(e53, t3, r, i, a, n, s3, o) {
    let { circle: l, seenUids: u3, overlapMode: c3 } = s3, h = this.boxCells[a];
    if (null !== h) {
      let e54 = this.bboxes;
      for (let t4 of h)
        if (!u3.box[t4]) {
          u3.box[t4] = true;
          let r3 = 4 * t4, i3 = this.boxKeys[t4];
          if (this._circleAndRectCollide(l.x, l.y, l.radius, e54[r3 + 0], e54[r3 + 1], e54[r3 + 2], e54[r3 + 3]) && (!o || o(i3)) && !Sl(c3, i3.overlapMode))
            return n.push(true), true;
        }
    }
    let p = this.circleCells[a];
    if (null !== p) {
      let e54 = this.circles;
      for (let t4 of p)
        if (!u3.circle[t4]) {
          u3.circle[t4] = true;
          let r3 = 3 * t4, i3 = this.circleKeys[t4];
          if (this._circlesCollide(e54[r3], e54[r3 + 1], e54[r3 + 2], l.x, l.y, l.radius) && (!o || o(i3)) && !Sl(c3, i3.overlapMode))
            return n.push(true), true;
        }
    }
  }
  _forEachCell(e53, t3, r, i, a, n, s3, o) {
    let l = this._convertToXCellCoord(e53), u3 = this._convertToYCellCoord(t3), c3 = this._convertToXCellCoord(r), h = this._convertToYCellCoord(i);
    for (let p = l; p <= c3; p++)
      for (let l3 = u3; l3 <= h; l3++) {
        let u4 = this.xCellCount * l3 + p;
        if (a.call(this, e53, t3, r, i, u4, n, s3, o))
          return;
      }
  }
  _convertToXCellCoord(e53) {
    return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e53 * this.xScale)));
  }
  _convertToYCellCoord(e53) {
    return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e53 * this.yScale)));
  }
  _circlesCollide(e53, t3, r, i, a, n) {
    let s3 = i - e53, o = a - t3, l = r + n;
    return l * l > s3 * s3 + o * o;
  }
  _circleAndRectCollide(e53, t3, r, i, a, n, s3) {
    let o = (n - i) / 2, l = Math.abs(e53 - (i + o));
    if (l > o + r)
      return false;
    let u3 = (s3 - a) / 2, c3 = Math.abs(t3 - (a + u3));
    if (c3 > u3 + r)
      return false;
    if (l <= o || c3 <= u3)
      return true;
    let h = l - o, p = c3 - u3;
    return h * h + p * p <= r * r;
  }
};
q(Tm, "GridIndex");
var Za = Tm;
c();
var yn = u(Pe(), 1);
function Wa(e53, t3, r, i, a) {
  let n = q3.create();
  return t3 ? (q3.scale(n, n, [1 / a, 1 / a, 1]), r || q3.rotateZ(n, n, i.angle)) : q3.multiply(n, i.labelPlaneMatrix, e53), n;
}
function Tl(e53, t3, r, i, a) {
  if (t3) {
    let t4 = q3.clone(e53);
    return q3.scale(t4, t4, [a, a, 1]), r || q3.rotateZ(t4, t4, -i.angle), t4;
  }
  return i.glCoordMatrix;
}
function bt(e53, t3, r) {
  let i;
  r ? (i = [e53.x, e53.y, r(e53.x, e53.y), 1], Xe.transformMat4(i, i, t3)) : (i = [e53.x, e53.y, 0, 1], Al(i, i, t3));
  let a = i[3];
  return { point: new yn.default(i[0] / a, i[1] / a), signedDistanceFromCamera: a };
}
function Xa(e53, t3) {
  return 0.5 + e53 / t3 * 0.5;
}
function tC(e53, t3) {
  let r = e53[0] / e53[3], i = e53[1] / e53[3];
  return r >= -t3[0] && r <= t3[0] && i >= -t3[1] && i <= t3[1];
}
function av(e53, t3, r, i, a, n, s3, o, l, u3) {
  let c3 = i ? e53.textSizeData : e53.iconSizeData, h = ci(c3, r.transform.zoom), p = [256 / r.width * 2 + 1, 256 / r.height * 2 + 1], d = i ? e53.text.dynamicLayoutVertexArray : e53.icon.dynamicLayoutVertexArray;
  d.clear();
  let f = e53.lineVertexArray, m = i ? e53.text.placedSymbolArray : e53.icon.placedSymbolArray, y = r.transform.width / r.transform.height, g = false;
  for (let i3 = 0; i3 < m.length; i3++) {
    let _, x = m.get(i3);
    if (x.hidden || 2 === x.writingMode && !g) {
      yi(x.numGlyphs, d);
      continue;
    }
    if (g = false, u3 ? (_ = [x.anchorX, x.anchorY, u3(x.anchorX, x.anchorY), 1], Xe.transformMat4(_, _, t3)) : (_ = [x.anchorX, x.anchorY, 0, 1], Al(_, _, t3)), !tC(_, p)) {
      yi(x.numGlyphs, d);
      continue;
    }
    let v = _[3], b = Xa(r.transform.cameraToCenterDistance, v), w = rn(c3, h, x), S = s3 ? w / b : w * b, A = new yn.default(x.anchorX, x.anchorY), M3 = bt(A, a, u3).point, I = { projections: {}, offsets: {} }, T = nv(x, S, false, o, t3, a, n, e53.glyphOffsetArray, f, d, M3, A, I, y, l, u3);
    g = T.useVertical, (T.notEnoughRoom || g || T.needsFlipping && nv(x, S, true, o, t3, a, n, e53.glyphOffsetArray, f, d, M3, A, I, y, l, u3).notEnoughRoom) && yi(x.numGlyphs, d);
  }
  i ? e53.text.dynamicLayoutVertexBuffer.updateData(d) : e53.icon.dynamicLayoutVertexBuffer.updateData(d);
}
function Mm(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p) {
  let d = o.glyphStartIndex + o.numGlyphs, f = o.lineStartIndex, m = o.lineStartIndex + o.lineLength, y = t3.getoffsetX(o.glyphStartIndex), g = t3.getoffsetX(d - 1), _ = Pl(e53 * y, r, i, a, n, s3, o.segment, f, m, l, u3, c3, h, p);
  if (!_)
    return null;
  let x = Pl(e53 * g, r, i, a, n, s3, o.segment, f, m, l, u3, c3, h, p);
  return x ? { first: _, last: x } : null;
}
function iv(e53, t3, r, i) {
  if (1 === e53) {
    if (Math.abs(r.y - t3.y) > Math.abs(r.x - t3.x) * i)
      return { useVertical: true };
  }
  return (2 === e53 ? t3.y < r.y : t3.x > r.x) ? { needsFlipping: true } : null;
}
function nv(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m) {
  let y, g = t3 / 24, _ = e53.lineOffsetX * g, x = e53.lineOffsetY * g;
  if (e53.numGlyphs > 1) {
    let t4 = e53.glyphStartIndex + e53.numGlyphs, a3 = e53.lineStartIndex, u4 = e53.lineStartIndex + e53.lineLength, v = Mm(g, o, _, x, r, c3, h, e53, l, n, p, f, m);
    if (!v)
      return { notEnoughRoom: true };
    let b = bt(v.first.point, s3, m).point, w = bt(v.last.point, s3, m).point;
    if (i && !r) {
      let t5 = iv(e53.writingMode, b, w, d);
      if (t5)
        return t5;
    }
    y = [v.first];
    for (let i3 = e53.glyphStartIndex + 1; i3 < t4 - 1; i3++)
      y.push(Pl(g * o.getoffsetX(i3), _, x, r, c3, h, e53.segment, a3, u4, l, n, p, f, m));
    y.push(v.last);
  } else {
    if (i && !r) {
      let t5 = bt(h, a, m).point, r3 = e53.lineStartIndex + e53.segment + 1, i3 = new yn.default(l.getx(r3), l.gety(r3)), n3 = bt(i3, a, m), s4 = n3.signedDistanceFromCamera > 0 ? n3.point : ov(h, i3, t5, 1, a, m), o3 = iv(e53.writingMode, t5, s4, d);
      if (o3)
        return o3;
    }
    let t4 = Pl(g * o.getoffsetX(e53.glyphStartIndex), _, x, r, c3, h, e53.segment, e53.lineStartIndex, e53.lineStartIndex + e53.lineLength, l, n, p, f, m);
    if (!t4)
      return { notEnoughRoom: true };
    y = [t4];
  }
  for (let e54 of y)
    pi(u3, e54.point, e54.angle);
  return {};
}
function ov(e53, t3, r, i, a, n) {
  let s3 = bt(e53.add(e53.sub(t3)._unit()), a, n).point, o = r.sub(s3);
  return r.add(o._mult(i / o.mag()));
}
function Am(e53, t3) {
  let { projectionCache: r, lineVertexArray: i, labelPlaneMatrix: a, tileAnchorPoint: n, distanceFromAnchor: s3, getElevation: o, previousVertex: l, direction: u3, absOffsetX: c3 } = t3;
  if (r.projections[e53])
    return r.projections[e53];
  let h = new yn.default(i.getx(e53), i.gety(e53)), p = bt(h, a, o);
  if (p.signedDistanceFromCamera > 0)
    return r.projections[e53] = p.point, p.point;
  let d = e53 - u3;
  return ov(0 === s3 ? n : new yn.default(i.getx(d), i.gety(d)), h, l, c3 - s3 + 1, a, o);
}
function Im(e53, t3, r) {
  return e53._unit()._perp()._mult(t3 * r);
}
function rC(e53, t3, r, i, a, n, s3, o) {
  let { projectionCache: l, direction: u3 } = o;
  if (l.offsets[e53])
    return l.offsets[e53];
  let c3 = r.add(t3);
  if (e53 + u3 < i || e53 + u3 >= a)
    return l.offsets[e53] = c3, c3;
  let h = Am(e53 + u3, o), p = Im(h.sub(r), s3, u3), d = r.add(p), f = h.add(p);
  return l.offsets[e53] = Yy(n, c3, d, f) || c3, l.offsets[e53];
}
function Pl(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d) {
  let f = i ? e53 - t3 : e53 + t3, m = f > 0 ? 1 : -1, y = 0;
  i && (m *= -1, y = Math.PI), m < 0 && (y += Math.PI);
  let g, _, x, v = m > 0 ? o + s3 : o + s3 + 1, b = a, w = a, S = 0, A = 0, M3 = Math.abs(f), I = [];
  for (; S + A <= M3; ) {
    if (v += m, v < o || v >= l)
      return null;
    S += A, w = b, _ = g;
    let e54 = { projectionCache: h, lineVertexArray: u3, labelPlaneMatrix: c3, tileAnchorPoint: n, distanceFromAnchor: S, getElevation: d, previousVertex: w, direction: m, absOffsetX: M3 };
    if (b = Am(v, e54), 0 === r)
      I.push(w), x = b.sub(w);
    else {
      let t4, i3 = b.sub(w);
      if (0 === i3.mag()) {
        t4 = Im(Am(v + m, e54).sub(b), r, m);
      } else
        t4 = Im(i3, r, m);
      _ || (_ = w.add(t4)), g = rC(v, t4, b, o, l, _, r, e54), I.push(_), x = g.sub(_);
    }
    A = x.mag();
  }
  let T = (M3 - S) / A, C = x._mult(T)._add(_ || w), P = y + Math.atan2(b.y - w.y, b.x - w.x);
  return I.push(C), { point: C, angle: p ? P : 0, path: I };
}
q(Wa, "getLabelPlaneMatrix"), q(Tl, "getGlCoordMatrix"), q(bt, "project"), q(Xa, "getPerspectiveRatio"), q(tC, "isVisible"), q(av, "updateLineLabels"), q(Mm, "placeFirstAndLastGlyph"), q(iv, "requiresOrientationChange"), q(nv, "placeGlyphsAlongLine"), q(ov, "projectTruncatedLineSegment"), q(Am, "projectVertexToViewport"), q(Im, "transformToOffsetNormal"), q(rC, "findOffsetIntersectionPoint"), q(Pl, "placeGlyphAlongLine");
var iC = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
function yi(e53, t3) {
  for (let r = 0; r < e53; r++) {
    let e54 = t3.length;
    t3.resize(e54 + 4), t3.float32.set(iC, 3 * e54);
  }
}
function Al(e53, t3, r) {
  let i = t3[0], a = t3[1];
  return e53[0] = r[0] * i + r[4] * a + r[12], e53[1] = r[1] * i + r[5] * a + r[13], e53[3] = r[3] * i + r[7] * a + r[15], e53;
}
q(yi, "hideGlyphs"), q(Al, "xyTransformMat4");
var Ye = 100;
var Em = class {
  constructor(e53, t3 = new Za(e53.width + 2 * Ye, e53.height + 2 * Ye, 25), r = new Za(e53.width + 2 * Ye, e53.height + 2 * Ye, 25)) {
    this.transform = e53, this.grid = t3, this.ignoredGrid = r, this.pitchfactor = Math.cos(e53._pitch) * e53.cameraToCenterDistance, this.screenRightBoundary = e53.width + Ye, this.screenBottomBoundary = e53.height + Ye, this.gridRightBoundary = e53.width + 2 * Ye, this.gridBottomBoundary = e53.height + 2 * Ye, this.perspectiveRatioCutoff = 0.6;
  }
  placeCollisionBox(e53, t3, r, i, a, n) {
    let s3 = this.projectAndGetPerspectiveRatio(i, e53.anchorPointX, e53.anchorPointY, n), o = r * s3.perspectiveRatio, l = e53.x1 * o + s3.point.x, u3 = e53.y1 * o + s3.point.y, c3 = e53.x2 * o + s3.point.x, h = e53.y2 * o + s3.point.y;
    return !this.isInsideGrid(l, u3, c3, h) || "always" !== t3 && this.grid.hitTest(l, u3, c3, h, t3, a) || s3.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l, u3, c3, h], offscreen: this.isOffscreen(l, u3, c3, h) };
  }
  placeCollisionCircles(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d) {
    let f = [], m = new Zt.default(t3.anchorX, t3.anchorY), y = bt(m, n, d), g = Xa(this.transform.cameraToCenterDistance, y.signedDistanceFromCamera), _ = (u3 ? a / g : a * g) / li, x = bt(m, s3, d).point, v = Mm(_, i, t3.lineOffsetX * _, t3.lineOffsetY * _, false, x, m, t3, r, s3, { projections: {}, offsets: {} }, false, d), b = false, w = false, S = true;
    if (v) {
      let t4 = 0.5 * h * g + p, r3 = new Zt.default(-Ye, -Ye), i3 = new Zt.default(this.screenRightBoundary, this.screenBottomBoundary), a3 = new wl(), n3 = v.first, s4 = v.last, u4 = [];
      for (let e54 = n3.path.length - 1; e54 >= 1; e54--)
        u4.push(n3.path[e54]);
      for (let e54 = 1; e54 < s4.path.length; e54++)
        u4.push(s4.path[e54]);
      let m3 = 2.5 * t4;
      if (o) {
        let e54 = u4.map((e55) => bt(e55, o, d));
        u4 = e54.some((e55) => e55.signedDistanceFromCamera <= 0) ? [] : e54.map((e55) => e55.point);
      }
      let y3 = [];
      if (u4.length > 0) {
        let e54 = u4[0].clone(), t5 = u4[0].clone();
        for (let r4 = 1; r4 < u4.length; r4++)
          e54.x = Math.min(e54.x, u4[r4].x), e54.y = Math.min(e54.y, u4[r4].y), t5.x = Math.max(t5.x, u4[r4].x), t5.y = Math.max(t5.y, u4[r4].y);
        y3 = e54.x >= r3.x && t5.x <= i3.x && e54.y >= r3.y && t5.y <= i3.y ? [u4] : t5.x < r3.x || e54.x > i3.x || t5.y < r3.y || e54.y > i3.y ? [] : Sm([u4], r3.x, r3.y, i3.x, i3.y);
      }
      for (let r4 of y3) {
        a3.reset(r4, 0.25 * t4);
        let i4 = 0;
        i4 = a3.length <= 0.5 * t4 ? 1 : Math.ceil(a3.paddedLength / m3) + 1;
        for (let r5 = 0; r5 < i4; r5++) {
          let n4 = r5 / Math.max(i4 - 1, 1), s5 = a3.lerp(n4), o3 = s5.x + Ye, u5 = s5.y + Ye;
          f.push(o3, u5, t4, 0);
          let h3 = o3 - t4, p3 = u5 - t4, d3 = o3 + t4, m4 = u5 + t4;
          if (S = S && this.isOffscreen(h3, p3, d3, m4), w = w || this.isInsideGrid(h3, p3, d3, m4), "always" !== e53 && this.grid.hitTestCircle(o3, u5, t4, e53, c3) && (b = true, !l))
            return { circles: [], offscreen: false, collisionDetected: b };
        }
      }
    }
    return { circles: !l && b || !w || g < this.perspectiveRatioCutoff ? [] : f, offscreen: S, collisionDetected: b };
  }
  queryRenderedSymbols(e53) {
    if (0 === e53.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
      return {};
    let t3 = [], r = 1 / 0, i = 1 / 0, a = -1 / 0, n = -1 / 0;
    for (let s4 of e53) {
      let e54 = new Zt.default(s4.x + Ye, s4.y + Ye);
      r = Math.min(r, e54.x), i = Math.min(i, e54.y), a = Math.max(a, e54.x), n = Math.max(n, e54.y), t3.push(e54);
    }
    let s3 = this.grid.query(r, i, a, n).concat(this.ignoredGrid.query(r, i, a, n)), o = {}, l = {};
    for (let e54 of s3) {
      let r3 = e54.key;
      (void 0 === o[r3.bucketInstanceId] && (o[r3.bucketInstanceId] = {}), o[r3.bucketInstanceId][r3.featureIndex]) || Fs(t3, [new Zt.default(e54.x1, e54.y1), new Zt.default(e54.x2, e54.y1), new Zt.default(e54.x2, e54.y2), new Zt.default(e54.x1, e54.y2)]) && (o[r3.bucketInstanceId][r3.featureIndex] = true, void 0 === l[r3.bucketInstanceId] && (l[r3.bucketInstanceId] = []), l[r3.bucketInstanceId].push(r3.featureIndex));
    }
    return l;
  }
  insertCollisionBox(e53, t3, r, i, a, n) {
    let s3 = { bucketInstanceId: i, featureIndex: a, collisionGroupID: n, overlapMode: t3 };
    (r ? this.ignoredGrid : this.grid).insert(s3, e53[0], e53[1], e53[2], e53[3]);
  }
  insertCollisionCircles(e53, t3, r, i, a, n) {
    let s3 = r ? this.ignoredGrid : this.grid, o = { bucketInstanceId: i, featureIndex: a, collisionGroupID: n, overlapMode: t3 };
    for (let t4 = 0; t4 < e53.length; t4 += 4)
      s3.insertCircle(o, e53[t4], e53[t4 + 1], e53[t4 + 2]);
  }
  projectAndGetPerspectiveRatio(e53, t3, r, i) {
    let a;
    return i ? (a = [t3, r, i(t3, r), 1], Xe.transformMat4(a, a, e53)) : (a = [t3, r, 0, 1], Al(a, a, e53)), { point: new Zt.default((a[0] / a[3] + 1) / 2 * this.transform.width + Ye, (-a[1] / a[3] + 1) / 2 * this.transform.height + Ye), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / a[3] * 0.5 };
  }
  isOffscreen(e53, t3, r, i) {
    return r < Ye || e53 >= this.screenRightBoundary || i < Ye || t3 > this.screenBottomBoundary;
  }
  isInsideGrid(e53, t3, r, i) {
    return r >= 0 && e53 < this.gridRightBoundary && i >= 0 && t3 < this.gridBottomBoundary;
  }
  getViewportMatrix() {
    let e53 = q3.identity([]);
    return q3.translate(e53, e53, [-Ye, -Ye, 0]), e53;
  }
};
q(Em, "CollisionIndex");
var Il = Em;
c(), c();
var sv = u(Pe(), 1);
var Ml = class e46 extends sv.default {
  constructor(e53, t3, r, i) {
    super(e53, t3), this.angle = r, void 0 !== i && (this.segment = i);
  }
  clone() {
    return new e46(this.x, this.y, this.angle, this.segment);
  }
};
q(Ml, "Anchor");
var Ka = Ml;
G("Anchor", Ka), c(), c(), c();
var nC = u(Pe(), 1);
c();
var aC = u(Pe(), 1);
c();
var oC = u(fe(), 1);
var sC = u(Pe(), 1);
var lC = u(Vh(), 1);
var gn = 7;
var uC = Number.POSITIVE_INFINITY;
function Cl(e53, t3) {
  function r(e54, t4) {
    let r3 = 0, i3 = 0;
    t4 < 0 && (t4 = 0);
    let a = t4 / Math.sqrt(2);
    switch (e54) {
      case "top-right":
      case "top-left":
        i3 = a - gn;
        break;
      case "bottom-right":
      case "bottom-left":
        i3 = -a + gn;
        break;
      case "bottom":
        i3 = -t4 + gn;
        break;
      case "top":
        i3 = t4 - gn;
    }
    switch (e54) {
      case "top-right":
      case "bottom-right":
        r3 = -a;
        break;
      case "top-left":
      case "bottom-left":
        r3 = a;
        break;
      case "left":
        r3 = t4;
        break;
      case "right":
        r3 = -t4;
    }
    return [r3, i3];
  }
  function i(e54, t4, r3) {
    let i3 = 0, a = 0;
    switch (t4 = Math.abs(t4), r3 = Math.abs(r3), e54) {
      case "top-right":
      case "top-left":
      case "top":
        a = r3 - gn;
        break;
      case "bottom-right":
      case "bottom-left":
      case "bottom":
        a = -r3 + gn;
    }
    switch (e54) {
      case "top-right":
      case "bottom-right":
      case "right":
        i3 = -t4;
        break;
      case "top-left":
      case "bottom-left":
      case "left":
        i3 = t4;
    }
    return [i3, a];
  }
  return q(r, "fromRadialOffset"), q(i, "fromTextOffset"), t3[1] !== uC ? i(e53, t3[0], t3[1]) : r(e53, t3[0]);
}
function lv(e53) {
  switch (e53) {
    case "right":
    case "top-right":
    case "bottom-right":
      return "right";
    case "left":
    case "top-left":
    case "bottom-left":
      return "left";
  }
  return "center";
}
function Ke(e53, t3, r) {
  return t3 * (8192 / (e53.tileSize * Math.pow(2, r - e53.tileID.overscaledZ)));
}
q(Cl, "evaluateVariableOffset"), q(lv, "getAnchorJustification"), c(), q(Ke, "pixelsToTileUnits");
var zl = u(Pe(), 1);
var Fm = class {
  constructor(e53, t3, r, i) {
    this.opacity = e53 ? Math.max(0, Math.min(1, e53.opacity + (e53.placed ? t3 : -t3))) : i && r ? 1 : 0, this.placed = r;
  }
  isHidden() {
    return 0 === this.opacity && !this.placed;
  }
};
q(Fm, "OpacityState");
var kl = Fm;
var Bm = class {
  constructor(e53, t3, r, i, a) {
    this.text = new kl(e53 ? e53.text : null, t3, r, a), this.icon = new kl(e53 ? e53.icon : null, t3, i, a);
  }
  isHidden() {
    return this.text.isHidden() && this.icon.isHidden();
  }
};
q(Bm, "JointOpacityState");
var gi = Bm;
var Rm = class {
  constructor(e53, t3, r) {
    this.text = e53, this.icon = t3, this.skipFade = r;
  }
};
q(Rm, "JointPlacement");
var Ll = Rm;
var Om = class {
  constructor() {
    this.invProjMatrix = q3.create(), this.viewportMatrix = q3.create(), this.circles = [];
  }
};
q(Om, "CollisionCircleArray");
var Lm = Om;
var Vm = class {
  constructor(e53, t3, r, i, a) {
    this.bucketInstanceId = e53, this.featureIndex = t3, this.sourceLayerIndex = r, this.bucketIndex = i, this.tileID = a;
  }
};
q(Vm, "RetainedQueryData");
var Dm = Vm;
var Um = class {
  constructor(e53) {
    this.crossSourceCollisions = e53, this.maxGroupID = 0, this.collisionGroups = {};
  }
  get(e53) {
    if (this.crossSourceCollisions)
      return { ID: 0, predicate: null };
    if (!this.collisionGroups[e53]) {
      let t3 = ++this.maxGroupID;
      this.collisionGroups[e53] = { ID: t3, predicate: (e54) => e54.collisionGroupID === t3 };
    }
    return this.collisionGroups[e53];
  }
};
q(Um, "CollisionGroups");
var zm = Um;
function uv(e53, t3, r, i, a) {
  let { horizontalAlign: n, verticalAlign: s3 } = Js(e53), o = -(n - 0.5) * t3, l = -(s3 - 0.5) * r, u3 = Cl(e53, i);
  return new zl.default(o + u3[0] * a, l + u3[1] * a);
}
function km(e53, t3, r, i, a, n) {
  let { x1: s3, x2: o, y1: l, y2: u3, anchorPointX: c3, anchorPointY: h } = e53, p = new zl.default(t3, r);
  return i && p._rotate(a ? n : -n), { x1: s3 + p.x, y1: l + p.y, x2: o + p.x, y2: u3 + p.y, anchorPointX: c3, anchorPointY: h };
}
q(uv, "calculateVariableLayoutShift"), q(km, "shiftVariableCollisionBox");
var Nm = class {
  constructor(e53, t3, r, i, a) {
    this.transform = e53.clone(), this.terrain = t3, this.collisionIndex = new Il(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = r, this.retainedQueryData = {}, this.collisionGroups = new zm(i), this.collisionCircleArrays = {}, this.prevPlacement = a, a && (a.prevPlacement = void 0), this.placedOrientations = {};
  }
  getBucketParts(e53, t3, r, i) {
    let a = r.getBucket(t3), n = r.latestFeatureIndex;
    if (!a || !n || t3.id !== a.layerIds[0])
      return;
    let s3 = r.collisionBoxArray, o = a.layers[0].layout, l = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ), u3 = r.tileSize / 8192, c3 = this.transform.calculatePosMatrix(r.tileID.toUnwrapped()), h = "map" === o.get("text-pitch-alignment"), p = "map" === o.get("text-rotation-alignment"), d = Ke(r, 1, this.transform.zoom), f = Wa(c3, h, p, this.transform, d), m = null;
    if (h) {
      let e54 = Tl(c3, h, p, this.transform, d);
      m = q3.multiply([], this.transform.labelPlaneMatrix, e54);
    }
    this.retainedQueryData[a.bucketInstanceId] = new Dm(a.bucketInstanceId, n, a.sourceLayerIndex, a.index, r.tileID);
    let y = { bucket: a, layout: o, posMatrix: c3, textLabelPlaneMatrix: f, labelToScreenMatrix: m, scale: l, textPixelRatio: u3, holdingForFade: r.holdingForFade(), collisionBoxArray: s3, partiallyEvaluatedTextSize: ci(a.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a.sourceID) };
    if (i)
      for (let t4 of a.sortKeyRanges) {
        let { sortKey: r3, symbolInstanceStart: i3, symbolInstanceEnd: a3 } = t4;
        e53.push({ sortKey: r3, symbolInstanceStart: i3, symbolInstanceEnd: a3, parameters: y });
      }
    else
      e53.push({ symbolInstanceStart: 0, symbolInstanceEnd: a.symbolInstances.length, parameters: y });
  }
  attemptAnchorPlacement(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m) {
    let y = [h.textOffset0, h.textOffset1], g = uv(e53, r, i, y, a), _ = this.collisionIndex.placeCollisionBox(km(t3, g.x, g.y, n, s3, this.transform.angle), c3, o, l, u3.predicate, m);
    if ((!f || 0 !== this.collisionIndex.placeCollisionBox(km(f, g.x, g.y, n, s3, this.transform.angle), c3, o, l, u3.predicate, m).box.length) && _.box.length > 0) {
      let t4;
      if (this.prevPlacement && this.prevPlacement.variableOffsets[h.crossTileID] && this.prevPlacement.placements[h.crossTileID] && this.prevPlacement.placements[h.crossTileID].text && (t4 = this.prevPlacement.variableOffsets[h.crossTileID].anchor), 0 === h.crossTileID)
        throw new Error("symbolInstance.crossTileID can't be 0");
      return this.variableOffsets[h.crossTileID] = { textOffset: y, width: r, height: i, anchor: e53, textBoxScale: a, prevAnchor: t4 }, this.markUsedJustification(p, e53, h, d), p.allowVerticalPlacement && (this.markUsedOrientation(p, d, h), this.placedOrientations[h.crossTileID] = d), { shift: g, placedGlyphBoxes: _ };
    }
  }
  placeLayerBucketPart(e53, t3, r) {
    let { bucket: i, layout: a, posMatrix: n, textLabelPlaneMatrix: s3, labelToScreenMatrix: o, textPixelRatio: l, holdingForFade: c3, collisionBoxArray: h, partiallyEvaluatedTextSize: p, collisionGroup: d } = e53.parameters, f = a.get("text-optional"), m = a.get("icon-optional"), y = nn(a, "text-overlap", "text-allow-overlap"), g = "always" === y, _ = nn(a, "icon-overlap", "icon-allow-overlap"), x = "always" === _, v = "map" === a.get("text-rotation-alignment"), b = "map" === a.get("text-pitch-alignment"), w = "none" !== a.get("icon-text-fit"), S = "viewport-y" === a.get("symbol-z-order"), A = g && (x || !i.hasIconData() || m), M3 = x && (g || !i.hasTextData() || f);
    !i.collisionArrays && h && i.deserializeCollisionBoxes(h);
    let I = this.retainedQueryData[i.bucketInstanceId].tileID, T = this.terrain ? (e54, t4) => this.terrain.getElevation(I, e54, t4) : null, C = q((e54, h3) => {
      if (t3[e54.crossTileID])
        return;
      if (c3)
        return void (this.placements[e54.crossTileID] = new Ll(false, false, false));
      let x3 = false, S3 = false, I4 = true, C3 = null, P = { box: null, offscreen: null }, k = { box: null, offscreen: null }, z3 = null, E = null, D = null, B3 = 0, L = 0, F = 0;
      h3.textFeatureIndex ? B3 = h3.textFeatureIndex : e54.useRuntimeCollisionCircles && (B3 = e54.featureIndex), h3.verticalTextFeatureIndex && (L = h3.verticalTextFeatureIndex);
      let R3 = h3.textBox;
      if (R3) {
        let t4 = q((t5) => {
          let r4 = 1;
          if (i.allowVerticalPlacement && !t5 && this.prevPlacement) {
            let t6 = this.prevPlacement.placedOrientations[e54.crossTileID];
            t6 && (this.placedOrientations[e54.crossTileID] = t6, r4 = t6, this.markUsedOrientation(i, r4, e54));
          }
          return r4;
        }, "updatePreviousOrientationIfNotPlaced"), r3 = q((t5, r4) => {
          if (i.allowVerticalPlacement && e54.numVerticalGlyphVertices > 0 && h3.verticalTextBox) {
            for (let e55 of i.writingModes)
              if (2 === e55 ? (P = r4(), k = P) : P = t5(), P && P.box && P.box.length)
                break;
          } else
            P = t5();
        }, "placeTextForPlacementModes");
        if (a.get("text-variable-anchor")) {
          let s4 = a.get("text-variable-anchor");
          if (this.prevPlacement && this.prevPlacement.variableOffsets[e54.crossTileID]) {
            let t5 = this.prevPlacement.variableOffsets[e54.crossTileID];
            s4.indexOf(t5.anchor) > 0 && (s4 = s4.filter((e55) => e55 !== t5.anchor), s4.unshift(t5.anchor));
          }
          let o3 = q((t5, r4, a3) => {
            let o4 = t5.x2 - t5.x1, u3 = t5.y2 - t5.y1, c5 = e54.textBoxScale, h4 = w && "never" === _ ? r4 : null, p3 = { box: [], offscreen: false }, f3 = "never" !== y ? 2 * s4.length : s4.length;
            for (let r5 = 0; r5 < f3; ++r5) {
              let f4 = s4[r5 % s4.length], m3 = r5 >= s4.length ? y : "never", g3 = this.attemptAnchorPlacement(f4, t5, o4, u3, c5, v, b, l, n, d, m3, e54, i, a3, h4, T);
              if (g3 && (p3 = g3.placedGlyphBoxes, p3 && p3.box && p3.box.length)) {
                x3 = true, C3 = g3.shift;
                break;
              }
            }
            return p3;
          }, "placeBoxForVariableAnchors");
          r3(q(() => o3(R3, h3.iconBox, 1), "placeHorizontal"), q(() => {
            let t5 = h3.verticalTextBox, r4 = P && P.box && P.box.length;
            return i.allowVerticalPlacement && !r4 && e54.numVerticalGlyphVertices > 0 && t5 ? o3(t5, h3.verticalIconBox, 2) : { box: null, offscreen: null };
          }, "placeVertical")), P && (x3 = P.box, I4 = P.offscreen);
          let c4 = t4(P && P.box);
          if (!x3 && this.prevPlacement) {
            let t5 = this.prevPlacement.variableOffsets[e54.crossTileID];
            t5 && (this.variableOffsets[e54.crossTileID] = t5, this.markUsedJustification(i, t5.anchor, e54, c4));
          }
        } else {
          let a3 = q((t5, r4) => {
            let a4 = this.collisionIndex.placeCollisionBox(t5, y, l, n, d.predicate, T);
            return a4 && a4.box && a4.box.length && (this.markUsedOrientation(i, r4, e54), this.placedOrientations[e54.crossTileID] = r4), a4;
          }, "placeBox");
          r3(q(() => a3(R3, 1), "placeHorizontal"), q(() => {
            let t5 = h3.verticalTextBox;
            return i.allowVerticalPlacement && e54.numVerticalGlyphVertices > 0 && t5 ? a3(t5, 2) : { box: null, offscreen: null };
          }, "placeVertical")), t4(P && P.box && P.box.length);
        }
      }
      if (z3 = P, x3 = z3 && z3.box && z3.box.length > 0, I4 = z3 && z3.offscreen, e54.useRuntimeCollisionCircles) {
        let t4 = i.text.placedSymbolArray.get(e54.centerJustifiedTextSymbolIndex), l3 = rn(i.textSizeData, p, t4), u3 = a.get("text-padding"), c4 = e54.collisionCircleDiameter;
        E = this.collisionIndex.placeCollisionCircles(y, t4, i.lineVertexArray, i.glyphOffsetArray, l3, n, s3, o, r, b, d.predicate, c4, u3, T), E.circles.length && E.collisionDetected && !r && Ce("Collisions detected, but collision boxes are not shown"), x3 = g || E.circles.length > 0 && !E.collisionDetected, I4 = I4 && E.offscreen;
      }
      if (h3.iconFeatureIndex && (F = h3.iconFeatureIndex), h3.iconBox) {
        let e55 = q((e56) => {
          let t4 = w && C3 ? km(e56, C3.x, C3.y, v, b, this.transform.angle) : e56;
          return this.collisionIndex.placeCollisionBox(t4, _, l, n, d.predicate, T);
        }, "placeIconFeature");
        k && k.box && k.box.length && h3.verticalIconBox ? (D = e55(h3.verticalIconBox), S3 = D.box.length > 0) : (D = e55(h3.iconBox), S3 = D.box.length > 0), I4 = I4 && D.offscreen;
      }
      let V = f || 0 === e54.numHorizontalGlyphVertices && 0 === e54.numVerticalGlyphVertices, O = m || 0 === e54.numIconVertices;
      if (V || O ? O ? V || (S3 = S3 && x3) : x3 = S3 && x3 : S3 = x3 = S3 && x3, x3 && z3 && z3.box && (k && k.box && L ? this.collisionIndex.insertCollisionBox(z3.box, y, a.get("text-ignore-placement"), i.bucketInstanceId, L, d.ID) : this.collisionIndex.insertCollisionBox(z3.box, y, a.get("text-ignore-placement"), i.bucketInstanceId, B3, d.ID)), S3 && D && this.collisionIndex.insertCollisionBox(D.box, _, a.get("icon-ignore-placement"), i.bucketInstanceId, F, d.ID), E && (x3 && this.collisionIndex.insertCollisionCircles(E.circles, y, a.get("text-ignore-placement"), i.bucketInstanceId, B3, d.ID), r)) {
        let e55 = i.bucketInstanceId, t4 = this.collisionCircleArrays[e55];
        void 0 === t4 && (t4 = this.collisionCircleArrays[e55] = new Lm());
        for (let e56 = 0; e56 < E.circles.length; e56 += 4)
          t4.circles.push(E.circles[e56 + 0]), t4.circles.push(E.circles[e56 + 1]), t4.circles.push(E.circles[e56 + 2]), t4.circles.push(E.collisionDetected ? 1 : 0);
      }
      if (0 === e54.crossTileID)
        throw new Error("symbolInstance.crossTileID can't be 0");
      if (0 === i.bucketInstanceId)
        throw new Error("bucket.bucketInstanceId can't be 0");
      this.placements[e54.crossTileID] = new Ll(x3 || A, S3 || M3, I4 || i.justReloaded), t3[e54.crossTileID] = true;
    }, "placeSymbol");
    if (S) {
      if (0 !== e53.symbolInstanceStart)
        throw new Error("bucket.bucketInstanceId should be 0");
      let t4 = i.getSortedSymbolIndexes(this.transform.angle);
      for (let e54 = t4.length - 1; e54 >= 0; --e54) {
        let r3 = t4[e54];
        C(i.symbolInstances.get(r3), i.collisionArrays[r3]);
      }
    } else
      for (let t4 = e53.symbolInstanceStart; t4 < e53.symbolInstanceEnd; t4++)
        C(i.symbolInstances.get(t4), i.collisionArrays[t4]);
    if (r && i.bucketInstanceId in this.collisionCircleArrays) {
      let e54 = this.collisionCircleArrays[i.bucketInstanceId];
      q3.invert(e54.invProjMatrix, n), e54.viewportMatrix = this.collisionIndex.getViewportMatrix();
    }
    i.justReloaded = false;
  }
  markUsedJustification(e53, t3, r, i) {
    let a, n = { left: r.leftJustifiedTextSymbolIndex, center: r.centerJustifiedTextSymbolIndex, right: r.rightJustifiedTextSymbolIndex };
    a = 2 === i ? r.verticalPlacedTextSymbolIndex : n[lv(t3)];
    let s3 = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex, r.verticalPlacedTextSymbolIndex];
    for (let t4 of s3)
      t4 >= 0 && (e53.text.placedSymbolArray.get(t4).crossTileID = a >= 0 && t4 !== a ? 0 : r.crossTileID);
  }
  markUsedOrientation(e53, t3, r) {
    let i = 1 === t3 || 3 === t3 ? t3 : 0, a = 2 === t3 ? t3 : 0, n = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex];
    for (let t4 of n)
      e53.text.placedSymbolArray.get(t4).placedOrientation = i;
    r.verticalPlacedTextSymbolIndex && (e53.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).placedOrientation = a);
  }
  commit(e53) {
    this.commitTime = e53, this.zoomAtLastRecencyCheck = this.transform.zoom;
    let t3 = this.prevPlacement, r = false;
    this.prevZoomAdjustment = t3 ? t3.zoomAdjustment(this.transform.zoom) : 0;
    let i = t3 ? t3.symbolFadeChange(e53) : 1, a = t3 ? t3.opacities : {}, n = t3 ? t3.variableOffsets : {}, s3 = t3 ? t3.placedOrientations : {};
    for (let e54 in this.placements) {
      let t4 = this.placements[e54], n3 = a[e54];
      n3 ? (this.opacities[e54] = new gi(n3, i, t4.text, t4.icon), r = r || t4.text !== n3.text.placed || t4.icon !== n3.icon.placed) : (this.opacities[e54] = new gi(null, i, t4.text, t4.icon, t4.skipFade), r = r || t4.text || t4.icon);
    }
    for (let e54 in a) {
      let t4 = a[e54];
      if (!this.opacities[e54]) {
        let a3 = new gi(t4, i, false, false);
        a3.isHidden() || (this.opacities[e54] = a3, r = r || t4.text.placed || t4.icon.placed);
      }
    }
    for (let e54 in n)
      !this.variableOffsets[e54] && this.opacities[e54] && !this.opacities[e54].isHidden() && (this.variableOffsets[e54] = n[e54]);
    for (let e54 in s3)
      !this.placedOrientations[e54] && this.opacities[e54] && !this.opacities[e54].isHidden() && (this.placedOrientations[e54] = s3[e54]);
    if (t3 && void 0 === t3.lastPlacementChangeTime)
      throw new Error("Last placement time for previous placement is not defined");
    r ? this.lastPlacementChangeTime = e53 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t3 ? t3.lastPlacementChangeTime : e53);
  }
  updateLayerOpacities(e53, t3) {
    let r = {};
    for (let i of t3) {
      let t4 = i.getBucket(e53);
      t4 && i.latestFeatureIndex && e53.id === t4.layerIds[0] && this.updateBucketOpacities(t4, r, i.collisionBoxArray);
    }
  }
  updateBucketOpacities(e53, t3, r) {
    e53.hasTextData() && (e53.text.opacityVertexArray.clear(), e53.text.hasVisibleVertices = false), e53.hasIconData() && (e53.icon.opacityVertexArray.clear(), e53.icon.hasVisibleVertices = false), e53.hasIconCollisionBoxData() && e53.iconCollisionBox.collisionVertexArray.clear(), e53.hasTextCollisionBoxData() && e53.textCollisionBox.collisionVertexArray.clear();
    let i = e53.layers[0].layout, a = new gi(null, 0, false, false, true), n = i.get("text-allow-overlap"), s3 = i.get("icon-allow-overlap"), o = i.get("text-variable-anchor"), l = "map" === i.get("text-rotation-alignment"), c3 = "map" === i.get("text-pitch-alignment"), h = "none" !== i.get("icon-text-fit"), p = new gi(null, 0, n && (s3 || !e53.hasIconData() || i.get("icon-optional")), s3 && (n || !e53.hasTextData() || i.get("text-optional")), true);
    !e53.collisionArrays && r && (e53.hasIconCollisionBoxData() || e53.hasTextCollisionBoxData()) && e53.deserializeCollisionBoxes(r);
    let d = q((e54, t4, r3) => {
      for (let i3 = 0; i3 < t4 / 4; i3++)
        e54.opacityVertexArray.emplaceBack(r3);
      e54.hasVisibleVertices = e54.hasVisibleVertices || r3 !== Ya;
    }, "addOpacities");
    for (let r3 = 0; r3 < e53.symbolInstances.length; r3++) {
      let i3 = e53.symbolInstances.get(r3), { numHorizontalGlyphVertices: n3, numVerticalGlyphVertices: s4, crossTileID: u3 } = i3, f = t3[u3], m = this.opacities[u3];
      f ? m = a : m || (m = p, this.opacities[u3] = m), t3[u3] = true;
      let y = n3 > 0 || s4 > 0, g = i3.numIconVertices > 0, _ = this.placedOrientations[i3.crossTileID], x = 2 === _, v = 1 === _ || 3 === _;
      if (y) {
        let t4 = cv(m.text), r4 = x ? Ya : t4;
        d(e53.text, n3, r4);
        let a3 = v ? Ya : t4;
        d(e53.text, s4, a3);
        let o3 = m.text.isHidden();
        [i3.rightJustifiedTextSymbolIndex, i3.centerJustifiedTextSymbolIndex, i3.leftJustifiedTextSymbolIndex].forEach((t5) => {
          t5 >= 0 && (e53.text.placedSymbolArray.get(t5).hidden = o3 || x ? 1 : 0);
        }), i3.verticalPlacedTextSymbolIndex >= 0 && (e53.text.placedSymbolArray.get(i3.verticalPlacedTextSymbolIndex).hidden = o3 || v ? 1 : 0);
        let l3 = this.variableOffsets[i3.crossTileID];
        l3 && this.markUsedJustification(e53, l3.anchor, i3, _);
        let u4 = this.placedOrientations[i3.crossTileID];
        u4 && (this.markUsedJustification(e53, "left", i3, u4), this.markUsedOrientation(e53, u4, i3));
      }
      if (g) {
        let t4 = cv(m.icon), r4 = !(h && i3.verticalPlacedIconSymbolIndex && x);
        if (i3.placedIconSymbolIndex >= 0) {
          let a3 = r4 ? t4 : Ya;
          d(e53.icon, i3.numIconVertices, a3), e53.icon.placedSymbolArray.get(i3.placedIconSymbolIndex).hidden = m.icon.isHidden();
        }
        if (i3.verticalPlacedIconSymbolIndex >= 0) {
          let a3 = r4 ? Ya : t4;
          d(e53.icon, i3.numVerticalIconVertices, a3), e53.icon.placedSymbolArray.get(i3.verticalPlacedIconSymbolIndex).hidden = m.icon.isHidden();
        }
      }
      if (e53.hasIconCollisionBoxData() || e53.hasTextCollisionBoxData()) {
        let t4 = e53.collisionArrays[r3];
        if (t4) {
          let r4 = new zl.default(0, 0);
          if (t4.textBox || t4.verticalTextBox) {
            let i5 = true;
            if (o) {
              let e54 = this.variableOffsets[u3];
              e54 ? (r4 = uv(e54.anchor, e54.width, e54.height, e54.textOffset, e54.textBoxScale), l && r4._rotate(c3 ? this.transform.angle : -this.transform.angle)) : i5 = false;
            }
            t4.textBox && El(e53.textCollisionBox.collisionVertexArray, m.text.placed, !i5 || x, r4.x, r4.y), t4.verticalTextBox && El(e53.textCollisionBox.collisionVertexArray, m.text.placed, !i5 || v, r4.x, r4.y);
          }
          let i4 = !(v || !t4.verticalIconBox);
          t4.iconBox && El(e53.iconCollisionBox.collisionVertexArray, m.icon.placed, i4, h ? r4.x : 0, h ? r4.y : 0), t4.verticalIconBox && El(e53.iconCollisionBox.collisionVertexArray, m.icon.placed, !i4, h ? r4.x : 0, h ? r4.y : 0);
        }
      }
    }
    if (e53.sortFeatures(this.transform.angle), this.retainedQueryData[e53.bucketInstanceId] && (this.retainedQueryData[e53.bucketInstanceId].featureSortOrder = e53.featureSortOrder), e53.hasTextData() && e53.text.opacityVertexBuffer && e53.text.opacityVertexBuffer.updateData(e53.text.opacityVertexArray), e53.hasIconData() && e53.icon.opacityVertexBuffer && e53.icon.opacityVertexBuffer.updateData(e53.icon.opacityVertexArray), e53.hasIconCollisionBoxData() && e53.iconCollisionBox.collisionVertexBuffer && e53.iconCollisionBox.collisionVertexBuffer.updateData(e53.iconCollisionBox.collisionVertexArray), e53.hasTextCollisionBoxData() && e53.textCollisionBox.collisionVertexBuffer && e53.textCollisionBox.collisionVertexBuffer.updateData(e53.textCollisionBox.collisionVertexArray), e53.text.opacityVertexArray.length !== e53.text.layoutVertexArray.length / 4)
      throw new Error("bucket.text.opacityVertexArray.length (= ".concat(e53.text.opacityVertexArray.length, ") !== bucket.text.layoutVertexArray.length (= ").concat(e53.text.layoutVertexArray.length, ") / 4"));
    if (e53.icon.opacityVertexArray.length !== e53.icon.layoutVertexArray.length / 4)
      throw new Error("bucket.icon.opacityVertexArray.length (= ".concat(e53.icon.opacityVertexArray.length, ") !== bucket.icon.layoutVertexArray.length (= ").concat(e53.icon.layoutVertexArray.length, ") / 4"));
    if (e53.bucketInstanceId in this.collisionCircleArrays) {
      let t4 = this.collisionCircleArrays[e53.bucketInstanceId];
      e53.placementInvProjMatrix = t4.invProjMatrix, e53.placementViewportMatrix = t4.viewportMatrix, e53.collisionCircleArray = t4.circles, delete this.collisionCircleArrays[e53.bucketInstanceId];
    }
  }
  symbolFadeChange(e53) {
    return 0 === this.fadeDuration ? 1 : (e53 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
  }
  zoomAdjustment(e53) {
    return Math.max(0, (this.transform.zoom - e53) / 1.5);
  }
  hasTransitions(e53) {
    return this.stale || e53 - this.lastPlacementChangeTime < this.fadeDuration;
  }
  stillRecent(e53, t3) {
    let r = this.zoomAtLastRecencyCheck === t3 ? 1 - this.zoomAdjustment(t3) : 1;
    return this.zoomAtLastRecencyCheck = t3, this.commitTime + this.fadeDuration * r > e53;
  }
  setStale() {
    this.stale = true;
  }
};
q(Nm, "Placement");
var Dl = Nm;
function El(e53, t3, r, i, a) {
  e53.emplaceBack(t3 ? 1 : 0, r ? 1 : 0, i || 0, a || 0), e53.emplaceBack(t3 ? 1 : 0, r ? 1 : 0, i || 0, a || 0), e53.emplaceBack(t3 ? 1 : 0, r ? 1 : 0, i || 0, a || 0), e53.emplaceBack(t3 ? 1 : 0, r ? 1 : 0, i || 0, a || 0);
}
q(El, "updateCollisionVertices");
var cC = Math.pow(2, 25);
var pC = Math.pow(2, 24);
var hC = Math.pow(2, 17);
var fC = Math.pow(2, 16);
var mC = Math.pow(2, 9);
var dC = Math.pow(2, 8);
var yC = Math.pow(2, 1);
function cv(e53) {
  if (0 === e53.opacity && !e53.placed)
    return 0;
  if (1 === e53.opacity && e53.placed)
    return 4294967295;
  let t3 = e53.placed ? 1 : 0, r = Math.floor(127 * e53.opacity);
  return r * cC + t3 * pC + r * hC + t3 * fC + r * mC + t3 * dC + r * yC + t3;
}
q(cv, "packOpacity");
var Ya = 0;
var qm = class {
  constructor(e53) {
    this._sortAcrossTiles = "viewport-y" !== e53.layout.get("symbol-z-order") && !e53.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
  }
  continuePlacement(e53, t3, r, i, a) {
    let n = this._bucketParts;
    for (; this._currentTileIndex < e53.length; ) {
      let r3 = e53[this._currentTileIndex];
      if (t3.getBucketParts(n, i, r3, this._sortAcrossTiles), this._currentTileIndex++, a())
        return true;
    }
    for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n.sort((e54, t4) => e54.sortKey - t4.sortKey)); this._currentPartIndex < n.length; ) {
      let e54 = n[this._currentPartIndex];
      if (t3.placeLayerBucketPart(e54, this._seenCrossTileIDs, r), this._currentPartIndex++, a())
        return true;
    }
    return false;
  }
};
q(qm, "LayerPlacement");
var Gm = qm;
var jm = class {
  constructor(e53, t3, r, i, a, n, s3, o) {
    this.placement = new Dl(e53, t3, n, s3, o), this._currentPlacementIndex = r.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = a, this._done = false;
  }
  isDone() {
    return this._done;
  }
  continuePlacement(e53, t3, r) {
    let i = ne.now(), a = q(() => !this._forceFullPlacement && ne.now() - i > 2, "shouldPausePlacement");
    for (; this._currentPlacementIndex >= 0; ) {
      let i3 = t3[e53[this._currentPlacementIndex]], n = this.placement.collisionIndex.transform.zoom;
      if ("symbol" === i3.type && (!i3.minzoom || i3.minzoom <= n) && (!i3.maxzoom || i3.maxzoom > n)) {
        if (this._inProgressLayer || (this._inProgressLayer = new Gm(i3)), this._inProgressLayer.continuePlacement(r[i3.source], this.placement, this._showCollisionBoxes, i3, a))
          return;
        delete this._inProgressLayer;
      }
      this._currentPlacementIndex--;
    }
    this._done = true;
  }
  commit(e53) {
    return this.placement.commit(e53), this.placement;
  }
};
q(jm, "PauseablePlacement");
var Fl = jm;
c(), c();
var pv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
var $m = 1;
var Ja = 8;
var Bl = class e47 {
  static from(t3) {
    if (!(t3 instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    let [r, i] = new Uint8Array(t3, 0, 2);
    if (219 !== r)
      throw new Error("Data does not appear to be in a KDBush format.");
    let a = i >> 4;
    if (a !== $m)
      throw new Error("Got v".concat(a, " data when expected v").concat($m, "."));
    let n = pv[15 & i];
    if (!n)
      throw new Error("Unrecognized array type.");
    let [s3] = new Uint16Array(t3, 2, 1), [o] = new Uint32Array(t3, 4, 1);
    return new e47(o, s3, n, t3);
  }
  constructor(e53, t3 = 64, r = Float64Array, i) {
    if (isNaN(e53) || e53 < 0)
      throw new Error("Unpexpected numItems value: ".concat(e53, "."));
    this.numItems = +e53, this.nodeSize = Math.min(Math.max(+t3, 2), 65535), this.ArrayType = r, this.IndexArrayType = e53 < 65536 ? Uint16Array : Uint32Array;
    let a = pv.indexOf(this.ArrayType), n = 2 * e53 * this.ArrayType.BYTES_PER_ELEMENT, s3 = e53 * this.IndexArrayType.BYTES_PER_ELEMENT, o = (8 - s3 % 8) % 8;
    if (a < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    i && i instanceof ArrayBuffer ? (this.data = i, this.ids = new this.IndexArrayType(this.data, Ja, e53), this.coords = new this.ArrayType(this.data, Ja + s3 + o, 2 * e53), this._pos = 2 * e53, this._finished = true) : (this.data = new ArrayBuffer(Ja + n + s3 + o), this.ids = new this.IndexArrayType(this.data, Ja, e53), this.coords = new this.ArrayType(this.data, Ja + s3 + o, 2 * e53), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, ($m << 4) + a]), new Uint16Array(this.data, 2, 1)[0] = t3, new Uint32Array(this.data, 4, 1)[0] = e53);
  }
  add(e53, t3) {
    let r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = e53, this.coords[this._pos++] = t3, r;
  }
  finish() {
    let e53 = this._pos >> 1;
    if (e53 !== this.numItems)
      throw new Error("Added ".concat(e53, " items when expected ").concat(this.numItems, "."));
    return Zm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
  }
  range(e53, t3, r, i) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    let { ids: a, coords: n, nodeSize: s3 } = this, o = [0, a.length - 1, 0], l = [];
    for (; o.length; ) {
      let u3 = o.pop() || 0, c3 = o.pop() || 0, h = o.pop() || 0;
      if (c3 - h <= s3) {
        for (let s4 = h; s4 <= c3; s4++) {
          let o3 = n[2 * s4], u4 = n[2 * s4 + 1];
          o3 >= e53 && o3 <= r && u4 >= t3 && u4 <= i && l.push(a[s4]);
        }
        continue;
      }
      let p = h + c3 >> 1, d = n[2 * p], f = n[2 * p + 1];
      d >= e53 && d <= r && f >= t3 && f <= i && l.push(a[p]), (0 === u3 ? e53 <= d : t3 <= f) && (o.push(h), o.push(p - 1), o.push(1 - u3)), (0 === u3 ? r >= d : i >= f) && (o.push(p + 1), o.push(c3), o.push(1 - u3));
    }
    return l;
  }
  within(e53, t3, r) {
    if (!this._finished)
      throw new Error("Data not yet indexed - call index.finish().");
    let { ids: i, coords: a, nodeSize: n } = this, s3 = [0, i.length - 1, 0], o = [], l = r * r;
    for (; s3.length; ) {
      let u3 = s3.pop() || 0, c3 = s3.pop() || 0, h = s3.pop() || 0;
      if (c3 - h <= n) {
        for (let r3 = h; r3 <= c3; r3++)
          hv(a[2 * r3], a[2 * r3 + 1], e53, t3) <= l && o.push(i[r3]);
        continue;
      }
      let p = h + c3 >> 1, d = a[2 * p], f = a[2 * p + 1];
      hv(d, f, e53, t3) <= l && o.push(i[p]), (0 === u3 ? e53 - r <= d : t3 - r <= f) && (s3.push(h), s3.push(p - 1), s3.push(1 - u3)), (0 === u3 ? e53 + r >= d : t3 + r >= f) && (s3.push(p + 1), s3.push(c3), s3.push(1 - u3));
    }
    return o;
  }
};
q(Bl, "KDBush");
var eo = Bl;
function Zm(e53, t3, r, i, a, n) {
  if (a - i <= r)
    return;
  let s3 = i + a >> 1;
  fv(e53, t3, s3, i, a, n), Zm(e53, t3, r, i, s3 - 1, 1 - n), Zm(e53, t3, r, s3 + 1, a, 1 - n);
}
function fv(e53, t3, r, i, a, n) {
  for (; a > i; ) {
    if (a - i > 600) {
      let s4 = a - i + 1, o3 = r - i + 1, l3 = Math.log(s4), u3 = 0.5 * Math.exp(2 * l3 / 3), c3 = 0.5 * Math.sqrt(l3 * u3 * (s4 - u3) / s4) * (o3 - s4 / 2 < 0 ? -1 : 1);
      fv(e53, t3, r, Math.max(i, Math.floor(r - o3 * u3 / s4 + c3)), Math.min(a, Math.floor(r + (s4 - o3) * u3 / s4 + c3)), n);
    }
    let s3 = t3[2 * r + n], o = i, l = a;
    for (Qa(e53, t3, i, r), t3[2 * a + n] > s3 && Qa(e53, t3, i, a); o < l; ) {
      for (Qa(e53, t3, o, l), o++, l--; t3[2 * o + n] < s3; )
        o++;
      for (; t3[2 * l + n] > s3; )
        l--;
    }
    t3[2 * i + n] === s3 ? Qa(e53, t3, i, l) : (l++, Qa(e53, t3, l, a)), l <= r && (i = l + 1), r <= l && (a = l - 1);
  }
}
function Qa(e53, t3, r, i) {
  Hm(e53, r, i), Hm(t3, 2 * r, 2 * i), Hm(t3, 2 * r + 1, 2 * i + 1);
}
function Hm(e53, t3, r) {
  let i = e53[t3];
  e53[t3] = e53[r], e53[r] = i;
}
function hv(e53, t3, r, i) {
  let a = e53 - r, n = t3 - i;
  return a * a + n * n;
}
q(Zm, "sort"), q(fv, "select"), q(Qa, "swapItem"), q(Hm, "swap"), q(hv, "sqDist");
var to = 0.03125;
var gC = 128;
var Ym = class {
  constructor(e53, t3, r) {
    this.tileID = e53, this.bucketInstanceId = r, this._symbolsByKey = {};
    let i = /* @__PURE__ */ new Map();
    for (let e54 = 0; e54 < t3.length; e54++) {
      let r3 = t3.get(e54), a = r3.key, n = i.get(a);
      n ? n.push(r3) : i.set(a, [r3]);
    }
    for (let [e54, t4] of i) {
      let r3 = { positions: t4.map((e55) => ({ x: Math.floor(e55.anchorX * to), y: Math.floor(e55.anchorY * to) })), crossTileIDs: t4.map((e55) => e55.crossTileID) };
      if (r3.positions.length > gC) {
        let e55 = new eo(r3.positions.length, 16, Uint16Array);
        for (let { x: t5, y: i3 } of r3.positions)
          e55.add(t5, i3);
        e55.finish(), delete r3.positions, r3.index = e55;
      }
      this._symbolsByKey[e54] = r3;
    }
  }
  getScaledCoordinates(e53, t3) {
    let { x: r, y: i, z: a } = this.tileID.canonical, { x: n, y: s3, z: o } = t3.canonical, l = o - a, u3 = to / Math.pow(2, l), c3 = (8192 * n + e53.anchorX) * u3, h = (8192 * s3 + e53.anchorY) * u3, p = 8192 * r * to, d = 8192 * i * to;
    return { x: Math.floor(c3 - p), y: Math.floor(h - d) };
  }
  findMatches(e53, t3, r) {
    let i = this.tileID.canonical.z < t3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t3.canonical.z);
    for (let a = 0; a < e53.length; a++) {
      let n = e53.get(a);
      if (n.crossTileID)
        continue;
      let s3 = this._symbolsByKey[n.key];
      if (!s3)
        continue;
      let o = this.getScaledCoordinates(n, t3);
      if (s3.index) {
        let e54 = s3.index.range(o.x - i, o.y - i, o.x + i, o.y + i).sort();
        for (let t4 of e54) {
          let e55 = s3.crossTileIDs[t4];
          if (!r[e55]) {
            r[e55] = true, n.crossTileID = e55;
            break;
          }
        }
      } else if (s3.positions)
        for (let e54 = 0; e54 < s3.positions.length; e54++) {
          let t4 = s3.positions[e54], a3 = s3.crossTileIDs[e54];
          if (Math.abs(t4.x - o.x) <= i && Math.abs(t4.y - o.y) <= i && !r[a3]) {
            r[a3] = true, n.crossTileID = a3;
            break;
          }
        }
    }
  }
  getCrossTileIDsLists() {
    return Object.values(this._symbolsByKey).map(({ crossTileIDs: e53 }) => e53);
  }
};
q(Ym, "TileLayerIndex");
var Wm = Ym;
var Jm = class {
  constructor() {
    this.maxCrossTileID = 0;
  }
  generate() {
    return ++this.maxCrossTileID;
  }
};
q(Jm, "CrossTileIDs");
var Xm = Jm;
var Qm = class {
  constructor() {
    this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
  }
  handleWrapJump(e53) {
    let t3 = Math.round((e53 - this.lng) / 360);
    if (0 !== t3)
      for (let e54 in this.indexes) {
        let r = this.indexes[e54], i = {};
        for (let e55 in r) {
          let a = r[e55];
          a.tileID = a.tileID.unwrapTo(a.tileID.wrap + t3), i[a.tileID.key] = a;
        }
        this.indexes[e54] = i;
      }
    this.lng = e53;
  }
  addBucket(e53, t3, r) {
    if (this.indexes[e53.overscaledZ] && this.indexes[e53.overscaledZ][e53.key]) {
      if (this.indexes[e53.overscaledZ][e53.key].bucketInstanceId === t3.bucketInstanceId)
        return false;
      this.removeBucketCrossTileIDs(e53.overscaledZ, this.indexes[e53.overscaledZ][e53.key]);
    }
    for (let e54 = 0; e54 < t3.symbolInstances.length; e54++) {
      t3.symbolInstances.get(e54).crossTileID = 0;
    }
    this.usedCrossTileIDs[e53.overscaledZ] || (this.usedCrossTileIDs[e53.overscaledZ] = {});
    let i = this.usedCrossTileIDs[e53.overscaledZ];
    for (let r3 in this.indexes) {
      let a = this.indexes[r3];
      if (Number(r3) > e53.overscaledZ)
        for (let r4 in a) {
          let n = a[r4];
          n.tileID.isChildOf(e53) && n.findMatches(t3.symbolInstances, e53, i);
        }
      else {
        let n = a[e53.scaledTo(Number(r3)).key];
        n && n.findMatches(t3.symbolInstances, e53, i);
      }
    }
    for (let e54 = 0; e54 < t3.symbolInstances.length; e54++) {
      let a = t3.symbolInstances.get(e54);
      a.crossTileID || (a.crossTileID = r.generate(), i[a.crossTileID] = true);
    }
    return void 0 === this.indexes[e53.overscaledZ] && (this.indexes[e53.overscaledZ] = {}), this.indexes[e53.overscaledZ][e53.key] = new Wm(e53, t3.symbolInstances, t3.bucketInstanceId), true;
  }
  removeBucketCrossTileIDs(e53, t3) {
    for (let r of t3.getCrossTileIDsLists())
      for (let t4 of r)
        delete this.usedCrossTileIDs[e53][t4];
  }
  removeStaleBuckets(e53) {
    let t3 = false;
    for (let r in this.indexes) {
      let i = this.indexes[r];
      for (let a in i)
        e53[i[a].bucketInstanceId] || (this.removeBucketCrossTileIDs(r, i[a]), delete i[a], t3 = true);
    }
    return t3;
  }
};
q(Qm, "CrossTileSymbolLayerIndex");
var Km = Qm;
var ed = class {
  constructor() {
    this.layerIndexes = {}, this.crossTileIDs = new Xm(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
  }
  addLayer(e53, t3, r) {
    let i = this.layerIndexes[e53.id];
    void 0 === i && (i = this.layerIndexes[e53.id] = new Km());
    let a = false, n = {};
    i.handleWrapJump(r);
    for (let r3 of t3) {
      let t4 = r3.getBucket(e53);
      !t4 || e53.id !== t4.layerIds[0] || (t4.bucketInstanceId || (t4.bucketInstanceId = ++this.maxBucketInstanceId), i.addBucket(r3.tileID, t4, this.crossTileIDs) && (a = true), n[t4.bucketInstanceId] = true);
    }
    return i.removeStaleBuckets(n) && (a = true), a;
  }
  pruneUnusedLayers(e53) {
    let t3 = {};
    e53.forEach((e54) => {
      t3[e54] = true;
    });
    for (let e54 in this.layerIndexes)
      t3[e54] || delete this.layerIndexes[e54];
  }
};
q(ed, "CrossTileSymbolIndex");
var xn = ed;
var Rl = q((e53, t3) => Ri(e53, t3 && t3.filter((e54) => "source.canvas" !== e54.identifier)), "emitValidationErrors");
var xC = Bt(Ae, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]);
var bC = Bt(Ae, ["setCenter", "setZoom", "setBearing", "setPitch"]);
var _C = Hg();
var Ol = class e48 extends de {
  constructor(t3, r = {}) {
    super(), this.map = t3, this.dispatcher = new ja(wm(), this, t3._getMapId()), this.imageManager = new ll(), this.imageManager.setEventedParent(this), this.glyphManager = new ul(t3._requestManager, r.localIdeographFontFamily), this.lineAtlas = new pl(256, 512), this.crossTileSymbolIndex = new xn(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new Ui(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", go());
    let i = this;
    this._rtlTextPluginCallback = e48.registerForPluginStateChange((e53) => {
      let t4 = { pluginStatus: e53.pluginStatus, pluginURL: e53.pluginURL };
      i.dispatcher.broadcast("syncRTLPluginState", t4, (e54, t5) => {
        if (_p(e54), t5 && t5.every((e55) => e55))
          for (let e55 in i.sourceCaches) {
            let t6 = i.sourceCaches[e55].getSource().type;
            ("vector" === t6 || "geojson" === t6) && i.sourceCaches[e55].reload();
          }
      });
    }), this.on("data", (e53) => {
      if ("source" !== e53.dataType || "metadata" !== e53.sourceDataType)
        return;
      let t4 = this.sourceCaches[e53.sourceId];
      if (!t4)
        return;
      let r3 = t4.getSource();
      if (r3 && r3.vectorLayerIds)
        for (let e54 in this._layers) {
          let t5 = this._layers[e54];
          t5.source === r3.id && this._validateLayer(t5);
        }
    });
  }
  loadURL(e53, t3 = {}, r) {
    this.fire(new z("dataloading", { dataType: "style" })), t3.validate = "boolean" != typeof t3.validate || t3.validate;
    let i = this.map._requestManager.transformRequest(e53, "Style");
    this._request = fr(i, (e54, i3) => {
      this._request = null, e54 ? this.fire(new Z(e54)) : i3 && this._load(i3, t3, r);
    });
  }
  loadJSON(e53, t3 = {}, r) {
    this.fire(new z("dataloading", { dataType: "style" })), this._request = ne.frame(() => {
      this._request = null, t3.validate = false !== t3.validate, this._load(e53, t3, r);
    });
  }
  loadEmpty() {
    this.fire(new z("dataloading", { dataType: "style" })), this._load(_C, { validate: false });
  }
  _load(e53, t3, r) {
    let i = t3.transformStyle ? t3.transformStyle(r, e53) : e53;
    if (!t3.validate || !Rl(this, qe(i))) {
      this._loaded = true, this.stylesheet = i;
      for (let e54 in i.sources)
        this.addSource(e54, i.sources[e54], { validate: false });
      i.sprite ? this._loadSprite(i.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(i.glyphs), this._createLayers(), this.light = new cl(this.stylesheet.light), this.map.setTerrain(this.stylesheet.terrain), this.fire(new z("data", { dataType: "style" })), this.fire(new z("style.load"));
    }
  }
  _createLayers() {
    let e53 = Kc(this.stylesheet.layers);
    this.dispatcher.broadcast("setLayers", e53), this._order = e53.map((e54) => e54.id), this._layers = {}, this._serializedLayers = null;
    for (let t3 of e53) {
      let e54 = ol(t3);
      e54.setEventedParent(this, { layer: { id: t3.id } }), this._layers[t3.id] = e54;
    }
  }
  _loadSprite(e53, t3 = false, r) {
    this.imageManager.setLoaded(false), this._spriteRequest = I_(e53, this.map._requestManager, this.map.getPixelRatio(), (e54, i) => {
      if (this._spriteRequest = null, e54)
        this.fire(new Z(e54));
      else if (i)
        for (let e55 in i) {
          this._spritesImagesIds[e55] = [];
          let r3 = this._spritesImagesIds[e55] ? this._spritesImagesIds[e55].filter((e56) => !(e56 in i)) : [];
          for (let e56 of r3)
            this.imageManager.removeImage(e56), this._changedImages[e56] = true;
          for (let r4 in i[e55]) {
            let a = "default" === e55 ? r4 : "".concat(e55, ":").concat(r4);
            this._spritesImagesIds[e55].push(a), a in this.imageManager.images ? this.imageManager.updateImage(a, i[e55][r4], false) : this.imageManager.addImage(a, i[e55][r4]), t3 && (this._changedImages[a] = true);
          }
        }
      this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), t3 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new z("data", { dataType: "style" })), r && r(e54);
    });
  }
  _unloadSprite() {
    for (let e53 of Object.values(this._spritesImagesIds).flat())
      this.imageManager.removeImage(e53), this._changedImages[e53] = true;
    this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new z("data", { dataType: "style" }));
  }
  _validateLayer(e53) {
    let t3 = this.sourceCaches[e53.source];
    if (!t3)
      return;
    let r = e53.sourceLayer;
    if (!r)
      return;
    let i = t3.getSource();
    ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(r)) && this.fire(new Z(new Error('Source layer "'.concat(r, '" ') + 'does not exist on source "'.concat(i.id, '" ') + 'as specified by style layer "'.concat(e53.id, '".'))));
  }
  loaded() {
    if (!this._loaded || Object.keys(this._updatedSources).length)
      return false;
    for (let e53 in this.sourceCaches)
      if (!this.sourceCaches[e53].loaded())
        return false;
    return !!this.imageManager.isLoaded();
  }
  _serializeByIds(e53) {
    let t3 = this._serializedAllLayers();
    if (!e53 || 0 === e53.length)
      return Object.values(t3);
    let r = [];
    for (let i of e53)
      t3[i] && r.push(t3[i]);
    return r;
  }
  _serializedAllLayers() {
    let e53 = this._serializedLayers;
    if (e53)
      return e53;
    e53 = this._serializedLayers = {};
    let t3 = Object.keys(this._layers);
    for (let r of t3) {
      let t4 = this._layers[r];
      "custom" !== t4.type && (e53[r] = t4.serialize());
    }
    return e53;
  }
  hasTransitions() {
    if (this.light && this.light.hasTransition())
      return true;
    for (let e53 in this.sourceCaches)
      if (this.sourceCaches[e53].hasTransition())
        return true;
    for (let e53 in this._layers)
      if (this._layers[e53].hasTransition())
        return true;
    return false;
  }
  _checkLoaded() {
    if (!this._loaded)
      throw new Error("Style is not done loading.");
  }
  update(e53) {
    if (!this._loaded)
      return;
    let t3 = this._changed;
    if (this._changed) {
      let t4 = Object.keys(this._updatedLayers), r3 = Object.keys(this._removedLayers);
      (t4.length || r3.length) && this._updateWorkerLayers(t4, r3);
      for (let e54 in this._updatedSources) {
        let t5 = this._updatedSources[e54];
        if ("reload" === t5)
          this._reloadSource(e54);
        else {
          if ("clear" !== t5)
            throw new Error("Invalid action ".concat(t5));
          this._clearSource(e54);
        }
      }
      this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
      for (let t5 in this._updatedPaintProps)
        this._layers[t5].updateTransitions(e53);
      this.light.updateTransitions(e53), this._resetUpdates();
    }
    let r = {};
    for (let e54 in this.sourceCaches) {
      let t4 = this.sourceCaches[e54];
      r[e54] = t4.used, t4.used = false;
    }
    for (let t4 of this._order) {
      let r3 = this._layers[t4];
      r3.recalculate(e53, this._availableImages), !r3.isHidden(e53.zoom) && r3.source && (this.sourceCaches[r3.source].used = true);
    }
    for (let e54 in r) {
      let t4 = this.sourceCaches[e54];
      r[e54] !== t4.used && t4.fire(new z("data", { sourceDataType: "visibility", dataType: "source", sourceId: e54 }));
    }
    this.light.recalculate(e53), this.z = e53.zoom, t3 && this.fire(new z("data", { dataType: "style" }));
  }
  _updateTilesForChangedImages() {
    let e53 = Object.keys(this._changedImages);
    if (e53.length) {
      for (let t3 in this.sourceCaches)
        this.sourceCaches[t3].reloadTilesForDependencies(["icons", "patterns"], e53);
      this._changedImages = {};
    }
  }
  _updateTilesForChangedGlyphs() {
    if (this._glyphsDidChange) {
      for (let e53 in this.sourceCaches)
        this.sourceCaches[e53].reloadTilesForDependencies(["glyphs"], [""]);
      this._glyphsDidChange = false;
    }
  }
  _updateWorkerLayers(e53, t3) {
    this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(e53), removedIds: t3 });
  }
  _resetUpdates() {
    this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
  }
  setState(e53, t3 = {}) {
    this._checkLoaded();
    let r = this.serialize();
    if (e53 = t3.transformStyle ? t3.transformStyle(r, e53) : e53, Rl(this, qe(e53)))
      return false;
    (e53 = ut(e53)).layers = Kc(e53.layers);
    let i = Ig(r, e53).filter((e54) => !(e54.command in bC));
    if (0 === i.length)
      return false;
    let a = i.filter((e54) => !(e54.command in xC));
    if (a.length > 0)
      throw new Error("Unimplemented: ".concat(a.map((e54) => e54.command).join(", "), "."));
    for (let e54 of i)
      "setTransition" !== e54.command && this[e54.command].apply(this, e54.args);
    return this.stylesheet = e53, true;
  }
  addImage(e53, t3) {
    if (this.getImage(e53))
      return this.fire(new Z(new Error('An image named "'.concat(e53, '" already exists.'))));
    this.imageManager.addImage(e53, t3), this._afterImageUpdated(e53);
  }
  updateImage(e53, t3) {
    this.imageManager.updateImage(e53, t3);
  }
  getImage(e53) {
    return this.imageManager.getImage(e53);
  }
  removeImage(e53) {
    if (!this.getImage(e53))
      return this.fire(new Z(new Error('An image named "'.concat(e53, '" does not exist.'))));
    this.imageManager.removeImage(e53), this._afterImageUpdated(e53);
  }
  _afterImageUpdated(e53) {
    this._availableImages = this.imageManager.listImages(), this._changedImages[e53] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new z("data", { dataType: "style" }));
  }
  listImages() {
    return this._checkLoaded(), this.imageManager.listImages();
  }
  addSource(e53, t3, r = {}) {
    if (this._checkLoaded(), void 0 !== this.sourceCaches[e53])
      throw new Error('Source "'.concat(e53, '" already exists.'));
    if (!t3.type)
      throw new Error("The type property must be defined, but only the following properties were given: ".concat(Object.keys(t3).join(", "), "."));
    if (["vector", "raster", "geojson", "video", "image"].indexOf(t3.type) >= 0 && this._validate(qe.source, "sources.".concat(e53), t3, null, r))
      return;
    this.map && this.map._collectResourceTiming && (t3.collectResourceTiming = true);
    let i = this.sourceCaches[e53] = new or(e53, t3, this.dispatcher);
    i.style = this, i.setEventedParent(this, () => ({ isSourceLoaded: i.loaded(), source: i.serialize(), sourceId: e53 })), i.onAdd(this.map), this._changed = true;
  }
  removeSource(e53) {
    if (this._checkLoaded(), void 0 === this.sourceCaches[e53])
      throw new Error("There is no source with this ID");
    for (let t4 in this._layers)
      if (this._layers[t4].source === e53)
        return this.fire(new Z(new Error('Source "'.concat(e53, '" cannot be removed while layer "').concat(t4, '" is using it.'))));
    let t3 = this.sourceCaches[e53];
    delete this.sourceCaches[e53], delete this._updatedSources[e53], t3.fire(new z("data", { sourceDataType: "metadata", dataType: "source", sourceId: e53 })), t3.setEventedParent(null), t3.onRemove(this.map), this._changed = true;
  }
  setGeoJSONSourceData(e53, t3) {
    if (this._checkLoaded(), void 0 === this.sourceCaches[e53])
      throw new Error("There is no source with this ID=".concat(e53));
    let r = this.sourceCaches[e53].getSource();
    if ("geojson" !== r.type)
      throw new Error("geojsonSource.type is ".concat(r.type, ", which is !== 'geojson"));
    r.setData(t3), this._changed = true;
  }
  getSource(e53) {
    return this.sourceCaches[e53] && this.sourceCaches[e53].getSource();
  }
  addLayer(e53, t3, r = {}) {
    this._checkLoaded();
    let i, a = e53.id;
    if (this.getLayer(a))
      return void this.fire(new Z(new Error('Layer "'.concat(a, '" already exists on this map.'))));
    if ("custom" === e53.type) {
      if (Rl(this, T_(e53)))
        return;
      i = ol(e53);
    } else {
      if ("object" == typeof e53.source && (this.addSource(a, e53.source), e53 = R(e53 = ut(e53), { source: a })), this._validate(qe.layer, "layers.".concat(a), e53, { arrayIndex: -1 }, r))
        return;
      i = ol(e53), this._validateLayer(i), i.setEventedParent(this, { layer: { id: a } });
    }
    let n = t3 ? this._order.indexOf(t3) : this._order.length;
    if (t3 && -1 === n)
      this.fire(new Z(new Error('Cannot add layer "'.concat(a, '" before non-existing layer "').concat(t3, '".'))));
    else {
      if (this._order.splice(n, 0, a), this._layerOrderChanged = true, this._layers[a] = i, this._removedLayers[a] && i.source && "custom" !== i.type) {
        let e54 = this._removedLayers[a];
        delete this._removedLayers[a], e54.type !== i.type ? this._updatedSources[i.source] = "clear" : (this._updatedSources[i.source] = "reload", this.sourceCaches[i.source].pause());
      }
      this._updateLayer(i), i.onAdd && i.onAdd(this.map);
    }
  }
  moveLayer(e53, t3) {
    if (this._checkLoaded(), this._changed = true, !this._layers[e53])
      return void this.fire(new Z(new Error("The layer '".concat(e53, "' does not exist in the map's style and cannot be moved."))));
    if (e53 === t3)
      return;
    let r = this._order.indexOf(e53);
    this._order.splice(r, 1);
    let i = t3 ? this._order.indexOf(t3) : this._order.length;
    t3 && -1 === i ? this.fire(new Z(new Error('Cannot move layer "'.concat(e53, '" before non-existing layer "').concat(t3, '".')))) : (this._order.splice(i, 0, e53), this._layerOrderChanged = true);
  }
  removeLayer(e53) {
    this._checkLoaded();
    let t3 = this._layers[e53];
    if (!t3)
      return void this.fire(new Z(new Error('Cannot remove non-existing layer "'.concat(e53, '".'))));
    t3.setEventedParent(null);
    let r = this._order.indexOf(e53);
    this._order.splice(r, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e53] = t3, delete this._layers[e53], this._serializedLayers && delete this._serializedLayers[e53], delete this._updatedLayers[e53], delete this._updatedPaintProps[e53], t3.onRemove && t3.onRemove(this.map);
  }
  getLayer(e53) {
    return this._layers[e53];
  }
  hasLayer(e53) {
    return e53 in this._layers;
  }
  setLayerZoomRange(e53, t3, r) {
    this._checkLoaded();
    let i = this.getLayer(e53);
    i ? i.minzoom === t3 && i.maxzoom === r || (null != t3 && (i.minzoom = t3), null != r && (i.maxzoom = r), this._updateLayer(i)) : this.fire(new Z(new Error('Cannot set the zoom range of non-existing layer "'.concat(e53, '".'))));
  }
  setFilter(e53, t3, r = {}) {
    this._checkLoaded();
    let i = this.getLayer(e53);
    if (i) {
      if (!Kt(i.filter, t3)) {
        if (null == t3)
          return i.filter = void 0, void this._updateLayer(i);
        this._validate(qe.filter, "layers.".concat(i.id, ".filter"), t3, null, r) || (i.filter = ut(t3), this._updateLayer(i));
      }
    } else
      this.fire(new Z(new Error('Cannot filter non-existing layer "'.concat(e53, '".'))));
  }
  getFilter(e53) {
    return ut(this.getLayer(e53).filter);
  }
  setLayoutProperty(e53, t3, r, i = {}) {
    this._checkLoaded();
    let a = this.getLayer(e53);
    a ? Kt(a.getLayoutProperty(t3), r) || (a.setLayoutProperty(t3, r, i), this._updateLayer(a)) : this.fire(new Z(new Error('Cannot style non-existing layer "'.concat(e53, '".'))));
  }
  getLayoutProperty(e53, t3) {
    let r = this.getLayer(e53);
    if (r)
      return r.getLayoutProperty(t3);
    this.fire(new Z(new Error('Cannot get style of non-existing layer "'.concat(e53, '".'))));
  }
  setPaintProperty(e53, t3, r, i = {}) {
    this._checkLoaded();
    let a = this.getLayer(e53);
    a ? Kt(a.getPaintProperty(t3), r) || (a.setPaintProperty(t3, r, i) && this._updateLayer(a), this._changed = true, this._updatedPaintProps[e53] = true) : this.fire(new Z(new Error('Cannot style non-existing layer "'.concat(e53, '".'))));
  }
  getPaintProperty(e53, t3) {
    return this.getLayer(e53).getPaintProperty(t3);
  }
  setFeatureState(e53, t3) {
    this._checkLoaded();
    let r = e53.source, i = e53.sourceLayer, a = this.sourceCaches[r];
    if (void 0 === a)
      return void this.fire(new Z(new Error("The source '".concat(r, "' does not exist in the map's style."))));
    let n = a.getSource().type;
    "geojson" === n && i ? this.fire(new Z(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n || i ? (void 0 === e53.id && this.fire(new Z(new Error("The feature id parameter must be provided."))), a.setFeatureState(i, e53.id, t3)) : this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
  }
  removeFeatureState(e53, t3) {
    this._checkLoaded();
    let r = e53.source, i = this.sourceCaches[r];
    if (void 0 === i)
      return void this.fire(new Z(new Error("The source '".concat(r, "' does not exist in the map's style."))));
    let a = i.getSource().type, n = "vector" === a ? e53.sourceLayer : void 0;
    "vector" !== a || n ? t3 && "string" != typeof e53.id && "number" != typeof e53.id ? this.fire(new Z(new Error("A feature id is required to remove its specific state property."))) : i.removeFeatureState(n, e53.id, t3) : this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
  }
  getFeatureState(e53) {
    this._checkLoaded();
    let t3 = e53.source, r = e53.sourceLayer, i = this.sourceCaches[t3];
    if (void 0 !== i) {
      if ("vector" !== i.getSource().type || r)
        return void 0 === e53.id && this.fire(new Z(new Error("The feature id parameter must be provided."))), i.getFeatureState(r, e53.id);
      this.fire(new Z(new Error("The sourceLayer parameter must be provided for vector source types.")));
    } else
      this.fire(new Z(new Error("The source '".concat(t3, "' does not exist in the map's style."))));
  }
  getTransition() {
    return R({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
  }
  serialize() {
    if (!this._loaded)
      return;
    let e53 = Tn(this.sourceCaches, (e54) => e54.serialize()), t3 = this._serializeByIds(this._order), r = this.stylesheet;
    return mo({ version: r.version, name: r.name, metadata: r.metadata, light: r.light, center: r.center, zoom: r.zoom, bearing: r.bearing, pitch: r.pitch, sprite: r.sprite, glyphs: r.glyphs, transition: r.transition, sources: e53, layers: t3 }, (e54) => void 0 !== e54);
  }
  _updateLayer(e53) {
    this._updatedLayers[e53.id] = true, e53.source && !this._updatedSources[e53.source] && "raster" !== this.sourceCaches[e53.source].getSource().type && (this._updatedSources[e53.source] = "reload", this.sourceCaches[e53.source].pause()), this._serializedLayers = null, this._changed = true;
  }
  _flattenAndSortRenderedFeatures(e53) {
    let t3 = q((e54) => "fill-extrusion" === this._layers[e54].type, "isLayer3D"), r = {}, i = [];
    for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
      let n = this._order[a3];
      if (t3(n)) {
        r[n] = a3;
        for (let t4 of e53) {
          let e54 = t4[n];
          if (e54)
            for (let t5 of e54)
              i.push(t5);
        }
      }
    }
    i.sort((e54, t4) => t4.intersectionZ - e54.intersectionZ);
    let a = [];
    for (let n = this._order.length - 1; n >= 0; n--) {
      let s3 = this._order[n];
      if (t3(s3))
        for (let e54 = i.length - 1; e54 >= 0; e54--) {
          let t4 = i[e54].feature;
          if (r[t4.layer.id] < n)
            break;
          a.push(t4), i.pop();
        }
      else
        for (let t4 of e53) {
          let e54 = t4[s3];
          if (e54)
            for (let t5 of e54)
              a.push(t5.feature);
        }
    }
    return a;
  }
  queryRenderedFeatures(e53, t3, r) {
    t3 && t3.filter && this._validate(qe.filter, "queryRenderedFeatures.filter", t3.filter, null, t3);
    let i = {};
    if (t3 && t3.layers) {
      if (!Array.isArray(t3.layers))
        return this.fire(new Z(new Error("parameters.layers must be an Array."))), [];
      for (let e54 of t3.layers) {
        let t4 = this._layers[e54];
        if (!t4)
          return this.fire(new Z(new Error("The layer '".concat(e54, "' does not exist in the map's style and cannot be queried for features.")))), [];
        i[t4.source] = true;
      }
    }
    let a = [];
    t3.availableImages = this._availableImages;
    let n = this._serializedAllLayers();
    for (let s3 in this.sourceCaches)
      t3.layers && !i[s3] || a.push(G_(this.sourceCaches[s3], this._layers, n, e53, t3, r));
    return this.placement && a.push(q_(this._layers, n, this.sourceCaches, e53, t3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a);
  }
  querySourceFeatures(e53, t3) {
    t3 && t3.filter && this._validate(qe.filter, "querySourceFeatures.filter", t3.filter, null, t3);
    let r = this.sourceCaches[e53];
    return r ? j_(r, t3) : [];
  }
  addSourceType(e53, t3, r) {
    return fm(e53) ? r(new Error('A source type called "'.concat(e53, '" already exists.'))) : (N_(e53, t3), t3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e53, url: t3.workerSourceURL }, r) : r(null, null));
  }
  getLight() {
    return this.light.getLight();
  }
  setLight(e53, t3 = {}) {
    this._checkLoaded();
    let r = this.light.getLight(), i = false;
    for (let t4 in e53)
      if (!Kt(e53[t4], r[t4])) {
        i = true;
        break;
      }
    if (!i)
      return;
    let a = { now: ne.now(), transition: R({ duration: 300, delay: 0 }, this.stylesheet.transition) };
    this.light.setLight(e53, t3), this.light.updateTransitions(a);
  }
  _validate(e53, t3, r, i, a = {}) {
    return (!a || false !== a.validate) && Rl(this, e53.call(qe, R({ key: t3, style: this.serialize(), value: r, styleSpec: M }, i)));
  }
  _remove(e53 = true) {
    this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), us.off("pluginStateChange", this._rtlTextPluginCallback);
    for (let e54 in this._layers)
      this._layers[e54].setEventedParent(null);
    for (let e54 in this.sourceCaches) {
      let t3 = this.sourceCaches[e54];
      t3.setEventedParent(null), t3.onRemove(this.map);
    }
    this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e53);
  }
  _clearSource(e53) {
    this.sourceCaches[e53].clearTiles();
  }
  _reloadSource(e53) {
    this.sourceCaches[e53].resume(), this.sourceCaches[e53].reload();
  }
  _updateSources(e53) {
    for (let t3 in this.sourceCaches)
      this.sourceCaches[t3].update(e53, this.map.terrain);
  }
  _generateCollisionBoxes() {
    for (let e53 in this.sourceCaches)
      this._reloadSource(e53);
  }
  _updatePlacement(e53, t3, r, i, a = false) {
    let n = false, s3 = false, o = {};
    for (let t4 of this._order) {
      let r3 = this._layers[t4];
      if ("symbol" !== r3.type)
        continue;
      if (!o[r3.source]) {
        let e54 = this.sourceCaches[r3.source];
        o[r3.source] = e54.getRenderableIds(true).map((t5) => e54.getTileByID(t5)).sort((e55, t5) => t5.tileID.overscaledZ - e55.tileID.overscaledZ || (e55.tileID.isLessThan(t5.tileID) ? -1 : 1));
      }
      let i3 = this.crossTileSymbolIndex.addLayer(r3, o[r3.source], e53.center.lng);
      n = n || i3;
    }
    if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || 0 === r) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(ne.now(), e53.zoom)) && (this.pauseablePlacement = new Fl(e53, this.map.terrain, this._order, a, t3, r, i, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, o), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(ne.now()), s3 = true), n && this.pauseablePlacement.placement.setStale()), s3 || n)
      for (let e54 of this._order) {
        let t4 = this._layers[e54];
        "symbol" === t4.type && this.placement.updateLayerOpacities(t4, o[t4.source]);
      }
    return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(ne.now());
  }
  _releaseSymbolFadeTiles() {
    for (let e53 in this.sourceCaches)
      this.sourceCaches[e53].releaseSymbolFadeTiles();
  }
  getImages(e53, t3, r) {
    this.imageManager.getImages(t3.icons, r), this._updateTilesForChangedImages();
    let i = this.sourceCaches[t3.source];
    i && i.setDependencies(t3.tileID.key, t3.type, t3.icons);
  }
  getGlyphs(e53, t3, r) {
    this.glyphManager.getGlyphs(t3.stacks, r);
    let i = this.sourceCaches[t3.source];
    i && i.setDependencies(t3.tileID.key, t3.type, [""]);
  }
  getResource(e53, t3, r) {
    return wi(t3, r);
  }
  getGlyphsUrl() {
    return this.stylesheet.glyphs || null;
  }
  setGlyphs(e53, t3 = {}) {
    this._checkLoaded(), (!e53 || !this._validate(qe.glyphs, "glyphs", e53, null, t3)) && (this._glyphsDidChange = true, this.stylesheet.glyphs = e53, this.glyphManager.entries = {}, this.glyphManager.setURL(e53));
  }
  addSprite(e53, t3, r = {}, i) {
    this._checkLoaded();
    let a = [{ id: e53, url: t3 }], n = [...an(this.stylesheet.sprite), ...a];
    this._validate(qe.sprite, "sprite", n, null, r) || (this.stylesheet.sprite = n, this._loadSprite(a, true, i));
  }
  removeSprite(e53) {
    this._checkLoaded();
    let t3 = an(this.stylesheet.sprite);
    if (t3.find((t4) => t4.id === e53)) {
      if (this._spritesImagesIds[e53])
        for (let t4 of this._spritesImagesIds[e53])
          this.imageManager.removeImage(t4), this._changedImages[t4] = true;
      t3.splice(t3.findIndex((t4) => t4.id === e53), 1), this.stylesheet.sprite = t3.length > 0 ? t3 : void 0, delete this._spritesImagesIds[e53], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new z("data", { dataType: "style" }));
    } else
      this.fire(new Z(new Error('Sprite "'.concat(e53, `" doesn't exists on this map.`))));
  }
  getSprite() {
    return an(this.stylesheet.sprite);
  }
  setSprite(e53, t3 = {}, r) {
    this._checkLoaded(), (!e53 || !this._validate(qe.sprite, "sprite", e53, null, t3)) && (this.stylesheet.sprite = e53, e53 ? this._loadSprite(e53, true, r) : (this._unloadSprite(), r && r(null)));
  }
};
q(Ol, "Style");
var Br = Ol;
Br.registerForPluginStateChange = mx, c(), c();
var Vl = ve([{ name: "a_pos", type: "Int16", components: 2 }]);
c(), c();
var mv = "#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n";
c();
var dv = "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}";
c();
var yv = "uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var gv = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
c();
var xv = "uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var bv = "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}";
c();
var _v = "varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var vv = "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}";
c();
var wv = "void main() {gl_FragColor=vec4(1.0);}";
c();
var Sv = "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}";
c();
var Pv = "uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Tv = "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}";
c();
var Av = "uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}";
c();
var Iv = "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}";
c();
var Mv = "varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}";
c();
var Cv = "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}";
c();
var Ev = "varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}";
c();
var kv = "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}";
c();
var Lv = "uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}";
c();
var Dv = "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}";
c();
var zv = "#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Fv = "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}";
c();
var Bv = "varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Rv = "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";
c();
var Ov = "uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Vv = "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}";
c();
var Uv = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Nv = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}";
c();
var Gv = "varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var qv = "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}";
c();
var jv = "uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var $v = "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}";
c();
var Hv = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Zv = "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}";
c();
var Wv = "uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Xv = "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}";
c();
var Kv = "uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Yv = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}";
c();
var Jv = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var Qv = "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}";
c();
var e0 = "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var t0 = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}";
c();
var r0 = "uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var i0 = "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}";
c();
var n0 = "uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var a0 = "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}";
c();
var o0 = "uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var s0 = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}";
c();
var l0 = "#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var u0 = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}";
c();
var c0 = "#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}";
c();
var p0 = "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}";
c();
var h0 = "varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}";
c();
var f0 = "precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}";
c();
var m0 = "uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}";
c();
var Ul = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
var xi = { prelude: Le(mv, dv), background: Le(yv, gv), backgroundPattern: Le(xv, bv), circle: Le(_v, vv), clippingMask: Le(wv, Sv), heatmap: Le(Pv, Tv), heatmapTexture: Le(Av, Iv), collisionBox: Le(Mv, Cv), collisionCircle: Le(Ev, kv), debug: Le(Lv, Dv), fill: Le(zv, Fv), fillOutline: Le(Bv, Rv), fillOutlinePattern: Le(Ov, Vv), fillPattern: Le(Uv, Nv), fillExtrusion: Le(Gv, qv), fillExtrusionPattern: Le(jv, $v), hillshadePrepare: Le(Hv, Zv), hillshade: Le(Wv, Xv), line: Le(Kv, Yv), lineGradient: Le(Jv, Qv), linePattern: Le(e0, t0), lineSDF: Le(r0, i0), raster: Le(n0, a0), symbolIcon: Le(o0, s0), symbolSDF: Le(l0, u0), symbolTextAndIcon: Le(c0, p0), terrain: Le(m0, Ul), terrainDepth: Le(h0, Ul), terrainCoords: Le(f0, Ul) };
function Le(e53, t3) {
  let r = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, i = t3.match(/attribute ([\w]+) ([\w]+)/g), a = e53.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), n = t3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s3 = n ? n.concat(a) : a, o = {};
  return { fragmentSource: e53 = e53.replace(r, (e54, t4, r3, i3, a3) => (o[a3] = true, "define" === t4 ? "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\nvarying ").concat(r3, " ").concat(i3, " ").concat(a3, ";\n#else\nuniform ").concat(r3, " ").concat(i3, " u_").concat(a3, ";\n#endif\n") : "\n#ifdef HAS_UNIFORM_u_".concat(a3, "\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = u_").concat(a3, ";\n#endif\n"))), vertexSource: t3 = t3.replace(r, (e54, t4, r3, i3, a3) => {
    let n3 = "float" === i3 ? "vec2" : "vec4", s4 = a3.match(/color/) ? "color" : n3;
    return o[a3] ? "define" === t4 ? "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\nuniform lowp float u_").concat(a3, "_t;\nattribute ").concat(r3, " ").concat(n3, " a_").concat(a3, ";\nvarying ").concat(r3, " ").concat(i3, " ").concat(a3, ";\n#else\nuniform ").concat(r3, " ").concat(i3, " u_").concat(a3, ";\n#endif\n") : "vec4" === s4 ? "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\n    ").concat(a3, " = a_").concat(a3, ";\n#else\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = u_").concat(a3, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\n    ").concat(a3, " = unpack_mix_").concat(s4, "(a_").concat(a3, ", u_").concat(a3, "_t);\n#else\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = u_").concat(a3, ";\n#endif\n") : "define" === t4 ? "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\nuniform lowp float u_").concat(a3, "_t;\nattribute ").concat(r3, " ").concat(n3, " a_").concat(a3, ";\n#else\nuniform ").concat(r3, " ").concat(i3, " u_").concat(a3, ";\n#endif\n") : "vec4" === s4 ? "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = a_").concat(a3, ";\n#else\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = u_").concat(a3, ";\n#endif\n") : "\n#ifndef HAS_UNIFORM_u_".concat(a3, "\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = unpack_mix_").concat(s4, "(a_").concat(a3, ", u_").concat(a3, "_t);\n#else\n    ").concat(r3, " ").concat(i3, " ").concat(a3, " = u_").concat(a3, ";\n#endif\n");
  }), staticAttributes: i, staticUniforms: s3 };
}
q(Le, "compile"), c(), c();
var td = class {
  constructor() {
    this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
  }
  bind(e53, t3, r, i, a, n, s3, o, l) {
    this.context = e53;
    let u3 = this.boundPaintVertexBuffers.length !== i.length;
    for (let e54 = 0; !u3 && e54 < i.length; e54++)
      this.boundPaintVertexBuffers[e54] !== i[e54] && (u3 = true);
    !this.vao || this.boundProgram !== t3 || this.boundLayoutVertexBuffer !== r || u3 || this.boundIndexBuffer !== a || this.boundVertexOffset !== n || this.boundDynamicVertexBuffer !== s3 || this.boundDynamicVertexBuffer2 !== o || this.boundDynamicVertexBuffer3 !== l ? this.freshBind(t3, r, i, a, n, s3, o, l) : (e53.bindVertexArray.set(this.vao), s3 && s3.bind(), a && a.dynamicDraw && a.bind(), o && o.bind(), l && l.bind());
  }
  freshBind(e53, t3, r, i, a, n, s3, o) {
    let l = e53.numAttributes, u3 = this.context, c3 = u3.gl;
    this.vao && this.destroy(), this.vao = u3.createVertexArray(), u3.bindVertexArray.set(this.vao), this.boundProgram = e53, this.boundLayoutVertexBuffer = t3, this.boundPaintVertexBuffers = r, this.boundIndexBuffer = i, this.boundVertexOffset = a, this.boundDynamicVertexBuffer = n, this.boundDynamicVertexBuffer2 = s3, this.boundDynamicVertexBuffer3 = o, t3.enableAttributes(c3, e53);
    for (let t4 of r)
      t4.enableAttributes(c3, e53);
    n && n.enableAttributes(c3, e53), s3 && s3.enableAttributes(c3, e53), o && o.enableAttributes(c3, e53), t3.bind(), t3.setVertexAttribPointers(c3, e53, a);
    for (let t4 of r)
      t4.bind(), t4.setVertexAttribPointers(c3, e53, a);
    n && (n.bind(), n.setVertexAttribPointers(c3, e53, a)), i && i.bind(), s3 && (s3.bind(), s3.setVertexAttribPointers(c3, e53, a)), o && (o.bind(), o.setVertexAttribPointers(c3, e53, a)), u3.currentNumAttributes = l;
  }
  destroy() {
    this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
  }
};
q(td, "VertexArrayObject");
var Nl = td;
c();
var d0 = q((e53, t3) => ({ u_depth: new Y(e53, t3.u_depth), u_terrain: new Y(e53, t3.u_terrain), u_terrain_dim: new U(e53, t3.u_terrain_dim), u_terrain_matrix: new te(e53, t3.u_terrain_matrix), u_terrain_unpack: new Ar(e53, t3.u_terrain_unpack), u_terrain_exaggeration: new U(e53, t3.u_terrain_exaggeration) }), "terrainPreludeUniforms");
var y0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_texture: new Y(e53, t3.u_texture), u_ele_delta: new U(e53, t3.u_ele_delta) }), "terrainUniforms");
var g0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_ele_delta: new U(e53, t3.u_ele_delta) }), "terrainDepthUniforms");
var x0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_texture: new Y(e53, t3.u_texture), u_terrain_coords_id: new U(e53, t3.u_terrain_coords_id), u_ele_delta: new U(e53, t3.u_ele_delta) }), "terrainCoordsUniforms");
var b0 = q((e53, t3) => ({ u_matrix: e53, u_texture: 0, u_ele_delta: t3 }), "terrainUniformValues");
var _0 = q((e53, t3) => ({ u_matrix: e53, u_ele_delta: t3 }), "terrainDepthUniformValues");
var v0 = q((e53, t3, r) => ({ u_matrix: e53, u_terrain_coords_id: t3 / 255, u_texture: 0, u_ele_delta: r }), "terrainCoordsUniformValues");
function rd(e53) {
  let t3 = [];
  for (let r = 0; r < e53.length; r++) {
    if (null === e53[r])
      continue;
    let i = e53[r].split(" ");
    t3.push(i.pop());
  }
  return t3;
}
q(rd, "getTokenizedAttributesAndUniforms");
var id = class {
  constructor(e53, t3, r, i, a, n) {
    let s3 = e53.gl;
    this.program = s3.createProgram();
    let o = rd(t3.staticAttributes), l = r ? r.getBinderAttributes() : [], u3 = o.concat(l), c3 = xi.prelude.staticUniforms ? rd(xi.prelude.staticUniforms) : [], h = t3.staticUniforms ? rd(t3.staticUniforms) : [], p = r ? r.getBinderUniforms() : [], d = c3.concat(h).concat(p), f = [];
    for (let e54 of d)
      f.indexOf(e54) < 0 && f.push(e54);
    let m = r ? r.defines() : [];
    a && m.push("#define OVERDRAW_INSPECTOR;"), n && m.push("#define TERRAIN3D;");
    let y = m.concat(xi.prelude.fragmentSource, t3.fragmentSource).join("\n"), g = m.concat(xi.prelude.vertexSource, t3.vertexSource).join("\n"), _ = s3.createShader(s3.FRAGMENT_SHADER);
    if (s3.isContextLost())
      return void (this.failedToCreate = true);
    s3.shaderSource(_, y), s3.compileShader(_), s3.attachShader(this.program, _);
    let x = s3.createShader(s3.VERTEX_SHADER);
    if (s3.isContextLost())
      return void (this.failedToCreate = true);
    s3.shaderSource(x, g), s3.compileShader(x), s3.attachShader(this.program, x), this.attributes = {};
    let v = {};
    this.numAttributes = u3.length;
    for (let e54 = 0; e54 < this.numAttributes; e54++)
      u3[e54] && (s3.bindAttribLocation(this.program, e54, u3[e54]), this.attributes[u3[e54]] = e54);
    s3.linkProgram(this.program), s3.deleteShader(x), s3.deleteShader(_);
    for (let e54 = 0; e54 < f.length; e54++) {
      let t4 = f[e54];
      if (t4 && !v[t4]) {
        let e55 = s3.getUniformLocation(this.program, t4);
        e55 && (v[t4] = e55);
      }
    }
    this.fixedUniforms = i(e53, v), this.terrainUniforms = d0(e53, v), this.binderUniforms = r ? r.getUniforms(e53, v) : [];
  }
  draw(e53, t3, r, i, a, n, s3, o, l, u3, c3, h, p, d, f, m, y, g) {
    let _ = e53.gl;
    if (this.failedToCreate)
      return;
    e53.program.set(this.program), e53.setDepthMode(r), e53.setStencilMode(i), e53.setColorMode(a), e53.setCullFace(n);
    for (let e54 in this.fixedUniforms)
      this.fixedUniforms[e54].set(s3[e54]);
    f && f.setUniforms(e53, this.binderUniforms, p, { zoom: d });
    let x = 0;
    switch (t3) {
      case _.LINES:
        x = 2;
        break;
      case _.TRIANGLES:
        x = 3;
        break;
      case _.LINE_STRIP:
        x = 1;
    }
    for (let r3 of h.get()) {
      let i3 = r3.vaos || (r3.vaos = {});
      (i3[l] || (i3[l] = new Nl())).bind(e53, this, u3, f ? f.getPaintVertexBuffers() : [], c3, r3.vertexOffset, m, y, g), _.drawElements(t3, r3.primitiveLength * x, _.UNSIGNED_SHORT, r3.primitiveOffset * x * 2);
    }
  }
};
q(id, "Program");
var Gl = id;
function ql(e53, t3, r) {
  let i = 1 / Ke(r, 1, t3.transform.tileZoom), a = Math.pow(2, r.tileID.overscaledZ), n = r.tileSize * Math.pow(2, t3.transform.tileZoom) / a, s3 = n * (r.tileID.canonical.x + r.tileID.wrap * a), o = n * r.tileID.canonical.y;
  return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [i, e53.fromScale, e53.toScale], u_fade: e53.t, u_pixel_coord_upper: [s3 >> 16, o >> 16], u_pixel_coord_lower: [65535 & s3, 65535 & o] };
}
function w0(e53, t3, r, i) {
  let a = r.imageManager.getPattern(e53.from.toString()), n = r.imageManager.getPattern(e53.to.toString()), { width: s3, height: o } = r.imageManager.getPixelSize(), l = Math.pow(2, i.tileID.overscaledZ), u3 = i.tileSize * Math.pow(2, r.transform.tileZoom) / l, c3 = u3 * (i.tileID.canonical.x + i.tileID.wrap * l), h = u3 * i.tileID.canonical.y;
  return { u_image: 0, u_pattern_tl_a: a.tl, u_pattern_br_a: a.br, u_pattern_tl_b: n.tl, u_pattern_br_b: n.br, u_texsize: [s3, o], u_mix: t3.t, u_pattern_size_a: a.displaySize, u_pattern_size_b: n.displaySize, u_scale_a: t3.fromScale, u_scale_b: t3.toScale, u_tile_units_to_pixels: 1 / Ke(i, 1, r.transform.tileZoom), u_pixel_coord_upper: [c3 >> 16, h >> 16], u_pixel_coord_lower: [65535 & c3, 65535 & h] };
}
c(), c(), c(), q(ql, "patternUniformValues"), q(w0, "bgPatternUniformValues");
var S0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_lightpos: new st(e53, t3.u_lightpos), u_lightintensity: new U(e53, t3.u_lightintensity), u_lightcolor: new st(e53, t3.u_lightcolor), u_vertical_gradient: new U(e53, t3.u_vertical_gradient), u_opacity: new U(e53, t3.u_opacity) }), "fillExtrusionUniforms");
var P0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_lightpos: new st(e53, t3.u_lightpos), u_lightintensity: new U(e53, t3.u_lightintensity), u_lightcolor: new st(e53, t3.u_lightcolor), u_vertical_gradient: new U(e53, t3.u_vertical_gradient), u_height_factor: new U(e53, t3.u_height_factor), u_image: new Y(e53, t3.u_image), u_texsize: new ee(e53, t3.u_texsize), u_pixel_coord_upper: new ee(e53, t3.u_pixel_coord_upper), u_pixel_coord_lower: new ee(e53, t3.u_pixel_coord_lower), u_scale: new st(e53, t3.u_scale), u_fade: new U(e53, t3.u_fade), u_opacity: new U(e53, t3.u_opacity) }), "fillExtrusionPatternUniforms");
var nd = q((e53, t3, r, i) => {
  let a = t3.style.light, n = a.properties.get("position"), s3 = [n.x, n.y, n.z], o = Aa.create();
  "viewport" === a.properties.get("anchor") && Aa.fromRotation(o, -t3.transform.angle), gt.transformMat3(s3, s3, o);
  let l = a.properties.get("color");
  return { u_matrix: e53, u_lightpos: s3, u_lightintensity: a.properties.get("intensity"), u_lightcolor: [l.r, l.g, l.b], u_vertical_gradient: +r, u_opacity: i };
}, "fillExtrusionUniformValues");
var T0 = q((e53, t3, r, i, a, n, s3) => R(nd(e53, t3, r, i), ql(n, t3, s3), { u_height_factor: -Math.pow(2, a.overscaledZ) / s3.tileSize / 8 }), "fillExtrusionPatternUniformValues");
c();
var A0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix) }), "fillUniforms");
var I0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_image: new Y(e53, t3.u_image), u_texsize: new ee(e53, t3.u_texsize), u_pixel_coord_upper: new ee(e53, t3.u_pixel_coord_upper), u_pixel_coord_lower: new ee(e53, t3.u_pixel_coord_lower), u_scale: new st(e53, t3.u_scale), u_fade: new U(e53, t3.u_fade) }), "fillPatternUniforms");
var M0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_world: new ee(e53, t3.u_world) }), "fillOutlineUniforms");
var C0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_world: new ee(e53, t3.u_world), u_image: new Y(e53, t3.u_image), u_texsize: new ee(e53, t3.u_texsize), u_pixel_coord_upper: new ee(e53, t3.u_pixel_coord_upper), u_pixel_coord_lower: new ee(e53, t3.u_pixel_coord_lower), u_scale: new st(e53, t3.u_scale), u_fade: new U(e53, t3.u_fade) }), "fillOutlinePatternUniforms");
var ad = q((e53) => ({ u_matrix: e53 }), "fillUniformValues");
var od = q((e53, t3, r, i) => R(ad(e53), ql(r, t3, i)), "fillPatternUniformValues");
var E0 = q((e53, t3) => ({ u_matrix: e53, u_world: t3 }), "fillOutlineUniformValues");
var k0 = q((e53, t3, r, i, a) => R(od(e53, t3, r, i), { u_world: a }), "fillOutlinePatternUniformValues");
c();
var L0 = q((e53, t3) => ({ u_camera_to_center_distance: new U(e53, t3.u_camera_to_center_distance), u_scale_with_map: new Y(e53, t3.u_scale_with_map), u_pitch_with_map: new Y(e53, t3.u_pitch_with_map), u_extrude_scale: new ee(e53, t3.u_extrude_scale), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_matrix: new te(e53, t3.u_matrix) }), "circleUniforms");
var D0 = q((e53, t3, r, i) => {
  let a, n, s3 = e53.transform;
  if ("map" === i.paint.get("circle-pitch-alignment")) {
    let e54 = Ke(r, 1, s3.zoom);
    a = true, n = [e54, e54];
  } else
    a = false, n = s3.pixelsToGLUnits;
  return { u_camera_to_center_distance: s3.cameraToCenterDistance, u_scale_with_map: +("map" === i.paint.get("circle-pitch-scale")), u_matrix: e53.translatePosMatrix(t3.posMatrix, r, i.paint.get("circle-translate"), i.paint.get("circle-translate-anchor")), u_pitch_with_map: +a, u_device_pixel_ratio: e53.pixelRatio, u_extrude_scale: n };
}, "circleUniformValues");
c();
var z0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_camera_to_center_distance: new U(e53, t3.u_camera_to_center_distance), u_pixels_to_tile_units: new U(e53, t3.u_pixels_to_tile_units), u_extrude_scale: new ee(e53, t3.u_extrude_scale), u_overscale_factor: new U(e53, t3.u_overscale_factor) }), "collisionUniforms");
var F0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_inv_matrix: new te(e53, t3.u_inv_matrix), u_camera_to_center_distance: new U(e53, t3.u_camera_to_center_distance), u_viewport_size: new ee(e53, t3.u_viewport_size) }), "collisionCircleUniforms");
var B0 = q((e53, t3, r) => {
  let i = Ke(r, 1, t3.zoom), a = Math.pow(2, t3.zoom - r.tileID.overscaledZ), n = r.tileID.overscaleFactor();
  return { u_matrix: e53, u_camera_to_center_distance: t3.cameraToCenterDistance, u_pixels_to_tile_units: i, u_extrude_scale: [t3.pixelsToGLUnits[0] / (i * a), t3.pixelsToGLUnits[1] / (i * a)], u_overscale_factor: n };
}, "collisionUniformValues");
var R0 = q((e53, t3, r) => ({ u_matrix: e53, u_inv_matrix: t3, u_camera_to_center_distance: r.cameraToCenterDistance, u_viewport_size: [r.width, r.height] }), "collisionCircleUniformValues");
c();
var O0 = q((e53, t3) => ({ u_color: new Dt(e53, t3.u_color), u_matrix: new te(e53, t3.u_matrix), u_overlay: new Y(e53, t3.u_overlay), u_overlay_scale: new U(e53, t3.u_overlay_scale) }), "debugUniforms");
var sd = q((e53, t3, r = 1) => ({ u_matrix: e53, u_color: t3, u_overlay: 0, u_overlay_scale: r }), "debugUniformValues");
c();
var V0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix) }), "clippingMaskUniforms");
var ld = q((e53) => ({ u_matrix: e53 }), "clippingMaskUniformValues");
c();
var U0 = q((e53, t3) => ({ u_extrude_scale: new U(e53, t3.u_extrude_scale), u_intensity: new U(e53, t3.u_intensity), u_matrix: new te(e53, t3.u_matrix) }), "heatmapUniforms");
var N0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_world: new ee(e53, t3.u_world), u_image: new Y(e53, t3.u_image), u_color_ramp: new Y(e53, t3.u_color_ramp), u_opacity: new U(e53, t3.u_opacity) }), "heatmapTextureUniforms");
var G0 = q((e53, t3, r, i) => ({ u_matrix: e53, u_extrude_scale: Ke(t3, 1, r), u_intensity: i }), "heatmapUniformValues");
var q0 = q((e53, t3, r, i) => {
  let a = q3.create();
  q3.ortho(a, 0, e53.width, e53.height, 0, 0, 1);
  let n = e53.context.gl;
  return { u_matrix: a, u_world: [n.drawingBufferWidth, n.drawingBufferHeight], u_image: r, u_color_ramp: i, u_opacity: t3.paint.get("heatmap-opacity") };
}, "heatmapTextureUniformValues");
c();
var j0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_image: new Y(e53, t3.u_image), u_latrange: new ee(e53, t3.u_latrange), u_light: new ee(e53, t3.u_light), u_shadow: new Dt(e53, t3.u_shadow), u_highlight: new Dt(e53, t3.u_highlight), u_accent: new Dt(e53, t3.u_accent) }), "hillshadeUniforms");
var $0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_image: new Y(e53, t3.u_image), u_dimension: new ee(e53, t3.u_dimension), u_zoom: new U(e53, t3.u_zoom), u_unpack: new Ar(e53, t3.u_unpack) }), "hillshadePrepareUniforms");
var H0 = q((e53, t3, r, i) => {
  let a = r.paint.get("hillshade-shadow-color"), n = r.paint.get("hillshade-highlight-color"), s3 = r.paint.get("hillshade-accent-color"), o = r.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
  "viewport" === r.paint.get("hillshade-illumination-anchor") && (o -= e53.transform.angle);
  let l = !e53.options.moving;
  return { u_matrix: i ? i.posMatrix : e53.transform.calculatePosMatrix(t3.tileID.toUnwrapped(), l), u_image: 0, u_latrange: vC(e53, t3.tileID), u_light: [r.paint.get("hillshade-exaggeration"), o], u_shadow: a, u_highlight: n, u_accent: s3 };
}, "hillshadeUniformValues");
var Z0 = q((e53, t3) => {
  let r = t3.stride, i = q3.create();
  return q3.ortho(i, 0, 8192, -8192, 0, 0, 1), q3.translate(i, i, [0, -8192, 0]), { u_matrix: i, u_image: 1, u_dimension: [r, r], u_zoom: e53.overscaledZ, u_unpack: t3.getUnpackVector() };
}, "hillshadeUniformPrepareValues");
function vC(e53, t3) {
  let r = Math.pow(2, t3.canonical.z), i = t3.canonical.y;
  return [new ze(0, i / r).toLngLat().lat, new ze(0, (i + 1) / r).toLngLat().lat];
}
q(vC, "getTileLatRange"), c();
var W0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_ratio: new U(e53, t3.u_ratio), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_units_to_pixels: new ee(e53, t3.u_units_to_pixels) }), "lineUniforms");
var X0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_ratio: new U(e53, t3.u_ratio), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_units_to_pixels: new ee(e53, t3.u_units_to_pixels), u_image: new Y(e53, t3.u_image), u_image_height: new U(e53, t3.u_image_height) }), "lineGradientUniforms");
var K0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_texsize: new ee(e53, t3.u_texsize), u_ratio: new U(e53, t3.u_ratio), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_image: new Y(e53, t3.u_image), u_units_to_pixels: new ee(e53, t3.u_units_to_pixels), u_scale: new st(e53, t3.u_scale), u_fade: new U(e53, t3.u_fade) }), "linePatternUniforms");
var Y0 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_ratio: new U(e53, t3.u_ratio), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_units_to_pixels: new ee(e53, t3.u_units_to_pixels), u_patternscale_a: new ee(e53, t3.u_patternscale_a), u_patternscale_b: new ee(e53, t3.u_patternscale_b), u_sdfgamma: new U(e53, t3.u_sdfgamma), u_image: new Y(e53, t3.u_image), u_tex_y_a: new U(e53, t3.u_tex_y_a), u_tex_y_b: new U(e53, t3.u_tex_y_b), u_mix: new U(e53, t3.u_mix) }), "lineSDFUniforms");
var jl = q((e53, t3, r, i) => {
  let a = e53.transform;
  return { u_matrix: r1(e53, t3, r, i), u_ratio: 1 / Ke(t3, 1, a.zoom), u_device_pixel_ratio: e53.pixelRatio, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]] };
}, "lineUniformValues");
var J0 = q((e53, t3, r, i, a) => R(jl(e53, t3, r, a), { u_image: 0, u_image_height: i }), "lineGradientUniformValues");
var Q0 = q((e53, t3, r, i, a) => {
  let n = e53.transform, s3 = t1(t3, n);
  return { u_matrix: r1(e53, t3, r, a), u_texsize: t3.imageAtlasTexture.size, u_ratio: 1 / Ke(t3, 1, n.zoom), u_device_pixel_ratio: e53.pixelRatio, u_image: 0, u_scale: [s3, i.fromScale, i.toScale], u_fade: i.t, u_units_to_pixels: [1 / n.pixelsToGLUnits[0], 1 / n.pixelsToGLUnits[1]] };
}, "linePatternUniformValues");
var e1 = q((e53, t3, r, i, a, n) => {
  let s3 = e53.transform, o = e53.lineAtlas, l = t1(t3, s3), u3 = "round" === r.layout.get("line-cap"), c3 = o.getDash(i.from, u3), h = o.getDash(i.to, u3), p = c3.width * a.fromScale, d = h.width * a.toScale;
  return R(jl(e53, t3, r, n), { u_patternscale_a: [l / p, -c3.height / 2], u_patternscale_b: [l / d, -h.height / 2], u_sdfgamma: o.width / (256 * Math.min(p, d) * e53.pixelRatio) / 2, u_image: 0, u_tex_y_a: c3.y, u_tex_y_b: h.y, u_mix: a.t });
}, "lineSDFUniformValues");
function t1(e53, t3) {
  return 1 / Ke(e53, 1, t3.tileZoom);
}
function r1(e53, t3, r, i) {
  return e53.translatePosMatrix(i ? i.posMatrix : t3.tileID.posMatrix, t3, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
}
q(t1, "calculateTileRatio"), q(r1, "calculateMatrix"), c();
var i1 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_tl_parent: new ee(e53, t3.u_tl_parent), u_scale_parent: new U(e53, t3.u_scale_parent), u_buffer_scale: new U(e53, t3.u_buffer_scale), u_fade_t: new U(e53, t3.u_fade_t), u_opacity: new U(e53, t3.u_opacity), u_image0: new Y(e53, t3.u_image0), u_image1: new Y(e53, t3.u_image1), u_brightness_low: new U(e53, t3.u_brightness_low), u_brightness_high: new U(e53, t3.u_brightness_high), u_saturation_factor: new U(e53, t3.u_saturation_factor), u_contrast_factor: new U(e53, t3.u_contrast_factor), u_spin_weights: new st(e53, t3.u_spin_weights) }), "rasterUniforms");
var n1 = q((e53, t3, r, i, a) => ({ u_matrix: e53, u_tl_parent: t3, u_scale_parent: r, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * a.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a.paint.get("raster-brightness-min"), u_brightness_high: a.paint.get("raster-brightness-max"), u_saturation_factor: PC(a.paint.get("raster-saturation")), u_contrast_factor: SC(a.paint.get("raster-contrast")), u_spin_weights: wC(a.paint.get("raster-hue-rotate")) }), "rasterUniformValues");
function wC(e53) {
  e53 *= Math.PI / 180;
  let t3 = Math.sin(e53), r = Math.cos(e53);
  return [(2 * r + 1) / 3, (-Math.sqrt(3) * t3 - r + 1) / 3, (Math.sqrt(3) * t3 - r + 1) / 3];
}
function SC(e53) {
  return e53 > 0 ? 1 / (1 - e53) : 1 + e53;
}
function PC(e53) {
  return e53 > 0 ? 1 - 1 / (1.001 - e53) : -e53;
}
q(wC, "spinWeights"), q(SC, "contrastFactor"), q(PC, "saturationFactor"), c();
var a1 = q((e53, t3) => ({ u_is_size_zoom_constant: new Y(e53, t3.u_is_size_zoom_constant), u_is_size_feature_constant: new Y(e53, t3.u_is_size_feature_constant), u_size_t: new U(e53, t3.u_size_t), u_size: new U(e53, t3.u_size), u_camera_to_center_distance: new U(e53, t3.u_camera_to_center_distance), u_pitch: new U(e53, t3.u_pitch), u_rotate_symbol: new Y(e53, t3.u_rotate_symbol), u_aspect_ratio: new U(e53, t3.u_aspect_ratio), u_fade_change: new U(e53, t3.u_fade_change), u_matrix: new te(e53, t3.u_matrix), u_label_plane_matrix: new te(e53, t3.u_label_plane_matrix), u_coord_matrix: new te(e53, t3.u_coord_matrix), u_is_text: new Y(e53, t3.u_is_text), u_pitch_with_map: new Y(e53, t3.u_pitch_with_map), u_texsize: new ee(e53, t3.u_texsize), u_texture: new Y(e53, t3.u_texture) }), "symbolIconUniforms");
var o1 = q((e53, t3) => ({ u_is_size_zoom_constant: new Y(e53, t3.u_is_size_zoom_constant), u_is_size_feature_constant: new Y(e53, t3.u_is_size_feature_constant), u_size_t: new U(e53, t3.u_size_t), u_size: new U(e53, t3.u_size), u_camera_to_center_distance: new U(e53, t3.u_camera_to_center_distance), u_pitch: new U(e53, t3.u_pitch), u_rotate_symbol: new Y(e53, t3.u_rotate_symbol), u_aspect_ratio: new U(e53, t3.u_aspect_ratio), u_fade_change: new U(e53, t3.u_fade_change), u_matrix: new te(e53, t3.u_matrix), u_label_plane_matrix: new te(e53, t3.u_label_plane_matrix), u_coord_matrix: new te(e53, t3.u_coord_matrix), u_is_text: new Y(e53, t3.u_is_text), u_pitch_with_map: new Y(e53, t3.u_pitch_with_map), u_texsize: new ee(e53, t3.u_texsize), u_texture: new Y(e53, t3.u_texture), u_gamma_scale: new U(e53, t3.u_gamma_scale), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_is_halo: new Y(e53, t3.u_is_halo) }), "symbolSDFUniforms");
var s1 = q((e53, t3) => ({ u_is_size_zoom_constant: new Y(e53, t3.u_is_size_zoom_constant), u_is_size_feature_constant: new Y(e53, t3.u_is_size_feature_constant), u_size_t: new U(e53, t3.u_size_t), u_size: new U(e53, t3.u_size), u_camera_to_center_distance: new U(e53, t3.u_camera_to_center_distance), u_pitch: new U(e53, t3.u_pitch), u_rotate_symbol: new Y(e53, t3.u_rotate_symbol), u_aspect_ratio: new U(e53, t3.u_aspect_ratio), u_fade_change: new U(e53, t3.u_fade_change), u_matrix: new te(e53, t3.u_matrix), u_label_plane_matrix: new te(e53, t3.u_label_plane_matrix), u_coord_matrix: new te(e53, t3.u_coord_matrix), u_is_text: new Y(e53, t3.u_is_text), u_pitch_with_map: new Y(e53, t3.u_pitch_with_map), u_texsize: new ee(e53, t3.u_texsize), u_texsize_icon: new ee(e53, t3.u_texsize_icon), u_texture: new Y(e53, t3.u_texture), u_texture_icon: new Y(e53, t3.u_texture_icon), u_gamma_scale: new U(e53, t3.u_gamma_scale), u_device_pixel_ratio: new U(e53, t3.u_device_pixel_ratio), u_is_halo: new Y(e53, t3.u_is_halo) }), "symbolTextAndIconUniforms");
var ud = q((e53, t3, r, i, a, n, s3, o, l, u3) => {
  let c3 = a.transform;
  return { u_is_size_zoom_constant: +("constant" === e53 || "source" === e53), u_is_size_feature_constant: +("constant" === e53 || "camera" === e53), u_size_t: t3 ? t3.uSizeT : 0, u_size: t3 ? t3.uSize : 0, u_camera_to_center_distance: c3.cameraToCenterDistance, u_pitch: c3.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +r, u_aspect_ratio: c3.width / c3.height, u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1, u_matrix: n, u_label_plane_matrix: s3, u_coord_matrix: o, u_is_text: +l, u_pitch_with_map: +i, u_texsize: u3, u_texture: 0 };
}, "symbolIconUniformValues");
var cd = q((e53, t3, r, i, a, n, s3, o, l, u3, c3) => {
  let h = a.transform;
  return R(ud(e53, t3, r, i, a, n, s3, o, l, u3), { u_gamma_scale: i ? Math.cos(h._pitch) * h.cameraToCenterDistance : 1, u_device_pixel_ratio: a.pixelRatio, u_is_halo: +c3 });
}, "symbolSDFUniformValues");
var l1 = q((e53, t3, r, i, a, n, s3, o, l, u3) => R(cd(e53, t3, r, i, a, n, s3, o, true, l, true), { u_texsize_icon: u3, u_texture_icon: 1 }), "symbolTextAndIconUniformValues");
c();
var u1 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_opacity: new U(e53, t3.u_opacity), u_color: new Dt(e53, t3.u_color) }), "backgroundUniforms");
var c1 = q((e53, t3) => ({ u_matrix: new te(e53, t3.u_matrix), u_opacity: new U(e53, t3.u_opacity), u_image: new Y(e53, t3.u_image), u_pattern_tl_a: new ee(e53, t3.u_pattern_tl_a), u_pattern_br_a: new ee(e53, t3.u_pattern_br_a), u_pattern_tl_b: new ee(e53, t3.u_pattern_tl_b), u_pattern_br_b: new ee(e53, t3.u_pattern_br_b), u_texsize: new ee(e53, t3.u_texsize), u_mix: new U(e53, t3.u_mix), u_pattern_size_a: new ee(e53, t3.u_pattern_size_a), u_pattern_size_b: new ee(e53, t3.u_pattern_size_b), u_scale_a: new U(e53, t3.u_scale_a), u_scale_b: new U(e53, t3.u_scale_b), u_pixel_coord_upper: new ee(e53, t3.u_pixel_coord_upper), u_pixel_coord_lower: new ee(e53, t3.u_pixel_coord_lower), u_tile_units_to_pixels: new U(e53, t3.u_tile_units_to_pixels) }), "backgroundPatternUniforms");
var p1 = q((e53, t3, r) => ({ u_matrix: e53, u_opacity: t3, u_color: r }), "backgroundUniformValues");
var h1 = q((e53, t3, r, i, a, n) => R(w0(i, n, r, a), { u_matrix: e53, u_opacity: t3 }), "backgroundPatternUniformValues");
var f1 = { fillExtrusion: S0, fillExtrusionPattern: P0, fill: A0, fillPattern: I0, fillOutline: M0, fillOutlinePattern: C0, circle: L0, collisionBox: z0, collisionCircle: F0, debug: O0, clippingMask: V0, heatmap: U0, heatmapTexture: N0, hillshade: j0, hillshadePrepare: $0, line: W0, lineGradient: X0, linePattern: K0, lineSDF: Y0, raster: i1, symbolIcon: a1, symbolSDF: o1, symbolTextAndIcon: s1, background: u1, backgroundPattern: c1, terrain: y0, terrainDepth: g0, terrainCoords: x0 };
c(), c();
var pd = class {
  constructor(e53, t3, r) {
    this.context = e53;
    let i = e53.gl;
    this.buffer = i.createBuffer(), this.dynamicDraw = !!r, this.context.unbindVAO(), e53.bindElementBuffer.set(this.buffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete t3.arrayBuffer;
  }
  bind() {
    this.context.bindElementBuffer.set(this.buffer);
  }
  updateData(e53) {
    let t3 = this.context.gl;
    if (!this.dynamicDraw)
      throw new Error("Attempted to update data while not in dynamic mode.");
    this.context.unbindVAO(), this.bind(), t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, 0, e53.arrayBuffer);
  }
  destroy() {
    let e53 = this.context.gl;
    this.buffer && (e53.deleteBuffer(this.buffer), delete this.buffer);
  }
};
q(pd, "IndexBuffer");
var $l = pd;
c();
var TC = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
var hd = class {
  constructor(e53, t3, r, i) {
    this.length = t3.length, this.attributes = r, this.itemSize = t3.bytesPerElement, this.dynamicDraw = i, this.context = e53;
    let a = e53.gl;
    this.buffer = a.createBuffer(), e53.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, t3.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || delete t3.arrayBuffer;
  }
  bind() {
    this.context.bindVertexBuffer.set(this.buffer);
  }
  updateData(e53) {
    if (e53.length !== this.length)
      throw new Error("Length of new data is ".concat(e53.length, ", which doesn't match current length of ").concat(this.length));
    let t3 = this.context.gl;
    this.bind(), t3.bufferSubData(t3.ARRAY_BUFFER, 0, e53.arrayBuffer);
  }
  enableAttributes(e53, t3) {
    for (let r = 0; r < this.attributes.length; r++) {
      let i = this.attributes[r], a = t3.attributes[i.name];
      void 0 !== a && e53.enableVertexAttribArray(a);
    }
  }
  setVertexAttribPointers(e53, t3, r) {
    for (let i = 0; i < this.attributes.length; i++) {
      let a = this.attributes[i], n = t3.attributes[a.name];
      void 0 !== n && e53.vertexAttribPointer(n, a.components, e53[TC[a.type]], false, this.itemSize, a.offset + this.itemSize * (r || 0));
    }
  }
  destroy() {
    let e53 = this.context.gl;
    this.buffer && (e53.deleteBuffer(this.buffer), delete this.buffer);
  }
};
q(hd, "VertexBuffer");
var Hl = hd;
c(), c(), c();
var fd = /* @__PURE__ */ new WeakMap();
function bn(e53) {
  if (fd.has(e53))
    return fd.get(e53);
  {
    let t3 = e53.getParameter(e53.VERSION).startsWith("WebGL 2.0");
    return fd.set(e53, t3), t3;
  }
}
q(bn, "isWebGL2");
var md = class {
  constructor(e53) {
    this.gl = e53.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
  }
  get() {
    return this.current;
  }
  set(e53) {
  }
  getDefault() {
    return this.default;
  }
  setDefault() {
    this.set(this.default);
  }
};
q(md, "BaseValue");
var xe = md;
var dd = class extends xe {
  getDefault() {
    return K.transparent;
  }
  set(e53) {
    let t3 = this.current;
    e53.r === t3.r && e53.g === t3.g && e53.b === t3.b && e53.a === t3.a && !this.dirty || (this.gl.clearColor(e53.r, e53.g, e53.b, e53.a), this.current = e53, this.dirty = false);
  }
};
q(dd, "ClearColor");
var Zl = dd;
var yd = class extends xe {
  getDefault() {
    return 1;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.clearDepth(e53), this.current = e53, this.dirty = false);
  }
};
q(yd, "ClearDepth");
var Wl = yd;
var gd = class extends xe {
  getDefault() {
    return 0;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.clearStencil(e53), this.current = e53, this.dirty = false);
  }
};
q(gd, "ClearStencil");
var Xl = gd;
var xd = class extends xe {
  getDefault() {
    return [true, true, true, true];
  }
  set(e53) {
    let t3 = this.current;
    e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && e53[3] === t3[3] && !this.dirty || (this.gl.colorMask(e53[0], e53[1], e53[2], e53[3]), this.current = e53, this.dirty = false);
  }
};
q(xd, "ColorMask");
var Kl = xd;
var bd = class extends xe {
  getDefault() {
    return true;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.depthMask(e53), this.current = e53, this.dirty = false);
  }
};
q(bd, "DepthMask");
var Yl = bd;
var _d = class extends xe {
  getDefault() {
    return 255;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.stencilMask(e53), this.current = e53, this.dirty = false);
  }
};
q(_d, "StencilMask");
var Jl = _d;
var vd = class extends xe {
  getDefault() {
    return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
  }
  set(e53) {
    let t3 = this.current;
    e53.func === t3.func && e53.ref === t3.ref && e53.mask === t3.mask && !this.dirty || (this.gl.stencilFunc(e53.func, e53.ref, e53.mask), this.current = e53, this.dirty = false);
  }
};
q(vd, "StencilFunc");
var Ql = vd;
var wd = class extends xe {
  getDefault() {
    let e53 = this.gl;
    return [e53.KEEP, e53.KEEP, e53.KEEP];
  }
  set(e53) {
    let t3 = this.current;
    e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && !this.dirty || (this.gl.stencilOp(e53[0], e53[1], e53[2]), this.current = e53, this.dirty = false);
  }
};
q(wd, "StencilOp");
var eu = wd;
var Sd = class extends xe {
  getDefault() {
    return false;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    e53 ? t3.enable(t3.STENCIL_TEST) : t3.disable(t3.STENCIL_TEST), this.current = e53, this.dirty = false;
  }
};
q(Sd, "StencilTest");
var tu = Sd;
var Pd = class extends xe {
  getDefault() {
    return [0, 1];
  }
  set(e53) {
    let t3 = this.current;
    e53[0] === t3[0] && e53[1] === t3[1] && !this.dirty || (this.gl.depthRange(e53[0], e53[1]), this.current = e53, this.dirty = false);
  }
};
q(Pd, "DepthRange");
var ru = Pd;
var Td = class extends xe {
  getDefault() {
    return false;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    e53 ? t3.enable(t3.DEPTH_TEST) : t3.disable(t3.DEPTH_TEST), this.current = e53, this.dirty = false;
  }
};
q(Td, "DepthTest");
var iu = Td;
var Ad = class extends xe {
  getDefault() {
    return this.gl.LESS;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.depthFunc(e53), this.current = e53, this.dirty = false);
  }
};
q(Ad, "DepthFunc");
var nu = Ad;
var Id = class extends xe {
  getDefault() {
    return false;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    e53 ? t3.enable(t3.BLEND) : t3.disable(t3.BLEND), this.current = e53, this.dirty = false;
  }
};
q(Id, "Blend");
var au = Id;
var Md = class extends xe {
  getDefault() {
    let e53 = this.gl;
    return [e53.ONE, e53.ZERO];
  }
  set(e53) {
    let t3 = this.current;
    e53[0] === t3[0] && e53[1] === t3[1] && !this.dirty || (this.gl.blendFunc(e53[0], e53[1]), this.current = e53, this.dirty = false);
  }
};
q(Md, "BlendFunc");
var ou = Md;
var Cd = class extends xe {
  getDefault() {
    return K.transparent;
  }
  set(e53) {
    let t3 = this.current;
    e53.r === t3.r && e53.g === t3.g && e53.b === t3.b && e53.a === t3.a && !this.dirty || (this.gl.blendColor(e53.r, e53.g, e53.b, e53.a), this.current = e53, this.dirty = false);
  }
};
q(Cd, "BlendColor");
var su = Cd;
var Ed = class extends xe {
  getDefault() {
    return this.gl.FUNC_ADD;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.blendEquation(e53), this.current = e53, this.dirty = false);
  }
};
q(Ed, "BlendEquation");
var lu = Ed;
var kd = class extends xe {
  getDefault() {
    return false;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    e53 ? t3.enable(t3.CULL_FACE) : t3.disable(t3.CULL_FACE), this.current = e53, this.dirty = false;
  }
};
q(kd, "CullFace");
var uu = kd;
var Ld = class extends xe {
  getDefault() {
    return this.gl.BACK;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.cullFace(e53), this.current = e53, this.dirty = false);
  }
};
q(Ld, "CullFaceSide");
var cu = Ld;
var Dd = class extends xe {
  getDefault() {
    return this.gl.CCW;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.frontFace(e53), this.current = e53, this.dirty = false);
  }
};
q(Dd, "FrontFace");
var pu = Dd;
var zd = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.useProgram(e53), this.current = e53, this.dirty = false);
  }
};
q(zd, "ProgramValue");
var hu = zd;
var Fd = class extends xe {
  getDefault() {
    return this.gl.TEXTURE0;
  }
  set(e53) {
    e53 === this.current && !this.dirty || (this.gl.activeTexture(e53), this.current = e53, this.dirty = false);
  }
};
q(Fd, "ActiveTextureUnit");
var fu = Fd;
var Bd = class extends xe {
  getDefault() {
    let e53 = this.gl;
    return [0, 0, e53.drawingBufferWidth, e53.drawingBufferHeight];
  }
  set(e53) {
    let t3 = this.current;
    e53[0] === t3[0] && e53[1] === t3[1] && e53[2] === t3[2] && e53[3] === t3[3] && !this.dirty || (this.gl.viewport(e53[0], e53[1], e53[2], e53[3]), this.current = e53, this.dirty = false);
  }
};
q(Bd, "Viewport");
var mu = Bd;
var Rd = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.bindFramebuffer(t3.FRAMEBUFFER, e53), this.current = e53, this.dirty = false;
  }
};
q(Rd, "BindFramebuffer");
var du = Rd;
var Od = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.bindRenderbuffer(t3.RENDERBUFFER, e53), this.current = e53, this.dirty = false;
  }
};
q(Od, "BindRenderbuffer");
var yu = Od;
var Vd = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.bindTexture(t3.TEXTURE_2D, e53), this.current = e53, this.dirty = false;
  }
};
q(Vd, "BindTexture");
var gu = Vd;
var Ud = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.bindBuffer(t3.ARRAY_BUFFER, e53), this.current = e53, this.dirty = false;
  }
};
q(Ud, "BindVertexBuffer");
var xu = Ud;
var Nd = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    let t3 = this.gl;
    t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, e53), this.current = e53, this.dirty = false;
  }
};
q(Nd, "BindElementBuffer");
var bu = Nd;
var Gd = class extends xe {
  getDefault() {
    return null;
  }
  set(e53) {
    var t3;
    if (e53 === this.current && !this.dirty)
      return;
    let r = this.gl;
    bn(r) ? r.bindVertexArray(e53) : null == (t3 = r.getExtension("OES_vertex_array_object")) || t3.bindVertexArrayOES(e53), this.current = e53, this.dirty = false;
  }
};
q(Gd, "BindVertexArray");
var _u = Gd;
var qd = class extends xe {
  getDefault() {
    return 4;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.pixelStorei(t3.UNPACK_ALIGNMENT, e53), this.current = e53, this.dirty = false;
  }
};
q(qd, "PixelStoreUnpack");
var vu = qd;
var jd = class extends xe {
  getDefault() {
    return false;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.pixelStorei(t3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e53), this.current = e53, this.dirty = false;
  }
};
q(jd, "PixelStoreUnpackPremultiplyAlpha");
var wu = jd;
var $d = class extends xe {
  getDefault() {
    return false;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    let t3 = this.gl;
    t3.pixelStorei(t3.UNPACK_FLIP_Y_WEBGL, e53), this.current = e53, this.dirty = false;
  }
};
q($d, "PixelStoreUnpackFlipY");
var Su = $d;
var Hd = class extends xe {
  constructor(e53, t3) {
    super(e53), this.context = e53, this.parent = t3;
  }
  getDefault() {
    return null;
  }
};
q(Hd, "FramebufferAttachment");
var ro = Hd;
var Zd = class extends ro {
  setDirty() {
    this.dirty = true;
  }
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    this.context.bindFramebuffer.set(this.parent);
    let t3 = this.gl;
    t3.framebufferTexture2D(t3.FRAMEBUFFER, t3.COLOR_ATTACHMENT0, t3.TEXTURE_2D, e53, 0), this.current = e53, this.dirty = false;
  }
};
q(Zd, "ColorAttachment");
var Pu = Zd;
var Wd = class extends ro {
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    this.context.bindFramebuffer.set(this.parent);
    let t3 = this.gl;
    t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_ATTACHMENT, t3.RENDERBUFFER, e53), this.current = e53, this.dirty = false;
  }
};
q(Wd, "DepthAttachment");
var Tu = Wd;
var Xd = class extends ro {
  set(e53) {
    if (e53 === this.current && !this.dirty)
      return;
    this.context.bindFramebuffer.set(this.parent);
    let t3 = this.gl;
    t3.framebufferRenderbuffer(t3.FRAMEBUFFER, t3.DEPTH_STENCIL_ATTACHMENT, t3.RENDERBUFFER, e53), this.current = e53, this.dirty = false;
  }
};
q(Xd, "DepthStencilAttachment");
var Au = Xd;
var Kd = class {
  constructor(e53, t3, r, i, a) {
    this.context = e53, this.width = t3, this.height = r;
    let n = e53.gl, s3 = this.framebuffer = n.createFramebuffer();
    if (this.colorAttachment = new Pu(e53, s3), i)
      this.depthAttachment = a ? new Au(e53, s3) : new Tu(e53, s3);
    else if (a)
      throw new Error("Stencil cannot be setted without depth");
    if (n.checkFramebufferStatus(n.FRAMEBUFFER) !== n.FRAMEBUFFER_COMPLETE)
      throw new Error("Framebuffer is not complete");
  }
  destroy() {
    let e53 = this.context.gl, t3 = this.colorAttachment.get();
    if (t3 && e53.deleteTexture(t3), this.depthAttachment) {
      let t4 = this.depthAttachment.get();
      t4 && e53.deleteRenderbuffer(t4);
    }
    e53.deleteFramebuffer(this.framebuffer);
  }
};
q(Kd, "Framebuffer");
var Iu = Kd;
c();
var AC = 0;
var m1 = 1;
var IC = 771;
var Yd = class {
  constructor(e53, t3, r) {
    this.blendFunction = e53, this.blendColor = t3, this.mask = r;
  }
};
q(Yd, "ColorMode");
var De = Yd;
De.Replace = [m1, AC], De.disabled = new De(De.Replace, K.transparent, [false, false, false, false]), De.unblended = new De(De.Replace, K.transparent, [true, true, true, true]), De.alphaBlended = new De([m1, IC], K.transparent, [true, true, true, true]);
var Jd = class {
  constructor(e53) {
    var t3, r;
    if (this.gl = e53, this.clearColor = new Zl(this), this.clearDepth = new Wl(this), this.clearStencil = new Xl(this), this.colorMask = new Kl(this), this.depthMask = new Yl(this), this.stencilMask = new Jl(this), this.stencilFunc = new Ql(this), this.stencilOp = new eu(this), this.stencilTest = new tu(this), this.depthRange = new ru(this), this.depthTest = new iu(this), this.depthFunc = new nu(this), this.blend = new au(this), this.blendFunc = new ou(this), this.blendColor = new su(this), this.blendEquation = new lu(this), this.cullFace = new uu(this), this.cullFaceSide = new cu(this), this.frontFace = new pu(this), this.program = new hu(this), this.activeTexture = new fu(this), this.viewport = new mu(this), this.bindFramebuffer = new du(this), this.bindRenderbuffer = new yu(this), this.bindTexture = new gu(this), this.bindVertexBuffer = new xu(this), this.bindElementBuffer = new bu(this), this.bindVertexArray = new _u(this), this.pixelStoreUnpack = new vu(this), this.pixelStoreUnpackPremultiplyAlpha = new wu(this), this.pixelStoreUnpackFlipY = new Su(this), this.extTextureFilterAnisotropic = e53.getExtension("EXT_texture_filter_anisotropic") || e53.getExtension("MOZ_EXT_texture_filter_anisotropic") || e53.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e53.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e53.getParameter(e53.MAX_TEXTURE_SIZE), bn(e53)) {
      this.HALF_FLOAT = e53.HALF_FLOAT;
      let i = e53.getExtension("EXT_color_buffer_half_float");
      this.RGBA16F = null != (t3 = e53.RGBA16F) ? t3 : null == i ? void 0 : i.RGBA16F_EXT, this.RGB16F = null != (r = e53.RGB16F) ? r : null == i ? void 0 : i.RGB16F_EXT, e53.getExtension("EXT_color_buffer_float");
    } else {
      e53.getExtension("EXT_color_buffer_half_float"), e53.getExtension("OES_texture_half_float_linear");
      let t4 = e53.getExtension("OES_texture_half_float");
      this.HALF_FLOAT = null == t4 ? void 0 : t4.HALF_FLOAT_OES;
    }
  }
  setDefault() {
    this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
  }
  setDirty() {
    this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
  }
  createIndexBuffer(e53, t3) {
    return new $l(this, e53, t3);
  }
  createVertexBuffer(e53, t3, r) {
    return new Hl(this, e53, t3, r);
  }
  createRenderbuffer(e53, t3, r) {
    let i = this.gl, a = i.createRenderbuffer();
    return this.bindRenderbuffer.set(a), i.renderbufferStorage(i.RENDERBUFFER, e53, t3, r), this.bindRenderbuffer.set(null), a;
  }
  createFramebuffer(e53, t3, r, i) {
    return new Iu(this, e53, t3, r, i);
  }
  clear({ color: e53, depth: t3, stencil: r }) {
    let i = this.gl, a = 0;
    e53 && (a |= i.COLOR_BUFFER_BIT, this.clearColor.set(e53), this.colorMask.set([true, true, true, true])), typeof t3 < "u" && (a |= i.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t3), this.depthMask.set(true)), typeof r < "u" && (a |= i.STENCIL_BUFFER_BIT, this.clearStencil.set(r), this.stencilMask.set(255)), i.clear(a);
  }
  setCullFace(e53) {
    false === e53.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e53.mode), this.frontFace.set(e53.frontFace));
  }
  setDepthMode(e53) {
    e53.func !== this.gl.ALWAYS || e53.mask ? (this.depthTest.set(true), this.depthFunc.set(e53.func), this.depthMask.set(e53.mask), this.depthRange.set(e53.range)) : this.depthTest.set(false);
  }
  setStencilMode(e53) {
    e53.test.func !== this.gl.ALWAYS || e53.mask ? (this.stencilTest.set(true), this.stencilMask.set(e53.mask), this.stencilOp.set([e53.fail, e53.depthFail, e53.pass]), this.stencilFunc.set({ func: e53.test.func, ref: e53.ref, mask: e53.test.mask })) : this.stencilTest.set(false);
  }
  setColorMode(e53) {
    Kt(e53.blendFunction, De.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e53.blendFunction), this.blendColor.set(e53.blendColor)), this.colorMask.set(e53.mask);
  }
  createVertexArray() {
    var e53;
    return bn(this.gl) ? this.gl.createVertexArray() : null == (e53 = this.gl.getExtension("OES_vertex_array_object")) ? void 0 : e53.createVertexArrayOES();
  }
  deleteVertexArray(e53) {
    var t3;
    return bn(this.gl) ? this.gl.deleteVertexArray(e53) : null == (t3 = this.gl.getExtension("OES_vertex_array_object")) ? void 0 : t3.deleteVertexArrayOES(e53);
  }
  unbindVAO() {
    this.bindVertexArray.set(null);
  }
};
q(Jd, "Context");
var Mu = Jd;
c();
var Qd = class {
  constructor(e53, t3, r) {
    this.func = e53, this.mask = t3, this.range = r;
  }
};
q(Qd, "DepthMode");
var Q = Qd;
Q.ReadOnly = false, Q.ReadWrite = true, Q.disabled = new Q(519, Q.ReadOnly, [0, 1]), c();
var ey = class {
  constructor(e53, t3, r, i, a, n) {
    this.test = e53, this.ref = t3, this.mask = r, this.fail = i, this.depthFail = a, this.pass = n;
  }
};
q(ey, "StencilMode");
var he = ey;
he.disabled = new he({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680), c();
var ty = class {
  constructor(e53, t3, r) {
    this.enable = e53, this.mode = t3, this.frontFace = r;
  }
};
q(ty, "CullFaceMode");
var le = ty;
le.disabled = new le(false, 1029, 2305), le.backCCW = new le(true, 1029, 2305), c();
var Cu;
var iy = u(Pe(), 1);
function ry(e53, t3, r, i, a, n, s3) {
  let o = e53.context, l = o.gl, u3 = e53.useProgram("collisionBox"), c3 = [], h = 0, p = 0;
  for (let d3 = 0; d3 < i.length; d3++) {
    let f3 = i[d3], m3 = t3.getTile(f3), y3 = m3.getBucket(r);
    if (!y3)
      continue;
    let g3 = f3.posMatrix;
    (0 !== a[0] || 0 !== a[1]) && (g3 = e53.translatePosMatrix(f3.posMatrix, m3, a, n));
    let _ = s3 ? y3.textCollisionBox : y3.iconCollisionBox, x = y3.collisionCircleArray;
    if (x.length > 0) {
      let t4 = q3.create(), r3 = g3;
      q3.mul(t4, y3.placementInvProjMatrix, e53.transform.glCoordMatrix), q3.mul(t4, t4, y3.placementViewportMatrix), c3.push({ circleArray: x, circleOffset: p, transform: r3, invTransform: t4, coord: f3 }), h += x.length / 4, p = h;
    }
    _ && u3.draw(o, l.LINES, Q.disabled, he.disabled, e53.colorModeForRenderPass(), le.disabled, B0(g3, e53.transform, m3), e53.style.map.terrain && e53.style.map.terrain.getTerrainData(f3), r.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, null, e53.transform.zoom, null, null, _.collisionVertexBuffer);
  }
  if (!s3 || !c3.length)
    return;
  let d = e53.useProgram("collisionCircle"), f = new Is();
  f.resize(4 * h), f._trim();
  let m = 0;
  for (let e54 of c3)
    for (let t4 = 0; t4 < e54.circleArray.length / 4; t4++) {
      let r3 = 4 * t4, i3 = e54.circleArray[r3 + 0], a3 = e54.circleArray[r3 + 1], n3 = e54.circleArray[r3 + 2], s4 = e54.circleArray[r3 + 3];
      f.emplace(m++, i3, a3, n3, s4, 0), f.emplace(m++, i3, a3, n3, s4, 1), f.emplace(m++, i3, a3, n3, s4, 2), f.emplace(m++, i3, a3, n3, s4, 3);
    }
  (!Cu || Cu.length < 2 * h) && (Cu = MC(h));
  let y = o.createIndexBuffer(Cu, true), g = o.createVertexBuffer(f, r_.members, true);
  for (let t4 of c3) {
    let i3 = R0(t4.transform, t4.invTransform, e53.transform);
    d.draw(o, l.TRIANGLES, Q.disabled, he.disabled, e53.colorModeForRenderPass(), le.disabled, i3, e53.style.map.terrain && e53.style.map.terrain.getTerrainData(t4.coord), r.id, g, y, me.simpleSegment(0, 2 * t4.circleOffset, t4.circleArray.length, t4.circleArray.length / 2), null, e53.transform.zoom, null, null, null);
  }
  g.destroy(), y.destroy();
}
function MC(e53) {
  let t3 = 2 * e53, r = new Cs();
  r.resize(t3), r._trim();
  for (let e54 = 0; e54 < t3; e54++) {
    let t4 = 6 * e54;
    r.uint16[t4 + 0] = 4 * e54 + 0, r.uint16[t4 + 1] = 4 * e54 + 1, r.uint16[t4 + 2] = 4 * e54 + 2, r.uint16[t4 + 3] = 4 * e54 + 2, r.uint16[t4 + 4] = 4 * e54 + 3, r.uint16[t4 + 5] = 4 * e54 + 0;
  }
  return r;
}
c(), q(ry, "drawCollisionDebug"), q(MC, "createQuadTriangles");
var CC = q3.identity(new Float32Array(16));
function g1(e53, t3, r, i, a) {
  if ("translucent" !== e53.renderPass)
    return;
  let n = he.disabled, s3 = e53.colorModeForRenderPass();
  r.layout.get("text-variable-anchor") && kC(i, e53, r, t3, r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), a), 0 !== r.paint.get("icon-opacity").constantOr(1) && d1(e53, t3, r, i, false, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), n, s3), 0 !== r.paint.get("text-opacity").constantOr(1) && d1(e53, t3, r, i, true, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), n, s3), t3.map.showCollisionBoxes && (ry(e53, t3, r, i, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), true), ry(e53, t3, r, i, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), false));
}
function EC(e53, t3, r, i, a, n) {
  let { horizontalAlign: s3, verticalAlign: o } = Js(e53), l = -(s3 - 0.5) * t3, u3 = -(o - 0.5) * r, c3 = Cl(e53, i);
  return new iy.default((l / a + c3[0]) * n, (u3 / a + c3[1]) * n);
}
function kC(e53, t3, r, i, a, n, s3) {
  let o = t3.transform, l = "map" === a, u3 = "map" === n;
  for (let a3 of e53) {
    let e54 = i.getTile(a3), n3 = e54.getBucket(r);
    if (!n3 || !n3.text || !n3.text.segments.get().length)
      continue;
    let c3 = ci(n3.textSizeData, o.zoom), h = Ke(e54, 1, t3.transform.zoom), p = Wa(a3.posMatrix, u3, l, t3.transform, h), d = "none" !== r.layout.get("icon-text-fit") && n3.hasIconData();
    if (c3) {
      let r3 = Math.pow(2, o.zoom - e54.tileID.overscaledZ), i3 = t3.style.map.terrain ? (e55, r4) => t3.style.map.terrain.getElevation(a3, e55, r4) : null;
      LC(n3, l, u3, s3, o, p, a3.posMatrix, r3, c3, d, i3);
    }
  }
}
function LC(e53, t3, r, i, a, n, s3, o, l, u3, c3) {
  let h = e53.text.placedSymbolArray, p = e53.text.dynamicLayoutVertexArray, d = e53.icon.dynamicLayoutVertexArray, f = {};
  p.clear();
  for (let d3 = 0; d3 < h.length; d3++) {
    let m = h.get(d3), y = e53.allowVerticalPlacement && !m.placedOrientation, g = m.hidden || !m.crossTileID || y ? null : i[m.crossTileID];
    if (g) {
      let i3 = new iy.default(m.anchorX, m.anchorY), h3 = bt(i3, r ? s3 : n, c3), d4 = Xa(a.cameraToCenterDistance, h3.signedDistanceFromCamera), y3 = rn(e53.textSizeData, l, m) * d4 / li;
      r && (y3 *= e53.tilePixelRatio / o);
      let { width: _, height: x, anchor: v, textOffset: b, textBoxScale: w } = g, S = EC(v, _, x, b, w, y3), A = r ? bt(i3.add(S), n, c3).point : h3.point.add(t3 ? S.rotate(-a.angle) : S), M3 = e53.allowVerticalPlacement && 2 === m.placedOrientation ? Math.PI / 2 : 0;
      for (let e54 = 0; e54 < m.numGlyphs; e54++)
        pi(p, A, M3);
      u3 && m.associatedIconIndex >= 0 && (f[m.associatedIconIndex] = { shiftedAnchor: A, angle: M3 });
    } else
      yi(m.numGlyphs, p);
  }
  if (u3) {
    d.clear();
    let t4 = e53.icon.placedSymbolArray;
    for (let e54 = 0; e54 < t4.length; e54++) {
      let r3 = t4.get(e54);
      if (r3.hidden)
        yi(r3.numGlyphs, d);
      else {
        let t5 = f[e54];
        if (t5)
          for (let e55 = 0; e55 < r3.numGlyphs; e55++)
            pi(d, t5.shiftedAnchor, t5.angle);
        else
          yi(r3.numGlyphs, d);
      }
    }
    e53.icon.dynamicLayoutVertexBuffer.updateData(d);
  }
  e53.text.dynamicLayoutVertexBuffer.updateData(p);
}
function DC(e53, t3, r) {
  return r.iconsInText && t3 ? "symbolTextAndIcon" : e53 ? "symbolSDF" : "symbolIcon";
}
function d1(e53, t3, r, i, a, n, s3, o, l, u3, c3, h) {
  let p = e53.context, d = p.gl, f = e53.transform, m = "map" === o, y = "map" === l, g = "viewport" !== o && "point" !== r.layout.get("symbol-placement"), _ = m && !y && !g, x = !r.layout.get("symbol-sort-key").isConstant(), v = false, b = e53.depthModeForSublayer(0, Q.ReadOnly), w = r.layout.get("text-variable-anchor"), S = [];
  for (let o3 of i) {
    let i3 = t3.getTile(o3), l3 = i3.getBucket(r);
    if (!l3)
      continue;
    let c4 = a ? l3.text : l3.icon;
    if (!c4 || !c4.segments.get().length || !c4.hasVisibleVertices)
      continue;
    let h3, p3, b3, A, M3 = c4.programConfigurations.get(r.id), I = a || l3.sdfIcons, T = a ? l3.textSizeData : l3.iconSizeData, C = y || 0 !== f.pitch, P = e53.useProgram(DC(I, a, l3), M3), k = ci(T, f.zoom), z3 = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(o3), E = [0, 0], D = null;
    if (a) {
      if (p3 = i3.glyphAtlasTexture, b3 = d.LINEAR, h3 = i3.glyphAtlasTexture.size, l3.iconsInText) {
        E = i3.imageAtlasTexture.size, D = i3.imageAtlasTexture;
        let t4 = "composite" === T.kind || "camera" === T.kind;
        A = C || e53.options.rotating || e53.options.zooming || t4 ? d.LINEAR : d.NEAREST;
      }
    } else {
      let t4 = 1 !== r.layout.get("icon-size").constantOr(0) || l3.iconsNeedLinear;
      p3 = i3.imageAtlasTexture, b3 = I || e53.options.rotating || e53.options.zooming || t4 || C ? d.LINEAR : d.NEAREST, h3 = i3.imageAtlasTexture.size;
    }
    let B3 = Ke(i3, 1, e53.transform.zoom), L = Wa(o3.posMatrix, y, m, e53.transform, B3), F = Tl(o3.posMatrix, y, m, e53.transform, B3), R3 = w && l3.hasTextData(), V = "none" !== r.layout.get("icon-text-fit") && R3 && l3.hasIconData();
    if (g) {
      let t4 = e53.style.map.terrain ? (t5, r3) => e53.style.map.terrain.getElevation(o3, t5, r3) : null, i4 = "map" === r.layout.get("text-rotation-alignment");
      av(l3, o3.posMatrix, e53, a, L, F, y, u3, i4, t4);
    }
    let O, U3 = e53.translatePosMatrix(o3.posMatrix, i3, n, s3), N3 = g || a && w || V ? CC : L, q4 = e53.translatePosMatrix(F, i3, n, s3, true), j3 = I && 0 !== r.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1);
    O = I ? l3.iconsInText ? l1(T.kind, k, _, y, e53, U3, N3, q4, h3, E) : cd(T.kind, k, _, y, e53, U3, N3, q4, a, h3, true) : ud(T.kind, k, _, y, e53, U3, N3, q4, a, h3);
    let G3 = { program: P, buffers: c4, uniformValues: O, atlasTexture: p3, atlasTextureIcon: D, atlasInterpolation: b3, atlasInterpolationIcon: A, isSDF: I, hasHalo: j3 };
    if (x && l3.canOverlap) {
      v = true;
      let e54 = c4.segments.get();
      for (let t4 of e54)
        S.push({ segments: new me([t4]), sortKey: t4.sortKey, state: G3, terrainData: z3 });
    } else
      S.push({ segments: c4.segments, sortKey: 0, state: G3, terrainData: z3 });
  }
  v && S.sort((e54, t4) => e54.sortKey - t4.sortKey);
  for (let t4 of S) {
    let i3 = t4.state;
    if (p.activeTexture.set(d.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, d.CLAMP_TO_EDGE), i3.atlasTextureIcon && (p.activeTexture.set(d.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, d.CLAMP_TO_EDGE)), i3.isSDF) {
      let a3 = i3.uniformValues;
      i3.hasHalo && (a3.u_is_halo = 1, y1(i3.buffers, t4.segments, r, e53, i3.program, b, c3, h, a3, t4.terrainData)), a3.u_is_halo = 0;
    }
    y1(i3.buffers, t4.segments, r, e53, i3.program, b, c3, h, i3.uniformValues, t4.terrainData);
  }
}
function y1(e53, t3, r, i, a, n, s3, o, l, u3) {
  let c3 = i.context, h = c3.gl;
  a.draw(c3, h.TRIANGLES, n, s3, o, le.disabled, l, u3, r.id, e53.layoutVertexBuffer, e53.indexBuffer, t3, r.paint, i.transform.zoom, e53.programConfigurations.get(r.id), e53.dynamicLayoutVertexBuffer, e53.opacityVertexBuffer);
}
function x1(e53, t3, r, i) {
  if ("translucent" !== e53.renderPass)
    return;
  let a = r.paint.get("circle-opacity"), n = r.paint.get("circle-stroke-width"), s3 = r.paint.get("circle-stroke-opacity"), o = !r.layout.get("circle-sort-key").isConstant();
  if (0 === a.constantOr(1) && (0 === n.constantOr(1) || 0 === s3.constantOr(1)))
    return;
  let l = e53.context, u3 = l.gl, c3 = e53.depthModeForSublayer(0, Q.ReadOnly), h = he.disabled, p = e53.colorModeForRenderPass(), d = [];
  for (let a3 = 0; a3 < i.length; a3++) {
    let n3 = i[a3], s4 = t3.getTile(n3), l3 = s4.getBucket(r);
    if (!l3)
      continue;
    let u4 = l3.programConfigurations.get(r.id), c4 = e53.useProgram("circle", u4), h3 = l3.layoutVertexBuffer, p3 = l3.indexBuffer, f = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(n3), m = { programConfiguration: u4, program: c4, layoutVertexBuffer: h3, indexBuffer: p3, uniformValues: D0(e53, n3, s4, r), terrainData: f };
    if (o) {
      let e54 = l3.segments.get();
      for (let t4 of e54)
        d.push({ segments: new me([t4]), sortKey: t4.sortKey, state: m });
    } else
      d.push({ segments: l3.segments, sortKey: 0, state: m });
  }
  o && d.sort((e54, t4) => e54.sortKey - t4.sortKey);
  for (let t4 of d) {
    let { programConfiguration: i3, program: a3, layoutVertexBuffer: n3, indexBuffer: s4, uniformValues: o3, terrainData: d3 } = t4.state, f = t4.segments;
    a3.draw(l, u3.TRIANGLES, c3, h, p, le.disabled, o3, d3, r.id, n3, s4, f, r.paint, e53.transform.zoom, i3);
  }
}
function b1(e53, t3, r, i) {
  if (0 !== r.paint.get("heatmap-opacity"))
    if ("offscreen" === e53.renderPass) {
      let a = e53.context, n = a.gl, s3 = he.disabled, o = new De([n.ONE, n.ONE], K.transparent, [true, true, true, true]);
      zC(a, e53, r), a.clear({ color: K.transparent });
      for (let l = 0; l < i.length; l++) {
        let u3 = i[l];
        if (t3.hasRenderableParent(u3))
          continue;
        let c3 = t3.getTile(u3), h = c3.getBucket(r);
        if (!h)
          continue;
        let p = h.programConfigurations.get(r.id), d = e53.useProgram("heatmap", p), { zoom: f } = e53.transform;
        d.draw(a, n.TRIANGLES, Q.disabled, s3, o, le.disabled, G0(u3.posMatrix, c3, f, r.paint.get("heatmap-intensity")), null, r.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, r.paint, e53.transform.zoom, p);
      }
      a.viewport.set([0, 0, e53.width, e53.height]);
    } else
      "translucent" === e53.renderPass && (e53.context.setColorMode(e53.colorModeForRenderPass()), BC(e53, r));
}
function zC(e53, t3, r) {
  let i = e53.gl;
  e53.activeTexture.set(i.TEXTURE1), e53.viewport.set([0, 0, t3.width / 4, t3.height / 4]);
  let a = r.heatmapFbo;
  if (a)
    i.bindTexture(i.TEXTURE_2D, a.colorAttachment.get()), e53.bindFramebuffer.set(a.framebuffer);
  else {
    let n = i.createTexture();
    i.bindTexture(i.TEXTURE_2D, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), a = r.heatmapFbo = e53.createFramebuffer(t3.width / 4, t3.height / 4, false, false), FC(e53, t3, n, a);
  }
}
function FC(e53, t3, r, i) {
  var a, n;
  let s3 = e53.gl, o = null != (a = e53.HALF_FLOAT) ? a : s3.UNSIGNED_BYTE, l = null != (n = e53.RGBA16F) ? n : s3.RGBA;
  s3.texImage2D(s3.TEXTURE_2D, 0, l, t3.width / 4, t3.height / 4, 0, s3.RGBA, o, null), i.colorAttachment.set(r);
}
function BC(e53, t3) {
  let r = e53.context, i = r.gl, a = t3.heatmapFbo;
  if (!a)
    return;
  r.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, a.colorAttachment.get()), r.activeTexture.set(i.TEXTURE1);
  let n = t3.colorRampTexture;
  n || (n = t3.colorRampTexture = new be(r, t3.colorRamp, i.RGBA)), n.bind(i.LINEAR, i.CLAMP_TO_EDGE), e53.useProgram("heatmapTexture").draw(r, i.TRIANGLES, Q.disabled, he.disabled, e53.colorModeForRenderPass(), le.disabled, q0(e53, t3, 0, 1), null, t3.id, e53.viewportBuffer, e53.quadTriangleIndexBuffer, e53.viewportSegments, t3.paint, e53.transform.zoom);
}
function _1(e53, t3, r, i) {
  if ("translucent" !== e53.renderPass)
    return;
  let a = r.paint.get("line-opacity"), n = r.paint.get("line-width");
  if (0 === a.constantOr(1) || 0 === n.constantOr(1))
    return;
  let s3 = e53.depthModeForSublayer(0, Q.ReadOnly), o = e53.colorModeForRenderPass(), l = r.paint.get("line-dasharray"), u3 = r.paint.get("line-pattern"), c3 = u3.constantOr(1), h = r.paint.get("line-gradient"), p = r.getCrossfadeParameters(), d = c3 ? "linePattern" : l ? "lineSDF" : h ? "lineGradient" : "line", f = e53.context, m = f.gl, y = true;
  for (let a3 of i) {
    let i3 = t3.getTile(a3);
    if (c3 && !i3.patternsLoaded())
      continue;
    let n3 = i3.getBucket(r);
    if (!n3)
      continue;
    let g = n3.programConfigurations.get(r.id), _ = e53.context.program.get(), x = e53.useProgram(d, g), v = y || x.program !== _, b = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(a3), w = u3.constantOr(null);
    if (w && i3.imageAtlas) {
      let e54 = i3.imageAtlas, t4 = e54.patternPositions[w.to.toString()], r3 = e54.patternPositions[w.from.toString()];
      t4 && r3 && g.setConstantPatternPositions(t4, r3);
    }
    let S = b ? a3 : null, A = c3 ? Q0(e53, i3, r, p, S) : l ? e1(e53, i3, r, l, p, S) : h ? J0(e53, i3, r, n3.lineClipsArray.length, S) : jl(e53, i3, r, S);
    if (c3)
      f.activeTexture.set(m.TEXTURE0), i3.imageAtlasTexture.bind(m.LINEAR, m.CLAMP_TO_EDGE), g.updatePaintBuffers(p);
    else if (l && (v || e53.lineAtlas.dirty))
      f.activeTexture.set(m.TEXTURE0), e53.lineAtlas.bind(f);
    else if (h) {
      let i4 = n3.gradients[r.id], s4 = i4.texture;
      if (r.gradientVersion !== i4.version) {
        let o3 = 256;
        if (r.stepInterpolant) {
          let r3 = t3.getSource().maxzoom, i5 = a3.canonical.z === r3 ? Math.ceil(1 << e53.transform.maxZoom - a3.canonical.z) : 1;
          o3 = Te(Xy(n3.maxLineLength / 8192 * 1024 * i5), 256, f.maxTextureSize);
        }
        i4.gradient = Ns({ expression: r.gradientExpression(), evaluationKey: "lineProgress", resolution: o3, image: i4.gradient || void 0, clips: n3.lineClipsArray }), i4.texture ? i4.texture.update(i4.gradient) : i4.texture = new be(f, i4.gradient, m.RGBA), i4.version = r.gradientVersion, s4 = i4.texture;
      }
      f.activeTexture.set(m.TEXTURE0), s4.bind(r.stepInterpolant ? m.NEAREST : m.LINEAR, m.CLAMP_TO_EDGE);
    }
    x.draw(f, m.TRIANGLES, s3, e53.stencilModeForClipping(a3), o, le.disabled, A, b, r.id, n3.layoutVertexBuffer, n3.indexBuffer, n3.segments, r.paint, e53.transform.zoom, g, n3.layoutVertexBuffer2), y = false;
  }
}
function Eu(e53, t3, r, i, a) {
  if (!r || !i || !i.imageAtlas)
    return;
  let n = i.imageAtlas.patternPositions, s3 = n[r.to.toString()], o = n[r.from.toString()];
  if (!s3 || !o) {
    let e54 = a.getPaintProperty(t3);
    s3 = n[e54], o = n[e54];
  }
  s3 && o && e53.setConstantPatternPositions(s3, o);
}
function w1(e53, t3, r, i) {
  let a = r.paint.get("fill-color"), n = r.paint.get("fill-opacity");
  if (0 === n.constantOr(1))
    return;
  let s3 = e53.colorModeForRenderPass(), o = r.paint.get("fill-pattern"), l = e53.opaquePassEnabledForLayer() && !o.constantOr(1) && 1 === a.constantOr(K.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent";
  if (e53.renderPass === l) {
    let a3 = e53.depthModeForSublayer(1, "opaque" === e53.renderPass ? Q.ReadWrite : Q.ReadOnly);
    v1(e53, t3, r, i, a3, s3, false);
  }
  if ("translucent" === e53.renderPass && r.paint.get("fill-antialias")) {
    let a3 = e53.depthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, Q.ReadOnly);
    v1(e53, t3, r, i, a3, s3, true);
  }
}
function v1(e53, t3, r, i, a, n, s3) {
  let o, l, u3, c3, h, p = e53.context.gl, d = "fill-pattern", f = r.paint.get(d), m = f && f.constantOr(1), y = r.getCrossfadeParameters();
  s3 ? (l = m && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", o = p.LINES) : (l = m ? "fillPattern" : "fill", o = p.TRIANGLES);
  let g = f.constantOr(null);
  for (let f3 of i) {
    let i3 = t3.getTile(f3);
    if (m && !i3.patternsLoaded())
      continue;
    let _ = i3.getBucket(r);
    if (!_)
      continue;
    let x = _.programConfigurations.get(r.id), v = e53.useProgram(l, x), b = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(f3);
    m && (e53.context.activeTexture.set(p.TEXTURE0), i3.imageAtlasTexture.bind(p.LINEAR, p.CLAMP_TO_EDGE), x.updatePaintBuffers(y)), Eu(x, d, g, i3, r);
    let w = b ? f3 : null, S = w ? w.posMatrix : f3.posMatrix, A = e53.translatePosMatrix(S, i3, r.paint.get("fill-translate"), r.paint.get("fill-translate-anchor"));
    if (s3) {
      c3 = _.indexBuffer2, h = _.segments2;
      let t4 = [p.drawingBufferWidth, p.drawingBufferHeight];
      u3 = "fillOutlinePattern" === l && m ? k0(A, e53, y, i3, t4) : E0(A, t4);
    } else
      c3 = _.indexBuffer, h = _.segments, u3 = m ? od(A, e53, y, i3) : ad(A);
    v.draw(e53.context, o, a, e53.stencilModeForClipping(f3), n, le.disabled, u3, b, r.id, _.layoutVertexBuffer, c3, h, r.paint, e53.transform.zoom, x);
  }
}
function S1(e53, t3, r, i) {
  let a = r.paint.get("fill-extrusion-opacity");
  if (0 !== a && "translucent" === e53.renderPass) {
    let n = new Q(e53.context.gl.LEQUAL, Q.ReadWrite, e53.depthRangeFor3D);
    if (1 !== a || r.paint.get("fill-extrusion-pattern").constantOr(1))
      ny(e53, t3, r, i, n, he.disabled, De.disabled), ny(e53, t3, r, i, n, e53.stencilModeFor3D(), e53.colorModeForRenderPass());
    else {
      let a3 = e53.colorModeForRenderPass();
      ny(e53, t3, r, i, n, he.disabled, a3);
    }
  }
}
function ny(e53, t3, r, i, a, n, s3) {
  let o = e53.context, l = o.gl, u3 = "fill-extrusion-pattern", c3 = r.paint.get(u3), h = c3.constantOr(1), p = r.getCrossfadeParameters(), d = r.paint.get("fill-extrusion-opacity"), f = c3.constantOr(null);
  for (let c4 of i) {
    let i3 = t3.getTile(c4), m = i3.getBucket(r);
    if (!m)
      continue;
    let y = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(c4), g = m.programConfigurations.get(r.id), _ = e53.useProgram(h ? "fillExtrusionPattern" : "fillExtrusion", g);
    h && (e53.context.activeTexture.set(l.TEXTURE0), i3.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), g.updatePaintBuffers(p)), Eu(g, u3, f, i3, r);
    let x = e53.translatePosMatrix(c4.posMatrix, i3, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), v = r.paint.get("fill-extrusion-vertical-gradient"), b = h ? T0(x, e53, v, d, c4, p, i3) : nd(x, e53, v, d);
    _.draw(o, o.gl.TRIANGLES, a, n, s3, le.backCCW, b, y, r.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, r.paint, e53.transform.zoom, g, e53.style.map.terrain && m.centroidVertexBuffer);
  }
}
function P1(e53, t3, r, i) {
  if ("offscreen" !== e53.renderPass && "translucent" !== e53.renderPass)
    return;
  let a = e53.context, n = e53.depthModeForSublayer(0, Q.ReadOnly), s3 = e53.colorModeForRenderPass(), [o, l] = "translucent" === e53.renderPass ? e53.stencilConfigForOverlap(i) : [{}, i];
  for (let i3 of l) {
    let a3 = t3.getTile(i3);
    typeof a3.needsHillshadePrepare < "u" && a3.needsHillshadePrepare && "offscreen" === e53.renderPass ? OC(e53, a3, r, n, he.disabled, s3) : "translucent" === e53.renderPass && RC(e53, i3, a3, r, n, o[i3.overscaledZ], s3);
  }
  a.viewport.set([0, 0, e53.width, e53.height]);
}
function RC(e53, t3, r, i, a, n, s3) {
  let o = e53.context, l = o.gl, u3 = r.fbo;
  if (!u3)
    return;
  let c3 = e53.useProgram("hillshade"), h = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(t3);
  o.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, u3.colorAttachment.get());
  let p = h ? t3 : null;
  c3.draw(o, l.TRIANGLES, a, n, s3, le.disabled, H0(e53, r, i, p), h, i.id, e53.rasterBoundsBuffer, e53.quadTriangleIndexBuffer, e53.rasterBoundsSegments);
}
function OC(e53, t3, r, i, a, n) {
  let s3 = e53.context, o = s3.gl, l = t3.dem;
  if (l && l.data) {
    let u3 = l.dim, c3 = l.stride, h = l.getPixels();
    if (s3.activeTexture.set(o.TEXTURE1), s3.pixelStoreUnpackPremultiplyAlpha.set(false), t3.demTexture = t3.demTexture || e53.getTileTexture(c3), t3.demTexture) {
      let e54 = t3.demTexture;
      e54.update(h, { premultiply: false }), e54.bind(o.NEAREST, o.CLAMP_TO_EDGE);
    } else
      t3.demTexture = new be(s3, h, o.RGBA, { premultiply: false }), t3.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE);
    s3.activeTexture.set(o.TEXTURE0);
    let p = t3.fbo;
    if (!p) {
      let e54 = new be(s3, { width: u3, height: u3, data: null }, o.RGBA);
      e54.bind(o.LINEAR, o.CLAMP_TO_EDGE), p = t3.fbo = s3.createFramebuffer(u3, u3, true, false), p.colorAttachment.set(e54.texture);
    }
    s3.bindFramebuffer.set(p.framebuffer), s3.viewport.set([0, 0, u3, u3]), e53.useProgram("hillshadePrepare").draw(s3, o.TRIANGLES, i, a, n, le.disabled, Z0(t3.tileID, l), null, r.id, e53.rasterBoundsBuffer, e53.quadTriangleIndexBuffer, e53.rasterBoundsSegments), t3.needsHillshadePrepare = false;
  }
}
function T1(e53, t3, r, i) {
  if ("translucent" !== e53.renderPass || 0 === r.paint.get("raster-opacity") || !i.length)
    return;
  let a = e53.context, n = a.gl, s3 = t3.getSource(), o = e53.useProgram("raster"), l = e53.colorModeForRenderPass(), [u3, c3] = s3 instanceof At ? [{}, i] : e53.stencilConfigForOverlap(i), h = c3[c3.length - 1].overscaledZ, p = !e53.options.moving;
  for (let i3 of c3) {
    let c4 = e53.depthModeForSublayer(i3.overscaledZ - h, 1 === r.paint.get("raster-opacity") ? Q.ReadWrite : Q.ReadOnly, n.LESS), d = t3.getTile(i3);
    d.registerFadeDuration(r.paint.get("raster-fade-duration"));
    let f, m, y = t3.findLoadedParent(i3, 0), g = VC(d, y, t3, r, e53.transform, e53.style.map.terrain), _ = "nearest" === r.paint.get("raster-resampling") ? n.NEAREST : n.LINEAR;
    a.activeTexture.set(n.TEXTURE0), d.texture.bind(_, n.CLAMP_TO_EDGE, n.LINEAR_MIPMAP_NEAREST), a.activeTexture.set(n.TEXTURE1), y ? (y.texture.bind(_, n.CLAMP_TO_EDGE, n.LINEAR_MIPMAP_NEAREST), f = Math.pow(2, y.tileID.overscaledZ - d.tileID.overscaledZ), m = [d.tileID.canonical.x * f % 1, d.tileID.canonical.y * f % 1]) : d.texture.bind(_, n.CLAMP_TO_EDGE, n.LINEAR_MIPMAP_NEAREST);
    let x = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(i3), v = x ? i3 : null, b = v ? v.posMatrix : e53.transform.calculatePosMatrix(i3.toUnwrapped(), p), w = n1(b, m || [0, 0], f || 1, g, r);
    s3 instanceof At ? o.draw(a, n.TRIANGLES, c4, he.disabled, l, le.disabled, w, x, r.id, s3.boundsBuffer, e53.quadTriangleIndexBuffer, s3.boundsSegments) : o.draw(a, n.TRIANGLES, c4, u3[i3.overscaledZ], l, le.disabled, w, x, r.id, e53.rasterBoundsBuffer, e53.quadTriangleIndexBuffer, e53.rasterBoundsSegments);
  }
}
function VC(e53, t3, r, i, a, n) {
  let s3 = i.paint.get("raster-fade-duration");
  if (!n && s3 > 0) {
    let i3 = ne.now(), n3 = (i3 - e53.timeAdded) / s3, o = t3 ? (i3 - t3.timeAdded) / s3 : -1, l = r.getSource(), u3 = a.coveringZoomLevel({ tileSize: l.tileSize, roundZoom: l.roundZoom }), c3 = !t3 || Math.abs(t3.tileID.overscaledZ - u3) > Math.abs(e53.tileID.overscaledZ - u3), h = c3 && e53.refreshedUponExpiration ? 1 : Te(c3 ? n3 : 1 - o, 0, 1);
    return e53.refreshedUponExpiration && n3 >= 1 && (e53.refreshedUponExpiration = false), t3 ? { opacity: 1, mix: 1 - h } : { opacity: h, mix: 0 };
  }
  return { opacity: 1, mix: 0 };
}
function A1(e53, t3, r, i) {
  let a = r.paint.get("background-color"), n = r.paint.get("background-opacity");
  if (0 === n)
    return;
  let s3 = e53.context, o = s3.gl, l = e53.transform, u3 = l.tileSize, c3 = r.paint.get("background-pattern");
  if (e53.isPatternMissing(c3))
    return;
  let h = !c3 && 1 === a.a && 1 === n && e53.opaquePassEnabledForLayer() ? "opaque" : "translucent";
  if (e53.renderPass !== h)
    return;
  let p = he.disabled, d = e53.depthModeForSublayer(0, "opaque" === h ? Q.ReadWrite : Q.ReadOnly), f = e53.colorModeForRenderPass(), m = e53.useProgram(c3 ? "backgroundPattern" : "background"), y = i || l.coveringTiles({ tileSize: u3, terrain: e53.style.map.terrain });
  c3 && (s3.activeTexture.set(o.TEXTURE0), e53.imageManager.bind(e53.context));
  let g = r.getCrossfadeParameters();
  for (let t4 of y) {
    let l3 = i ? t4.posMatrix : e53.transform.calculatePosMatrix(t4.toUnwrapped()), h3 = c3 ? h1(l3, n, e53, c3, { tileID: t4, tileSize: u3 }, g) : p1(l3, n, a), y3 = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(t4);
    m.draw(s3, o.TRIANGLES, d, p, f, le.disabled, h3, y3, r.id, e53.tileExtentBuffer, e53.quadTriangleIndexBuffer, e53.tileExtentSegments);
  }
}
q(g1, "drawSymbols"), q(EC, "calculateVariableRenderShift"), q(kC, "updateVariableAnchors"), q(LC, "updateVariableAnchorsForBucket"), q(DC, "getSymbolProgramName"), q(d1, "drawLayerSymbols"), q(y1, "drawSymbolElements"), c(), q(x1, "drawCircles"), c(), q(b1, "drawHeatmap"), q(zC, "bindFramebuffer"), q(FC, "bindTextureToFramebuffer"), q(BC, "renderTextureToMap"), c(), q(_1, "drawLine"), c(), c(), q(Eu, "updatePatternPositionsInProgram"), q(w1, "drawFill"), q(v1, "drawFillTiles"), c(), q(S1, "drawFillExtrusion"), q(ny, "drawExtrusionTiles"), c(), q(P1, "drawHillshade"), q(RC, "renderHillshade"), q(OC, "prepareHillshade"), c(), q(T1, "drawRaster"), q(VC, "getFadeValues"), c(), q(A1, "drawBackground"), c();
var UC = new K(1, 0, 0, 1);
var NC = new K(0, 1, 0, 1);
var GC = new K(0, 0, 1, 1);
var qC = new K(1, 0, 1, 1);
var jC = new K(0, 1, 1, 1);
function C1(e53) {
  let t3 = e53.transform.padding;
  I1(e53, e53.transform.height - (t3.top || 0), 3, UC), I1(e53, t3.bottom || 0, 3, NC), M1(e53, t3.left || 0, 3, GC), M1(e53, e53.transform.width - (t3.right || 0), 3, qC);
  let r = e53.transform.centerPoint;
  $C(e53, r.x, e53.transform.height - r.y, jC);
}
function $C(e53, t3, r, i) {
  ku(e53, t3 - 1, r - 10, 2, 20, i), ku(e53, t3 - 10, r - 1, 20, 2, i);
}
function I1(e53, t3, r, i) {
  ku(e53, 0, t3 + r / 2, e53.transform.width, r, i);
}
function M1(e53, t3, r, i) {
  ku(e53, t3 - r / 2, 0, r, e53.transform.height, i);
}
function ku(e53, t3, r, i, a, n) {
  let s3 = e53.context, o = s3.gl;
  o.enable(o.SCISSOR_TEST), o.scissor(t3 * e53.pixelRatio, r * e53.pixelRatio, i * e53.pixelRatio, a * e53.pixelRatio), s3.clear({ color: n }), o.disable(o.SCISSOR_TEST);
}
function E1(e53, t3, r) {
  for (let i = 0; i < r.length; i++)
    HC(e53, t3, r[i]);
}
function HC(e53, t3, r) {
  let i = e53.context, a = i.gl, n = r.posMatrix, s3 = e53.useProgram("debug"), o = Q.disabled, l = he.disabled, u3 = e53.colorModeForRenderPass(), c3 = "$debug", h = e53.style.map.terrain && e53.style.map.terrain.getTerrainData(r);
  i.activeTexture.set(a.TEXTURE0);
  let p = t3.getTileByID(r.key).latestRawTileData, d = p && p.byteLength || 0, f = Math.floor(d / 1024), m = t3.getTile(r).tileSize, y = 512 / Math.min(m, 512) * (r.overscaledZ / e53.transform.zoom) * 0.5, g = r.canonical.toString();
  r.overscaledZ !== r.canonical.z && (g += " => ".concat(r.overscaledZ)), ZC(e53, "".concat(g, " ").concat(f, "kB")), s3.draw(i, a.TRIANGLES, o, l, De.alphaBlended, le.disabled, sd(n, K.transparent, y), null, c3, e53.debugBuffer, e53.quadTriangleIndexBuffer, e53.debugSegments), s3.draw(i, a.LINE_STRIP, o, l, u3, le.disabled, sd(n, K.red), h, c3, e53.debugBuffer, e53.tileBorderIndexBuffer, e53.debugSegments);
}
function ZC(e53, t3) {
  e53.initDebugOverlayCanvas();
  let r = e53.debugOverlayCanvas, i = e53.context.gl, a = e53.debugOverlayCanvas.getContext("2d");
  a.clearRect(0, 0, r.width, r.height), a.shadowColor = "white", a.shadowBlur = 2, a.lineWidth = 1.5, a.strokeStyle = "white", a.textBaseline = "top", a.font = "bold 36px Open Sans, sans-serif", a.fillText(t3, 5, 5), a.strokeText(t3, 5, 5), e53.debugOverlayTexture.update(r), e53.debugOverlayTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
}
function k1(e53, t3) {
  let r = null, i = Object.values(e53._layers).flatMap((r3) => r3.source && !r3.isHidden(t3) ? [e53.sourceCaches[r3.source]] : []), a = i.filter((e54) => "vector" === e54.getSource().type), n = i.filter((e54) => "vector" !== e54.getSource().type), s3 = q((e54) => {
    (!r || r.getSource().maxzoom < e54.getSource().maxzoom) && (r = e54);
  }, "considerSource");
  return a.forEach((e54) => s3(e54)), r || n.forEach((e54) => s3(e54)), r;
}
function L1(e53, t3, r) {
  let i = e53.context, a = r.implementation;
  if ("offscreen" === e53.renderPass) {
    let t4 = a.prerender;
    t4 && (e53.setCustomLayerDefaults(), i.setColorMode(e53.colorModeForRenderPass()), t4.call(a, i.gl, e53.transform.customLayerMatrix()), i.setDirty(), e53.setBaseState());
  } else if ("translucent" === e53.renderPass) {
    e53.setCustomLayerDefaults(), i.setColorMode(e53.colorModeForRenderPass()), i.setStencilMode(he.disabled);
    let t4 = "3d" === a.renderingMode ? new Q(e53.context.gl.LEQUAL, Q.ReadWrite, e53.depthRangeFor3D) : e53.depthModeForSublayer(0, Q.ReadOnly);
    i.setDepthMode(t4), a.render(i.gl, e53.transform.customLayerMatrix()), i.setDirty(), e53.setBaseState(), i.bindFramebuffer.set(null);
  }
}
function D1(e53, t3) {
  let r = e53.context, i = r.gl, a = De.unblended, n = new Q(i.LEQUAL, Q.ReadWrite, [0, 1]), s3 = t3.getTerrainMesh(), o = t3.sourceCache.getRenderableTiles(), l = e53.useProgram("terrainDepth");
  r.bindFramebuffer.set(t3.getFramebuffer("depth").framebuffer), r.viewport.set([0, 0, e53.width / devicePixelRatio, e53.height / devicePixelRatio]), r.clear({ color: K.transparent, depth: 1 });
  for (let u3 of o) {
    let o3 = t3.getTerrainData(u3.tileID), c3 = e53.transform.calculatePosMatrix(u3.tileID.toUnwrapped()), h = _0(c3, t3.getMeshFrameDelta(e53.transform.zoom));
    l.draw(r, i.TRIANGLES, n, he.disabled, a, le.backCCW, h, o3, "terrain", s3.vertexBuffer, s3.indexBuffer, s3.segments);
  }
  r.bindFramebuffer.set(null), r.viewport.set([0, 0, e53.width, e53.height]);
}
function z1(e53, t3) {
  let r = e53.context, i = r.gl, a = De.unblended, n = new Q(i.LEQUAL, Q.ReadWrite, [0, 1]), s3 = t3.getTerrainMesh(), o = t3.getCoordsTexture(), l = t3.sourceCache.getRenderableTiles(), u3 = e53.useProgram("terrainCoords");
  r.bindFramebuffer.set(t3.getFramebuffer("coords").framebuffer), r.viewport.set([0, 0, e53.width / devicePixelRatio, e53.height / devicePixelRatio]), r.clear({ color: K.transparent, depth: 1 }), t3.coordsIndex = [];
  for (let c3 of l) {
    let l3 = t3.getTerrainData(c3.tileID);
    r.activeTexture.set(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, o.texture);
    let h = e53.transform.calculatePosMatrix(c3.tileID.toUnwrapped()), p = v0(h, 255 - t3.coordsIndex.length, t3.getMeshFrameDelta(e53.transform.zoom));
    u3.draw(r, i.TRIANGLES, n, he.disabled, a, le.backCCW, p, l3, "terrain", s3.vertexBuffer, s3.indexBuffer, s3.segments), t3.coordsIndex.push(c3.tileID.key);
  }
  r.bindFramebuffer.set(null), r.viewport.set([0, 0, e53.width, e53.height]);
}
function ay(e53, t3, r) {
  let i = e53.context, a = i.gl, n = e53.colorModeForRenderPass(), s3 = new Q(a.LEQUAL, Q.ReadWrite, e53.depthRangeFor3D), o = e53.useProgram("terrain"), l = t3.getTerrainMesh();
  i.bindFramebuffer.set(null), i.viewport.set([0, 0, e53.width, e53.height]);
  for (let u3 of r) {
    let r3 = e53.renderToTexture.getTexture(u3), c3 = t3.getTerrainData(u3.tileID);
    i.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, r3.texture);
    let h = e53.transform.calculatePosMatrix(u3.tileID.toUnwrapped()), p = b0(h, t3.getMeshFrameDelta(e53.transform.zoom));
    o.draw(i, a.TRIANGLES, s3, he.disabled, n, le.backCCW, p, c3, "terrain", l.vertexBuffer, l.indexBuffer, l.segments);
  }
}
q(C1, "drawDebugPadding"), q($C, "drawCrosshair"), q(I1, "drawHorizontalLine"), q(M1, "drawVerticalLine"), q(ku, "drawDebugSSRect"), q(E1, "drawDebug"), q(HC, "drawDebugTile"), q(ZC, "drawTextToOverlay"), q(k1, "selectDebugSource"), c(), q(L1, "drawCustom"), c(), q(D1, "drawDepth"), q(z1, "drawCoords"), q(ay, "drawTerrain");
var oy = class {
  constructor(e53, t3) {
    this.context = new Mu(e53), this.transform = t3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: q3.create(), renderTime: 0 }, this.setup(), this.numSublayers = or.maxUnderzooming + or.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new xn();
  }
  resize(e53, t3, r) {
    if (this.width = Math.floor(e53 * r), this.height = Math.floor(t3 * r), this.pixelRatio = r, this.context.viewport.set([0, 0, this.width, this.height]), this.setupRemoteFrameRendering(this.width, this.height), this.style)
      for (let e54 of this.style._order)
        this.style._layers[e54].resize();
  }
  setup() {
    let e53 = this.context, t3 = new Pr();
    t3.emplaceBack(0, 0), t3.emplaceBack(8192, 0), t3.emplaceBack(0, 8192), t3.emplaceBack(8192, 8192), this.tileExtentBuffer = e53.createVertexBuffer(t3, Vl.members), this.tileExtentSegments = me.simpleSegment(0, 0, 4, 2);
    let r = new Pr();
    r.emplaceBack(0, 0), r.emplaceBack(8192, 0), r.emplaceBack(0, 8192), r.emplaceBack(8192, 8192), this.debugBuffer = e53.createVertexBuffer(r, Vl.members), this.debugSegments = me.simpleSegment(0, 0, 4, 5);
    let i = new Hi();
    i.emplaceBack(0, 0, 0, 0), i.emplaceBack(8192, 0, 8192, 0), i.emplaceBack(0, 8192, 0, 8192), i.emplaceBack(8192, 8192, 8192, 8192), this.rasterBoundsBuffer = e53.createVertexBuffer(i, zr.members), this.rasterBoundsSegments = me.simpleSegment(0, 0, 4, 2);
    let a = new Pr();
    a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e53.createVertexBuffer(a, Vl.members), this.viewportSegments = me.simpleSegment(0, 0, 4, 2);
    let n = new va();
    n.emplaceBack(0), n.emplaceBack(1), n.emplaceBack(3), n.emplaceBack(2), n.emplaceBack(0), this.tileBorderIndexBuffer = e53.createIndexBuffer(n);
    let s3 = new nt();
    s3.emplaceBack(0, 1, 2), s3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e53.createIndexBuffer(s3);
    let o = this.context.gl;
    this.stencilClearMode = new he({ func: o.ALWAYS, mask: 0 }, 0, 255, o.ZERO, o.ZERO, o.ZERO), this.setupRemoteFrameRendering(this.width, this.height);
  }
  setupRemoteFrameRendering(e53, t3) {
    if (null == e53 || null == t3)
      return;
    let r = this.context.gl;
    r.bindFramebuffer(r.FRAMEBUFFER, null), this.webGLRenderTargetFrameBuffer && (r.deleteFramebuffer(this.webGLRenderTargetFrameBuffer), r.deleteRenderbuffer(this.webGLRenderTargetRenderBuffer), r.deleteTexture(this.webGLRenderTargetTexture)), this.webGLRenderTargetFrameBuffer = r.createFramebuffer(), this.webGLRenderTargetRenderBuffer = r.createRenderbuffer(), r.bindFramebuffer(r.FRAMEBUFFER, this.webGLRenderTargetFrameBuffer), this.webGLRenderTargetTexture = r.createTexture(), r.bindTexture(r.TEXTURE_2D, this.webGLRenderTargetTexture), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, e53, t3, 0, r.RGBA, r.UNSIGNED_BYTE, null), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, this.webGLRenderTargetTexture, 0), r.bindRenderbuffer(r.RENDERBUFFER, this.webGLRenderTargetRenderBuffer), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, e53, t3), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, this.webGLRenderTargetRenderBuffer), r.checkFramebufferStatus(r.FRAMEBUFFER) !== r.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is not complete");
  }
  clearStencil() {
    let e53 = this.context, t3 = e53.gl;
    this.nextStencilID = 1, this.currentStencilSource = void 0;
    let r = q3.create();
    q3.ortho(r, 0, this.width, this.height, 0, 0, 1), q3.scale(r, r, [t3.drawingBufferWidth, t3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e53, t3.TRIANGLES, Q.disabled, this.stencilClearMode, De.disabled, le.disabled, ld(r), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
  }
  _renderTileClippingMasks(e53, t3) {
    if (this.currentStencilSource === e53.source || !e53.isTileClipped() || !t3 || !t3.length)
      return;
    this.currentStencilSource = e53.source;
    let r = this.context, i = r.gl;
    this.nextStencilID + t3.length > 256 && this.clearStencil(), r.setColorMode(De.disabled), r.setDepthMode(Q.disabled);
    let a = this.useProgram("clippingMask");
    this._tileClippingMaskIDs = {};
    for (let e54 of t3) {
      let t4 = this._tileClippingMaskIDs[e54.key] = this.nextStencilID++, n = this.style.map.terrain && this.style.map.terrain.getTerrainData(e54);
      a.draw(r, i.TRIANGLES, Q.disabled, new he({ func: i.ALWAYS, mask: 0 }, t4, 255, i.KEEP, i.KEEP, i.REPLACE), De.disabled, le.disabled, ld(e54.posMatrix), n, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
    }
  }
  stencilModeFor3D() {
    this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
    let e53 = this.nextStencilID++, t3 = this.context.gl;
    return new he({ func: t3.NOTEQUAL, mask: 255 }, e53, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
  }
  stencilModeForClipping(e53) {
    let t3 = this.context.gl;
    return new he({ func: t3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e53.key], 0, t3.KEEP, t3.KEEP, t3.REPLACE);
  }
  stencilConfigForOverlap(e53) {
    let t3 = this.context.gl, r = e53.sort((e54, t4) => t4.overscaledZ - e54.overscaledZ), i = r[r.length - 1].overscaledZ, a = r[0].overscaledZ - i + 1;
    if (a > 1) {
      this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();
      let e54 = {};
      for (let r3 = 0; r3 < a; r3++)
        e54[r3 + i] = new he({ func: t3.GEQUAL, mask: 255 }, r3 + this.nextStencilID, 255, t3.KEEP, t3.KEEP, t3.REPLACE);
      return this.nextStencilID += a, [e54, r];
    }
    return [{ [i]: he.disabled }, r];
  }
  colorModeForRenderPass() {
    let e53 = this.context.gl;
    return this._showOverdrawInspector ? new De([e53.CONSTANT_COLOR, e53.ONE], new K(0.125, 0.125, 0.125, 0), [true, true, true, true]) : "opaque" === this.renderPass ? De.unblended : De.alphaBlended;
  }
  depthModeForSublayer(e53, t3, r) {
    if (!this.opaquePassEnabledForLayer())
      return Q.disabled;
    let i = 1 - ((1 + this.currentLayer) * this.numSublayers + e53) * this.depthEpsilon;
    return new Q(r || this.context.gl.LEQUAL, t3, [i, i]);
  }
  opaquePassEnabledForLayer() {
    return this.currentLayer < this.opaquePassCutoff;
  }
  render(e53, t3) {
    this.style = e53, this.options = t3, this.lineAtlas = e53.lineAtlas, this.imageManager = e53.imageManager, this.glyphManager = e53.glyphManager, this.symbolFadeChange = e53.placement.symbolFadeChange(ne.now()), this.imageManager.beginFrame();
    let r = this.style._order, i = this.style.sourceCaches, a = {}, n = {}, s3 = {};
    for (let e54 in i) {
      let t4 = i[e54];
      t4.used && t4.prepare(this.context), a[e54] = t4.getVisibleCoordinates(), n[e54] = a[e54].slice().reverse(), s3[e54] = t4.getVisibleCoordinates(true).reverse();
    }
    this.opaquePassCutoff = 1 / 0;
    for (let e54 = 0; e54 < r.length; e54++) {
      let t4 = r[e54];
      if (this.style._layers[t4].is3D()) {
        this.opaquePassCutoff = e54;
        break;
      }
    }
    if (this.renderToTexture) {
      this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
      let e54 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
      (this.terrainFacilitator.dirty || !q3.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e54.length) && (q3.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, D1(this, this.style.map.terrain), z1(this, this.style.map.terrain));
    }
    this.renderPass = "offscreen";
    for (let e54 of r) {
      let t4 = this.style._layers[e54];
      if (!t4.hasOffscreenPass() || t4.isHidden(this.transform.zoom))
        continue;
      let r3 = n[t4.source];
      "custom" !== t4.type && !r3.length || this.renderLayer(this, i[t4.source], t4, r3);
    }
    if (this.context.bindFramebuffer.set(this.webGLRenderTargetFrameBuffer), this.context.clear({ color: t3.showOverdrawInspector ? K.black : K.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = t3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e53._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
      for (this.renderPass = "opaque", this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--) {
        let e54 = this.style._layers[r[this.currentLayer]], t4 = i[e54.source], n3 = a[e54.source];
        this._renderTileClippingMasks(e54, n3), this.renderLayer(this, t4, e54, n3);
      }
    for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++) {
      let e54 = this.style._layers[r[this.currentLayer]], t4 = i[e54.source];
      if (this.renderToTexture && this.renderToTexture.renderLayer(e54))
        continue;
      let o = ("symbol" === e54.type ? s3 : n)[e54.source];
      this._renderTileClippingMasks(e54, a[e54.source]), this.renderLayer(this, t4, e54, o);
    }
    if (this.options.showTileBoundaries) {
      let e54 = k1(this.style, this.transform.zoom);
      e54 && E1(this, e54, e54.getVisibleCoordinates());
    }
    this.options.showPadding && C1(this), this.context.setDefault(), this.setCustomLayerDefaults(), this.context.gl.bindFramebuffer(this.context.gl.FRAMEBUFFER, null);
  }
  renderLayer(e53, t3, r, i) {
    if (!r.isHidden(this.transform.zoom) && ("background" === r.type || "custom" === r.type || (i || []).length))
      switch (this.id = r.id, r.type) {
        case "symbol":
          g1(e53, t3, r, i, this.style.placement.variableOffsets);
          break;
        case "circle":
          x1(e53, t3, r, i);
          break;
        case "heatmap":
          b1(e53, t3, r, i);
          break;
        case "line":
          _1(e53, t3, r, i);
          break;
        case "fill":
          w1(e53, t3, r, i);
          break;
        case "fill-extrusion":
          S1(e53, t3, r, i);
          break;
        case "hillshade":
          P1(e53, t3, r, i);
          break;
        case "raster":
          T1(e53, t3, r, i);
          break;
        case "background":
          A1(e53, t3, r, i);
          break;
        case "custom":
          L1(e53, t3, r);
      }
  }
  translatePosMatrix(e53, t3, r, i, a) {
    if (!r[0] && !r[1])
      return e53;
    let n = a ? "map" === i ? this.transform.angle : 0 : "viewport" === i ? -this.transform.angle : 0;
    if (n) {
      let e54 = Math.sin(n), t4 = Math.cos(n);
      r = [r[0] * t4 - r[1] * e54, r[0] * e54 + r[1] * t4];
    }
    let s3 = [a ? r[0] : Ke(t3, r[0], this.transform.zoom), a ? r[1] : Ke(t3, r[1], this.transform.zoom), 0], o = new Float32Array(16);
    return q3.translate(o, e53, s3), o;
  }
  saveTileTexture(e53) {
    let t3 = this._tileTextures[e53.size[0]];
    t3 ? t3.push(e53) : this._tileTextures[e53.size[0]] = [e53];
  }
  getTileTexture(e53) {
    let t3 = this._tileTextures[e53];
    return t3 && t3.length > 0 ? t3.pop() : null;
  }
  isPatternMissing(e53) {
    if (!e53)
      return false;
    if (!e53.from || !e53.to)
      return true;
    let t3 = this.imageManager.getPattern(e53.from.toString()), r = this.imageManager.getPattern(e53.to.toString());
    return !t3 || !r;
  }
  useProgram(e53, t3) {
    this.cache = this.cache || {};
    let r = e53 + (t3 ? t3.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
    return this.cache[r] || (this.cache[r] = new Gl(this.context, xi[e53], t3, f1[e53], this._showOverdrawInspector, this.style.map.terrain)), this.cache[r];
  }
  setCustomLayerDefaults() {
    this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
  }
  setBaseState() {
    let e53 = this.context.gl;
    this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e53.FUNC_ADD);
  }
  initDebugOverlayCanvas() {
    if (null == this.debugOverlayCanvas) {
      this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512;
      let e53 = this.context.gl;
      this.debugOverlayTexture = new be(this.context, this.debugOverlayCanvas, e53.RGBA);
    }
  }
  destroy() {
    this.debugOverlayTexture && this.debugOverlayTexture.destroy();
  }
  overLimit() {
    let { drawingBufferWidth: e53, drawingBufferHeight: t3 } = this.context.gl;
    return this.width !== e53 || this.height !== t3;
  }
};
q(oy, "Painter");
var Lu = oy;
c();
var Ge = u(Pe(), 1);
c();
var zu = class e49 {
  constructor(e53, t3) {
    this.points = e53, this.planes = t3;
  }
  static fromInvProjectionMatrix(t3, r, i) {
    let a = Math.pow(2, i), n = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((e53) => {
      let i3 = 1 / (e53 = Xe.transformMat4([], e53, t3))[3] / r * a;
      return Xe.mul(e53, e53, [i3, i3, 1 / e53[3], i3]);
    }), s3 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e53) => {
      let t4 = gt.sub([], n[e53[0]], n[e53[1]]), r3 = gt.sub([], n[e53[2]], n[e53[1]]), i3 = gt.normalize([], gt.cross([], t4, r3)), a3 = -gt.dot(i3, n[e53[1]]);
      return i3.concat(a3);
    });
    return new e49(n, s3);
  }
};
q(zu, "Frustum");
var Du = zu;
var Fu = class e50 {
  constructor(e53, t3) {
    this.min = e53, this.max = t3, this.center = gt.scale([], gt.add([], this.min, this.max), 0.5);
  }
  quadrant(t3) {
    let r = [t3 % 2 == 0, t3 < 2], i = gt.clone(this.min), a = gt.clone(this.max);
    for (let e53 = 0; e53 < r.length; e53++)
      i[e53] = r[e53] ? this.min[e53] : this.center[e53], a[e53] = r[e53] ? this.center[e53] : this.max[e53];
    return a[2] = this.max[2], new e50(i, a);
  }
  distanceX(e53) {
    return Math.max(Math.min(this.max[0], e53[0]), this.min[0]) - e53[0];
  }
  distanceY(e53) {
    return Math.max(Math.min(this.max[1], e53[1]), this.min[1]) - e53[1];
  }
  intersects(e53) {
    let t3 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]], r = true;
    for (let i = 0; i < e53.planes.length; i++) {
      let a = e53.planes[i], n = 0;
      for (let e54 = 0; e54 < t3.length; e54++)
        Xe.dot(a, t3[e54]) >= 0 && n++;
      if (0 === n)
        return 0;
      n !== t3.length && (r = false);
    }
    if (r)
      return 2;
    for (let t4 = 0; t4 < 3; t4++) {
      let r3 = Number.MAX_VALUE, i = -Number.MAX_VALUE;
      for (let a = 0; a < e53.points.length; a++) {
        let n = e53.points[a][t4] - this.min[t4];
        r3 = Math.min(r3, n), i = Math.max(i, n);
      }
      if (i < 0 || r3 > this.max[t4] - this.min[t4])
        return 0;
    }
    return 1;
  }
};
q(Fu, "Aabb");
var io = Fu;
c();
var F1 = u(Pe(), 1);
var Ru = class e51 {
  constructor(e53 = 0, t3 = 0, r = 0, i = 0) {
    if (isNaN(e53) || e53 < 0 || isNaN(t3) || t3 < 0 || isNaN(r) || r < 0 || isNaN(i) || i < 0)
      throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
    this.top = e53, this.bottom = t3, this.left = r, this.right = i;
  }
  interpolate(e53, t3, r) {
    return null != t3.top && null != e53.top && (this.top = ke.number(e53.top, t3.top, r)), null != t3.bottom && null != e53.bottom && (this.bottom = ke.number(e53.bottom, t3.bottom, r)), null != t3.left && null != e53.left && (this.left = ke.number(e53.left, t3.left, r)), null != t3.right && null != e53.right && (this.right = ke.number(e53.right, t3.right, r)), this;
  }
  getCenter(e53, t3) {
    let r = Te((this.left + e53 - this.right) / 2, 0, e53), i = Te((this.top + t3 - this.bottom) / 2, 0, t3);
    return new F1.default(r, i);
  }
  equals(e53) {
    return this.top === e53.top && this.bottom === e53.bottom && this.left === e53.left && this.right === e53.right;
  }
  clone() {
    return new e51(this.top, this.bottom, this.left, this.right);
  }
  toJSON() {
    return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
  }
};
q(Ru, "EdgeInsets");
var Bu = Ru;
var Vu = class e52 {
  constructor(e53, t3, r, i, a) {
    this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = false, this._renderWorldCopies = void 0 === a || !!a, this._minZoom = e53 || 0, this._maxZoom = t3 || 22, this._minPitch = null == r ? 0 : r, this._maxPitch = null == i ? 60 : i, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new re(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.698132, this._pitch = 0, this._unmodified = true, this._edgeInsets = new Bu(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
  }
  clone() {
    let t3 = new e52(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
    return t3.apply(this), t3;
  }
  apply(e53) {
    this.tileSize = e53.tileSize, this.latRange = e53.latRange, this.width = e53.width, this.height = e53.height, this._center = e53._center, this._elevation = e53._elevation, this.zoom = e53.zoom, this.angle = e53.angle, this._fov = e53._fov, this._pitch = e53._pitch, this._unmodified = e53._unmodified, this._edgeInsets = e53._edgeInsets.clone(), this._calcMatrices();
  }
  get minZoom() {
    return this._minZoom;
  }
  set minZoom(e53) {
    this._minZoom !== e53 && (this._minZoom = e53, this.zoom = Math.max(this.zoom, e53));
  }
  get maxZoom() {
    return this._maxZoom;
  }
  set maxZoom(e53) {
    this._maxZoom !== e53 && (this._maxZoom = e53, this.zoom = Math.min(this.zoom, e53));
  }
  get minPitch() {
    return this._minPitch;
  }
  set minPitch(e53) {
    this._minPitch !== e53 && (this._minPitch = e53, this.pitch = Math.max(this.pitch, e53));
  }
  get maxPitch() {
    return this._maxPitch;
  }
  set maxPitch(e53) {
    this._maxPitch !== e53 && (this._maxPitch = e53, this.pitch = Math.min(this.pitch, e53));
  }
  get renderWorldCopies() {
    return this._renderWorldCopies;
  }
  set renderWorldCopies(e53) {
    void 0 === e53 ? e53 = true : null === e53 && (e53 = false), this._renderWorldCopies = e53;
  }
  get worldSize() {
    return this.tileSize * this.scale;
  }
  get centerOffset() {
    return this.centerPoint._sub(this.size._div(2));
  }
  get size() {
    return new Ge.default(this.width, this.height);
  }
  get bearing() {
    return -this.angle / Math.PI * 180;
  }
  set bearing(e53) {
    let t3 = -Yt(e53, -180, 180) * Math.PI / 180;
    this.angle !== t3 && (this._unmodified = false, this.angle = t3, this._calcMatrices(), this.rotationMatrix = Ta.create(), Ta.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
  }
  get pitch() {
    return this._pitch / Math.PI * 180;
  }
  set pitch(e53) {
    let t3 = Te(e53, this.minPitch, this.maxPitch) / 180 * Math.PI;
    this._pitch !== t3 && (this._unmodified = false, this._pitch = t3, this._calcMatrices());
  }
  get fov() {
    return this._fov / Math.PI * 180;
  }
  set fov(e53) {
    e53 = Math.max(0.01, Math.min(60, e53)), this._fov !== e53 && (this._unmodified = false, this._fov = e53 / 180 * Math.PI, this._calcMatrices());
  }
  get zoom() {
    return this._zoom;
  }
  set zoom(e53) {
    let t3 = Math.min(Math.max(e53, this.minZoom), this.maxZoom);
    this._zoom !== t3 && (this._unmodified = false, this._zoom = t3, this.tileZoom = Math.max(0, Math.floor(t3)), this.scale = this.zoomScale(t3), this._constrain(), this._calcMatrices());
  }
  get center() {
    return this._center;
  }
  set center(e53) {
    e53.lat === this._center.lat && e53.lng === this._center.lng || (this._unmodified = false, this._center = e53, this._constrain(), this._calcMatrices());
  }
  get elevation() {
    return this._elevation;
  }
  set elevation(e53) {
    e53 !== this._elevation && (this._elevation = e53, this._constrain(), this._calcMatrices());
  }
  get padding() {
    return this._edgeInsets.toJSON();
  }
  set padding(e53) {
    this._edgeInsets.equals(e53) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e53, 1), this._calcMatrices());
  }
  get centerPoint() {
    return this._edgeInsets.getCenter(this.width, this.height);
  }
  isPaddingEqual(e53) {
    return this._edgeInsets.equals(e53);
  }
  interpolatePadding(e53, t3, r) {
    this._unmodified = false, this._edgeInsets.interpolate(e53, t3, r), this._constrain(), this._calcMatrices();
  }
  coveringZoomLevel(e53) {
    let t3 = (e53.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e53.tileSize));
    return Math.max(0, t3);
  }
  getVisibleUnwrappedCoordinates(e53) {
    let t3 = [new un(0, e53)];
    if (this._renderWorldCopies) {
      let r = this.pointCoordinate(new Ge.default(0, 0)), i = this.pointCoordinate(new Ge.default(this.width, 0)), a = this.pointCoordinate(new Ge.default(this.width, this.height)), n = this.pointCoordinate(new Ge.default(0, this.height)), s3 = Math.floor(Math.min(r.x, i.x, a.x, n.x)), o = Math.floor(Math.max(r.x, i.x, a.x, n.x)), l = 1;
      for (let r3 = s3 - l; r3 <= o + l; r3++)
        0 !== r3 && t3.push(new un(r3, e53));
    }
    return t3;
  }
  coveringTiles(e53) {
    var t3, r;
    let i = this.coveringZoomLevel(e53), a = i;
    if (void 0 !== e53.minzoom && i < e53.minzoom)
      return [];
    void 0 !== e53.maxzoom && i > e53.maxzoom && (i = e53.maxzoom);
    let n = this.pointCoordinate(this.getCameraPoint()), s3 = ze.fromLngLat(this.center), o = Math.pow(2, i), l = [o * n.x, o * n.y, 0], c3 = [o * s3.x, o * s3.y, 0], h = Du.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i), p = e53.minzoom || 0;
    !e53.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (p = i);
    let d = e53.terrain ? 2 / Math.min(this.tileSize, e53.tileSize) * this.tileSize : 3, f = q((e54) => ({ aabb: new io([e54 * o, 0, 0], [(e54 + 1) * o, o, 0]), zoom: 0, x: 0, y: 0, wrap: e54, fullyVisible: false }), "newRootTile"), m = [], y = [], g = i, _ = e53.reparseOverscaled ? a : i;
    if (this._renderWorldCopies)
      for (let e54 = 1; e54 <= 3; e54++)
        m.push(f(-e54)), m.push(f(e54));
    for (m.push(f(0)); m.length > 0; ) {
      let i3 = m.pop(), a3 = i3.x, n3 = i3.y, s4 = i3.fullyVisible;
      if (!s4) {
        let e54 = i3.aabb.intersects(h);
        if (0 === e54)
          continue;
        s4 = 2 === e54;
      }
      let o3 = e53.terrain ? l : c3, u3 = i3.aabb.distanceX(o3), f3 = i3.aabb.distanceY(o3), x = Math.max(Math.abs(u3), Math.abs(f3)), v = d + (1 << g - i3.zoom) - 2;
      if (i3.zoom === g || x > v && i3.zoom >= p) {
        let e54 = g - i3.zoom, t4 = l[0] - 0.5 - (a3 << e54), r3 = l[1] - 0.5 - (n3 << e54);
        y.push({ tileID: new rt(i3.zoom === g ? _ : i3.zoom, i3.wrap, i3.zoom, a3, n3), distanceSq: Xi.sqrLen([c3[0] - 0.5 - a3, c3[1] - 0.5 - n3]), tileDistanceToCamera: Math.sqrt(t4 * t4 + r3 * r3) });
      } else
        for (let o4 = 0; o4 < 4; o4++) {
          let l3 = (a3 << 1) + o4 % 2, u4 = (n3 << 1) + (o4 >> 1), c4 = i3.zoom + 1, h3 = i3.aabb.quadrant(o4);
          if (e53.terrain) {
            let a4 = new rt(c4, i3.wrap, c4, l3, u4), n4 = e53.terrain.getMinMaxElevation(a4), s5 = null != (t3 = n4.minElevation) ? t3 : this.elevation, o5 = null != (r = n4.maxElevation) ? r : this.elevation;
            h3 = new io([h3.min[0], h3.min[1], s5], [h3.max[0], h3.max[1], o5]);
          }
          m.push({ aabb: h3, zoom: c4, x: l3, y: u4, wrap: i3.wrap, fullyVisible: s4 });
        }
    }
    return y.sort((e54, t4) => e54.distanceSq - t4.distanceSq).map((e54) => e54.tileID);
  }
  resize(e53, t3) {
    this.width = e53, this.height = t3, this.pixelsToGLUnits = [2 / e53, -2 / t3], this._constrain(), this._calcMatrices();
  }
  get unmodified() {
    return this._unmodified;
  }
  zoomScale(e53) {
    return Math.pow(2, e53);
  }
  scaleZoom(e53) {
    return Math.log(e53) / Math.LN2;
  }
  project(e53) {
    let t3 = Te(e53.lat, -this.maxValidLatitude, this.maxValidLatitude);
    return new Ge.default(kr(e53.lng) * this.worldSize, Lr(t3) * this.worldSize);
  }
  calculateZMercatorFromAltitude(e53) {
    let { lat: t3 } = this.center, r = mi, i = this.tileSize, a = t3 * Math.PI / 180, n = (e53 + r) / (2 * Math.cos(a) * Math.PI * r / (i * Math.pow(2, 20))), s3 = Math.log2(i / n);
    return Math.abs(s3);
  }
  unproject(e53) {
    return new ze(e53.x / this.worldSize, e53.y / this.worldSize).toLngLat();
  }
  get point() {
    return this.project(this.center);
  }
  updateElevation(e53) {
    this.freezeElevation || (this.elevation = this.getElevation());
  }
  getElevation(e53, t3) {
    let r = ze.fromLngLat(e53.wrap()), i = 8192 * (1 << this.tileZoom), a = r.x * i, n = r.y * i, s3 = Math.floor(a / 8192), o = Math.floor(n / 8192), l = new rt(this.tileZoom, 0, this.tileZoom, s3, o);
    return t3.getElevation(l, a % 8192, n % 8192, 8192);
  }
  getCameraPosition() {
    return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
  }
  recalculateZoom(e53) {
    let t3 = this.pointLocation(this.centerPoint, e53), r = this.getElevation(t3, e53);
    if (!(this.elevation - r))
      return;
    let i = this.getCameraPosition(), a = ze.fromLngLat(i.lngLat, i.altitude), n = ze.fromLngLat(t3, r), s3 = a.x - n.x, o = a.y - n.y, l = a.z - n.z, u3 = Math.sqrt(s3 * s3 + o * o + l * l), c3 = this.scaleZoom(this.cameraToCenterDistance / u3 / this.tileSize);
    this._elevation = r, this._center = t3, this.zoom = c3;
  }
  setLocationAtPoint(e53, t3) {
    let r = this.pointCoordinate(t3), i = this.pointCoordinate(this.centerPoint), a = this.locationCoordinate(e53), n = new ze(a.x - (r.x - i.x), a.y - (r.y - i.y));
    this.center = this.coordinateLocation(n), this._renderWorldCopies && (this.center = this.center.wrap());
  }
  locationPoint(e53, t3) {
    return t3 ? this.coordinatePoint(this.locationCoordinate(e53), this.getElevation(e53, t3), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(e53));
  }
  pointLocation(e53, t3) {
    return this.coordinateLocation(this.pointCoordinate(e53, t3));
  }
  locationCoordinate(e53) {
    return ze.fromLngLat(e53);
  }
  coordinateLocation(e53) {
    return e53 && e53.toLngLat();
  }
  pointCoordinate(e53, t3) {
    if (t3) {
      let r3 = t3.pointCoordinate(e53);
      if (null != r3)
        return r3;
    }
    let r = [e53.x, e53.y, 0, 1], i = [e53.x, e53.y, 1, 1];
    Xe.transformMat4(r, r, this.pixelMatrixInverse), Xe.transformMat4(i, i, this.pixelMatrixInverse);
    let a = r[3], n = i[3], s3 = r[0] / a, o = i[0] / n, l = r[1] / a, u3 = i[1] / n, c3 = r[2] / a, h = i[2] / n, p = c3 === h ? 0 : (0 - c3) / (h - c3);
    return new ze(ke.number(s3, o, p) / this.worldSize, ke.number(l, u3, p) / this.worldSize);
  }
  coordinatePoint(e53, t3 = 0, r = this.pixelMatrix) {
    let i = [e53.x * this.worldSize, e53.y * this.worldSize, t3, 1];
    return Xe.transformMat4(i, i, r), new Ge.default(i[0] / i[3], i[1] / i[3]);
  }
  getBounds() {
    let e53 = Math.max(0, this.height / 2 - this.getHorizon());
    return new lt().extend(this.pointLocation(new Ge.default(0, e53))).extend(this.pointLocation(new Ge.default(this.width, e53))).extend(this.pointLocation(new Ge.default(this.width, this.height))).extend(this.pointLocation(new Ge.default(0, this.height)));
  }
  getMaxBounds() {
    return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new lt([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
  }
  getHorizon() {
    return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
  }
  setMaxBounds(e53) {
    e53 ? (this.lngRange = [e53.getWest(), e53.getEast()], this.latRange = [e53.getSouth(), e53.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
  }
  calculatePosMatrix(e53, t3 = false) {
    let r = e53.key, i = t3 ? this._alignedPosMatrixCache : this._posMatrixCache;
    if (i[r])
      return i[r];
    let a = e53.canonical, n = this.worldSize / this.zoomScale(a.z), s3 = a.x + Math.pow(2, a.z) * e53.wrap, o = q3.identity(new Float64Array(16));
    return q3.translate(o, o, [s3 * n, a.y * n, 0]), q3.scale(o, o, [n / 8192, n / 8192, 1]), q3.multiply(o, t3 ? this.alignedProjMatrix : this.projMatrix, o), i[r] = new Float32Array(o), i[r];
  }
  customLayerMatrix() {
    return this.mercatorMatrix.slice();
  }
  _constrain() {
    if (!this.center || !this.width || !this.height || this._constraining)
      return;
    this._constraining = true;
    let e53, t3, r, i, a = -90, n = 90, s3 = -180, o = 180, l = this.size, u3 = this._unmodified;
    if (this.latRange) {
      let t4 = this.latRange;
      a = Lr(t4[1]) * this.worldSize, n = Lr(t4[0]) * this.worldSize, e53 = n - a < l.y ? l.y / (n - a) : 0;
    }
    if (this.lngRange) {
      let e54 = this.lngRange;
      s3 = Yt(kr(e54[0]) * this.worldSize, 0, this.worldSize), o = Yt(kr(e54[1]) * this.worldSize, 0, this.worldSize), o < s3 && (o += this.worldSize), t3 = o - s3 < l.x ? l.x / (o - s3) : 0;
    }
    let c3 = this.point, h = Math.max(t3 || 0, e53 || 0);
    if (h)
      return this.center = this.unproject(new Ge.default(t3 ? (o + s3) / 2 : c3.x, e53 ? (n + a) / 2 : c3.y)), this.zoom += this.scaleZoom(h), this._unmodified = u3, void (this._constraining = false);
    if (this.latRange) {
      let e54 = c3.y, t4 = l.y / 2;
      e54 - t4 < a && (i = a + t4), e54 + t4 > n && (i = n - t4);
    }
    if (this.lngRange) {
      let e54 = (s3 + o) / 2, t4 = Yt(c3.x, e54 - this.worldSize / 2, e54 + this.worldSize / 2), i3 = l.x / 2;
      t4 - i3 < s3 && (r = s3 + i3), t4 + i3 > o && (r = o - i3);
    }
    (void 0 !== r || void 0 !== i) && (this.center = this.unproject(new Ge.default(void 0 !== r ? r : c3.x, void 0 !== i ? i : c3.y)).wrap()), this._unmodified = u3, this._constraining = false;
  }
  _calcMatrices() {
    if (!this.height)
      return;
    let e53 = this._fov / 2, t3 = this.centerOffset, r = this.point.x, i = this.point.y;
    this.cameraToCenterDistance = 0.5 / Math.tan(e53) * this.height, this._pixelPerMeter = Qf(1, this.center.lat) * this.worldSize;
    let a = q3.identity(new Float64Array(16));
    q3.scale(a, a, [this.width / 2, -this.height / 2, 1]), q3.translate(a, a, [1, -1, 0]), this.labelPlaneMatrix = a, a = q3.identity(new Float64Array(16)), q3.scale(a, a, [1, -1, 1]), q3.translate(a, a, [-1, -1, 0]), q3.scale(a, a, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
    let n = this._elevation < 0 ? this.cameraToCenterDistance : this.cameraToSeaLevelDistance, s3 = Math.PI / 2 + this._pitch, o = this._fov * (0.5 + t3.y / this.height), l = Math.sin(o) * n / Math.sin(Te(Math.PI - s3 - o, 0.01, Math.PI - 0.01)), u3 = this.getHorizon(), c3 = 2 * Math.atan(u3 / this.cameraToCenterDistance) * (0.5 + t3.y / (2 * u3)), h = Math.sin(c3) * n / Math.sin(Te(Math.PI - s3 - c3, 0.01, Math.PI - 0.01)), p = Math.min(l, h), d = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * p + n), f = this.height / 50;
    a = new Float64Array(16), q3.perspective(a, this._fov, this.width / this.height, f, d), a[8] = 2 * -t3.x / this.width, a[9] = 2 * t3.y / this.height, q3.scale(a, a, [1, -1, 1]), q3.translate(a, a, [0, 0, -this.cameraToCenterDistance]), q3.rotateX(a, a, this._pitch), q3.rotateZ(a, a, this.angle), q3.translate(a, a, [-r, -i, 0]), this.mercatorMatrix = q3.scale([], a, [this.worldSize, this.worldSize, this.worldSize]), q3.scale(a, a, [1, 1, this._pixelPerMeter]), this.pixelMatrix = q3.multiply(new Float64Array(16), this.labelPlaneMatrix, a), q3.translate(a, a, [0, 0, -this.elevation]), this.projMatrix = a, this.invProjMatrix = q3.invert([], a), this.pixelMatrix3D = q3.multiply(new Float64Array(16), this.labelPlaneMatrix, a);
    let m = this.width % 2 / 2, y = this.height % 2 / 2, g = Math.cos(this.angle), _ = Math.sin(this.angle), x = r - Math.round(r) + g * m + _ * y, v = i - Math.round(i) + g * y + _ * m, b = new Float64Array(a);
    if (q3.translate(b, b, [x > 0.5 ? x - 1 : x, v > 0.5 ? v - 1 : v, 0]), this.alignedProjMatrix = b, a = q3.invert(new Float64Array(16), this.pixelMatrix), !a)
      throw new Error("failed to invert matrix");
    this.pixelMatrixInverse = a, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
  }
  maxPitchScaleFactor() {
    if (!this.pixelMatrixInverse)
      return 1;
    let e53 = this.pointCoordinate(new Ge.default(0, 0)), t3 = [e53.x * this.worldSize, e53.y * this.worldSize, 0, 1];
    return Xe.transformMat4(t3, t3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
  }
  getCameraPoint() {
    let e53 = this._pitch, t3 = Math.tan(e53) * (this.cameraToCenterDistance || 1);
    return this.centerPoint.add(new Ge.default(0, t3));
  }
  getCameraQueryGeometry(e53) {
    let t3 = this.getCameraPoint();
    if (1 === e53.length)
      return [e53[0], t3];
    {
      let r = t3.x, i = t3.y, a = t3.x, n = t3.y;
      for (let t4 of e53)
        r = Math.min(r, t4.x), i = Math.min(i, t4.y), a = Math.max(a, t4.x), n = Math.max(n, t4.y);
      return [new Ge.default(r, i), new Ge.default(a, i), new Ge.default(a, n), new Ge.default(r, n), new Ge.default(r, i)];
    }
  }
  setCameraPosition(e53) {
    let { lng: t3, lat: r, altitude: i, pitch: a, bearing: n } = e53, s3 = a * (Math.PI / 180), o = 0.5 / Math.tan(this._fov / 2) * this.height, l = Math.abs(Math.cos(s3) * o) / i * (2 * Math.PI * 6378137 * Math.abs(Math.cos(r * (Math.PI / 180)))), u3 = Math.tan(s3) * o, c3 = new Ge.default(this.width / 2, this.height / 2 + u3), h = new re(t3, r);
    this.zoom = Math.log(l / this.tileSize) / Math.LN2, this.pitch = a, this.bearing = n, this.setLocationAtPoint(h, c3);
  }
  getCameraAltitude() {
    let e53 = this._pitch, t3 = Math.cos(e53) * this.cameraToCenterDistance, r = Math.tan(e53) * this.cameraToCenterDistance, i = this.pointLocation(this.centerPoint.add(new Ge.default(0, r))), a = 2 * Math.PI * 6378137;
    return t3 / (this.worldSize / (a * Math.abs(Math.cos(i.lat * (Math.PI / 180)))));
  }
};
q(Vu, "Transform");
var Ou = Vu;
function B1(e53, t3) {
  let r = false, i = null, a = q(() => {
    i = null, r && (e53(), i = setTimeout(a, t3), r = false);
  }, "later");
  return () => (r = true, i || a(), i);
}
c(), c(), q(B1, "throttle");
var sy = class {
  constructor(e53) {
    this._getCurrentHash = q(() => {
      let e54 = window.location.hash.replace("#", "");
      if (this._hashName) {
        let t3;
        return e54.split("&").map((e55) => e55.split("=")).forEach((e55) => {
          e55[0] === this._hashName && (t3 = e55);
        }), (t3 && t3[1] || "").split("/");
      }
      return e54.split("/");
    }, "_getCurrentHash"), this._onHashChange = q(() => {
      let e54 = this._getCurrentHash();
      if (e54.length >= 3 && !e54.some((e55) => isNaN(e55))) {
        let t3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e54[3] || 0) : this._map.getBearing();
        return this._map.jumpTo({ center: [+e54[2], +e54[1]], zoom: +e54[0], bearing: t3, pitch: +(e54[4] || 0) }), true;
      }
      return false;
    }, "_onHashChange"), this._updateHashUnthrottled = q(() => {
      let e54 = window.location.href.replace(/(#.+)?$/, this.getHashString());
      try {
        window.history.replaceState(window.history.state, null, e54);
      } catch {
      }
    }, "_updateHashUnthrottled"), this._updateHash = B1(this._updateHashUnthrottled, 300), this._hashName = e53 && encodeURIComponent(e53);
  }
  addTo(e53) {
    return this._map = e53, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
  }
  remove() {
    return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
  }
  getHashString(e53) {
    let t3 = this._map.getCenter(), r = Math.round(100 * this._map.getZoom()) / 100, i = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a = Math.pow(10, i), n = Math.round(t3.lng * a) / a, s3 = Math.round(t3.lat * a) / a, o = this._map.getBearing(), l = this._map.getPitch(), u3 = "";
    if (u3 += e53 ? "/".concat(n, "/").concat(s3, "/").concat(r) : "".concat(r, "/").concat(s3, "/").concat(n), (o || l) && (u3 += "/".concat(Math.round(10 * o) / 10)), l && (u3 += "/".concat(Math.round(l))), this._hashName) {
      let e54 = this._hashName, t4 = false, r3 = window.location.hash.slice(1).split("&").map((r4) => {
        let i3 = r4.split("=")[0];
        return i3 === e54 ? (t4 = true, "".concat(i3, "=").concat(u3)) : r4;
      }).filter((e55) => e55);
      return t4 || r3.push("".concat(e54, "=").concat(u3)), "#".concat(r3.join("&"));
    }
    return "#".concat(u3);
  }
};
q(sy, "Hash");
var Uu = sy;
c(), c();
var R1 = u(Pe(), 1);
var ju = { linearity: 0.3, easing: bc(0, 0, 0.3, 1) };
var WC = R({ deceleration: 2500, maxSpeed: 1400 }, ju);
var XC = R({ deceleration: 20, maxSpeed: 1400 }, ju);
var KC = R({ deceleration: 1e3, maxSpeed: 360 }, ju);
var YC = R({ deceleration: 1e3, maxSpeed: 90 }, ju);
var ly = class {
  constructor(e53) {
    this._map = e53, this.clear();
  }
  clear() {
    this._inertiaBuffer = [];
  }
  record(e53) {
    this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: ne.now(), settings: e53 });
  }
  _drainInertiaBuffer() {
    let e53 = this._inertiaBuffer, t3 = ne.now();
    for (; e53.length > 0 && t3 - e53[0].time > 160; )
      e53.shift();
  }
  _onMoveEnd(e53) {
    if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
      return;
    let t3 = { zoom: 0, bearing: 0, pitch: 0, pan: new R1.default(0, 0), pinchAround: void 0, around: void 0 };
    for (let { settings: e54 } of this._inertiaBuffer)
      t3.zoom += e54.zoomDelta || 0, t3.bearing += e54.bearingDelta || 0, t3.pitch += e54.pitchDelta || 0, e54.panDelta && t3.pan._add(e54.panDelta), e54.around && (t3.around = e54.around), e54.pinchAround && (t3.pinchAround = e54.pinchAround);
    let r = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, i = {};
    if (t3.pan.mag()) {
      let a = Gu(t3.pan.mag(), r, R({}, WC, e53 || {}));
      i.offset = t3.pan.mult(a.amount / t3.pan.mag()), i.center = this._map.transform.center, Nu(i, a);
    }
    if (t3.zoom) {
      let e54 = Gu(t3.zoom, r, XC);
      i.zoom = this._map.transform.zoom + e54.amount, Nu(i, e54);
    }
    if (t3.bearing) {
      let e54 = Gu(t3.bearing, r, KC);
      i.bearing = this._map.transform.bearing + Te(e54.amount, -179, 179), Nu(i, e54);
    }
    if (t3.pitch) {
      let e54 = Gu(t3.pitch, r, YC);
      i.pitch = this._map.transform.pitch + e54.amount, Nu(i, e54);
    }
    if (i.zoom || i.bearing) {
      let e54 = void 0 === t3.pinchAround ? t3.around : t3.pinchAround;
      i.around = e54 ? this._map.unproject(e54) : this._map.getCenter();
    }
    return this.clear(), R(i, { noMoveStart: true });
  }
};
q(ly, "HandlerInertia");
var qu = ly;
function Nu(e53, t3) {
  (!e53.duration || e53.duration < t3.duration) && (e53.duration = t3.duration, e53.easing = t3.easing);
}
function Gu(e53, t3, r) {
  let { maxSpeed: i, linearity: a, deceleration: n } = r, s3 = Te(e53 * a / (t3 / 1e3), -i, i), o = Math.abs(s3) / (n * a);
  return { easing: r.easing, duration: 1e3 * o, amount: s3 * (o / 2) };
}
q(Nu, "extendDuration"), q(Gu, "calculateEasing");
var O1 = u(Pe(), 1);
var $u = q((e53) => e53.zoom || e53.drag || e53.pitch || e53.rotate, "isMoving");
var py = class extends z {
};
q(py, "RenderFrameEvent");
var cy = py;
function uy(e53) {
  return e53.panDelta && e53.panDelta.mag() || e53.zoomDelta || e53.bearingDelta || e53.pitchDelta;
}
q(uy, "hasChange");
var hy = class {
  constructor(e53, t3) {
    this.handleWindowEvent = q((e54) => {
      this.handleEvent(e54, "".concat(e54.type, "Window"));
    }, "handleWindowEvent"), this.handleEvent = q((e54, t4) => {
      if ("blur" === e54.type)
        return void this.stop(true);
      this._updatingCamera = true;
      let r3 = "renderFrame" === e54.type ? void 0 : e54, i = { needsRenderFrame: false }, a = {}, n = {}, s3 = e54.touches, o = s3 ? this._getMapTouches(s3) : void 0, l = o ? B.touchPos(this._el, o) : B.mousePos(this._el, e54);
      for (let { handlerName: s4, handler: u4, allowed: c4 } of this._handlers) {
        if (!u4.isEnabled())
          continue;
        let h;
        this._blockedByActive(n, c4, s4) ? u4.reset() : u4[t4 || e54.type] && (h = u4[t4 || e54.type](e54, l, o), this.mergeHandlerResult(i, a, h, s4, r3), h && h.needsRenderFrame && this._triggerRenderFrame()), (h || u4.isActive()) && (n[s4] = u4);
      }
      let u3 = {};
      for (let e55 in this._previousActiveHandlers)
        n[e55] || (u3[e55] = r3);
      this._previousActiveHandlers = n, (Object.keys(u3).length || uy(i)) && (this._changes.push([i, a, u3]), this._triggerRenderFrame()), (Object.keys(n).length || uy(i)) && this._map._stop(true), this._updatingCamera = false;
      let { cameraAnimation: c3 } = i;
      c3 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], c3(this._map));
    }, "handleEvent"), this._map = e53, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new qu(e53), this._bearingSnap = t3.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {};
    let r = this._el;
    this._listeners = [[r, "touchstart", { passive: true }], [r, "touchmove", { passive: false }], [r, "touchend", void 0], [r, "touchcancel", void 0], [r, "mousedown", void 0], [r, "mousemove", void 0], [r, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [r, "mouseover", void 0], [r, "mouseout", void 0], [r, "dblclick", void 0], [r, "click", void 0], [r, "keydown", { capture: false }], [r, "keyup", void 0], [r, "wheel", { passive: false }], [r, "contextmenu", void 0], [window, "blur", void 0]];
  }
  destroy() {
  }
  _addDefaultHandlers(e53) {
  }
  _add(e53, t3, r) {
    this._handlers.push({ handlerName: e53, handler: t3, allowed: r }), this._handlersById[e53] = t3;
  }
  stop(e53) {
    if (!this._updatingCamera) {
      for (let { handler: e54 } of this._handlers)
        e54.reset();
      this._inertia.clear(), this._fireEvents({}, {}, e53), this._changes = [];
    }
  }
  isActive() {
    for (let { handler: e53 } of this._handlers)
      if (e53.isActive())
        return true;
    return false;
  }
  isZooming() {
    return !!this._eventsInProgress.zoom || false;
  }
  isRotating() {
    return !!this._eventsInProgress.rotate;
  }
  isMoving() {
    return !!$u(this._eventsInProgress) || this.isZooming();
  }
  _blockedByActive(e53, t3, r) {
    for (let i in e53)
      if (i !== r && (!t3 || t3.indexOf(i) < 0))
        return true;
    return false;
  }
  _getMapTouches(e53) {
    let t3 = [];
    for (let r of e53) {
      let e54 = r.target;
      this._el.contains(e54) && t3.push(r);
    }
    return t3;
  }
  mergeHandlerResult(e53, t3, r, i, a) {
    if (!r)
      return;
    R(e53, r);
    let n = { handlerName: i, originalEvent: r.originalEvent || a };
    void 0 !== r.zoomDelta && (t3.zoom = n), void 0 !== r.panDelta && (t3.drag = n), void 0 !== r.pitchDelta && (t3.pitch = n), void 0 !== r.bearingDelta && (t3.rotate = n);
  }
  _applyChanges() {
    let e53 = {}, t3 = {}, r = {};
    for (let [i, a, n] of this._changes)
      i.panDelta && (e53.panDelta = (e53.panDelta || new O1.default(0, 0))._add(i.panDelta)), i.zoomDelta && (e53.zoomDelta = (e53.zoomDelta || 0) + i.zoomDelta), i.bearingDelta && (e53.bearingDelta = (e53.bearingDelta || 0) + i.bearingDelta), i.pitchDelta && (e53.pitchDelta = (e53.pitchDelta || 0) + i.pitchDelta), void 0 !== i.around && (e53.around = i.around), void 0 !== i.pinchAround && (e53.pinchAround = i.pinchAround), i.noInertia && (e53.noInertia = i.noInertia), R(t3, a), R(r, n);
    this._updateMapTransform(e53, t3, r), this._changes = [];
  }
  _updateMapTransform(e53, t3, r) {
    let i = this._map, a = i._getTransformForUpdate(), n = i.terrain;
    if (!(uy(e53) || n && this._terrainMovement))
      return this._fireEvents(t3, r, true);
    let { panDelta: s3, zoomDelta: o, bearingDelta: l, pitchDelta: u3, around: c3, pinchAround: h } = e53;
    void 0 !== h && (c3 = h), i._stop(true), c3 = c3 || i.transform.centerPoint;
    let p = a.pointLocation(s3 ? c3.sub(s3) : c3);
    l && (a.bearing += l), u3 && (a.pitch += u3), o && (a.zoom += o), n ? this._terrainMovement || !t3.drag && !t3.zoom ? t3.drag && this._terrainMovement ? a.center = a.pointLocation(a.centerPoint.sub(s3)) : a.setLocationAtPoint(p, c3) : (this._terrainMovement = true, a.freezeElevation = true, a.setLocationAtPoint(p, c3), this._map.once("moveend", () => {
      a.freezeElevation = false, this._terrainMovement = false, a.recalculateZoom(i.terrain);
    })) : a.setLocationAtPoint(p, c3), i._applyUpdatedTransform(a), this._map._update(), e53.noInertia || this._inertia.record(e53), this._fireEvents(t3, r, true);
  }
  _fireEvents(e53, t3, r) {
    let i = $u(this._eventsInProgress), a = $u(e53), n = {};
    for (let t4 in e53) {
      let { originalEvent: r3 } = e53[t4];
      this._eventsInProgress[t4] || (n["".concat(t4, "start")] = r3), this._eventsInProgress[t4] = e53[t4];
    }
    !i && a && this._fireEvent("movestart", a.originalEvent);
    for (let e54 in n)
      this._fireEvent(e54, n[e54]);
    a && this._fireEvent("move", a.originalEvent);
    for (let t4 in e53) {
      let { originalEvent: r3 } = e53[t4];
      this._fireEvent(t4, r3);
    }
    let s3, o = {};
    for (let e54 in this._eventsInProgress) {
      let { handlerName: r3, originalEvent: i3 } = this._eventsInProgress[e54];
      this._handlersById[r3].isActive() || (delete this._eventsInProgress[e54], s3 = t3[r3] || i3, o["".concat(e54, "end")] = s3);
    }
    for (let e54 in o)
      this._fireEvent(e54, o[e54]);
    let l = $u(this._eventsInProgress);
    if (r && (i || a) && !l) {
      this._updatingCamera = true;
      let e54 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), t4 = q((e55) => 0 !== e55 && -this._bearingSnap < e55 && e55 < this._bearingSnap, "shouldSnapToNorth");
      e54 ? (t4(e54.bearing || this._map.getBearing()) && (e54.bearing = 0), e54.freezeElevation = true, this._map.easeTo(e54, { originalEvent: s3 })) : (this._map.fire(new z("moveend", { originalEvent: s3 })), t4(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
    }
  }
  _fireEvent(e53, t3) {
    this._map.fire(new z(e53, t3 ? { originalEvent: t3 } : {}));
  }
  _requestFrame() {
    return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e53) => {
      delete this._frameId, this.handleEvent(new cy("renderFrame", { timeStamp: e53 })), this._applyChanges();
    });
  }
  _triggerRenderFrame() {
    void 0 === this._frameId && (this._frameId = this._requestFrame());
  }
};
q(hy, "HandlerManager");
var Hu = hy;
c();
var Wt = u(Pe(), 1);
var fy = class extends de {
  constructor(e53, t3) {
    super(), this._renderFrameCallback = q(() => {
      let e54 = Math.min((ne.now() - this._easeStart) / this._easeOptions.duration, 1);
      this._onEaseFrame(this._easeOptions.easing(e54)), e54 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
    }, "_renderFrameCallback"), this._moving = false, this._zooming = false, this.transform = e53, this._bearingSnap = t3.bearingSnap, this.on("moveend", () => {
      delete this._requestedCameraState;
    });
  }
  getCenter() {
    return new re(this.transform.center.lng, this.transform.center.lat);
  }
  setCenter(e53, t3) {
    return this.jumpTo({ center: e53 }, t3);
  }
  panBy(e53, t3, r) {
    return e53 = Wt.default.convert(e53).mult(-1), this.panTo(this.transform.center, R({ offset: e53 }, t3), r);
  }
  panTo(e53, t3, r) {
    return this.easeTo(R({ center: e53 }, t3), r);
  }
  getZoom() {
    return this.transform.zoom;
  }
  setZoom(e53, t3) {
    return this.jumpTo({ zoom: e53 }, t3), this;
  }
  zoomTo(e53, t3, r) {
    return this.easeTo(R({ zoom: e53 }, t3), r);
  }
  zoomIn(e53, t3) {
    return this.zoomTo(this.getZoom() + 1, e53, t3), this;
  }
  zoomOut(e53, t3) {
    return this.zoomTo(this.getZoom() - 1, e53, t3), this;
  }
  getBearing() {
    return this.transform.bearing;
  }
  setBearing(e53, t3) {
    return this.jumpTo({ bearing: e53 }, t3), this;
  }
  getPadding() {
    return this.transform.padding;
  }
  setPadding(e53, t3) {
    return this.jumpTo({ padding: e53 }, t3), this;
  }
  rotateTo(e53, t3, r) {
    return this.easeTo(R({ bearing: e53 }, t3), r);
  }
  resetNorth(e53, t3) {
    return this.rotateTo(0, R({ duration: 1e3 }, e53), t3), this;
  }
  resetNorthPitch(e53, t3) {
    return this.easeTo(R({ bearing: 0, pitch: 0, duration: 1e3 }, e53), t3), this;
  }
  snapToNorth(e53, t3) {
    return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e53, t3) : this;
  }
  getPitch() {
    return this.transform.pitch;
  }
  setPitch(e53, t3) {
    return this.jumpTo({ pitch: e53 }, t3), this;
  }
  cameraForBounds(e53, t3) {
    e53 = lt.convert(e53);
    let r = t3 && t3.bearing || 0;
    return this._cameraForBoxAndBearing(e53.getNorthWest(), e53.getSouthEast(), r, t3);
  }
  _cameraForBoxAndBearing(e53, t3, r, i) {
    let a = { top: 0, bottom: 0, right: 0, left: 0 };
    if ("number" == typeof (i = R({ padding: a, offset: [0, 0], maxZoom: this.transform.maxZoom }, i)).padding) {
      let e54 = i.padding;
      i.padding = { top: e54, bottom: e54, right: e54, left: e54 };
    }
    i.padding = R(a, i.padding);
    let n = this.transform, s3 = n.padding, o = n.project(re.convert(e53)), l = n.project(re.convert(t3)), u3 = o.rotate(-r * Math.PI / 180), c3 = l.rotate(-r * Math.PI / 180), h = new Wt.default(Math.max(u3.x, c3.x), Math.max(u3.y, c3.y)), p = new Wt.default(Math.min(u3.x, c3.x), Math.min(u3.y, c3.y)), d = h.sub(p), f = (n.width - (s3.left + s3.right + i.padding.left + i.padding.right)) / d.x, m = (n.height - (s3.top + s3.bottom + i.padding.top + i.padding.bottom)) / d.y;
    if (m < 0 || f < 0)
      return void Ce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
    let y = Math.min(n.scaleZoom(n.scale * Math.min(f, m)), i.maxZoom), g = Wt.default.convert(i.offset), _ = (i.padding.left - i.padding.right) / 2, x = (i.padding.top - i.padding.bottom) / 2, v = new Wt.default(_, x).rotate(r * Math.PI / 180), b = g.add(v).mult(n.scale / n.zoomScale(y));
    return { center: n.unproject(o.add(l).div(2).sub(b)), zoom: y, bearing: r };
  }
  fitBounds(e53, t3, r) {
    return this._fitInternal(this.cameraForBounds(e53, t3), t3, r);
  }
  fitScreenCoordinates(e53, t3, r, i, a) {
    return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(Wt.default.convert(e53)), this.transform.pointLocation(Wt.default.convert(t3)), r, i), i, a);
  }
  _fitInternal(e53, t3, r) {
    return e53 ? (delete (t3 = R(e53, t3)).padding, t3.linear ? this.easeTo(t3, r) : this.flyTo(t3, r)) : this;
  }
  jumpTo(e53, t3) {
    this.stop();
    let r = this._getTransformForUpdate(), i = false, a = false, n = false;
    return "zoom" in e53 && r.zoom !== +e53.zoom && (i = true, r.zoom = +e53.zoom), void 0 !== e53.center && (r.center = re.convert(e53.center)), "bearing" in e53 && r.bearing !== +e53.bearing && (a = true, r.bearing = +e53.bearing), "pitch" in e53 && r.pitch !== +e53.pitch && (n = true, r.pitch = +e53.pitch), null != e53.padding && !r.isPaddingEqual(e53.padding) && (r.padding = e53.padding), this._applyUpdatedTransform(r), this.fire(new z("movestart", t3)).fire(new z("move", t3)), i && this.fire(new z("zoomstart", t3)).fire(new z("zoom", t3)).fire(new z("zoomend", t3)), a && this.fire(new z("rotatestart", t3)).fire(new z("rotate", t3)).fire(new z("rotateend", t3)), n && this.fire(new z("pitchstart", t3)).fire(new z("pitch", t3)).fire(new z("pitchend", t3)), this.fire(new z("moveend", t3));
  }
  calculateCameraOptionsFromTo(e53, t3, r, i = 0) {
    let a = ze.fromLngLat(e53, t3), n = ze.fromLngLat(r, i), s3 = n.x - a.x, o = n.y - a.y, l = n.z - a.z, u3 = Math.hypot(s3, o, l);
    if (0 === u3)
      throw new Error("Can't calculate camera options with same From and To");
    let c3 = Math.hypot(s3, o), h = this.transform.scaleZoom(this.transform.cameraToCenterDistance / u3 / this.transform.tileSize), p = 180 * Math.atan2(s3, -o) / Math.PI, d = 180 * Math.acos(c3 / u3) / Math.PI;
    return d = l < 0 ? 90 - d : 90 + d, { center: n.toLngLat(), zoom: h, pitch: d, bearing: p };
  }
  easeTo(e53, t3) {
    this._stop(false, e53.easeId), (false === (e53 = R({ offset: [0, 0], duration: 500, easing: _c }, e53)).animate || !e53.essential && ne.prefersReducedMotion) && (e53.duration = 0);
    let r = this._getTransformForUpdate(), i = this.getZoom(), a = this.getBearing(), n = this.getPitch(), s3 = this.getPadding(), o = "zoom" in e53 ? +e53.zoom : i, l = "bearing" in e53 ? this._normalizeBearing(e53.bearing, a) : a, u3 = "pitch" in e53 ? +e53.pitch : n, c3 = "padding" in e53 ? e53.padding : r.padding;
    console.log("aaaa", o), console.log("new zoom", o);
    let h = Wt.default.convert(e53.offset), p = r.centerPoint.add(h), d = r.pointLocation(p), f = re.convert(e53.center || d);
    this._normalizeCenter(f);
    let m, y, g = r.project(d), _ = r.project(f).sub(g), x = r.zoomScale(o - i);
    e53.around && (m = re.convert(e53.around), y = r.locationPoint(m));
    let v = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
    return this._zooming = this._zooming || o !== i, this._rotating = this._rotating || a !== l, this._pitching = this._pitching || u3 !== n, this._padding = !r.isPaddingEqual(c3), this._easeId = e53.easeId, this._prepareEase(t3, e53.noMoveStart, v), this.terrain && this._prepareElevation(f), this._ease((d3) => {
      if (this._zooming && (r.zoom = ke.number(i, o, d3)), this._rotating && (r.bearing = ke.number(a, l, d3)), this._pitching && (r.pitch = Te(ke.number(n, u3, d3), this.transform.minPitch, this.transform.maxPitch)), this._padding && (r.interpolatePadding(s3, c3, d3), p = r.centerPoint.add(h)), this.terrain && !e53.freezeElevation && this._updateElevation(d3), m)
        r.setLocationAtPoint(m, y);
      else {
        let e54 = r.zoomScale(r.zoom - i), t4 = o > i ? Math.min(2, x) : Math.max(0.5, x), a3 = Math.pow(t4, 1 - d3), n3 = r.unproject(g.add(_.mult(d3 * a3)).mult(e54));
        r.setLocationAtPoint(r.renderWorldCopies ? n3.wrap() : n3, p);
      }
      this._applyUpdatedTransform(r), this._fireMoveEvents(t3);
    }, (e54) => {
      this.terrain && this._finalizeElevation(), this._afterEase(t3, e54);
    }, e53), this;
  }
  _prepareEase(e53, t3, r = {}) {
    this._moving = true, !t3 && !r.moving && this.fire(new z("movestart", e53)), this._zooming && !r.zooming && this.fire(new z("zoomstart", e53)), this._rotating && !r.rotating && this.fire(new z("rotatestart", e53)), this._pitching && !r.pitching && this.fire(new z("pitchstart", e53));
  }
  _prepareElevation(e53) {
    this._elevationCenter = e53, this._elevationStart = this.transform.elevation, this._elevationTarget = this.transform.getElevation(e53, this.terrain), this.transform.freezeElevation = true;
  }
  _updateElevation(e53) {
    let t3 = this.transform.getElevation(this._elevationCenter, this.terrain);
    if (e53 < 1 && t3 !== this._elevationTarget) {
      let r = this._elevationTarget - this._elevationStart, i = (t3 - (r * e53 + this._elevationStart)) / (1 - e53);
      this._elevationStart += e53 * (r - i), this._elevationTarget = t3;
    }
    this.transform.elevation = ke.number(this._elevationStart, this._elevationTarget, e53);
  }
  _finalizeElevation() {
    this.transform.freezeElevation = false, this.transform.recalculateZoom(this.terrain);
  }
  _getTransformForUpdate() {
    return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
  }
  _applyUpdatedTransform(e53) {
    if (!this.transformCameraUpdate)
      return;
    let t3 = e53.clone(), { center: r, zoom: i, pitch: a, bearing: n, elevation: s3 } = this.transformCameraUpdate(t3);
    r && (t3.center = r), void 0 !== i && (t3.zoom = i), void 0 !== a && (t3.pitch = a), void 0 !== n && (t3.bearing = n), void 0 !== s3 && (t3.elevation = s3), this.transform.apply(t3);
  }
  _fireMoveEvents(e53) {
    this.fire(new z("move", e53)), this._zooming && this.fire(new z("zoom", e53)), this._rotating && this.fire(new z("rotate", e53)), this._pitching && this.fire(new z("pitch", e53));
  }
  _afterEase(e53, t3) {
    if (this._easeId && t3 && this._easeId === t3)
      return;
    delete this._easeId;
    let r = this._zooming, i = this._rotating, a = this._pitching;
    this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, r && this.fire(new z("zoomend", e53)), i && this.fire(new z("rotateend", e53)), a && this.fire(new z("pitchend", e53)), this.fire(new z("moveend", e53));
  }
  flyTo(e53, t3) {
    if (!e53.essential && ne.prefersReducedMotion) {
      let r3 = Bt(e53, ["center", "zoom", "bearing", "pitch", "around"]);
      return this.jumpTo(r3, t3);
    }
    this.stop(), e53 = R({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: _c }, e53);
    let r = this._getTransformForUpdate(), i = this.getZoom(), a = this.getBearing(), n = this.getPitch(), s3 = this.getPadding(), o = "zoom" in e53 ? Te(+e53.zoom, r.minZoom, r.maxZoom) : i, l = "bearing" in e53 ? this._normalizeBearing(e53.bearing, a) : a, c3 = "pitch" in e53 ? +e53.pitch : n, h = "padding" in e53 ? e53.padding : r.padding, p = r.zoomScale(o - i), d = Wt.default.convert(e53.offset), f = r.centerPoint.add(d), m = r.pointLocation(f), y = re.convert(e53.center || m);
    this._normalizeCenter(y);
    let g = r.project(m), _ = r.project(y).sub(g), x = e53.curve, v = Math.max(r.width, r.height), b = v / p, w = _.mag();
    if ("minZoom" in e53) {
      let t4 = Te(Math.min(e53.minZoom, i, o), r.minZoom, r.maxZoom), a3 = v / r.zoomScale(t4 - i);
      x = Math.sqrt(a3 / w * 2);
    }
    let S = x * x;
    function A(e54) {
      let t4 = (b * b - v * v + (e54 ? -1 : 1) * S * S * w * w) / (2 * (e54 ? b : v) * S * w);
      return Math.log(Math.sqrt(t4 * t4 + 1) - t4);
    }
    function M3(e54) {
      return (Math.exp(e54) - Math.exp(-e54)) / 2;
    }
    function I(e54) {
      return (Math.exp(e54) + Math.exp(-e54)) / 2;
    }
    function T(e54) {
      return M3(e54) / I(e54);
    }
    q(A, "zoomOutFactor"), q(M3, "sinh"), q(I, "cosh"), q(T, "tanh");
    let C = A(false), P = q(function(e54) {
      return I(C) / I(C + x * e54);
    }, "w"), k = q(function(e54) {
      return v * ((I(C) * T(C + x * e54) - M3(C)) / S) / w;
    }, "u"), z3 = (A(true) - C) / x;
    if (Math.abs(w) < 1e-6 || !isFinite(z3)) {
      if (Math.abs(v - b) < 1e-6)
        return this.easeTo(e53, t3);
      let r3 = b < v ? -1 : 1;
      z3 = Math.abs(Math.log(b / v)) / x, k = q(function() {
        return 0;
      }, "u"), P = q(function(e54) {
        return Math.exp(r3 * x * e54);
      }, "w");
    }
    if ("duration" in e53)
      e53.duration = +e53.duration;
    else {
      let t4 = "screenSpeed" in e53 ? +e53.screenSpeed / x : +e53.speed;
      e53.duration = 1e3 * z3 / t4;
    }
    return e53.maxDuration && e53.duration > e53.maxDuration && (e53.duration = 0), this._zooming = true, this._rotating = a !== l, this._pitching = c3 !== n, this._padding = !r.isPaddingEqual(h), this._prepareEase(t3, false), this.terrain && this._prepareElevation(y), this._ease((u3) => {
      let p3 = u3 * z3, m3 = 1 / P(p3);
      r.zoom = 1 === u3 ? o : i + r.scaleZoom(m3), this._rotating && (r.bearing = ke.number(a, l, u3)), this._pitching && (r.pitch = ke.number(n, c3, u3)), this._padding && (r.interpolatePadding(s3, h, u3), f = r.centerPoint.add(d)), this.terrain && !e53.freezeElevation && this._updateElevation(u3);
      let x3 = 1 === u3 ? y : r.unproject(g.add(_.mult(k(p3))).mult(m3));
      r.setLocationAtPoint(r.renderWorldCopies ? x3.wrap() : x3, f), this._applyUpdatedTransform(r), this._fireMoveEvents(t3);
    }, () => {
      this.terrain && this._finalizeElevation(), this._afterEase(t3);
    }, e53), this;
  }
  isEasing() {
    return !!this._easeFrameId;
  }
  stop() {
    return this._stop();
  }
  _stop(e53, t3) {
    if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
      let e54 = this._onEaseEnd;
      delete this._onEaseEnd, e54.call(this, t3);
    }
    if (!e53) {
      let e54 = this.handlers;
      e54 && e54.stop(false);
    }
    return this;
  }
  _ease(e53, t3, r) {
    false === r.animate || 0 === r.duration ? (e53(1), t3()) : (this._easeStart = ne.now(), this._easeOptions = r, this._onEaseFrame = e53, this._onEaseEnd = t3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
  }
  _normalizeBearing(e53, t3) {
    e53 = Yt(e53, -180, 180);
    let r = Math.abs(e53 - t3);
    return Math.abs(e53 - 360 - t3) < r && (e53 -= 360), Math.abs(e53 + 360 - t3) < r && (e53 += 360), e53;
  }
  _normalizeCenter(e53) {
    let t3 = this.transform;
    if (!t3.renderWorldCopies || t3.lngRange)
      return;
    let r = e53.lng - t3.center.lng;
    e53.lng += r > 180 ? -360 : r < -180 ? 360 : 0;
  }
  queryTerrainElevation(e53) {
    return this.terrain ? this.transform.getElevation(re.convert(e53), this.terrain) - this.transform.elevation : null;
  }
};
q(fy, "Camera");
var Zu = fy;
var lr = u(Pe(), 1);
c();
var my = class {
  constructor(e53 = {}) {
    this._toggleAttribution = q(() => {
      this._container.classList.contains("outdoor-compact") && (this._container.classList.contains("outdoor-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("outdoor-compact-show")) : (this._container.classList.add("outdoor-compact-show"), this._container.removeAttribute("open")));
    }, "_toggleAttribution"), this._updateData = q((e54) => {
      e54 && ("metadata" === e54.sourceDataType || "visibility" === e54.sourceDataType || "style" === e54.dataType || "terrain" === e54.type) && this._updateAttributions();
    }, "_updateData"), this._updateCompact = q(() => {
      this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : !this._container.classList.contains("outdoor-compact") && !this._container.classList.contains("outdoor-attrib-empty") && (this._container.setAttribute("open", ""), this._container.classList.add("outdoor-compact", "outdoor-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("outdoor-compact") && this._container.classList.remove("outdoor-compact", "outdoor-compact-show"));
    }, "_updateCompact"), this._updateCompactMinimize = q(() => {
      this._container.classList.contains("outdoor-compact") && this._container.classList.contains("outdoor-compact-show") && this._container.classList.remove("outdoor-compact-show");
    }, "_updateCompactMinimize"), this.options = e53, this.position = this.options.position || this.getDefaultPosition();
  }
  getDefaultPosition() {
    return "bottom-right";
  }
  onAdd(e53) {
    return this._map = e53, this._compact = this.options && this.options.compact, this._container = B.create("details", "outdoor-ctrl-attrib outdoor-ctrl-attrib-".concat(this.position)), this._compactButton = B.create("summary", "outdoor-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = B.create("div", "outdoor-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._attributions = [], this._container;
  }
  onRemove() {
    B.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
  }
  _setElementTitle(e53, t3) {
    let r = this._map._getUIString("AttributionControl.".concat(t3));
    e53.title = r, e53.setAttribute("aria-label", r);
  }
  get attributions() {
    return [...this._attributions];
  }
  _updateAttributions() {
    if (!this._map.style)
      return;
    let e53 = [];
    if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e53 = e53.concat(this.options.customAttribution.map((e54) => "string" != typeof e54 ? "" : e54)) : "string" == typeof this.options.customAttribution && e53.push(this.options.customAttribution)), this._map.style.stylesheet) {
      let e54 = this._map.style.stylesheet;
      this.styleOwner = e54.owner, this.styleId = e54.id;
    }
    let t3 = this._map.style.sourceCaches;
    for (let r3 in t3) {
      let i = t3[r3];
      if (i.used || i.usedForTerrain) {
        let t4 = i.getSource();
        t4.attribution && e53.indexOf(t4.attribution) < 0 && e53.push(t4.attribution);
      }
    }
    e53 = e53.filter((e54) => String(e54).trim()), e53.sort((e54, t4) => e54.length - t4.length), e53 = e53.filter((t4, r3) => {
      for (let i = r3 + 1; i < e53.length; i++)
        if (e53[i].indexOf(t4) >= 0)
          return false;
      return true;
    }), this._attributions = e53;
    let r = e53.join(" | ");
    r !== this._attribHTML && (this._attribHTML = r, e53.length ? (this._innerContainer.innerHTML = r, this._container.classList.remove("outdoor-attrib-empty")) : this._container.classList.add("outdoor-attrib-empty"), this._updateCompact(), this._editLink = null);
  }
  show() {
    this._container.classList.remove("outdoor-ctrl-attrib-hide");
  }
  hide() {
    this._container.classList.add("outdoor-ctrl-attrib-hide");
  }
  setPosition(e53) {
    this._container.classList.remove("outdoor-ctrl-attrib-".concat(this.position)), this.position = e53, this._container.classList.add("outdoor-ctrl-attrib-".concat(this.position));
  }
};
q(my, "AttributionControl");
var _n = my;
c();
var dy = class {
  constructor(e53 = {}) {
    this._updateCompact = q(() => {
      let e54 = this._container.children;
      if (e54.length) {
        let t3 = e54[0];
        this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t3.classList.add("maplibregl-compact") : t3.classList.remove("maplibregl-compact");
      }
    }, "_updateCompact"), this.options = e53;
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e53) {
    this._map = e53, this._compact = this.options && this.options.compact, this._container = B.create("div", "maplibregl-ctrl");
    let t3 = B.create("a", "maplibregl-ctrl-logo");
    return t3.target = "_blank", t3.rel = "noopener nofollow", t3.href = "https://maplibre.org/", t3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t3), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
  onRemove() {
    B.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
  }
};
q(dy, "LogoControl");
var vn = dy;
c();
var JC = u(Pe(), 1);
var yy = class extends z {
  constructor(e53, t3, r, i = {}) {
    let a = B.mousePos(t3.getCanvasContainer(), r);
    super(e53, R({ point: a, lngLat: t3.unproject(a), originalEvent: r }, i)), this._defaultPrevented = false, this.target = t3;
  }
  preventDefault() {
    this._defaultPrevented = true;
  }
  get defaultPrevented() {
    return this._defaultPrevented;
  }
};
q(yy, "MapMouseEvent");
var wn = yy;
c();
var gy = class {
  constructor() {
    this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
  }
  add(e53) {
    let t3 = ++this._id;
    return this._queue.push({ callback: e53, id: t3, cancelled: false }), t3;
  }
  remove(e53) {
    let t3 = this._currentlyRunning, r = t3 ? this._queue.concat(t3) : this._queue;
    for (let t4 of r)
      if (t4.id === e53)
        return void (t4.cancelled = true);
  }
  run(e53 = 0) {
    if (this._currentlyRunning)
      throw new Error("Attempting to run(), but is already running.");
    let t3 = this._currentlyRunning = this._queue;
    this._queue = [];
    for (let r of t3)
      if (!r.cancelled && (r.callback(e53), this._cleared))
        break;
    this._cleared = false, this._currentlyRunning = false;
  }
  clear() {
    this._currentlyRunning && (this._cleared = true), this._queue = [];
  }
};
q(gy, "TaskQueue");
var Wu = gy;
c();
var Ku = ((e53) => (e53.create = "create", e53.load = "load", e53.fullLoad = "fullLoad", e53))(Ku || {});
var Xu = null;
var no = [];
var QC = 60;
var xy = 1e3 / QC;
var by = "loadTime";
var _y = "fullLoadTime";
var Rr = { mark(e53) {
  performance.mark(e53);
}, frame(e53) {
  let t3 = e53;
  if (null != Xu) {
    let e54 = t3 - Xu;
    no.push(e54);
  }
  Xu = t3;
}, clearMetrics() {
  Xu = null, no = [], performance.clearMeasures(by), performance.clearMeasures(_y);
  for (let e53 in Ku)
    performance.clearMarks(Ku[e53]);
}, getPerformanceMetrics() {
  performance.measure(by, "create", "load"), performance.measure(_y, "create", "fullLoad");
  let e53 = performance.getEntriesByName(by)[0].duration, t3 = performance.getEntriesByName(_y)[0].duration, r = no.length, i = 1 / (no.reduce((e54, t4) => e54 + t4, 0) / r / 1e3), a = no.filter((e54) => e54 > xy).reduce((e54, t4) => e54 + (t4 - xy) / xy, 0);
  return { loadTime: e53, fullLoadTime: t3, fps: i, percentDroppedFrames: a / (r + a) * 100, totalFrames: r };
} };
c();
var V1 = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" };
c(), c();
var U1 = ve([{ name: "a_pos3d", type: "Int16", components: 3 }]);
c();
var vy = class extends de {
  constructor(e53) {
    super(), this.sourceCache = e53, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, e53.usedForTerrain = true, e53.tileSize = this.tileSize * 2 ** this.deltaZoom;
  }
  destruct() {
    this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
  }
  update(e53, t3) {
    this.sourceCache.update(e53, t3), this._renderableTilesKeys = [];
    let r = {};
    for (let i of e53.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: t3 }))
      r[i.key] = true, this._renderableTilesKeys.push(i.key), this._tiles[i.key] || (i.posMatrix = new Float64Array(16), q3.ortho(i.posMatrix, 0, 8192, 0, 8192, 0, 1), this._tiles[i.key] = new dn(i, this.tileSize));
    for (let e54 in this._tiles)
      r[e54] || delete this._tiles[e54];
  }
  freeRtt(e53) {
    for (let t3 in this._tiles) {
      let r = this._tiles[t3];
      (!e53 || r.tileID.equals(e53) || r.tileID.isChildOf(e53) || e53.isChildOf(r.tileID)) && (r.rtt = []);
    }
  }
  getRenderableTiles() {
    return this._renderableTilesKeys.map((e53) => this.getTileByID(e53));
  }
  getTileByID(e53) {
    return this._tiles[e53];
  }
  getTerrainCoords(e53) {
    let t3 = {};
    for (let r of this._renderableTilesKeys) {
      let i = this._tiles[r].tileID;
      if (i.canonical.equals(e53.canonical)) {
        let i3 = e53.clone();
        i3.posMatrix = new Float64Array(16), q3.ortho(i3.posMatrix, 0, 8192, 0, 8192, 0, 1), t3[r] = i3;
      } else if (i.canonical.isChildOf(e53.canonical)) {
        let a = e53.clone();
        a.posMatrix = new Float64Array(16);
        let n = i.canonical.z - e53.canonical.z, s3 = i.canonical.x - (i.canonical.x >> n << n), o = i.canonical.y - (i.canonical.y >> n << n), l = 8192 >> n;
        q3.ortho(a.posMatrix, 0, l, 0, l, 0, 1), q3.translate(a.posMatrix, a.posMatrix, [-s3 * l, -o * l, 0]), t3[r] = a;
      } else if (e53.canonical.isChildOf(i.canonical)) {
        let a = e53.clone();
        a.posMatrix = new Float64Array(16);
        let n = e53.canonical.z - i.canonical.z, s3 = e53.canonical.x - (e53.canonical.x >> n << n), o = e53.canonical.y - (e53.canonical.y >> n << n), l = 8192 >> n;
        q3.ortho(a.posMatrix, 0, 8192, 0, 8192, 0, 1), q3.translate(a.posMatrix, a.posMatrix, [s3 * l, o * l, 0]), q3.scale(a.posMatrix, a.posMatrix, [1 / 2 ** n, 1 / 2 ** n, 0]), t3[r] = a;
      }
    }
    return t3;
  }
  getSourceTile(e53, t3) {
    let r = this.sourceCache._source, i = e53.overscaledZ - this.deltaZoom;
    if (i > r.maxzoom && (i = r.maxzoom), i < r.minzoom)
      return null;
    this._sourceTileCache[e53.key] || (this._sourceTileCache[e53.key] = e53.scaledTo(i).key);
    let a = this.sourceCache.getTileByID(this._sourceTileCache[e53.key]);
    if ((!a || !a.dem) && t3)
      for (; i >= r.minzoom && (!a || !a.dem); )
        a = this.sourceCache.getTileByID(e53.scaledTo(i--).key);
    return a;
  }
  tilesAfterTime(e53 = Date.now()) {
    return Object.values(this._tiles).filter((t3) => t3.timeAdded >= e53);
  }
};
q(vy, "TerrainSourceCache");
var Yu = vy;
var wy = class {
  constructor(e53, t3, r) {
    this.painter = e53, this.sourceCache = new Yu(t3), this.options = r, this.exaggeration = "number" == typeof r.exaggeration ? r.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
  }
  getDEMElevation(e53, t3, r, i = 8192) {
    var a;
    if (!(t3 >= 0 && t3 < i && r >= 0 && r < i))
      return 0;
    let n = this.getTerrainData(e53), s3 = null == (a = n.tile) ? void 0 : a.dem;
    if (!s3)
      return 0;
    let o = Xi.transformMat4([], [t3 / i * 8192, r / i * 8192], n.u_terrain_matrix), l = [o[0] * s3.dim, o[1] * s3.dim], u3 = Math.floor(l[0]), c3 = Math.floor(l[1]), h = l[0] - u3, p = l[1] - c3;
    return s3.get(u3, c3) * (1 - h) * (1 - p) + s3.get(u3 + 1, c3) * h * (1 - p) + s3.get(u3, c3 + 1) * (1 - h) * p + s3.get(u3 + 1, c3 + 1) * h * p;
  }
  getElevation(e53, t3, r, i = 8192) {
    return this.getDEMElevation(e53, t3, r, i) * this.exaggeration;
  }
  getTerrainData(e53) {
    if (!this._emptyDemTexture) {
      let e54 = this.painter.context, t4 = new Ee({ width: 1, height: 1 }, new Uint8Array(4));
      this._emptyDepthTexture = new be(e54, t4, e54.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new be(e54, new Ee({ width: 1, height: 1 }), e54.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e54.gl.NEAREST, e54.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = q3.identity([]);
    }
    let t3 = this.sourceCache.getSourceTile(e53, true);
    if (t3 && t3.dem && (!t3.demTexture || t3.needsTerrainPrepare)) {
      let e54 = this.painter.context;
      t3.demTexture = this.painter.getTileTexture(t3.dem.stride), t3.demTexture ? t3.demTexture.update(t3.dem.getPixels(), { premultiply: false }) : t3.demTexture = new be(e54, t3.dem.getPixels(), e54.gl.RGBA, { premultiply: false }), t3.demTexture.bind(e54.gl.NEAREST, e54.gl.CLAMP_TO_EDGE), t3.needsTerrainPrepare = false;
    }
    let r = t3 && t3 + t3.tileID.key + e53.key;
    if (r && !this._demMatrixCache[r]) {
      let r3 = this.sourceCache.sourceCache._source.maxzoom, i = e53.canonical.z - t3.tileID.canonical.z;
      e53.overscaledZ > e53.canonical.z && (e53.canonical.z >= r3 ? i = e53.canonical.z - r3 : Ce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
      let a = e53.canonical.x - (e53.canonical.x >> i << i), n = e53.canonical.y - (e53.canonical.y >> i << i), s3 = q3.fromScaling(new Float64Array(16), [1 / (8192 << i), 1 / (8192 << i), 0]);
      q3.translate(s3, s3, [8192 * a, 8192 * n, 0]), this._demMatrixCache[e53.key] = { matrix: s3, coord: e53 };
    }
    return { u_depth: 2, u_terrain: 3, u_terrain_dim: t3 && t3.dem && t3.dem.dim || 1, u_terrain_matrix: r ? this._demMatrixCache[e53.key].matrix : this._emptyDemMatrix, u_terrain_unpack: t3 && t3.dem && t3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (t3 && t3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: t3 };
  }
  getFramebuffer(e53) {
    let t3 = this.painter, r = t3.width / devicePixelRatio, i = t3.height / devicePixelRatio;
    return this._fbo && (this._fbo.width !== r || this._fbo.height !== i) && (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new be(t3.context, { width: r, height: i, data: null }, t3.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t3.context.gl.NEAREST, t3.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new be(t3.context, { width: r, height: i, data: null }, t3.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t3.context.gl.NEAREST, t3.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t3.context.createFramebuffer(r, i, true, false), this._fbo.depthAttachment.set(t3.context.createRenderbuffer(t3.context.gl.DEPTH_COMPONENT16, r, i))), this._fbo.colorAttachment.set("coords" === e53 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
  }
  getCoordsTexture() {
    let e53 = this.painter.context;
    if (this._coordsTexture)
      return this._coordsTexture;
    let t3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
    for (let e54 = 0, r3 = 0; e54 < this._coordsTextureSize; e54++)
      for (let i3 = 0; i3 < this._coordsTextureSize; i3++, r3 += 4)
        t3[r3 + 0] = 255 & i3, t3[r3 + 1] = 255 & e54, t3[r3 + 2] = i3 >> 8 << 4 | e54 >> 8, t3[r3 + 3] = 0;
    let r = new Ee({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(t3.buffer)), i = new be(e53, r, e53.gl.RGBA, { premultiply: false });
    return i.bind(e53.gl.NEAREST, e53.gl.CLAMP_TO_EDGE), this._coordsTexture = i, i;
  }
  pointCoordinate(e53) {
    let t3 = new Uint8Array(4), r = this.painter.context, i = r.gl;
    r.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), i.readPixels(e53.x, this.painter.height / devicePixelRatio - e53.y - 1, 1, 1, i.RGBA, i.UNSIGNED_BYTE, t3), r.bindFramebuffer.set(null);
    let a = t3[0] + (t3[2] >> 4 << 8), n = t3[1] + ((15 & t3[2]) << 8), s3 = this.coordsIndex[255 - t3[3]], o = s3 && this.sourceCache.getTileByID(s3);
    if (!o)
      return null;
    let l = this._coordsTextureSize, u3 = (1 << o.tileID.canonical.z) * l;
    return new ze((o.tileID.canonical.x * l + a) / u3, (o.tileID.canonical.y * l + n) / u3, this.getElevation(o.tileID, a, n, l));
  }
  getTerrainMesh() {
    if (this._mesh)
      return this._mesh;
    let e53 = this.painter.context, t3 = new xs(), r = new nt(), i = this.meshSize, a = 8192 / i, n = i * i;
    for (let e54 = 0; e54 <= i; e54++)
      for (let r3 = 0; r3 <= i; r3++)
        t3.emplaceBack(r3 * a, e54 * a, 0);
    for (let e54 = 0; e54 < n; e54 += i + 1)
      for (let t4 = 0; t4 < i; t4++)
        r.emplaceBack(t4 + e54, i + t4 + e54 + 1, i + t4 + e54 + 2), r.emplaceBack(t4 + e54, i + t4 + e54 + 2, t4 + e54 + 1);
    let s3 = t3.length, o = s3 + 2 * (i + 1);
    for (let e54 of [0, 1])
      for (let r3 = 0; r3 <= i; r3++)
        for (let i3 of [0, 1])
          t3.emplaceBack(r3 * a, 8192 * e54, i3);
    for (let e54 = 0; e54 < 2 * i; e54 += 2)
      r.emplaceBack(o + e54, o + e54 + 1, o + e54 + 3), r.emplaceBack(o + e54, o + e54 + 3, o + e54 + 2), r.emplaceBack(s3 + e54, s3 + e54 + 3, s3 + e54 + 1), r.emplaceBack(s3 + e54, s3 + e54 + 2, s3 + e54 + 3);
    let l = t3.length, u3 = l + 2 * (i + 1);
    for (let e54 of [0, 1])
      for (let r3 = 0; r3 <= i; r3++)
        for (let i3 of [0, 1])
          t3.emplaceBack(8192 * e54, r3 * a, i3);
    for (let e54 = 0; e54 < 2 * i; e54 += 2)
      r.emplaceBack(l + e54, l + e54 + 1, l + e54 + 3), r.emplaceBack(l + e54, l + e54 + 3, l + e54 + 2), r.emplaceBack(u3 + e54, u3 + e54 + 3, u3 + e54 + 1), r.emplaceBack(u3 + e54, u3 + e54 + 2, u3 + e54 + 3);
    return this._mesh = { indexBuffer: e53.createIndexBuffer(r), vertexBuffer: e53.createVertexBuffer(t3, U1.members), segments: me.simpleSegment(0, 0, t3.length, r.length) }, this._mesh;
  }
  getMeshFrameDelta(e53) {
    return 2 * Math.PI * mi / Math.pow(2, e53) / 5;
  }
  getMinMaxElevation(e53) {
    let t3 = this.getTerrainData(e53).tile, r = { minElevation: null, maxElevation: null };
    return t3 && t3.dem && (r.minElevation = t3.dem.min * this.exaggeration, r.maxElevation = t3.dem.max * this.exaggeration), r;
  }
};
q(wy, "Terrain");
var Ju = wy;
c(), c();
var Sy = class {
  constructor(e53, t3, r) {
    this._context = e53, this._size = t3, this._tileSize = r, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
  }
  destruct() {
    for (let e53 of this._objects)
      e53.texture.destroy(), e53.fbo.destroy();
  }
  _createObject(e53) {
    let t3 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), r = new be(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
    return r.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), t3.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t3.colorAttachment.set(r.texture), { id: e53, fbo: t3, texture: r, stamp: -1, inUse: false };
  }
  getObjectForId(e53) {
    return this._objects[e53];
  }
  useObject(e53) {
    e53.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t3) => e53.id !== t3), this._recentlyUsed.push(e53.id);
  }
  stampObject(e53) {
    e53.stamp = ++this._stamp;
  }
  getOrCreateFreeObject() {
    for (let e54 of this._recentlyUsed)
      if (!this._objects[e54].inUse)
        return this._objects[e54];
    if (this._objects.length >= this._size)
      throw new Error("No free RenderPool available, call freeAllObjects() required!");
    let e53 = this._createObject(this._objects.length);
    return this._objects.push(e53), e53;
  }
  freeObject(e53) {
    e53.inUse = false;
  }
  freeAllObjects() {
    for (let e53 of this._objects)
      this.freeObject(e53);
  }
  isFull() {
    return !(this._objects.length < this._size) && false === this._objects.some((e53) => !e53.inUse);
  }
};
q(Sy, "RenderPool");
var Qu = Sy;
var Sn = { background: true, fill: true, line: true, raster: true, hillshade: true };
var Py = class {
  constructor(e53, t3) {
    this.painter = e53, this.terrain = t3, this.pool = new Qu(e53.context, 30, t3.sourceCache.tileSize * t3.qualityFactor);
  }
  destruct() {
    this.pool.destruct();
  }
  getTexture(e53) {
    return this.pool.getObjectForId(e53.rtt[this._stacks.length - 1].id).texture;
  }
  prepareForRender(e53, t3) {
    this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e53._order.filter((r) => !e53._layers[r].isHidden(t3)), this._coordsDescendingInv = {};
    for (let t4 in e53.sourceCaches) {
      this._coordsDescendingInv[t4] = {};
      let r = e53.sourceCaches[t4].getVisibleCoordinates();
      for (let e54 of r) {
        let r3 = this.terrain.sourceCache.getTerrainCoords(e54);
        for (let e55 in r3)
          this._coordsDescendingInv[t4][e55] || (this._coordsDescendingInv[t4][e55] = []), this._coordsDescendingInv[t4][e55].push(r3[e55]);
      }
    }
    this._coordsDescendingInvStr = {};
    for (let t4 of e53._order) {
      let r = e53._layers[t4], i = r.source;
      if (Sn[r.type] && !this._coordsDescendingInvStr[i]) {
        this._coordsDescendingInvStr[i] = {};
        for (let e54 in this._coordsDescendingInv[i])
          this._coordsDescendingInvStr[i][e54] = this._coordsDescendingInv[i][e54].map((e55) => e55.key).sort().join();
      }
    }
    for (let e54 of this._renderableTiles)
      for (let t4 in this._coordsDescendingInvStr) {
        let r = this._coordsDescendingInvStr[t4][e54.tileID.key];
        r && r !== e54.rttCoords[t4] && (e54.rtt = []);
      }
  }
  renderLayer(e53) {
    if (e53.isHidden(this.painter.transform.zoom))
      return false;
    let t3 = e53.type, r = this.painter, i = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e53.id;
    if (Sn[t3] && ((!this._prevType || !Sn[this._prevType]) && this._stacks.push([]), this._prevType = t3, this._stacks[this._stacks.length - 1].push(e53.id), !i))
      return true;
    if (Sn[this._prevType] || Sn[t3] && i) {
      this._prevType = t3;
      let e54 = this._stacks.length - 1, i3 = this._stacks[e54] || [];
      for (let t4 of this._renderableTiles) {
        if (this.pool.isFull() && (ay(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(t4), t4.rtt[e54]) {
          let r3 = this.pool.getObjectForId(t4.rtt[e54].id);
          if (r3.stamp === t4.rtt[e54].stamp) {
            this.pool.useObject(r3);
            continue;
          }
        }
        let a = this.pool.getOrCreateFreeObject();
        this.pool.useObject(a), this.pool.stampObject(a), t4.rtt[e54] = { id: a.id, stamp: a.stamp }, r.context.bindFramebuffer.set(a.fbo.framebuffer), r.context.clear({ color: K.transparent, stencil: 0 }), r.currentStencilSource = void 0;
        for (let e55 = 0; e55 < i3.length; e55++) {
          let n = r.style._layers[i3[e55]], s3 = n.source ? this._coordsDescendingInv[n.source][t4.tileID.key] : [t4.tileID];
          r.context.viewport.set([0, 0, a.fbo.width, a.fbo.height]), r._renderTileClippingMasks(n, s3), r.renderLayer(r, r.style.sourceCaches[n.source], n, s3), n.source && (t4.rttCoords[n.source] = this._coordsDescendingInvStr[n.source][t4.tileID.key]);
        }
      }
      return ay(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), Sn[t3];
    }
    return false;
  }
};
q(Py, "RenderToTexture");
var ec = Py;
var eE = po.version;
var rc = -2;
var N1 = 22;
var Or = 0;
var G1 = 90;
var tc = 90;
var tE = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: rc, maxZoom: N1, minPitch: Or, maxPitch: G1, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: it.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] };
var Ty = class extends Zu {
  constructor(e53) {
    if (Rr.mark("create"), null != (e53 = R({}, tE, e53)).minZoom && null != e53.maxZoom && e53.minZoom > e53.maxZoom)
      throw new Error("maxZoom must be greater than or equal to minZoom");
    if (null != e53.minPitch && null != e53.maxPitch && e53.minPitch > e53.maxPitch)
      throw new Error("maxPitch must be greater than or equal to minPitch");
    if (null != e53.minPitch && e53.minPitch < Or)
      throw new Error("minPitch must be greater than or equal to ".concat(Or));
    if (null != e53.maxPitch && e53.maxPitch > tc)
      throw new Error("maxPitch must be less than or equal to ".concat(tc));
    if (super(new Ou(e53.minZoom, e53.maxZoom, e53.minPitch, e53.maxPitch, e53.renderWorldCopies), { bearingSnap: e53.bearingSnap }), this._cooperativeGesturesOnWheel = q((e54) => {
      this._onCooperativeGesture(e54, e54[this._metaKey], 1);
    }, "_cooperativeGesturesOnWheel"), this._contextLost = q((e54) => {
      e54.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new z("webglcontextlost", { originalEvent: e54 }));
    }, "_contextLost"), this._contextRestored = q((e54) => {
      this._setupPainter(), this.resize(), this._update(), this.fire(new z("webglcontextrestored", { originalEvent: e54 }));
    }, "_contextRestored"), this._onMapScroll = q((e54) => {
      if (e54.target === this._container)
        return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
    }, "_onMapScroll"), this._onWindowOnline = q(() => {
      this._update();
    }, "_onWindowOnline"), this._interactive = e53.interactive, this._cooperativeGestures = e53.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e53.maxTileCacheSize, this._maxTileCacheZoomLevels = e53.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e53.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e53.preserveDrawingBuffer, this._antialias = e53.antialias, this._trackResize = e53.trackResize, this._bearingSnap = e53.bearingSnap, this._refreshExpiredTiles = e53.refreshExpiredTiles, this._fadeDuration = e53.fadeDuration, this._crossSourceCollisions = e53.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e53.collectResourceTiming, this._renderTaskQueue = new Wu(), this._controls = [], this._mapId = fo(), this._locale = R({}, V1, e53.locale), this._clickTolerance = e53.clickTolerance, this._overridePixelRatio = e53.pixelRatio, this._maxCanvasSize = e53.maxCanvasSize, this.transformCameraUpdate = e53.transformCameraUpdate, this._imageQueueHandle = ot.addThrottleControl(() => this.isMoving()), this._requestManager = new bo(e53.transformRequest), this._canvas = e53.canvas, this._canvasContainer = e53.canvasContainer, "string" == typeof e53.container) {
      if (this._container = document.getElementById(e53.container), !this._container)
        throw new Error("Container '".concat(e53.container, "' not found."));
    } else {
      if (!(e53.container instanceof HTMLElement))
        throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
      this._container = e53.container;
    }
    if (e53.maxBounds && this.setMaxBounds(e53.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
      this.painter.terrainFacilitator.dirty = true, this._update(true);
    }), this.once("idle", () => {
      this._idleTriggered = true;
    }), typeof window < "u") {
      addEventListener("online", this._onWindowOnline, false);
      let e54 = false;
      this._resizeObserver = new ResizeObserver((t4) => {
        e54 ? this._trackResize && this.resize(t4)._update() : e54 = true;
      }), this._resizeObserver.observe(this._container);
    }
    this.handlers = new Hu(this, e53), this._cooperativeGestures && this._setupCooperativeGestures();
    let t3 = "string" == typeof e53.hash && e53.hash || void 0;
    this._hash = e53.hash && new Uu(t3).addTo(this), (!this._hash || !this._hash._onHashChange()) && (this.jumpTo({ center: e53.center, zoom: e53.zoom, bearing: e53.bearing, pitch: e53.pitch }), e53.bounds && (this.resize(), this.fitBounds(e53.bounds, R({}, e53.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e53.localIdeographFontFamily, this._validateStyle = e53.validateStyle, e53.style && this.setStyle(e53.style, { localIdeographFontFamily: e53.localIdeographFontFamily }), e53.attributionControl && this.addControl(new _n({ customAttribution: e53.customAttribution })), e53.maplibreLogo && this.addControl(new vn(), e53.logoPosition), this.on("style.load", () => {
      this.transform.unmodified && this.jumpTo(this.style.stylesheet);
    }), this.on("data", (e54) => {
      this._update("style" === e54.dataType), this.fire(new z("".concat(e54.dataType, "data"), e54));
    }), this.on("dataloading", (e54) => {
      this.fire(new z("".concat(e54.dataType, "dataloading"), e54));
    }), this.on("dataabort", (e54) => {
      this.fire(new z("sourcedataabort", e54));
    });
  }
  _getMapId() {
    return this._mapId;
  }
  addControl(e53, t3) {
    return void 0 === t3 && (t3 = e53.getDefaultPosition ? e53.getDefaultPosition() : "top-right"), e53 && e53.onAdd ? this : this.fire(new Z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
  }
  removeControl(e53) {
    if (!e53 || !e53.onRemove)
      return this.fire(new Z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
    let t3 = this._controls.indexOf(e53);
    return t3 > -1 && this._controls.splice(t3, 1), e53.onRemove(this), this;
  }
  hasControl(e53) {
    return this._controls.indexOf(e53) > -1;
  }
  calculateCameraOptionsFromTo(e53, t3, r, i) {
    return null == i && this.terrain && (i = this.transform.getElevation(r, this.terrain)), super.calculateCameraOptionsFromTo(e53, t3, r, i);
  }
  resize(e53) {
    var t3;
    let r = this._containerDimensions(), i = r[0], a = r[1], n = this._getClampedPixelRatio(i, a);
    if (this.painter.resize(i, a, n), this.painter.overLimit()) {
      let e54 = this.painter.context.gl;
      this._maxCanvasSize = [e54.drawingBufferWidth, e54.drawingBufferHeight];
      let t4 = this._getClampedPixelRatio(i, a);
      this._resizeCanvas(i, a, t4), this.painter.resize(i, a, t4);
    }
    this.transform.resize(i, a), null == (t3 = this._requestedCameraState) || t3.resize(i, a);
    let s3 = !this._moving;
    return s3 && (this.stop(), this.fire(new z("movestart", e53)).fire(new z("move", e53))), this.fire(new z("resize", e53)), s3 && this.fire(new z("moveend", e53)), this;
  }
  _getClampedPixelRatio(e53, t3) {
    let { 0: r, 1: i } = this._maxCanvasSize, a = this.getPixelRatio(), n = e53 * a, s3 = t3 * a, o = n > r ? r / n : 1, l = s3 > i ? i / s3 : 1;
    return Math.min(o, l) * a;
  }
  getPixelRatio() {
    var e53;
    return null != (e53 = this._overridePixelRatio) ? e53 : devicePixelRatio;
  }
  setPixelRatio(e53) {
    this._overridePixelRatio = e53, this.resize();
  }
  getBounds() {
    return this.transform.getBounds();
  }
  getMaxBounds() {
    return this.transform.getMaxBounds();
  }
  setMaxBounds(e53) {
    return this.transform.setMaxBounds(lt.convert(e53)), this._update();
  }
  setMinZoom(e53) {
    if ((e53 = null == e53 ? rc : e53) >= rc && e53 <= this.transform.maxZoom)
      return this.transform.minZoom = e53, this._update(), this.getZoom() < e53 && this.setZoom(e53), this;
    throw new Error("minZoom must be between ".concat(rc, " and the current maxZoom, inclusive"));
  }
  getMinZoom() {
    return this.transform.minZoom;
  }
  setMaxZoom(e53) {
    if ((e53 = null == e53 ? N1 : e53) >= this.transform.minZoom)
      return this.transform.maxZoom = e53, this._update(), this.getZoom() > e53 && this.setZoom(e53), this;
    throw new Error("maxZoom must be greater than the current minZoom");
  }
  getMaxZoom() {
    return this.transform.maxZoom;
  }
  setMinPitch(e53) {
    if ((e53 = null == e53 ? Or : e53) < Or)
      throw new Error("minPitch must be greater than or equal to ".concat(Or));
    if (e53 >= Or && e53 <= this.transform.maxPitch)
      return this.transform.minPitch = e53, this._update(), this.getPitch() < e53 && this.setPitch(e53), this;
    throw new Error("minPitch must be between ".concat(Or, " and the current maxPitch, inclusive"));
  }
  getMinPitch() {
    return this.transform.minPitch;
  }
  setMaxPitch(e53) {
    if ((e53 = null == e53 ? G1 : e53) > tc)
      throw new Error("maxPitch must be less than or equal to ".concat(tc));
    if (e53 >= this.transform.minPitch)
      return this.transform.maxPitch = e53, this._update(), this.getPitch() > e53 && this.setPitch(e53), this;
    throw new Error("maxPitch must be greater than the current minPitch");
  }
  getMaxPitch() {
    return this.transform.maxPitch;
  }
  getRenderWorldCopies() {
    return this.transform.renderWorldCopies;
  }
  setRenderWorldCopies(e53) {
    return this.transform.renderWorldCopies = e53, this._update();
  }
  getCooperativeGestures() {
    return this._cooperativeGestures;
  }
  setCooperativeGestures(e53) {
    return this._cooperativeGestures = e53, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
  }
  project(e53) {
    return this.transform.locationPoint(re.convert(e53), this.style && this.terrain);
  }
  unproject(e53) {
    return this.transform.pointLocation(lr.default.convert(e53), this.terrain);
  }
  isMoving() {
    var e53;
    return this._moving || (null == (e53 = this.handlers) ? void 0 : e53.isMoving());
  }
  isZooming() {
    return this._zooming || false;
  }
  isRotating() {
    var e53;
    return this._rotating || (null == (e53 = this.handlers) ? void 0 : e53.isRotating());
  }
  _createDelegatedListener(e53, t3, r) {
    if ("mouseenter" === e53 || "mouseover" === e53) {
      let i = false;
      return { layer: t3, listener: r, delegates: { mousemove: q((a) => {
        let n = this.getLayer(t3) ? this.queryRenderedFeatures(a.point, { layers: [t3] }) : [];
        n.length ? i || (i = true, r.call(this, new wn(e53, this, a.originalEvent, { features: n }))) : i = false;
      }, "mousemove"), mouseout: q(() => {
        i = false;
      }, "mouseout") } };
    }
    if ("mouseleave" === e53 || "mouseout" === e53) {
      let i = false;
      return { layer: t3, listener: r, delegates: { mousemove: q((a) => {
        (this.getLayer(t3) ? this.queryRenderedFeatures(a.point, { layers: [t3] }) : []).length ? i = true : i && (i = false, r.call(this, new wn(e53, this, a.originalEvent)));
      }, "mousemove"), mouseout: q((t4) => {
        i && (i = false, r.call(this, new wn(e53, this, t4.originalEvent)));
      }, "mouseout") } };
    }
    {
      let i = q((e54) => {
        let i3 = this.getLayer(t3) ? this.queryRenderedFeatures(e54.point, { layers: [t3] }) : [];
        i3.length && (e54.features = i3, r.call(this, e54), delete e54.features);
      }, "delegate");
      return { layer: t3, listener: r, delegates: { [e53]: i } };
    }
  }
  on(e53, t3, r) {
    if (void 0 === r)
      return super.on(e53, t3);
    let i = this._createDelegatedListener(e53, t3, r);
    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e53] = this._delegatedListeners[e53] || [], this._delegatedListeners[e53].push(i);
    for (let e54 in i.delegates)
      this.on(e54, i.delegates[e54]);
    return this;
  }
  once(e53, t3, r) {
    if (void 0 === r)
      return super.once(e53, t3);
    let i = this._createDelegatedListener(e53, t3, r);
    for (let e54 in i.delegates)
      this.once(e54, i.delegates[e54]);
    return this;
  }
  off(e53, t3, r) {
    if (void 0 === r)
      return super.off(e53, t3);
    let i = q((i3) => {
      let a = i3[e53];
      for (let e54 = 0; e54 < a.length; e54++) {
        let i4 = a[e54];
        if (i4.layer === t3 && i4.listener === r) {
          for (let e55 in i4.delegates)
            this.off(e55, i4.delegates[e55]);
          return a.splice(e54, 1), this;
        }
      }
    }, "removeDelegatedListener");
    return this._delegatedListeners && this._delegatedListeners[e53] && i(this._delegatedListeners), this;
  }
  queryRenderedFeatures(e53, t3) {
    if (!this.style)
      return [];
    let r, i = e53 instanceof lr.default || Array.isArray(e53), a = i ? e53 : [[0, 0], [this.transform.width, this.transform.height]];
    if (t3 = t3 || (i ? {} : e53) || {}, a instanceof lr.default || "number" == typeof a[0])
      r = [lr.default.convert(a)];
    else {
      let e54 = lr.default.convert(a[0]), t4 = lr.default.convert(a[1]);
      r = [e54, new lr.default(t4.x, e54.y), t4, new lr.default(e54.x, t4.y), e54];
    }
    return this.style.queryRenderedFeatures(r, t3, this.transform);
  }
  querySourceFeatures(e53, t3) {
    return this.style.querySourceFeatures(e53, t3);
  }
  setStyle(e53, t3) {
    return false !== (t3 = R({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, t3)).diff && t3.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e53 ? (this._diffStyle(e53, t3), this) : (this._localIdeographFontFamily = t3.localIdeographFontFamily, this._updateStyle(e53, t3));
  }
  setTransformRequest(e53) {
    return this._requestManager.setTransformRequest(e53), this;
  }
  _getUIString(e53) {
    let t3 = this._locale[e53];
    if (null == t3)
      throw new Error("Missing UI string '".concat(e53, "'"));
    return t3;
  }
  _updateStyle(e53, t3) {
    if (t3.transformStyle && this.style && !this.style._loaded)
      return void this.style.once("style.load", () => this._updateStyle(e53, t3));
    let r = this.style && t3.transformStyle ? this.style.serialize() : void 0;
    return this.style && (this.style.setEventedParent(null), this.style._remove(!e53)), e53 ? (this.style = new Br(this, t3 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e53 ? this.style.loadURL(e53, t3, r) : this.style.loadJSON(e53, t3, r), this) : (delete this.style, this);
  }
  _lazyInitEmptyStyle() {
    this.style || (this.style = new Br(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
  }
  _diffStyle(e53, t3) {
    if ("string" == typeof e53) {
      let r = e53, i = this._requestManager.transformRequest(r, "Style");
      fr(i, (e54, r3) => {
        e54 ? this.fire(new Z(e54)) : r3 && this._updateDiff(r3, t3);
      });
    } else
      "object" == typeof e53 && this._updateDiff(e53, t3);
  }
  _updateDiff(e53, t3) {
    try {
      this.style.setState(e53, t3) && this._update(true);
    } catch (r) {
      Ce("Unable to perform style diff: ".concat(r.message || r.error || r, ".  Rebuilding the style from scratch.")), this._updateStyle(e53, t3);
    }
  }
  getStyle() {
    if (this.style)
      return this.style.serialize();
  }
  isStyleLoaded() {
    return this.style ? this.style.loaded() : Ce("There is no style added to the map.");
  }
  addSource(e53, t3) {
    return this._lazyInitEmptyStyle(), this.style.addSource(e53, t3), this._update(true);
  }
  isSourceLoaded(e53) {
    let t3 = this.style && this.style.sourceCaches[e53];
    if (void 0 !== t3)
      return t3.loaded();
    this.fire(new Z(new Error("There is no source with ID '".concat(e53, "'"))));
  }
  setTerrain(e53) {
    if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e53) {
      let t3 = this.style.sourceCaches[e53.source];
      if (!t3)
        throw new Error("cannot load terrain, because there exists no source with ID: ".concat(e53.source));
      for (let t4 in this.style._layers) {
        let r = this.style._layers[t4];
        "hillshade" === r.type && r.source === e53.source && Ce("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
      }
      this.terrain = new Ju(this.painter, t3, e53), this.painter.renderToTexture = new ec(this.painter, this.terrain), this.transform.updateElevation(this.terrain), this._terrainDataCallback = (t4) => {
        "style" === t4.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t4.dataType && t4.tile && (t4.sourceId === e53.source && this.transform.updateElevation(this.terrain), this.terrain.sourceCache.freeRtt(t4.tile.tileID));
      }, this.style.on("data", this._terrainDataCallback);
    } else
      this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.updateElevation(this.terrain);
    return this.fire(new z("terrain", { terrain: e53 })), this;
  }
  getTerrain() {
    return this.terrain && this.terrain.options;
  }
  areTilesLoaded() {
    let e53 = this.style && this.style.sourceCaches;
    for (let t3 in e53) {
      let r = e53[t3]._tiles;
      for (let e54 in r) {
        let t4 = r[e54];
        if ("loaded" !== t4.state && "errored" !== t4.state)
          return false;
      }
    }
    return true;
  }
  addSourceType(e53, t3, r) {
    return this._lazyInitEmptyStyle(), this.style.addSourceType(e53, t3, r);
  }
  removeSource(e53) {
    return this.style.removeSource(e53), this._update(true);
  }
  getSource(e53) {
    return this.style.getSource(e53);
  }
  addImage(e53, t3, r = {}) {
    let { pixelRatio: i = 1, sdf: a = false, stretchX: n, stretchY: s3, content: o } = r;
    this._lazyInitEmptyStyle();
    if (!(t3 instanceof HTMLImageElement || Ct(t3))) {
      if (void 0 === t3.width || void 0 === t3.height)
        return this.fire(new Z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
      {
        let { width: r3, height: l, data: u3 } = t3, c3 = t3;
        return this.style.addImage(e53, { data: new Ee({ width: r3, height: l }, new Uint8Array(u3)), pixelRatio: i, stretchX: n, stretchY: s3, content: o, sdf: a, version: 0, userImage: c3 }), c3.onAdd && c3.onAdd(this, e53), this;
      }
    }
    {
      let { width: r3, height: l, data: u3 } = ne.getImageData(t3);
      this.style.addImage(e53, { data: new Ee({ width: r3, height: l }, u3), pixelRatio: i, stretchX: n, stretchY: s3, content: o, sdf: a, version: 0 });
    }
  }
  updateImage(e53, t3) {
    let r = this.style.getImage(e53);
    if (!r)
      return this.fire(new Z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
    let i = t3 instanceof HTMLImageElement || Ct(t3) ? ne.getImageData(t3) : t3, { width: a, height: n, data: s3 } = i;
    if (void 0 === a || void 0 === n)
      return this.fire(new Z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
    if (a !== r.data.width || n !== r.data.height)
      return this.fire(new Z(new Error("The width and height of the updated image must be that same as the previous version of the image")));
    let o = !(t3 instanceof HTMLImageElement || Ct(t3));
    return r.data.replace(s3, o), this.style.updateImage(e53, r), this;
  }
  getImage(e53) {
    return this.style.getImage(e53);
  }
  hasImage(e53) {
    return e53 ? !!this.style.getImage(e53) : (this.fire(new Z(new Error("Missing required image id"))), false);
  }
  removeImage(e53) {
    this.style.removeImage(e53);
  }
  loadImage(e53, t3) {
    ot.getImage(this._requestManager.transformRequest(e53, "Image"), t3);
  }
  listImages() {
    return this.style.listImages();
  }
  addLayer(e53, t3) {
    return this._lazyInitEmptyStyle(), this.style.addLayer(e53, t3), this._update(true);
  }
  moveLayer(e53, t3) {
    return this.style.moveLayer(e53, t3), this._update(true);
  }
  removeLayer(e53) {
    return this.style.removeLayer(e53), this._update(true);
  }
  getLayer(e53) {
    return this.style.getLayer(e53);
  }
  setLayerZoomRange(e53, t3, r) {
    return this.style.setLayerZoomRange(e53, t3, r), this._update(true);
  }
  setFilter(e53, t3, r = {}) {
    return this.style.setFilter(e53, t3, r), this._update(true);
  }
  getFilter(e53) {
    return this.style.getFilter(e53);
  }
  setPaintProperty(e53, t3, r, i = {}) {
    return this.style.setPaintProperty(e53, t3, r, i), this._update(true);
  }
  getPaintProperty(e53, t3) {
    return this.style.getPaintProperty(e53, t3);
  }
  setLayoutProperty(e53, t3, r, i = {}) {
    return this.style.setLayoutProperty(e53, t3, r, i), this._update(true);
  }
  getLayoutProperty(e53, t3) {
    return this.style.getLayoutProperty(e53, t3);
  }
  setGlyphs(e53, t3 = {}) {
    return this._lazyInitEmptyStyle(), this.style.setGlyphs(e53, t3), this._update(true);
  }
  getGlyphs() {
    return this.style.getGlyphsUrl();
  }
  addSprite(e53, t3, r = {}) {
    return this._lazyInitEmptyStyle(), this.style.addSprite(e53, t3, r, (e54) => {
      e54 || this._update(true);
    }), this;
  }
  removeSprite(e53) {
    return this._lazyInitEmptyStyle(), this.style.removeSprite(e53), this._update(true);
  }
  getSprite() {
    return this.style.getSprite();
  }
  setSprite(e53, t3 = {}) {
    return this._lazyInitEmptyStyle(), this.style.setSprite(e53, t3, (e54) => {
      e54 || this._update(true);
    }), this;
  }
  setLight(e53, t3 = {}) {
    return this._lazyInitEmptyStyle(), this.style.setLight(e53, t3), this._update(true);
  }
  getLight() {
    return this.style.getLight();
  }
  setFeatureState(e53, t3) {
    return this.style.setFeatureState(e53, t3), this._update();
  }
  removeFeatureState(e53, t3) {
    return this.style.removeFeatureState(e53, t3), this._update();
  }
  getFeatureState(e53) {
    return this.style.getFeatureState(e53);
  }
  getContainer() {
    return this._container;
  }
  getCanvasContainer() {
    return this._canvasContainer;
  }
  getCanvas() {
    return this._canvas;
  }
  _containerDimensions() {
    let e53 = 0, t3 = 0;
    return this._container && (e53 = this._container.clientWidth || 400, t3 = this._container.clientHeight || 300), [e53, t3];
  }
  _setupContainer() {
    this._container;
    let e53 = this._containerDimensions(), t3 = this._getClampedPixelRatio(e53[0], e53[1]);
    this._resizeCanvas(e53[0], e53[1], t3);
  }
  _setupCooperativeGestures() {
    let e53 = this._container;
    this._cooperativeGesturesScreen = B.create("div", "maplibregl-cooperative-gesture-screen", e53);
    let t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
    0 === navigator.platform.indexOf("Mac") && (t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use ⌘ + scroll to zoom the map");
    let r = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map";
    this._cooperativeGesturesScreen.innerHTML = '\n            <div class="maplibregl-desktop-message">'.concat(t3, '</div>\n            <div class="maplibregl-mobile-message">').concat(r, "</div>\n        "), this._cooperativeGesturesScreen.setAttribute("aria-hidden", "true"), this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
  }
  _destroyCooperativeGestures() {
    B.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
  }
  _resizeCanvas(e53, t3, r) {
  }
  _setupPainter() {
    let e53 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }, t3 = null;
    this._canvas.addEventListener("webglcontextcreationerror", (r3) => {
      t3 = { requestedAttributes: e53 }, r3 && (t3.statusMessage = r3.statusMessage, t3.type = r3.type);
    }, { once: true });
    let r = this._canvas.getContext("webgl2", e53) || this._canvas.getContext("webgl", e53);
    if (!r) {
      let e54 = "Failed to initialize WebGL";
      throw t3 ? (t3.message = e54, new Error(JSON.stringify(t3))) : new Error(e54);
    }
    this.painter = new Lu(r, this.transform), In.testSupport(r);
  }
  _onCooperativeGesture(e53, t3, r) {
    return !t3 && r < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
      this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
    }, 100)), false;
  }
  loaded() {
    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
  }
  _update(e53) {
    return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e53, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
  }
  _requestRenderFrame(e53) {
    return this._update(), this._renderTaskQueue.add(e53);
  }
  _cancelRenderFrame(e53) {
    this._renderTaskQueue.remove(e53);
  }
  _render(e53) {
    let t3 = this._idleTriggered ? this._fadeDuration : 0;
    if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e53), this._removed)
      return;
    let r = false;
    if (this.style && this._styleDirty) {
      this._styleDirty = false;
      let e54 = this.transform.zoom, i3 = ne.now();
      this.style.zoomHistory.update(e54, i3);
      let a = new ye(e54, { now: i3, fadeDuration: t3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), n = a.crossFadingFactor();
      (1 !== n || n !== this._crossFadingFactor) && (r = true, this._crossFadingFactor = n), this.style.update(a);
    }
    this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain && this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.updateElevation(this.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, t3, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: false, zooming: false, moving: false, fadeDuration: t3, showPadding: this.showPadding }), this.fire(new z("render")), this.loaded() && !this._loaded && (this._loaded = true, Rr.mark("load"), this.fire(new z("load"))), this.style && (this.style.hasTransitions() || r) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
    let i = this._sourcesDirty || this._styleDirty || this._placementDirty;
    return i || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new z("idle")), this._loaded && !this._fullyLoaded && !i && (this._fullyLoaded = true, Rr.mark("fullLoad")), this._fullyLoaded = true, this;
  }
  redraw() {
    return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
  }
  remove() {
    var e53;
    this._hash && this._hash.remove();
    for (let e54 of this._controls)
      e54.onRemove(this);
    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, false), ot.removeThrottleControl(this._imageQueueHandle), null == (e53 = this._resizeObserver) || e53.disconnect();
    let t3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
    t3 && t3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), B.remove(this._canvasContainer), B.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), Rr.clearMetrics(), this._removed = true, this.fire(new z("remove"));
  }
  triggerRepaintSync() {
    this._render(performance.now());
  }
  triggerRepaint() {
    this.style && !this._frame && (this._frame = ne.frame((e53) => {
      Rr.frame(e53), this._frame = null, this._render(e53);
    }));
  }
  get showTileBoundaries() {
    return !!this._showTileBoundaries;
  }
  set showTileBoundaries(e53) {
    this._showTileBoundaries !== e53 && (this._showTileBoundaries = e53, this._update());
  }
  get showPadding() {
    return !!this._showPadding;
  }
  set showPadding(e53) {
    this._showPadding !== e53 && (this._showPadding = e53, this._update());
  }
  get showCollisionBoxes() {
    return !!this._showCollisionBoxes;
  }
  set showCollisionBoxes(e53) {
    this._showCollisionBoxes !== e53 && (this._showCollisionBoxes = e53, e53 ? this.style._generateCollisionBoxes() : this._update());
  }
  get showOverdrawInspector() {
    return !!this._showOverdrawInspector;
  }
  set showOverdrawInspector(e53) {
    this._showOverdrawInspector !== e53 && (this._showOverdrawInspector = e53, this._update());
  }
  get repaint() {
    return !!this._repaint;
  }
  set repaint(e53) {
    this._repaint !== e53 && (this._repaint = e53, this.triggerRepaint());
  }
  get vertices() {
    return !!this._vertices;
  }
  set vertices(e53) {
    this._vertices = e53, this._update();
  }
  get version() {
    return eE;
  }
  getCameraTargetElevation() {
    return this.transform.elevation;
  }
};
q(Ty, "Map");
var ic = Ty;
c(), c(), c();
var Ay = class {
  constructor(e53) {
    this._enabled = !!e53.enable, this._moveStateManager = e53.moveStateManager, this._clickTolerance = e53.clickTolerance || 1, this._moveFunction = e53.move, this._activateOnStart = !!e53.activateOnStart, e53.assignEvents(this), this.reset();
  }
  reset(e53) {
    this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e53);
  }
  _move(...e53) {
    let t3 = this._moveFunction(...e53);
    if (t3.bearingDelta || t3.pitchDelta || t3.around || t3.panDelta)
      return this._active = true, t3;
  }
  dragStart(e53, t3) {
    !this.isEnabled() || this._lastPoint || this._moveStateManager.isValidStartEvent(e53) && (this._moveStateManager.startMove(e53), this._lastPoint = t3.length ? t3[0] : t3, this._activateOnStart && this._lastPoint && (this._active = true));
  }
  dragMove(e53, t3) {
    if (!this.isEnabled())
      return;
    let r = this._lastPoint;
    if (!r)
      return;
    if (e53.preventDefault(), !this._moveStateManager.isValidMoveEvent(e53))
      return void this.reset(e53);
    let i = t3.length ? t3[0] : t3;
    return !this._moved && i.dist(r) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = i, this._move(r, i));
  }
  dragEnd(e53) {
    !this.isEnabled() || !this._lastPoint || this._moveStateManager.isValidEndEvent(e53) && (this._moved && B.suppressClick(), this.reset(e53));
  }
  enable() {
    this._enabled = true;
  }
  disable() {
    this._enabled = false, this.reset();
  }
  isEnabled() {
    return this._enabled;
  }
  isActive() {
    return this._active;
  }
  getClickTolerance() {
    return this._clickTolerance;
  }
};
q(Ay, "DragHandler");
var Vr = Ay;
c();
var rE = 0;
var iE = 2;
var nE = { [rE]: 1, [iE]: 2 };
function aE(e53, t3) {
  let r = nE[t3];
  return void 0 === e53.buttons || (e53.buttons & r) !== r;
}
q(aE, "buttonNoLongerPressed");
var Iy = class {
  constructor(e53) {
    this._correctEvent = e53.checkCorrectEvent;
  }
  startMove(e53) {
    let t3 = B.mouseButton(e53);
    this._eventButton = t3;
  }
  endMove(e53) {
    delete this._eventButton;
  }
  isValidStartEvent(e53) {
    return this._correctEvent(e53);
  }
  isValidMoveEvent(e53) {
    return !aE(e53, this._eventButton);
  }
  isValidEndEvent(e53) {
    return B.mouseButton(e53) === this._eventButton;
  }
};
q(Iy, "MouseMoveStateManager");
var ao = Iy;
var My = class {
  constructor() {
    this._firstTouch = void 0;
  }
  _isOneFingerTouch(e53) {
    return 1 === e53.targetTouches.length;
  }
  _isSameTouchEvent(e53) {
    return e53.targetTouches[0].identifier === this._firstTouch;
  }
  startMove(e53) {
    let t3 = e53.targetTouches[0].identifier;
    this._firstTouch = t3;
  }
  endMove(e53) {
    delete this._firstTouch;
  }
  isValidStartEvent(e53) {
    return this._isOneFingerTouch(e53);
  }
  isValidMoveEvent(e53) {
    return this._isOneFingerTouch(e53) && this._isSameTouchEvent(e53);
  }
  isValidEndEvent(e53) {
    return this._isOneFingerTouch(e53) && this._isSameTouchEvent(e53);
  }
};
q(My, "OneFingerTouchMoveStateManager");
var oo = My;
var q1 = 0;
var j1 = 2;
var $1 = q((e53) => {
  e53.mousedown = e53.dragStart, e53.mousemoveWindow = e53.dragMove, e53.mouseup = e53.dragEnd, e53.contextmenu = function(e54) {
    e54.preventDefault();
  };
}, "assignEvents");
var H1 = q(({ enable: e53, clickTolerance: t3, bearingDegreesPerPixelMoved: r = 0.8 }) => {
  let i = new ao({ checkCorrectEvent: (e54) => B.mouseButton(e54) === q1 && e54.ctrlKey || B.mouseButton(e54) === j1 });
  return new Vr({ clickTolerance: t3, move: (e54, t4) => ({ bearingDelta: (t4.x - e54.x) * r }), moveStateManager: i, enable: e53, assignEvents: $1 });
}, "generateMouseRotationHandler");
var Z1 = q(({ enable: e53, clickTolerance: t3, pitchDegreesPerPixelMoved: r = -0.5 }) => {
  let i = new ao({ checkCorrectEvent: (e54) => B.mouseButton(e54) === q1 && e54.ctrlKey || B.mouseButton(e54) === j1 });
  return new Vr({ clickTolerance: t3, move: (e54, t4) => ({ pitchDelta: (t4.y - e54.y) * r }), moveStateManager: i, enable: e53, assignEvents: $1 });
}, "generateMousePitchHandler");
c();
var W1 = q((e53) => {
  e53.touchstart = e53.dragStart, e53.touchmoveWindow = e53.dragMove, e53.touchend = e53.dragEnd;
}, "assignEvents");
var X1 = q(({ enable: e53, clickTolerance: t3, bearingDegreesPerPixelMoved: r = 0.8 }) => {
  let i = new oo();
  return new Vr({ clickTolerance: t3, move: (e54, t4) => ({ bearingDelta: (t4.x - e54.x) * r }), moveStateManager: i, enable: e53, assignEvents: W1 });
}, "generateOneFingerTouchRotationHandler");
var K1 = q(({ enable: e53, clickTolerance: t3, pitchDegreesPerPixelMoved: r = -0.5 }) => {
  let i = new oo();
  return new Vr({ clickTolerance: t3, move: (e54, t4) => ({ pitchDelta: (t4.y - e54.y) * r }), moveStateManager: i, enable: e53, assignEvents: W1 });
}, "generateOneFingerTouchPitchHandler");
var oE = { showCompass: true, showZoom: true, visualizePitch: false };
var Ey = class {
  constructor(e53) {
    this._updateZoomButtons = q(() => {
      let e54 = this._map.getZoom(), t3 = e54 === this._map.getMaxZoom(), r = e54 === this._map.getMinZoom();
      this._zoomInButton.disabled = t3, this._zoomOutButton.disabled = r, this._zoomInButton.setAttribute("aria-disabled", t3.toString()), this._zoomOutButton.setAttribute("aria-disabled", r.toString());
    }, "_updateZoomButtons"), this._rotateCompassArrow = q(() => {
      let e54 = this.options.visualizePitch ? "scale(".concat(1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5), ") rotateX(").concat(this._map.transform.pitch, "deg) rotateZ(").concat(this._map.transform.angle * (180 / Math.PI), "deg)") : "rotate(".concat(this._map.transform.angle * (180 / Math.PI), "deg)");
      this._compassIcon.style.transform = e54;
    }, "_rotateCompassArrow"), this._setButtonTitle = q((e54, t3) => {
      let r = this._map._getUIString("NavigationControl.".concat(t3));
      e54.title = r, e54.setAttribute("aria-label", r);
    }, "_setButtonTitle"), this.options = R({}, oE, e53), this._container = B.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e54) => e54.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e54) => this._map.zoomIn({}, { originalEvent: e54 })), B.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e54) => this._map.zoomOut({}, { originalEvent: e54 })), B.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e54) => {
      this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e54 }) : this._map.resetNorth({}, { originalEvent: e54 });
    }), this._compassIcon = B.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
  }
  onAdd(e53) {
    return this._map = e53, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Cy(this._map, this._compass, this.options.visualizePitch)), this._container;
  }
  onRemove() {
    B.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
  }
  _createButton(e53, t3) {
    let r = B.create("button", e53, this._container);
    return r.type = "button", r.addEventListener("click", t3), r;
  }
};
q(Ey, "NavigationControl");
var nc = Ey;
var ky = class {
  constructor(e53, t3, r = false) {
    this.mousedown = q((e54) => {
      this.startMouse(R({}, e54, { ctrlKey: true, preventDefault: () => e54.preventDefault() }), B.mousePos(this.element, e54)), B.addEventListener(window, "mousemove", this.mousemove), B.addEventListener(window, "mouseup", this.mouseup);
    }, "mousedown"), this.mousemove = q((e54) => {
      this.moveMouse(e54, B.mousePos(this.element, e54));
    }, "mousemove"), this.mouseup = q((e54) => {
      this.mouseRotate.dragEnd(e54), this.mousePitch && this.mousePitch.dragEnd(e54), this.offTemp();
    }, "mouseup"), this.touchstart = q((e54) => {
      1 !== e54.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = B.touchPos(this.element, e54.targetTouches)[0], this.startTouch(e54, this._startPos), B.addEventListener(window, "touchmove", this.touchmove, { passive: false }), B.addEventListener(window, "touchend", this.touchend));
    }, "touchstart"), this.touchmove = q((e54) => {
      1 !== e54.targetTouches.length ? this.reset() : (this._lastPos = B.touchPos(this.element, e54.targetTouches)[0], this.moveTouch(e54, this._lastPos));
    }, "touchmove"), this.touchend = q((e54) => {
      0 === e54.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
    }, "touchend"), this.reset = q(() => {
      this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
    }, "reset"), this._clickTolerance = 10;
    let i = e53.dragRotate._mouseRotate.getClickTolerance(), a = e53.dragRotate._mousePitch.getClickTolerance();
    this.element = t3, this.mouseRotate = H1({ clickTolerance: i, enable: true }), this.touchRotate = X1({ clickTolerance: i, enable: true }), this.map = e53, r && (this.mousePitch = Z1({ clickTolerance: a, enable: true }), this.touchPitch = K1({ clickTolerance: a, enable: true })), B.addEventListener(t3, "mousedown", this.mousedown), B.addEventListener(t3, "touchstart", this.touchstart, { passive: false }), B.addEventListener(t3, "touchcancel", this.reset);
  }
  startMouse(e53, t3) {
    this.mouseRotate.dragStart(e53, t3), this.mousePitch && this.mousePitch.dragStart(e53, t3), B.disableDrag();
  }
  startTouch(e53, t3) {
    this.touchRotate.dragStart(e53, t3), this.touchPitch && this.touchPitch.dragStart(e53, t3), B.disableDrag();
  }
  moveMouse(e53, t3) {
    let r = this.map, { bearingDelta: i } = this.mouseRotate.dragMove(e53, t3) || {};
    if (i && r.setBearing(r.getBearing() + i), this.mousePitch) {
      let { pitchDelta: i3 } = this.mousePitch.dragMove(e53, t3) || {};
      i3 && r.setPitch(r.getPitch() + i3);
    }
  }
  moveTouch(e53, t3) {
    let r = this.map, { bearingDelta: i } = this.touchRotate.dragMove(e53, t3) || {};
    if (i && r.setBearing(r.getBearing() + i), this.touchPitch) {
      let { pitchDelta: i3 } = this.touchPitch.dragMove(e53, t3) || {};
      i3 && r.setPitch(r.getPitch() + i3);
    }
  }
  off() {
    let e53 = this.element;
    B.removeEventListener(e53, "mousedown", this.mousedown), B.removeEventListener(e53, "touchstart", this.touchstart, { passive: false }), B.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), B.removeEventListener(window, "touchend", this.touchend), B.removeEventListener(e53, "touchcancel", this.reset), this.offTemp();
  }
  offTemp() {
    B.enableDrag(), B.removeEventListener(window, "mousemove", this.mousemove), B.removeEventListener(window, "mouseup", this.mouseup), B.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), B.removeEventListener(window, "touchend", this.touchend);
  }
};
q(ky, "MouseRotateWrapper");
var Ur;
var Cy = ky;
function Y1(e53, t3 = false) {
  void 0 === Ur || t3 ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((t4) => {
    Ur = "denied" !== t4.state, e53(Ur);
  }).catch(() => {
    Ur = !!window.navigator.geolocation, e53(Ur);
  }) : (Ur = !!window.navigator.geolocation, e53(Ur)) : e53(Ur);
}
c(), c(), q(Y1, "checkGeolocationSupport"), c();
var sc = u(Pe(), 1);
function ac(e53, t3, r) {
  if (e53 = new re(e53.lng, e53.lat), t3) {
    let i = new re(e53.lng - 360, e53.lat), a = new re(e53.lng + 360, e53.lat), n = r.locationPoint(e53).distSqr(t3);
    r.locationPoint(i).distSqr(t3) < n ? e53 = i : r.locationPoint(a).distSqr(t3) < n && (e53 = a);
  }
  for (; Math.abs(e53.lng - r.center.lng) > 180; ) {
    let t4 = r.locationPoint(e53);
    if (t4.x >= 0 && t4.y >= 0 && t4.x <= r.width && t4.y <= r.height)
      break;
    e53.lng > r.center.lng ? e53.lng -= 360 : e53.lng += 360;
  }
  return e53;
}
c(), q(ac, "smartWrap"), c();
var so = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
function oc(e53, t3, r) {
  let i = e53.classList;
  for (let e54 in so)
    i.remove("maplibregl-".concat(r, "-anchor-").concat(e54));
  i.add("maplibregl-".concat(r, "-anchor-").concat(t3));
}
q(oc, "applyAnchorClass");
var Ly = class extends de {
  constructor(e53) {
    if (super(), this._onKeyPress = q((e54) => {
      let t3 = e54.code, r = e54.charCode || e54.keyCode;
      ("Space" === t3 || "Enter" === t3 || 32 === r || 13 === r) && this.togglePopup();
    }, "_onKeyPress"), this._onMapClick = q((e54) => {
      let t3 = e54.originalEvent.target, r = this._element;
      this._popup && (t3 === r || r.contains(t3)) && this.togglePopup();
    }, "_onMapClick"), this._update = q((e54) => {
      if (!this._map)
        return;
      this._map.transform.renderWorldCopies && (this._lngLat = ac(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
      let t3 = "";
      "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? t3 = "rotateZ(".concat(this._rotation, "deg)") : "map" === this._rotationAlignment && (t3 = "rotateZ(".concat(this._rotation - this._map.getBearing(), "deg)"));
      let r = "";
      "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? r = "rotateX(0deg)" : "map" === this._pitchAlignment && (r = "rotateX(".concat(this._map.getPitch(), "deg)")), (!e54 || "moveend" === e54.type) && (this._pos = this._pos.round()), B.setTransform(this._element, "".concat(so[this._anchor], " translate(").concat(this._pos.x, "px, ").concat(this._pos.y, "px) ").concat(r, " ").concat(t3)), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
        let e55 = this._map.unproject(this._pos), t4 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
        this._element.style.opacity = e55.distanceTo(this._lngLat) > 20 * t4 ? "0.2" : "1.0", this._opacityTimeout = null;
      }, 100));
    }, "_update"), this._onMove = q((e54) => {
      if (!this._isDragging) {
        let t3 = this._clickTolerance || this._map._clickTolerance;
        this._isDragging = e54.point.dist(this._pointerdownPos) >= t3;
      }
      this._isDragging && (this._pos = e54.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new z("dragstart"))), this.fire(new z("drag")));
    }, "_onMove"), this._onUp = q(() => {
      this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new z("dragend")), this._state = "inactive";
    }, "_onUp"), this._addDragHandler = q((e54) => {
      this._element.contains(e54.originalEvent.target) && (e54.preventDefault(), this._positionDelta = e54.point.sub(this._pos).add(this._offset), this._pointerdownPos = e54.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
    }, "_addDragHandler"), this._anchor = e53 && e53.anchor || "center", this._color = e53 && e53.color || "#3FB1CE", this._scale = e53 && e53.scale || 1, this._draggable = e53 && e53.draggable || false, this._clickTolerance = e53 && e53.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e53 && e53.rotation || 0, this._rotationAlignment = e53 && e53.rotationAlignment || "auto", this._pitchAlignment = e53 && e53.pitchAlignment && "auto" !== e53.pitchAlignment ? e53.pitchAlignment : this._rotationAlignment, e53 && e53.element)
      this._element = e53.element, this._offset = sc.default.convert(e53 && e53.offset || [0, 0]);
    else {
      this._defaultMarker = true, this._element = B.create("div"), this._element.setAttribute("aria-label", "Map marker");
      let t3 = B.createNS("http://www.w3.org/2000/svg", "svg"), r = 41, i = 27;
      t3.setAttributeNS(null, "display", "block"), t3.setAttributeNS(null, "height", "".concat(r, "px")), t3.setAttributeNS(null, "width", "".concat(i, "px")), t3.setAttributeNS(null, "viewBox", "0 0 ".concat(i, " ").concat(r));
      let a = B.createNS("http://www.w3.org/2000/svg", "g");
      a.setAttributeNS(null, "stroke", "none"), a.setAttributeNS(null, "stroke-width", "1"), a.setAttributeNS(null, "fill", "none"), a.setAttributeNS(null, "fill-rule", "evenodd");
      let n = B.createNS("http://www.w3.org/2000/svg", "g");
      n.setAttributeNS(null, "fill-rule", "nonzero");
      let s3 = B.createNS("http://www.w3.org/2000/svg", "g");
      s3.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), s3.setAttributeNS(null, "fill", "#000000");
      let o = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
      for (let e54 of o) {
        let t4 = B.createNS("http://www.w3.org/2000/svg", "ellipse");
        t4.setAttributeNS(null, "opacity", "0.04"), t4.setAttributeNS(null, "cx", "10.5"), t4.setAttributeNS(null, "cy", "5.80029008"), t4.setAttributeNS(null, "rx", e54.rx), t4.setAttributeNS(null, "ry", e54.ry), s3.appendChild(t4);
      }
      let l = B.createNS("http://www.w3.org/2000/svg", "g");
      l.setAttributeNS(null, "fill", this._color);
      let u3 = B.createNS("http://www.w3.org/2000/svg", "path");
      u3.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), l.appendChild(u3);
      let c3 = B.createNS("http://www.w3.org/2000/svg", "g");
      c3.setAttributeNS(null, "opacity", "0.25"), c3.setAttributeNS(null, "fill", "#000000");
      let h = B.createNS("http://www.w3.org/2000/svg", "path");
      h.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), c3.appendChild(h);
      let p = B.createNS("http://www.w3.org/2000/svg", "g");
      p.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p.setAttributeNS(null, "fill", "#FFFFFF");
      let d = B.createNS("http://www.w3.org/2000/svg", "g");
      d.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
      let f = B.createNS("http://www.w3.org/2000/svg", "circle");
      f.setAttributeNS(null, "fill", "#000000"), f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "cx", "5.5"), f.setAttributeNS(null, "cy", "5.5"), f.setAttributeNS(null, "r", "5.4999962");
      let m = B.createNS("http://www.w3.org/2000/svg", "circle");
      m.setAttributeNS(null, "fill", "#FFFFFF"), m.setAttributeNS(null, "cx", "5.5"), m.setAttributeNS(null, "cy", "5.5"), m.setAttributeNS(null, "r", "5.4999962"), d.appendChild(f), d.appendChild(m), n.appendChild(s3), n.appendChild(l), n.appendChild(c3), n.appendChild(p), n.appendChild(d), t3.appendChild(n), t3.setAttributeNS(null, "height", "".concat(r * this._scale, "px")), t3.setAttributeNS(null, "width", "".concat(i * this._scale, "px")), this._element.appendChild(t3), this._offset = sc.default.convert(e53 && e53.offset || [0, -14]);
    }
    if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e54) => {
      e54.preventDefault();
    }), this._element.addEventListener("mousedown", (e54) => {
      e54.preventDefault();
    }), oc(this._element, this._anchor, "marker"), e53 && e53.className)
      for (let t3 of e53.className.split(" "))
        this._element.classList.add(t3);
    this._popup = null;
  }
  addTo(e53) {
    return this.remove(), this._map = e53, e53.getCanvasContainer().appendChild(this._element), e53.on("move", this._update), e53.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
  }
  remove() {
    return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), B.remove(this._element), this._popup && this._popup.remove(), this;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(e53) {
    return this._lngLat = re.convert(e53), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
  }
  getElement() {
    return this._element;
  }
  setPopup(e53) {
    if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e53) {
      if (!("offset" in e53.options)) {
        let t3 = Math.sqrt(Math.pow(13.5, 2) / 2);
        e53.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [t3, -1 * (24.6 + t3)], "bottom-right": [-t3, -1 * (24.6 + t3)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
      }
      this._popup = e53, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
    }
    return this;
  }
  getPopup() {
    return this._popup;
  }
  togglePopup() {
    let e53 = this._popup;
    return e53 ? (e53.isOpen() ? e53.remove() : e53.addTo(this._map), this) : this;
  }
  getOffset() {
    return this._offset;
  }
  setOffset(e53) {
    return this._offset = sc.default.convert(e53), this._update(), this;
  }
  addClassName(e53) {
    this._element.classList.add(e53);
  }
  removeClassName(e53) {
    this._element.classList.remove(e53);
  }
  toggleClassName(e53) {
    return this._element.classList.toggle(e53);
  }
  setDraggable(e53) {
    return this._draggable = !!e53, this._map && (e53 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
  }
  isDraggable() {
    return this._draggable;
  }
  setRotation(e53) {
    return this._rotation = e53 || 0, this._update(), this;
  }
  getRotation() {
    return this._rotation;
  }
  setRotationAlignment(e53) {
    return this._rotationAlignment = e53 || "auto", this._update(), this;
  }
  getRotationAlignment() {
    return this._rotationAlignment;
  }
  setPitchAlignment(e53) {
    return this._pitchAlignment = e53 && "auto" !== e53 ? e53 : this._rotationAlignment, this._update(), this;
  }
  getPitchAlignment() {
    return this._pitchAlignment;
  }
};
q(Ly, "Marker");
var bi = Ly;
var sE = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
var lc = 0;
var lo = false;
var Dy = class extends de {
  constructor(e53) {
    super(), this._onSuccess = q((e54) => {
      if (this._map) {
        if (this._isOutOfMapMaxBounds(e54))
          return this._setErrorState(), this.fire(new z("outofmaxbounds", e54)), this._updateMarker(), void this._finish();
        if (this.options.trackUserLocation)
          switch (this._lastKnownPosition = e54, this._watchState) {
            case "WAITING_ACTIVE":
            case "ACTIVE_LOCK":
            case "ACTIVE_ERROR":
              this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
              break;
            case "BACKGROUND":
            case "BACKGROUND_ERROR":
              this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
              break;
            default:
              throw new Error("Unexpected watchState ".concat(this._watchState));
          }
        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e54), (!this.options.trackUserLocation || "ACTIVE_LOCK" === this._watchState) && this._updateCamera(e54), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new z("geolocate", e54)), this._finish();
      }
    }, "_onSuccess"), this._updateCamera = q((e54) => {
      let t3 = new re(e54.coords.longitude, e54.coords.latitude), r = e54.coords.accuracy, i = R({ bearing: this._map.getBearing() }, this.options.fitBoundsOptions), a = lt.fromLngLat(t3, r);
      this._map.fitBounds(a, i, { geolocateSource: true });
    }, "_updateCamera"), this._updateMarker = q((e54) => {
      if (e54) {
        let t3 = new re(e54.coords.longitude, e54.coords.latitude);
        this._accuracyCircleMarker.setLngLat(t3).addTo(this._map), this._userLocationDotMarker.setLngLat(t3).addTo(this._map), this._accuracy = e54.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
      } else
        this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
    }, "_updateMarker"), this._onZoom = q(() => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    }, "_onZoom"), this._onError = q((e54) => {
      if (this._map) {
        if (this.options.trackUserLocation)
          if (1 === e54.code) {
            this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
            let e55 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.title = e55, this._geolocateButton.setAttribute("aria-label", e55), void 0 !== this._geolocationWatchID && this._clearWatch();
          } else {
            if (3 === e54.code && lo)
              return;
            this._setErrorState();
          }
        "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new z("error", e54)), this._finish();
      }
    }, "_onError"), this._finish = q(() => {
      this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
    }, "_finish"), this._setupUI = q((e54) => {
      if (this._map) {
        if (this._container.addEventListener("contextmenu", (e55) => e55.preventDefault()), this._geolocateButton = B.create("button", "maplibregl-ctrl-geolocate", this._container), B.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e54) {
          Ce("Geolocation support is not available so the GeolocateControl will be disabled.");
          let e55 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = true, this._geolocateButton.title = e55, this._geolocateButton.setAttribute("aria-label", e55);
        } else {
          let e55 = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.title = e55, this._geolocateButton.setAttribute("aria-label", e55);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = B.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new bi({ element: this._dotElement }), this._circleElement = B.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new bi({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e55) => {
          let t3 = e55.originalEvent && "resize" === e55.originalEvent.type;
          !e55.geolocateSource && "ACTIVE_LOCK" === this._watchState && !t3 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new z("trackuserlocationend")));
        });
      }
    }, "_setupUI"), this.options = R({}, sE, e53);
  }
  onAdd(e53) {
    return this._map = e53, this._container = B.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), Y1(this._setupUI), this._container;
  }
  onRemove() {
    void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), B.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, lc = 0, lo = false;
  }
  _isOutOfMapMaxBounds(e53) {
    let t3 = this._map.getMaxBounds(), r = e53.coords;
    return t3 && (r.longitude < t3.getWest() || r.longitude > t3.getEast() || r.latitude < t3.getSouth() || r.latitude > t3.getNorth());
  }
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      default:
        throw new Error("Unexpected watchState ".concat(this._watchState));
    }
  }
  _updateCircleRadius() {
    let e53 = this._map.getBounds(), t3 = e53.getSouthEast(), r = e53.getNorthEast(), i = t3.distanceTo(r), a = this._map._container.clientHeight, n = Math.ceil(this._accuracy / (i / a) * 2);
    this._circleElement.style.width = "".concat(n, "px"), this._circleElement.style.height = "".concat(n, "px");
  }
  trigger() {
    if (!this._setup)
      return Ce("Geolocate control triggered before added to a map"), false;
    if (this.options.trackUserLocation) {
      switch (this._watchState) {
        case "OFF":
          this._watchState = "WAITING_ACTIVE", this.fire(new z("trackuserlocationstart"));
          break;
        case "WAITING_ACTIVE":
        case "ACTIVE_LOCK":
        case "ACTIVE_ERROR":
        case "BACKGROUND_ERROR":
          lc--, lo = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new z("trackuserlocationend"));
          break;
        case "BACKGROUND":
          this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new z("trackuserlocationstart"));
          break;
        default:
          throw new Error("Unexpected watchState ".concat(this._watchState));
      }
      switch (this._watchState) {
        case "WAITING_ACTIVE":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "ACTIVE_LOCK":
          this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
          break;
        case "OFF":
          break;
        default:
          throw new Error("Unexpected watchState ".concat(this._watchState));
      }
      if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
        this._clearWatch();
      else if (void 0 === this._geolocationWatchID) {
        let e53;
        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++lc > 1 ? (e53 = { maximumAge: 6e5, timeout: 0 }, lo = true) : (e53 = this.options.positionOptions, lo = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e53);
      }
    } else
      window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
    return true;
  }
  _clearWatch() {
    window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
  }
};
q(Dy, "GeolocateControl");
var uc = Dy;
c();
var lE = { maxWidth: 100, unit: "metric" };
var zy = class {
  constructor(e53) {
    this._onMove = q(() => {
      J1(this._map, this._container, this.options);
    }, "_onMove"), this.setUnit = q((e54) => {
      this.options.unit = e54, J1(this._map, this._container, this.options);
    }, "setUnit"), this.options = R({}, lE, e53);
  }
  getDefaultPosition() {
    return "bottom-left";
  }
  onAdd(e53) {
    return this._map = e53, this._container = B.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e53.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
  }
  onRemove() {
    B.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
  }
};
q(zy, "ScaleControl");
var cc = zy;
function J1(e53, t3, r) {
  let i = r && r.maxWidth || 100, a = e53._container.clientHeight / 2, n = e53.unproject([0, a]), s3 = e53.unproject([i, a]), o = n.distanceTo(s3);
  if (r && "imperial" === r.unit) {
    let r3 = 3.2808 * o;
    if (r3 > 5280) {
      uo(t3, i, r3 / 5280, e53._getUIString("ScaleControl.Miles"));
    } else
      uo(t3, i, r3, e53._getUIString("ScaleControl.Feet"));
  } else if (r && "nautical" === r.unit) {
    uo(t3, i, o / 1852, e53._getUIString("ScaleControl.NauticalMiles"));
  } else
    o >= 1e3 ? uo(t3, i, o / 1e3, e53._getUIString("ScaleControl.Kilometers")) : uo(t3, i, o, e53._getUIString("ScaleControl.Meters"));
}
function uo(e53, t3, r, i) {
  let a = cE(r), n = a / r;
  e53.style.width = "".concat(t3 * n, "px"), e53.innerHTML = "".concat(a, "&nbsp;").concat(i);
}
function uE(e53) {
  let t3 = Math.pow(10, Math.ceil(-Math.log(e53) / Math.LN10));
  return Math.round(e53 * t3) / t3;
}
function cE(e53) {
  let t3 = Math.pow(10, "".concat(Math.floor(e53)).length - 1), r = e53 / t3;
  return r = r >= 10 ? 10 : r >= 5 ? 5 : r >= 3 ? 3 : r >= 2 ? 2 : r >= 1 ? 1 : uE(r), t3 * r;
}
q(J1, "updateScale"), q(uo, "setScale"), q(uE, "getDecimalRoundNum"), q(cE, "getRoundNum"), c();
var Fy = class extends de {
  constructor(e53 = {}) {
    super(), this._onFullscreenChange = q(() => {
      (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
    }, "_onFullscreenChange"), this._onClickFullscreen = q(() => {
      this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
    }, "_onClickFullscreen"), this._fullscreen = false, e53 && e53.container && (e53.container instanceof HTMLElement ? this._container = e53.container : Ce("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
  }
  onAdd(e53) {
    return this._map = e53, this._container || (this._container = this._map.getContainer()), this._controlContainer = B.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
  }
  onRemove() {
    B.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _setupUI() {
    let e53 = this._fullscreenButton = B.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
    B.create("span", "maplibregl-ctrl-icon", e53).setAttribute("aria-hidden", "true"), e53.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
  }
  _updateTitle() {
    let e53 = this._getTitle();
    this._fullscreenButton.setAttribute("aria-label", e53), this._fullscreenButton.title = e53;
  }
  _getTitle() {
    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
  }
  _isFullscreen() {
    return this._fullscreen;
  }
  _handleFullscreenChange() {
    this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new z("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new z("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
  }
  _exitFullscreen() {
    window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
  }
  _requestFullscreen() {
    this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
  }
  _togglePseudoFullScreen() {
    this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
  }
};
q(Fy, "FullscreenControl");
var pc = Fy;
c();
var By = class {
  constructor(e53) {
    this._toggleTerrain = q(() => {
      this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
    }, "_toggleTerrain"), this._updateTerrainIcon = q(() => {
      this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
    }, "_updateTerrainIcon"), this.options = e53;
  }
  onAdd(e53) {
    return this._map = e53, this._container = B.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = B.create("button", "maplibregl-ctrl-terrain", this._container), B.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    B.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
};
q(By, "TerrainControl");
var hc = By;
c();
var $e = u(Pe(), 1);
var pE = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" };
var hE = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
var Ry = class extends de {
  constructor(e53) {
    super(), this.remove = q(() => (this._content && B.remove(this._content), this._container && (B.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new z("close")), this), "remove"), this._onMouseUp = q((e54) => {
      this._update(e54.point);
    }, "_onMouseUp"), this._onMouseMove = q((e54) => {
      this._update(e54.point);
    }, "_onMouseMove"), this._onDrag = q((e54) => {
      this._update(e54.point);
    }, "_onDrag"), this._update = q((e54) => {
      let t3 = this._lngLat || this._trackPointer;
      if (!this._map || !t3 || !this._content)
        return;
      if (!this._container) {
        if (this._container = B.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = B.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
          for (let e55 of this.options.className.split(" "))
            this._container.classList.add(e55);
        this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
      }
      if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = ac(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !e54)
        return;
      let r = this._pos = this._trackPointer && e54 ? e54 : this._map.project(this._lngLat), i = this.options.anchor, a = Q1(this.options.offset);
      if (!i) {
        let e55, t4 = this._container.offsetWidth, n3 = this._container.offsetHeight;
        e55 = r.y + a.bottom.y < n3 ? ["top"] : r.y > this._map.transform.height - n3 ? ["bottom"] : [], r.x < t4 / 2 ? e55.push("left") : r.x > this._map.transform.width - t4 / 2 && e55.push("right"), i = 0 === e55.length ? "bottom" : e55.join("-");
      }
      let n = r.add(a[i]).round();
      B.setTransform(this._container, "".concat(so[i], " translate(").concat(n.x, "px,").concat(n.y, "px)")), oc(this._container, i, "popup");
    }, "_update"), this._onClose = q(() => {
      this.remove();
    }, "_onClose"), this.options = R(Object.create(pE), e53);
  }
  addTo(e53) {
    return this._map && this.remove(), this._map = e53, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new z("open")), this;
  }
  isOpen() {
    return !!this._map;
  }
  getLngLat() {
    return this._lngLat;
  }
  setLngLat(e53) {
    return this._lngLat = re.convert(e53), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
  }
  trackPointer() {
    return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
  }
  getElement() {
    return this._container;
  }
  setText(e53) {
    return this.setDOMContent(document.createTextNode(e53));
  }
  setHTML(e53) {
    let t3, r = document.createDocumentFragment(), i = document.createElement("body");
    for (i.innerHTML = e53; t3 = i.firstChild, t3; )
      r.appendChild(t3);
    return this.setDOMContent(r);
  }
  getMaxWidth() {
    var e53;
    return null == (e53 = this._container) ? void 0 : e53.style.maxWidth;
  }
  setMaxWidth(e53) {
    return this.options.maxWidth = e53, this._update(), this;
  }
  setDOMContent(e53) {
    if (this._content)
      for (; this._content.hasChildNodes(); )
        this._content.firstChild && this._content.removeChild(this._content.firstChild);
    else
      this._content = B.create("div", "maplibregl-popup-content", this._container);
    return this._content.appendChild(e53), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
  }
  addClassName(e53) {
    this._container && this._container.classList.add(e53);
  }
  removeClassName(e53) {
    this._container && this._container.classList.remove(e53);
  }
  setOffset(e53) {
    return this.options.offset = e53, this._update(), this;
  }
  toggleClassName(e53) {
    if (this._container)
      return this._container.classList.toggle(e53);
  }
  _createCloseButton() {
    this.options.closeButton && (this._closeButton = B.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
  }
  _focusFirstElement() {
    if (!this.options.focusAfterOpen || !this._container)
      return;
    let e53 = this._container.querySelector(hE);
    e53 && e53.focus();
  }
};
q(Ry, "Popup");
var fc = Ry;
function Q1(e53) {
  if (e53) {
    if ("number" == typeof e53) {
      let t3 = Math.round(Math.sqrt(0.5 * Math.pow(e53, 2)));
      return { center: new $e.default(0, 0), top: new $e.default(0, e53), "top-left": new $e.default(t3, t3), "top-right": new $e.default(-t3, t3), bottom: new $e.default(0, -e53), "bottom-left": new $e.default(t3, -t3), "bottom-right": new $e.default(-t3, -t3), left: new $e.default(e53, 0), right: new $e.default(-e53, 0) };
    }
    if (e53 instanceof $e.default || Array.isArray(e53)) {
      let t3 = $e.default.convert(e53);
      return { center: t3, top: t3, "top-left": t3, "top-right": t3, bottom: t3, "bottom-left": t3, "bottom-right": t3, left: t3, right: t3 };
    }
    return { center: $e.default.convert(e53.center || [0, 0]), top: $e.default.convert(e53.top || [0, 0]), "top-left": $e.default.convert(e53["top-left"] || [0, 0]), "top-right": $e.default.convert(e53["top-right"] || [0, 0]), bottom: $e.default.convert(e53.bottom || [0, 0]), "bottom-left": $e.default.convert(e53["bottom-left"] || [0, 0]), "bottom-right": $e.default.convert(e53["bottom-right"] || [0, 0]), left: $e.default.convert(e53.left || [0, 0]), right: $e.default.convert(e53.right || [0, 0]) };
  }
  return Q1(new $e.default(0, 0));
}
q(Q1, "normalizeOffset");
var tw = u(Pe(), 1);
c();
var ew = { extend: (e53, ...t3) => R(e53, ...t3), run(e53) {
  e53();
}, logToElement(e53, t3 = false, r = "log") {
  let i = window.document.getElementById(r);
  i && (t3 && (i.innerHTML = ""), i.innerHTML += "<br>".concat(e53));
} };
var fE = po.version;
var Se = class {
  static get version() {
    return fE;
  }
  static get workerCount() {
    return Fr.workerCount;
  }
  static set workerCount(e53) {
    Fr.workerCount = e53;
  }
  static get maxParallelImageRequests() {
    return it.MAX_PARALLEL_IMAGE_REQUESTS;
  }
  static set maxParallelImageRequests(e53) {
    it.MAX_PARALLEL_IMAGE_REQUESTS = e53;
  }
  static get workerUrl() {
    return it.WORKER_URL;
  }
  static set workerUrl(e53) {
    console.log("setting worker url", e53), it.WORKER_URL = e53;
  }
  static addProtocol(e53, t3) {
    it.REGISTERED_PROTOCOLS[e53] = t3;
  }
  static removeProtocol(e53) {
    delete it.REGISTERED_PROTOCOLS[e53];
  }
};
q(Se, "MapLibreGL"), Se.Map = ic, Se.NavigationControl = nc, Se.GeolocateControl = uc, Se.AttributionControl = _n, Se.LogoControl = vn, Se.ScaleControl = cc, Se.FullscreenControl = pc, Se.TerrainControl = hc, Se.Popup = fc, Se.Marker = bi, Se.Style = Br, Se.LngLat = re, Se.LngLatBounds = lt, Se.Point = tw.default, Se.MercatorCoordinate = ze, Se.Evented = de, Se.AJAXError = hr, Se.config = it, Se.CanvasSource = fn, Se.GeoJSONSource = pn, Se.ImageSource = At, Se.RasterDEMTileSource = cn, Se.RasterTileSource = Dr, Se.VectorTileSource = sn, Se.VideoSource = hn, Se.setRTLTextPlugin = dx, Se.getRTLTextPluginStatus = Kn, Se.prewarm = tv, Se.clearPrewarmedResources = rv;
var mc = Se;
ew.extend(mc, { isSafari: qr, getPerformanceMetrics: Rr.getPerformanceMetrics });
var mre = mc;
export {
  mre as default
};
//# sourceMappingURL=outdoor-context-EFVXH7VY-JMU23USB.js.map
